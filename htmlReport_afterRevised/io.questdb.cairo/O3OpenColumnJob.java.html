<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>O3OpenColumnJob.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">O3OpenColumnJob.java</span></div><h1>O3OpenColumnJob.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.MessageBus;
import io.questdb.cairo.vm.api.MemoryMA;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.mp.AbstractQueueConsumerJob;
import io.questdb.mp.Sequence;
import io.questdb.std.*;
import io.questdb.std.str.Path;
import io.questdb.tasks.O3CopyTask;
import io.questdb.tasks.O3OpenColumnTask;
import org.jetbrains.annotations.Nullable;

import java.util.concurrent.atomic.AtomicInteger;

import static io.questdb.cairo.TableUtils.*;
import static io.questdb.cairo.TableWriter.*;

public class O3OpenColumnJob extends AbstractQueueConsumerJob&lt;O3OpenColumnTask&gt; {
    public static final int OPEN_LAST_PARTITION_FOR_APPEND = 2;
    public static final int OPEN_LAST_PARTITION_FOR_MERGE = 4;
    public static final int OPEN_MID_PARTITION_FOR_APPEND = 1;
    public static final int OPEN_MID_PARTITION_FOR_MERGE = 3;
    public static final int OPEN_NEW_PARTITION_FOR_APPEND = 5;
<span class="fc" id="L50">    private final static Log LOG = LogFactory.getLog(O3OpenColumnJob.class);</span>

    public O3OpenColumnJob(MessageBus messageBus) {
<span class="fc" id="L53">        super(messageBus.getO3OpenColumnQueue(), messageBus.getO3OpenColumnSubSeq());</span>
<span class="fc" id="L54">    }</span>

    public static void appendLastPartition(
            Path pathToPartition,
            int plen,
            CharSequence columnName,
            AtomicInteger columnCounter,
            int columnType,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            long srcDataTop,
            long srcDataMax,
            int indexBlockCapacity,
            MemoryMA dstFixMem,
            MemoryMA dstVarMem,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long columnNameTxn
    ) {
<span class="fc" id="L79">        final long dstLen = srcOooHi - srcOooLo + 1 + srcDataMax - srcDataTop;</span>
<span class="fc bfc" id="L80" title="All 3 branches covered.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.BINARY:
            case ColumnType.STRING:
<span class="fc" id="L83">                appendVarColumn(</span>
                        columnCounter,
                        columnType,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcDataTop,
                        srcDataMax,
                        indexBlockCapacity,
                        0,
                        0,
                        0,
<span class="fc" id="L100">                        -dstFixMem.getFd(),</span>
<span class="fc" id="L101">                        -dstVarMem.getFd(),</span>
                        dstFixMem,
                        dstVarMem,
                        dstLen,
                        tableWriter
                );
<span class="fc" id="L107">                break;</span>
            case ColumnType.TIMESTAMP:
<span class="fc" id="L109">                final boolean designated = ColumnType.isDesignatedTimestamp(columnType);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">                if (designated) {</span>
<span class="fc" id="L111">                    appendTimestampColumn(</span>
                            columnCounter,
                            columnType,
                            srcOooFixAddr,
                            srcOooVarAddr,
                            srcOooLo,
                            srcOooHi,
                            srcOooMax,
                            timestampMin,
                            timestampMax,
                            partitionTimestamp,
                            srcDataMax,
                            indexBlockCapacity,
<span class="fc" id="L124">                            -dstFixMem.getFd(),</span>
                            0,
                            0,
                            dstFixMem,
                            dstLen,
                            tableWriter
                    );
<span class="fc" id="L131">                    break;</span>
                } // else fall through
            default:
<span class="fc" id="L134">                appendFixColumn(</span>
                        pathToPartition,
                        plen,
                        columnName,
                        columnCounter,
                        columnType,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcDataTop,
                        srcDataMax,
                        indexBlockCapacity,
                        0,
                        0,
                        0,
<span class="fc" id="L154">                        -dstFixMem.getFd(),</span>
                        dstFixMem,
                        dstLen,
                        tableWriter,
                        indexWriter,
                        columnNameTxn
                );
                break;
        }
<span class="fc" id="L163">    }</span>

    public static boolean isOpenColumnModeForAppend(int openColumnMode) {
<span class="fc bfc" id="L166" title="All 2 branches covered.">        switch (openColumnMode) {</span>
            case OPEN_MID_PARTITION_FOR_APPEND:
            case OPEN_LAST_PARTITION_FOR_APPEND:
            case OPEN_NEW_PARTITION_FOR_APPEND:
<span class="fc" id="L170">                return true;</span>
            default:
<span class="fc" id="L172">                return false;</span>
        }
    }

    public static void openColumn(O3OpenColumnTask task, long cursor, Sequence subSeq) {
<span class="fc" id="L177">        final int openColumnMode = task.getOpenColumnMode();</span>
<span class="fc" id="L178">        final Path pathToTable = task.getPathToTable();</span>
<span class="fc" id="L179">        final int columnType = task.getColumnType();</span>
<span class="fc" id="L180">        final CharSequence columnName = task.getColumnName();</span>
<span class="fc" id="L181">        final long srcOooLo = task.getSrcOooLo();</span>
<span class="fc" id="L182">        final long srcOooHi = task.getSrcOooHi();</span>
<span class="fc" id="L183">        final long srcOooMax = task.getSrcOooMax();</span>
<span class="fc" id="L184">        final long timestampMin = task.getTimestampMin();</span>
<span class="fc" id="L185">        final long timestampMax = task.getTimestampMax();</span>
<span class="fc" id="L186">        final long oooTimestampLo = task.getOooTimestampLo();</span>
<span class="fc" id="L187">        final long partitionTimestamp = task.getPartitionTimestamp();</span>
<span class="fc" id="L188">        final long srcDataMax = task.getSrcDataMax();</span>
<span class="fc" id="L189">        final long srcDataTxn = task.getSrcDataTxn();</span>
<span class="fc" id="L190">        final int srcTimestampFd = task.getSrcTimestampFd();</span>
<span class="fc" id="L191">        final long srcTimestampAddr = task.getSrcTimestampAddr();</span>
<span class="fc" id="L192">        final long srcTimestampSize = task.getSrcTimestampSize();</span>
<span class="fc" id="L193">        final AtomicInteger columnCounter = task.getColumnCounter();</span>
<span class="fc" id="L194">        final AtomicInteger partCounter = task.getPartCounter();</span>
<span class="fc" id="L195">        final int indexBlockCapacity = task.getIndexBlockCapacity();</span>
<span class="fc" id="L196">        final long srcOooFixAddr = task.getSrcOooFixAddr();</span>
<span class="fc" id="L197">        final long srcOooVarAddr = task.getSrcOooVarAddr();</span>
<span class="fc" id="L198">        final long mergeOOOLo = task.getMergeOOOLo();</span>
<span class="fc" id="L199">        final long mergeOOOHi = task.getMergeOOOHi();</span>
<span class="fc" id="L200">        final long mergeDataLo = task.getMergeDataLo();</span>
<span class="fc" id="L201">        final long mergeDataHi = task.getMergeDataHi();</span>
<span class="fc" id="L202">        final long txn = task.getTxn();</span>
<span class="fc" id="L203">        final int prefixType = task.getPrefixType();</span>
<span class="fc" id="L204">        final long prefixLo = task.getPrefixLo();</span>
<span class="fc" id="L205">        final long prefixHi = task.getPrefixHi();</span>
<span class="fc" id="L206">        final int suffixType = task.getSuffixType();</span>
<span class="fc" id="L207">        final long suffixLo = task.getSuffixLo();</span>
<span class="fc" id="L208">        final long suffixHi = task.getSuffixHi();</span>
<span class="fc" id="L209">        final int mergeType = task.getMergeType();</span>
<span class="fc" id="L210">        final long timestampMergeIndexAddr = task.getTimestampMergeIndexAddr();</span>
<span class="fc" id="L211">        final long timestampMergeIndexSize = task.getTimestampMergeIndexSize();</span>
<span class="fc" id="L212">        final int activeFixFd = task.getActiveFixFd();</span>
<span class="fc" id="L213">        final int activeVarFd = task.getActiveVarFd();</span>
<span class="fc" id="L214">        final long srcDataTop = task.getSrcDataTop();</span>
<span class="fc" id="L215">        final TableWriter tableWriter = task.getTableWriter();</span>
<span class="fc" id="L216">        final BitmapIndexWriter indexWriter = task.getIndexWriter();</span>
<span class="fc" id="L217">        final long colTopSinkAddr = task.getColTopSinkAddr();</span>
<span class="fc" id="L218">        final int columnIndex = task.getColumnIndex();</span>
<span class="fc" id="L219">        final long columnNameTxn = task.getColumnNameTxn();</span>

<span class="fc" id="L221">        subSeq.done(cursor);</span>

<span class="fc" id="L223">        openColumn(</span>
                openColumnMode,
                pathToTable,
                columnName,
                columnCounter,
                partCounter,
                columnType,
                timestampMergeIndexAddr,
                timestampMergeIndexSize,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                timestampMin,
                timestampMax,
                oooTimestampLo,
                partitionTimestamp,
                srcDataTop,
                srcDataMax,
                srcDataTxn,
                txn,
                prefixType,
                prefixLo,
                prefixHi,
                mergeType,
                mergeOOOLo,
                mergeOOOHi,
                mergeDataLo,
                mergeDataHi,
                suffixType,
                suffixLo,
                suffixHi,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                indexBlockCapacity,
                activeFixFd,
                activeVarFd,
                tableWriter,
                indexWriter,
                colTopSinkAddr,
                columnIndex,
                columnNameTxn
        );
<span class="fc" id="L268">    }</span>

    public static void openColumn(
            int openColumnMode,
            Path pathToTable,
            CharSequence columnName,
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long timestampMin,
            long timestampMax,
            long oooTimestampLo,
            long partitionTimestamp,
            long srcDataTop,
            long srcDataMax,
            long srcDataTxn,
            long txn,
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeOOOLo,
            long mergeOOOHi,
            long mergeDataLo,
            long mergeDataHi,
            int suffixType,
            long suffixLo,
            long suffixHi,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int indexBlockCapacity,
            int activeFixFd,
            int activeVarFd,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long colTopSinkAddr,
            int columnIndex,
            long columnNameTxn
    ) {
<span class="fc" id="L315">        final long mergeLen = mergeOOOHi - mergeOOOLo + 1 + mergeDataHi - mergeDataLo + 1;</span>
<span class="fc" id="L316">        final Path pathToPartition = Path.getThreadLocal(pathToTable);</span>
<span class="fc" id="L317">        TableUtils.setPathForPartition(pathToPartition, tableWriter.getPartitionBy(), oooTimestampLo, false);</span>
<span class="fc" id="L318">        final int pplen = pathToPartition.length();</span>
<span class="fc" id="L319">        TableUtils.txnPartitionConditionally(pathToPartition, srcDataTxn);</span>
<span class="fc" id="L320">        final int plen = pathToPartition.length();</span>
        // append jobs do not set value of part counter, we do it here for those
<span class="pc bpc" id="L322" title="1 of 5 branches missed.">        switch (openColumnMode) {</span>
            case OPEN_MID_PARTITION_FOR_APPEND:
<span class="fc" id="L324">                appendMidPartition(</span>
                        pathToPartition,
                        plen,
                        columnName,
                        columnCounter,
                        columnType,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcDataTop,
                        srcDataMax,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        tableWriter,
                        indexWriter,
                        colTopSinkAddr,
                        columnIndex,
                        columnNameTxn
                );
<span class="fc" id="L350">                break;</span>
            case OPEN_MID_PARTITION_FOR_MERGE:
<span class="fc" id="L352">                mergeMidPartition(</span>
                        pathToPartition,
                        plen,
                        pplen,
                        columnName,
                        columnCounter,
                        partCounter,
                        columnType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcDataTop,
                        srcDataMax,
                        txn,
                        prefixType,
                        prefixLo,
                        prefixHi,
                        mergeType,
                        mergeOOOLo,
                        mergeOOOHi,
                        mergeDataLo,
                        mergeDataHi,
                        mergeLen,
                        suffixType,
                        suffixLo,
                        suffixHi,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        tableWriter,
                        indexWriter,
                        colTopSinkAddr,
                        partitionTimestamp,
                        columnIndex,
                        columnNameTxn
                );
<span class="fc" id="L396">                break;</span>
            case OPEN_LAST_PARTITION_FOR_MERGE:
<span class="fc" id="L398">                mergeLastPartition(</span>
                        pathToPartition,
                        pplen,
                        columnName,
                        columnCounter,
                        partCounter,
                        columnType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcDataTop,
                        srcDataMax,
                        txn,
                        prefixType,
                        prefixLo,
                        prefixHi,
                        mergeType,
                        mergeOOOLo,
                        mergeOOOHi,
                        mergeDataLo,
                        mergeDataHi,
                        mergeLen,
                        suffixType,
                        suffixLo,
                        suffixHi,
                        indexBlockCapacity,
                        activeFixFd,
                        activeVarFd,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        tableWriter,
                        indexWriter,
                        colTopSinkAddr,
                        columnNameTxn
                );
<span class="fc" id="L441">                break;</span>
            case OPEN_NEW_PARTITION_FOR_APPEND:
                // mark the fact that the column is touched in the partition to the column version file
                // It's fine to overwrite this value if needed inside the job branches.
<span class="fc" id="L445">                Unsafe.getUnsafe().putLong(colTopSinkAddr, 0L);</span>
<span class="fc" id="L446">                appendNewPartition(</span>
                        pathToPartition,
                        plen,
                        columnName,
                        columnCounter,
                        columnType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcDataMax,
                        indexBlockCapacity,
                        tableWriter,
                        indexWriter,
                        columnNameTxn
                );
<span class="fc" id="L468">                break;</span>
            default:
                break;
        }
<span class="fc" id="L472">    }</span>

    private static void appendFixColumn(
            Path pathToPartition,
            int plen,
            CharSequence columnName,
            AtomicInteger columnCounter,
            int columnType,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp, // &lt;- pass thru
            long srcDataTop,
            long srcDataMax,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int dstFixFd,
            MemoryMA dstFixMem,
            long dstLen,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long columnNameTxn
    ) {
<span class="fc" id="L501">        int dstKFd = 0;</span>
<span class="fc" id="L502">        int dstVFd = 0;</span>
        long dstFixAddr;
        long dstFixOffset;
        long dstFixFileOffset;
        long dstIndexOffset;
        long dstIndexAdjust;
        long dstFixSize;
<span class="fc" id="L509">        final int shl = ColumnType.pow2SizeOf(columnType);</span>
<span class="fc" id="L510">        final FilesFacade ff = tableWriter.getFilesFacade();</span>

        try {
<span class="fc" id="L513">            dstFixSize = dstLen &lt;&lt; shl;</span>
<span class="fc" id="L514">            dstFixOffset = (srcDataMax - srcDataTop) &lt;&lt; shl;</span>
<span class="fc bfc" id="L515" title="All 4 branches covered.">            if (dstFixMem == null || dstFixMem.getAppendAddressSize() &lt; dstFixSize) {</span>
                // Area we want to write is not mapped
<span class="fc" id="L517">                dstFixAddr = mapRW(ff, Math.abs(dstFixFd), dstFixSize, MemoryTag.MMAP_O3);</span>
            } else {
                // Area we want to write is mapped.
                // Set dstFixAddr to Append Address with adjustment that dstFixOffset offset points to offset 0.
<span class="fc" id="L521">                dstFixAddr = dstFixMem.getAppendAddress() - dstFixOffset;</span>
                // Set size negative meaning it will not be freed
<span class="fc" id="L523">                dstFixSize = -dstFixSize;</span>
            }
<span class="fc" id="L525">            dstIndexOffset = dstFixOffset;</span>
<span class="fc" id="L526">            dstIndexAdjust = srcDataTop;</span>
<span class="fc" id="L527">            dstFixFileOffset = dstFixOffset;</span>

<span class="fc bfc" id="L529" title="All 4 branches covered.">            if (indexBlockCapacity &gt; -1 &amp;&amp; !indexWriter.isOpen()) {</span>
<span class="fc" id="L530">                BitmapIndexUtils.keyFileName(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L531">                dstKFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L532">                BitmapIndexUtils.valueFileName(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L533">                dstVFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
            }
<span class="fc" id="L535">        } catch (Throwable e) {</span>
<span class="fc" id="L536">            LOG.error().$(&quot;append fix error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L537">                    .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L538">                    .I$();</span>
<span class="fc" id="L539">            O3Utils.unmapAndClose(ff, dstFixFd, 0, 0);</span>
<span class="fc" id="L540">            O3Utils.close(ff, dstKFd);</span>
<span class="fc" id="L541">            O3Utils.close(ff, dstVFd);</span>
<span class="fc" id="L542">            freeTs(</span>
                    columnCounter,
                    0,
                    0,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    tableWriter,
                    ff
            );
<span class="fc" id="L552">            throw e;</span>
<span class="fc" id="L553">        }</span>

<span class="fc" id="L555">        publishCopyTask(</span>
                columnCounter,
                null,
                columnType,
                O3_BLOCK_O3,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                srcOooLo,
                srcOooHi,
                srcDataTop &lt;&lt; shl,
                srcDataMax,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                srcOooLo,
                srcOooHi,
                timestampMin,
                timestampMax,
                partitionTimestamp,
                dstFixFd,
                dstFixAddr,
                dstFixOffset,
                dstFixFileOffset,
                dstFixSize,
                0,
                0,
                0,
                0,
                0,
                0,
                dstKFd,
                dstVFd,
                dstIndexOffset,
                dstIndexAdjust,
                indexBlockCapacity,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                false,
                tableWriter,
                indexWriter
        );
<span class="fc" id="L607">    }</span>

    private static void appendMidPartition(
            Path pathToPartition,
            int plen,
            CharSequence columnName,
            AtomicInteger columnCounter,
            int columnType,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            long srcDataTop,
            long srcDataMax,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long colTopSinkAddr,
            int columnIndex,
            long columnNameTxn
    ) {
<span class="fc" id="L635">        int dstFixFd = 0;</span>
<span class="fc" id="L636">        int dstVarFd = 0;</span>
<span class="fc" id="L637">        final FilesFacade ff = tableWriter.getFilesFacade();</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">        if (srcDataTop == -1) {</span>
            try {
<span class="fc" id="L640">                srcDataTop = tableWriter.getColumnTop(partitionTimestamp, columnIndex, srcDataMax);</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">                if (srcDataTop == srcDataMax) {</span>
<span class="fc" id="L642">                    Unsafe.getUnsafe().putLong(colTopSinkAddr, srcDataMax);</span>
                }
<span class="nc" id="L644">            } catch (Throwable e) {</span>
<span class="nc" id="L645">                LOG.error().$(&quot;append mid partition error 1 [table=&quot;).$(tableWriter.getTableToken())</span>
<span class="nc" id="L646">                        .$(&quot;, e=&quot;).$(e)</span>
<span class="nc" id="L647">                        .I$();</span>
<span class="nc" id="L648">                freeTs(</span>
                        columnCounter,
                        0,
                        0,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        tableWriter,
                        ff
                );
<span class="nc" id="L658">                throw e;</span>
<span class="fc" id="L659">            }</span>
        }

<span class="fc" id="L662">        final long dstLen = srcOooHi - srcOooLo + 1 + srcDataMax - srcDataTop;</span>
<span class="fc bfc" id="L663" title="All 3 branches covered.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.BINARY:
            case ColumnType.STRING:
                try {
                    // index files are opened as normal
<span class="fc" id="L668">                    iFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L669">                    dstFixFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
                    // open data file now
<span class="fc" id="L671">                    dFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L672">                    dstVarFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L673">                } catch (Throwable e) {</span>
<span class="fc" id="L674">                    LOG.error().$(&quot;append mid partition error 2 [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L675">                            .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L676">                            .I$();</span>
<span class="fc" id="L677">                    O3Utils.close(ff, dstFixFd);</span>
<span class="fc" id="L678">                    O3Utils.close(ff, dstVarFd);</span>
<span class="fc" id="L679">                    freeTs(</span>
                            columnCounter,
                            0,
                            0,
                            srcTimestampFd,
                            srcTimestampAddr,
                            srcTimestampSize,
                            tableWriter,
                            ff
                    );
<span class="fc" id="L689">                    throw e;</span>
<span class="fc" id="L690">                }</span>
<span class="fc" id="L691">                appendVarColumn(</span>
                        columnCounter,
                        columnType,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcDataTop,
                        srcDataMax,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        dstFixFd,
                        dstVarFd,
                        null,
                        null,
                        dstLen,
                        tableWriter
                );
<span class="fc" id="L715">                break;</span>
            case ColumnType.TIMESTAMP:
<span class="fc" id="L717">                final boolean designated = ColumnType.isDesignatedTimestamp(columnType);</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">                if (designated) {</span>
<span class="fc" id="L719">                    appendTimestampColumn(</span>
                            columnCounter,
                            columnType,
                            srcOooFixAddr,
                            srcOooVarAddr,
                            srcOooLo,
                            srcOooHi,
                            srcOooMax,
                            timestampMin,
                            timestampMax,
                            partitionTimestamp,
                            srcDataMax,
                            indexBlockCapacity,
                            srcTimestampFd,
                            srcTimestampAddr,
                            srcTimestampSize,
                            null,
                            dstLen,
                            tableWriter
                    );
<span class="fc" id="L739">                    break;</span>
                } // else fall through
            default:
                try {
<span class="fc" id="L743">                    dFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L744">                    dstFixFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L745">                } catch (Throwable e) {</span>
<span class="fc" id="L746">                    LOG.error().$(&quot;append mid partition error 3 [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L747">                            .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L748">                            .I$();</span>
<span class="fc" id="L749">                    O3Utils.close(ff, dstFixFd);</span>
<span class="fc" id="L750">                    O3Utils.close(ff, dstVarFd);</span>
<span class="fc" id="L751">                    freeTs(</span>
                            columnCounter,
                            0,
                            0,
                            srcTimestampFd,
                            srcTimestampAddr,
                            srcTimestampSize,
                            tableWriter,
                            ff
                    );
<span class="fc" id="L761">                    throw e;</span>
<span class="fc" id="L762">                }</span>
<span class="fc" id="L763">                appendFixColumn(</span>
                        pathToPartition,
                        plen,
                        columnName,
                        columnCounter,
                        columnType,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcDataTop,
                        srcDataMax,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        dstFixFd,
                        null,
                        dstLen,
                        tableWriter,
                        indexWriter,
                        columnNameTxn
                );
                break;
        }
<span class="fc" id="L792">    }</span>

    private static void appendNewPartition(
            Path pathToPartition,
            int plen,
            CharSequence columnName,
            AtomicInteger columnCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            long srcDataMax,
            int indexBlockCapacity,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long columnNameTxn
    ) {
<span class="fc" id="L816">        int dstFixFd = 0;</span>
<span class="fc" id="L817">        long dstFixAddr = 0;</span>
<span class="fc" id="L818">        long dstFixSize = 0;</span>
<span class="fc" id="L819">        int dstVarFd = 0;</span>
<span class="fc" id="L820">        long dstVarAddr = 0;</span>
<span class="fc" id="L821">        long dstVarSize = 0;</span>
<span class="fc" id="L822">        int dstKFd = 0;</span>
<span class="fc" id="L823">        int dstVFd = 0;</span>
<span class="fc" id="L824">        final FilesFacade ff = tableWriter.getFilesFacade();</span>

        try {
<span class="fc bfc" id="L827" title="All 2 branches covered.">            if (ColumnType.isVariableLength(columnType)) {</span>
<span class="fc" id="L828">                iFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L829">                dstFixFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L830">                dstFixSize = (srcOooHi - srcOooLo + 1 + 1) * Long.BYTES;</span>
<span class="fc" id="L831">                dstFixAddr = mapRW(ff, dstFixFd, dstFixSize, MemoryTag.MMAP_O3);</span>

<span class="fc" id="L833">                dFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L834">                dstVarFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L835">                dstVarSize = O3Utils.getVarColumnLength(srcOooLo, srcOooHi, srcOooFixAddr);</span>
<span class="fc" id="L836">                dstVarAddr = mapRW(ff, dstVarFd, dstVarSize, MemoryTag.MMAP_O3);</span>
            } else {
<span class="fc" id="L838">                dFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L839">                dstFixFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L840">                dstFixSize = (srcOooHi - srcOooLo + 1) &lt;&lt; ColumnType.pow2SizeOf(Math.abs(columnType));</span>
<span class="fc" id="L841">                dstFixAddr = mapRW(ff, dstFixFd, dstFixSize, MemoryTag.MMAP_O3);</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">                if (indexBlockCapacity &gt; -1) {</span>
<span class="fc" id="L843">                    BitmapIndexUtils.keyFileName(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L844">                    dstKFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L845">                    BitmapIndexUtils.valueFileName(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L846">                    dstVFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
                }
            }
<span class="fc" id="L849">        } catch (Throwable e) {</span>
<span class="fc" id="L850">            LOG.error().$(&quot;append new partition error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L851">                    .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L852">                    .I$();</span>
<span class="fc" id="L853">            tableWriter.o3BumpErrorCount();</span>
<span class="fc" id="L854">            final FilesFacade ff1 = tableWriter.getFilesFacade();</span>
<span class="fc" id="L855">            O3Utils.unmapAndClose(ff1, dstFixFd, dstFixAddr, dstFixSize);</span>
<span class="fc" id="L856">            O3Utils.unmapAndClose(ff1, dstVarFd, dstVarAddr, dstVarSize);</span>
<span class="fc" id="L857">            O3Utils.close(ff1, dstKFd);</span>
<span class="fc" id="L858">            O3Utils.close(ff1, dstVFd);</span>
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">            if (columnCounter.decrementAndGet() == 0) {</span>
<span class="nc" id="L860">                tableWriter.o3ClockDownPartitionUpdateCount();</span>
<span class="nc" id="L861">                tableWriter.o3CountDownDoneLatch();</span>
            }
<span class="fc" id="L863">            throw e;</span>
<span class="fc" id="L864">        }</span>

<span class="fc" id="L866">        publishCopyTask(</span>
                columnCounter,
                null,
                columnType,
                O3_BLOCK_O3,
                timestampMergeIndexAddr,
                timestampMergeIndexSize,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                srcDataMax,
                // this is new partition
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                srcOooLo,
                srcOooHi,
                timestampMin,
                timestampMax,
                partitionTimestamp,
                dstFixFd,
                dstFixAddr,
                0,
                0,
                dstFixSize,
                dstVarFd,
                dstVarAddr,
                0,
                0,
                0,
                dstVarSize,
                dstKFd,
                dstVFd,
                0,
                0,
                indexBlockCapacity,
                0,
                0,
                0,
                false, // partition does not mutate above the append line
                tableWriter,
                indexWriter
        );
<span class="fc" id="L919">    }</span>

    private static void appendTimestampColumn(
            AtomicInteger columnCounter,
            int columnType,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            long srcDataMax,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            MemoryMA dstFixMem,
            long dstLen,
            TableWriter tableWriter
    ) {
<span class="fc" id="L941">        int dstFixFd = 0;</span>
        long dstFixAddr;
        long dstFixOffset;
        long dstFixFileOffset;
        long dstFixSize;
<span class="fc" id="L946">        final FilesFacade ff = tableWriter.getFilesFacade();</span>
        try {
<span class="fc" id="L948">            dstFixSize = dstLen * Long.BYTES;</span>
<span class="fc bfc" id="L949" title="All 4 branches covered.">            if (dstFixMem == null || dstFixMem.getAppendAddressSize() &lt; dstFixSize) {</span>
<span class="fc" id="L950">                dstFixOffset = srcDataMax * Long.BYTES;</span>
<span class="fc" id="L951">                dstFixFileOffset = dstFixOffset;</span>
<span class="fc" id="L952">                dstFixFd = -Math.abs(srcTimestampFd);</span>
<span class="fc" id="L953">                dstFixAddr = mapRW(ff, -dstFixFd, dstFixSize, MemoryTag.MMAP_O3);</span>
            } else {
<span class="fc" id="L955">                dstFixAddr = dstFixMem.getAppendAddress();</span>
<span class="fc" id="L956">                dstFixOffset = 0;</span>
<span class="fc" id="L957">                dstFixFileOffset = dstFixMem.getAppendOffset();</span>
<span class="fc" id="L958">                dstFixSize = -dstFixSize;</span>
            }
<span class="fc" id="L960">        } catch (Throwable e) {</span>
<span class="fc" id="L961">            LOG.error().$(&quot;append ts error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L962">                    .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L963">                    .I$();</span>
<span class="fc" id="L964">            O3Utils.close(ff, dstFixFd);</span>
<span class="fc" id="L965">            freeTs(</span>
                    columnCounter,
                    0,
                    0,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    tableWriter,
                    ff
            );
<span class="fc" id="L975">            throw e;</span>
<span class="fc" id="L976">        }</span>

<span class="fc" id="L978">        publishCopyTask(</span>
                columnCounter,
                null,
                columnType,
                O3_BLOCK_O3,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                srcOooLo,
                srcOooHi,
                0, // designated timestamp column cannot be added after table is created
                srcDataMax,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                srcOooLo,
                srcOooHi,
                timestampMin,
                timestampMax,
                partitionTimestamp, // &lt;-- pass thru
                dstFixFd,
                dstFixAddr,
                dstFixOffset,
                dstFixFileOffset,
                dstFixSize,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                indexBlockCapacity,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                false,
                tableWriter,
                null
        );
<span class="fc" id="L1030">    }</span>

    private static void appendVarColumn(
            AtomicInteger columnCounter,
            int columnType,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            long srcDataTop,
            long srcDataMax,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int activeFixFd,
            int activeVarFd,
            MemoryMA dstFixMem,
            MemoryMA dstVarMem,
            long dstLen,
            TableWriter tableWriter
    ) {
<span class="fc" id="L1056">        long dstFixAddr = 0;</span>
        long dstFixOffset;
        long dstFixFileOffset;
<span class="fc" id="L1059">        long dstVarAddr = 0;</span>
        long dstVarOffset;
        long dstVarAdjust;
<span class="fc" id="L1062">        long dstVarSize = 0;</span>
<span class="fc" id="L1063">        long dstFixSize = 0;</span>
<span class="fc" id="L1064">        final FilesFacade ff = tableWriter.getFilesFacade();</span>
        try {
<span class="fc" id="L1066">            long l = O3Utils.getVarColumnLength(srcOooLo, srcOooHi, srcOooFixAddr);</span>
<span class="fc" id="L1067">            dstFixSize = (dstLen + 1) * Long.BYTES;</span>
<span class="fc bfc" id="L1068" title="All 6 branches covered.">            if (dstFixMem == null || dstFixMem.getAppendAddressSize() &lt; dstFixSize || dstVarMem.getAppendAddressSize() &lt; l) {</span>
<span class="pc bpc" id="L1069" title="1 of 4 branches missed.">                assert dstFixMem == null || dstFixMem.getAppendOffset() - Long.BYTES == (srcDataMax - srcDataTop) * Long.BYTES;</span>

<span class="fc" id="L1071">                dstFixOffset = (srcDataMax - srcDataTop) * Long.BYTES;</span>
<span class="fc" id="L1072">                dstFixFileOffset = dstFixOffset;</span>
<span class="fc" id="L1073">                dstFixAddr = mapRW(ff, Math.abs(activeFixFd), dstFixSize, MemoryTag.MMAP_O3);</span>

<span class="fc bfc" id="L1075" title="All 2 branches covered.">                if (dstFixOffset &gt; 0) {</span>
<span class="fc" id="L1076">                    dstVarOffset = Unsafe.getUnsafe().getLong(dstFixAddr + dstFixOffset);</span>
                } else {
<span class="fc" id="L1078">                    dstVarOffset = 0;</span>
                }

<span class="fc" id="L1081">                dstVarSize = l + dstVarOffset;</span>
<span class="fc" id="L1082">                dstVarAddr = mapRW(ff, Math.abs(activeVarFd), dstVarSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1083">                dstVarAdjust = 0;</span>
            } else {
<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">                assert dstFixMem.getAppendOffset() &gt;= Long.BYTES;</span>
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">                assert dstFixMem.getAppendOffset() - Long.BYTES == (srcDataMax - srcDataTop) * Long.BYTES;</span>

<span class="fc" id="L1088">                dstFixAddr = dstFixMem.getAppendAddress() - Long.BYTES;</span>
<span class="fc" id="L1089">                dstVarAddr = dstVarMem.getAppendAddress();</span>
<span class="fc" id="L1090">                dstFixOffset = 0;</span>
<span class="fc" id="L1091">                dstFixFileOffset = dstFixMem.getAppendOffset() - Long.BYTES;</span>
<span class="fc" id="L1092">                dstFixSize = -dstFixSize;</span>
<span class="fc" id="L1093">                dstVarOffset = 0;</span>
<span class="fc" id="L1094">                dstVarSize = -l;</span>
<span class="fc" id="L1095">                dstVarAdjust = dstVarMem.getAppendOffset();</span>
            }
<span class="fc" id="L1097">        } catch (Throwable e) {</span>
<span class="fc" id="L1098">            LOG.error().$(&quot;append var error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L1099">                    .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L1100">                    .I$();</span>
<span class="fc" id="L1101">            O3Utils.unmapAndClose(ff, activeFixFd, dstFixAddr, dstFixSize);</span>
<span class="fc" id="L1102">            O3Utils.unmapAndClose(ff, activeVarFd, dstVarAddr, dstVarSize);</span>
<span class="fc" id="L1103">            freeTs(</span>
                    columnCounter,
                    0,
                    0,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    tableWriter,
                    ff
            );
<span class="fc" id="L1113">            throw e;</span>
<span class="fc" id="L1114">        }</span>
<span class="fc" id="L1115">        publishCopyTask(</span>
                columnCounter,
                null,
                columnType,
                O3_BLOCK_O3,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                srcOooLo,
                srcOooHi,
                srcDataTop,
                srcDataMax,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                srcOooLo,
                srcOooHi,
                timestampMin,
                timestampMax,
                partitionTimestamp, // &lt;-- pass thru
                activeFixFd,
                dstFixAddr,
                dstFixOffset,
                dstFixFileOffset,
                dstFixSize,
                activeVarFd,
                dstVarAddr,
                dstVarOffset,
                0,
                dstVarAdjust,
                dstVarSize,
                0,
                0,
                0,
                0,
                indexBlockCapacity,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                false,
                tableWriter,
                null
        );
<span class="fc" id="L1167">    }</span>

    private static void freeTs(
            AtomicInteger columnCounter,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            TableWriter tableWriter,
            FilesFacade ff
    ) {
<span class="fc" id="L1179">        tableWriter.o3BumpErrorCount();</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">        if (columnCounter.decrementAndGet() == 0) {</span>
<span class="fc" id="L1181">            O3Utils.unmap(ff, srcTimestampAddr, srcTimestampSize);</span>
<span class="fc" id="L1182">            O3Utils.close(ff, srcTimestampFd);</span>
<span class="fc" id="L1183">            tableWriter.o3ClockDownPartitionUpdateCount();</span>
<span class="fc" id="L1184">            tableWriter.o3CountDownDoneLatch();</span>
<span class="pc bpc" id="L1185" title="1 of 2 branches missed.">            if (timestampMergeIndexAddr != 0) {</span>
<span class="fc" id="L1186">                Vect.freeMergedIndex(timestampMergeIndexAddr, timestampMergeIndexSize);</span>
            }
        }
<span class="fc" id="L1189">    }</span>

    private static void mergeFixColumn(
            Path pathToPartition,
            int pplen,
            CharSequence columnName,
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long oooPartitionMin,
            long oooPartitionMax,
            long oooPartitionHi,
            long srcDataMax,
            long srcDataTop,
            int srcDataFixFd,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            long txn,
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeOOOLo,
            long mergeOOOHi,
            long mergeDataLo,
            long mergeDataHi,
            long mergeLen,
            int suffixType,
            long suffixLo,
            long suffixHi,
            int indexBlockCapacity,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long colTopSinkAddr,
            long columnNameTxn
    ) {
<span class="fc" id="L1233">        int partCount = 0;</span>
        long dstFixAppendOffset1;
<span class="fc" id="L1235">        long srcDataFixSize = 0;</span>
        long srcDataFixOffset;
<span class="fc" id="L1237">        long srcDataFixAddr = 0;</span>
        final int pDirNameLen;
        long dstFixAppendOffset2;
<span class="fc" id="L1240">        int dstFixFd = 0;</span>
<span class="fc" id="L1241">        long dstFixAddr = 0;</span>
        long srcDataTopOffset;
<span class="fc" id="L1243">        long dstFixSize = 0;</span>
<span class="fc" id="L1244">        int dstKFd = 0;</span>
<span class="fc" id="L1245">        int dstVFd = 0;</span>
<span class="fc" id="L1246">        final int srcFixFd = Math.abs(srcDataFixFd);</span>
<span class="fc" id="L1247">        final int shl = ColumnType.pow2SizeOf(Math.abs(columnType));</span>
<span class="fc" id="L1248">        final FilesFacade ff = tableWriter.getFilesFacade();</span>
<span class="fc" id="L1249">        final boolean directIoFlag = tableWriter.preferDirectIO();</span>

        try {
<span class="fc" id="L1252">            txnPartition(pathToPartition.trimTo(pplen), txn);</span>
<span class="fc" id="L1253">            pDirNameLen = pathToPartition.length();</span>

<span class="fc bfc" id="L1255" title="All 2 branches covered.">            if (srcDataTop &gt; 0) {</span>
<span class="fc" id="L1256">                final long srcDataActualBytes = (srcDataMax - srcDataTop) &lt;&lt; shl;</span>
<span class="fc" id="L1257">                final long srcDataMaxBytes = srcDataMax &lt;&lt; shl;</span>
<span class="fc bfc" id="L1258" title="All 4 branches covered.">                if (srcDataTop &gt; prefixHi || prefixType == O3_BLOCK_O3) {</span>
                    // extend the existing column down, we will be discarding it anyway
<span class="fc" id="L1260">                    srcDataFixSize = srcDataActualBytes + srcDataMaxBytes;</span>
<span class="fc" id="L1261">                    srcDataFixAddr = mapRW(ff, srcFixFd, srcDataFixSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1262">                    ff.madvise(srcDataFixAddr, srcDataFixSize, Files.POSIX_MADV_SEQUENTIAL);</span>
<span class="fc" id="L1263">                    TableUtils.setNull(columnType, srcDataFixAddr + srcDataActualBytes, srcDataTop);</span>
<span class="fc" id="L1264">                    Vect.memcpy(srcDataFixAddr + srcDataMaxBytes, srcDataFixAddr, srcDataActualBytes);</span>
<span class="fc" id="L1265">                    srcDataTop = 0;</span>
<span class="fc" id="L1266">                    srcDataFixOffset = srcDataActualBytes;</span>
                } else {
                    // when we are shuffling &quot;empty&quot; space we can just reduce column top instead
                    // of moving data
<span class="fc" id="L1270">                    Unsafe.getUnsafe().putLong(colTopSinkAddr, srcDataTop);</span>
<span class="fc" id="L1271">                    srcDataFixSize = srcDataActualBytes;</span>
<span class="fc" id="L1272">                    srcDataFixAddr = mapRW(ff, srcFixFd, srcDataFixSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1273">                    ff.madvise(srcDataFixAddr, srcDataFixSize, Files.POSIX_MADV_SEQUENTIAL);</span>
<span class="fc" id="L1274">                    srcDataFixOffset = 0;</span>
                }
<span class="fc" id="L1276">            } else {</span>
<span class="fc" id="L1277">                srcDataFixSize = srcDataMax &lt;&lt; shl;</span>
<span class="fc" id="L1278">                srcDataFixAddr = mapRW(ff, srcFixFd, srcDataFixSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1279">                ff.madvise(srcDataFixAddr, srcDataFixSize, Files.POSIX_MADV_SEQUENTIAL);</span>
<span class="fc" id="L1280">                srcDataFixOffset = 0;</span>
            }

<span class="fc" id="L1283">            srcDataTopOffset = srcDataTop &lt;&lt; shl;</span>

<span class="fc" id="L1285">            dFile(pathToPartition.trimTo(pDirNameLen), columnName, columnNameTxn);</span>
<span class="fc" id="L1286">            dstFixFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L1287">            dstFixSize = ((srcOooHi - srcOooLo + 1) + srcDataMax - srcDataTop) &lt;&lt; shl;</span>
<span class="fc" id="L1288">            dstFixAddr = mapRW(ff, dstFixFd, dstFixSize, MemoryTag.MMAP_O3);</span>
<span class="pc bpc" id="L1289" title="1 of 2 branches missed.">            if (directIoFlag) {</span>
<span class="fc" id="L1290">                ff.fadvise(dstFixFd, 0, dstFixSize, Files.POSIX_FADV_RANDOM);</span>
            } else {
<span class="nc" id="L1292">                ff.madvise(dstFixAddr, dstFixSize, Files.POSIX_MADV_RANDOM);</span>
            }

            // when prefix is &quot;data&quot; we need to reduce it by &quot;srcDataTop&quot;
<span class="fc bfc" id="L1296" title="All 2 branches covered.">            if (prefixType == O3_BLOCK_DATA) {</span>
<span class="fc" id="L1297">                dstFixAppendOffset1 = (prefixHi - prefixLo + 1 - srcDataTop) &lt;&lt; shl;</span>
<span class="fc" id="L1298">                prefixHi -= srcDataTop;</span>
            } else {
<span class="fc" id="L1300">                dstFixAppendOffset1 = (prefixHi - prefixLo + 1) &lt;&lt; shl;</span>
            }

<span class="pc bpc" id="L1303" title="1 of 4 branches missed.">            if (mergeDataLo &gt; -1 &amp;&amp; mergeOOOLo &gt; -1) {</span>
<span class="fc" id="L1304">                dstFixAppendOffset2 = dstFixAppendOffset1 + (mergeLen &lt;&lt; shl);</span>
            } else {
<span class="fc" id="L1306">                dstFixAppendOffset2 = dstFixAppendOffset1;</span>
            }

<span class="fc bfc" id="L1309" title="All 4 branches covered.">            if (suffixType == O3_BLOCK_DATA &amp;&amp; srcDataTop &gt; 0) {</span>
<span class="fc" id="L1310">                suffixHi -= srcDataTop;</span>
<span class="fc" id="L1311">                suffixLo -= srcDataTop;</span>
            }

<span class="fc bfc" id="L1314" title="All 2 branches covered.">            if (indexBlockCapacity &gt; -1) {</span>
<span class="fc" id="L1315">                BitmapIndexUtils.keyFileName(pathToPartition.trimTo(pDirNameLen), columnName, columnNameTxn);</span>
<span class="fc" id="L1316">                dstKFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L1317">                BitmapIndexUtils.valueFileName(pathToPartition.trimTo(pDirNameLen), columnName, columnNameTxn);</span>
<span class="fc" id="L1318">                dstVFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
            }

<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">            if (prefixType != O3_BLOCK_NONE) {</span>
<span class="fc" id="L1322">                partCount++;</span>
            }

<span class="fc bfc" id="L1325" title="All 2 branches covered.">            if (mergeType != O3_BLOCK_NONE) {</span>
<span class="fc" id="L1326">                partCount++;</span>
            }

<span class="fc bfc" id="L1329" title="All 2 branches covered.">            if (suffixType != O3_BLOCK_NONE) {</span>
<span class="fc" id="L1330">                partCount++;</span>
            }
<span class="fc" id="L1332">        } catch (Throwable e) {</span>
<span class="fc" id="L1333">            LOG.error().$(&quot;merge fix error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L1334">                    .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L1335">                    .I$();</span>
<span class="fc" id="L1336">            O3Utils.unmapAndClose(ff, srcDataFixFd, srcDataFixAddr, srcDataFixSize);</span>
<span class="fc" id="L1337">            O3Utils.unmapAndClose(ff, dstFixFd, dstFixAddr, dstFixSize);</span>
<span class="fc" id="L1338">            O3Utils.close(ff, dstKFd);</span>
<span class="fc" id="L1339">            O3Utils.close(ff, dstVFd);</span>
<span class="fc" id="L1340">            tableWriter.o3BumpErrorCount();</span>
<span class="fc bfc" id="L1341" title="All 2 branches covered.">            if (columnCounter.decrementAndGet() == 0) {</span>
<span class="fc" id="L1342">                O3Utils.unmap(ff, srcTimestampAddr, srcTimestampSize);</span>
<span class="fc" id="L1343">                O3Utils.close(ff, srcTimestampFd);</span>
<span class="fc" id="L1344">                Vect.freeMergedIndex(timestampMergeIndexAddr, timestampMergeIndexSize);</span>
<span class="fc" id="L1345">                tableWriter.o3ClockDownPartitionUpdateCount();</span>
<span class="fc" id="L1346">                tableWriter.o3CountDownDoneLatch();</span>
            }
<span class="fc" id="L1348">            throw e;</span>
<span class="fc" id="L1349">        }</span>

<span class="fc" id="L1351">        partCounter.set(partCount);</span>
<span class="fc" id="L1352">        publishMultiCopyTasks(</span>
                columnCounter,
                partCounter,
                columnType,
                timestampMergeIndexAddr,
                timestampMergeIndexSize,
                srcDataFixFd,
                srcDataFixAddr,
                srcDataFixOffset,
                srcDataFixSize,
                0,
                0,
                0,
                0,
                srcDataTopOffset,
                srcDataMax,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                oooPartitionMin,
                oooPartitionMax,
                oooPartitionHi,
                prefixType,
                prefixLo,
                prefixHi,
                mergeType,
                mergeDataLo,
                mergeDataHi,
                mergeOOOLo,
                mergeOOOHi,
                suffixType,
                suffixLo,
                suffixHi,
                dstFixFd,
                dstFixAddr,
                dstFixSize,
                0,
                0,
                0,
                dstFixAppendOffset1,
                dstFixAppendOffset2,
                0,
                0,
                dstKFd,
                dstVFd,
                indexBlockCapacity,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                tableWriter,
                indexWriter
        );
<span class="fc" id="L1406">    }</span>

    private static void mergeLastPartition(
            Path pathToPartition,
            int pplen,
            CharSequence columnName,
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long oooPartitionMin,
            long oooPartitionMax,
            long oooPartitionHi,
            long srcDataTop,
            long srcDataMax,
            long txn,
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeOOOLo,
            long mergeOOOHi,
            long mergeDataLo,
            long mergeDataHi,
            long mergeLen,
            int suffixType,
            long suffixLo,
            long suffixHi,
            int indexBlockCapacity,
            int activeFixFd,
            int activeVarFd,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long colTopSinkAddr,
            long columnNameTxn
    ) {
<span class="fc bfc" id="L1451" title="All 2 branches covered.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.BINARY:
            case ColumnType.STRING:
                // index files are opened as normal
<span class="fc" id="L1455">                mergeVarColumn(</span>
                        pathToPartition,
                        pplen,
                        columnName,
                        columnCounter,
                        partCounter,
                        columnType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        oooPartitionMin,
                        oooPartitionMax,
                        oooPartitionHi,
                        srcDataTop,
                        srcDataMax,
                        txn,
                        prefixType,
                        prefixLo,
                        prefixHi,
                        mergeType,
                        mergeOOOLo,
                        mergeOOOHi,
                        mergeDataLo,
                        mergeDataHi,
                        mergeLen,
                        suffixType,
                        suffixLo,
                        suffixHi,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        -activeFixFd,
                        -activeVarFd,
                        tableWriter,
                        colTopSinkAddr,
                        columnNameTxn
                );
<span class="fc" id="L1497">                break;</span>
            default:
<span class="fc" id="L1499">                mergeFixColumn(</span>
                        pathToPartition,
                        pplen,
                        columnName,
                        columnCounter,
                        partCounter,
                        columnType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        oooPartitionMin,
                        oooPartitionMax,
                        oooPartitionHi,
                        srcDataMax,
                        srcDataTop,
                        -activeFixFd,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        txn,
                        prefixType,
                        prefixLo,
                        prefixHi,
                        mergeType,
                        mergeOOOLo,
                        mergeOOOHi,
                        mergeDataLo,
                        mergeDataHi,
                        mergeLen,
                        suffixType,
                        suffixLo,
                        suffixHi,
                        indexBlockCapacity,
                        tableWriter,
                        indexWriter,
                        colTopSinkAddr,
                        columnNameTxn
                );
                break;
        }
<span class="fc" id="L1543">    }</span>

    private static void mergeMidPartition(
            Path pathToPartition,
            int plen,
            int pplen,
            CharSequence columnName,
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long oooPartitionMin,
            long oooPartitionMax,
            long oooPartitionHi,
            long srcDataTop,
            long srcDataMax,
            long txn,
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeOOOLo,
            long mergeOOOHi,
            long mergeDataLo,
            long mergeDataHi,
            long mergeLen,
            int suffixType,
            long suffixLo,
            long suffixHi,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long colTopSinkAddr,
            long partitionTimestamp,
            int columnIndex,
            long columnNameTxn
    ) {
<span class="fc" id="L1589">        final FilesFacade ff = tableWriter.getFilesFacade();</span>
        // not set, we need to check file existence and read
<span class="pc bpc" id="L1591" title="1 of 2 branches missed.">        if (srcDataTop == -1) {</span>
            try {
<span class="fc" id="L1593">                srcDataTop = tableWriter.getColumnTop(partitionTimestamp, columnIndex, srcDataMax);</span>
<span class="nc" id="L1594">            } catch (Throwable e) {</span>
<span class="nc" id="L1595">                LOG.error().$(&quot;merge mid partition error 1 [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="nc" id="L1596">                        .$(&quot;, e=&quot;).$(e)</span>
<span class="nc" id="L1597">                        .I$();</span>
<span class="nc" id="L1598">                freeTs(</span>
                        columnCounter,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        tableWriter,
                        ff
                );
<span class="nc" id="L1608">                throw e;</span>
<span class="fc" id="L1609">            }</span>
        }

<span class="fc" id="L1612">        int srcDataFixFd = 0;</span>
<span class="fc" id="L1613">        int srcDataVarFd = 0;</span>
<span class="fc bfc" id="L1614" title="All 2 branches covered.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.BINARY:
            case ColumnType.STRING:
                try {
<span class="fc" id="L1618">                    iFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L1619">                    srcDataFixFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L1620">                    dFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L1621">                    srcDataVarFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L1622">                } catch (Throwable e) {</span>
<span class="fc" id="L1623">                    LOG.error().$(&quot;merge mid partition error 2 [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L1624">                            .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L1625">                            .I$();</span>
<span class="fc" id="L1626">                    O3Utils.close(ff, srcDataFixFd);</span>
<span class="fc" id="L1627">                    O3Utils.close(ff, srcDataVarFd);</span>
<span class="fc" id="L1628">                    freeTs(</span>
                            columnCounter,
                            timestampMergeIndexAddr,
                            timestampMergeIndexSize,
                            srcTimestampFd,
                            srcTimestampAddr,
                            srcTimestampSize,
                            tableWriter,
                            ff
                    );
<span class="fc" id="L1638">                    throw e;</span>
<span class="fc" id="L1639">                }</span>

<span class="fc" id="L1641">                mergeVarColumn(</span>
                        pathToPartition,
                        pplen,
                        columnName,
                        columnCounter,
                        partCounter,
                        columnType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        oooPartitionMin,
                        oooPartitionMax,
                        oooPartitionHi,
                        srcDataTop,
                        srcDataMax,
                        txn,
                        prefixType,
                        prefixLo,
                        prefixHi,
                        mergeType,
                        mergeOOOLo,
                        mergeOOOHi,
                        mergeDataLo,
                        mergeDataHi,
                        mergeLen,
                        suffixType,
                        suffixLo,
                        suffixHi,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        srcDataFixFd,
                        srcDataVarFd,
                        tableWriter,
                        colTopSinkAddr,
                        columnNameTxn
                );
<span class="fc" id="L1683">                break;</span>
            default:
                try {
<span class="pc bpc" id="L1686" title="3 of 4 branches missed.">                    if (columnType &lt; 0 &amp;&amp; srcTimestampFd &gt; 0) {</span>
                        // ensure timestamp srcDataFixFd is always negative, we will close it externally
<span class="nc" id="L1688">                        srcDataFixFd = -srcTimestampFd;</span>
                    } else {
<span class="fc" id="L1690">                        dFile(pathToPartition.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L1691">                        srcDataFixFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
                    }
<span class="fc" id="L1693">                } catch (Throwable e) {</span>
<span class="fc" id="L1694">                    LOG.error().$(&quot;merge mid partition error 3 [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L1695">                            .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L1696">                            .I$();</span>
<span class="fc" id="L1697">                    freeTs(</span>
                            columnCounter,
                            timestampMergeIndexAddr,
                            timestampMergeIndexSize,
                            srcTimestampFd,
                            srcTimestampAddr,
                            srcTimestampSize,
                            tableWriter,
                            ff
                    );
<span class="fc" id="L1707">                    throw e;</span>
<span class="fc" id="L1708">                }</span>
<span class="fc" id="L1709">                mergeFixColumn(</span>
                        pathToPartition,
                        pplen,
                        columnName,
                        columnCounter,
                        partCounter,
                        columnType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        srcOooMax,
                        oooPartitionMin,
                        oooPartitionMax,
                        oooPartitionHi,
                        srcDataMax,
                        srcDataTop,
                        srcDataFixFd,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        txn,
                        prefixType,
                        prefixLo,
                        prefixHi,
                        mergeType,
                        mergeOOOLo,
                        mergeOOOHi,
                        mergeDataLo,
                        mergeDataHi,
                        mergeLen,
                        suffixType,
                        suffixLo,
                        suffixHi,
                        indexBlockCapacity,
                        tableWriter,
                        indexWriter,
                        colTopSinkAddr,
                        columnNameTxn
                );
                break;
        }
<span class="fc" id="L1753">    }</span>

    private static void mergeVarColumn(
            Path pathToPartition,
            int pplen,
            CharSequence columnName,
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long oooPartitionMin,
            long oooPartitionMax,
            long oooPartitionHi,
            long srcDataTop,
            long srcDataMax,
            long txn,
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeOOOLo,
            long mergeOOOHi,
            long mergeDataLo,
            long mergeDataHi,
            long mergeLen,
            int suffixType,
            long suffixLo,
            long suffixHi,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int srcDataFixFd,
            int srcDataVarFd,
            TableWriter tableWriter,
            long colTopSinkAddr,
            long columnNameTxn
    ) {
<span class="fc" id="L1797">        int partCount = 0;</span>
<span class="fc" id="L1798">        int dstVarFd = 0;</span>
<span class="fc" id="L1799">        long dstVarAddr = 0;</span>
        long srcDataFixOffset;
<span class="fc" id="L1801">        long srcDataFixAddr = 0;</span>
        final int pDirNameLen;
<span class="fc" id="L1803">        long dstVarSize = 0;</span>
        long srcDataTopOffset;
<span class="fc" id="L1805">        long dstFixSize = 0;</span>
        long dstFixAppendOffset1;
<span class="fc" id="L1807">        long srcDataFixSize = 0;</span>
<span class="fc" id="L1808">        long srcDataVarSize = 0;</span>
        long dstVarAppendOffset2;
        long dstFixAppendOffset2;
<span class="fc" id="L1811">        int dstFixFd = 0;</span>
<span class="fc" id="L1812">        long dstFixAddr = 0;</span>
<span class="fc" id="L1813">        long srcDataVarAddr = 0;</span>
<span class="fc" id="L1814">        long srcDataVarOffset = 0;</span>
<span class="fc" id="L1815">        long dstVarAppendOffset1 = 0;</span>
<span class="fc" id="L1816">        final int srcFixFd = Math.abs(srcDataFixFd);</span>
<span class="fc" id="L1817">        final int srcVarFd = Math.abs(srcDataVarFd);</span>
<span class="fc" id="L1818">        final FilesFacade ff = tableWriter.getFilesFacade();</span>
<span class="fc" id="L1819">        final boolean directIoFlag = tableWriter.preferDirectIO();</span>

        try {
<span class="fc" id="L1822">            txnPartition(pathToPartition.trimTo(pplen), txn);</span>
<span class="fc" id="L1823">            pDirNameLen = pathToPartition.length();</span>

<span class="fc bfc" id="L1825" title="All 2 branches covered.">            if (srcDataTop &gt; 0) {</span>
<span class="fc" id="L1826">                final long srcDataActualBytes = (srcDataMax - srcDataTop) * Long.BYTES;</span>
<span class="fc" id="L1827">                final long srcDataMaxBytes = srcDataMax * Long.BYTES;</span>
<span class="fc bfc" id="L1828" title="All 4 branches covered.">                if (srcDataTop &gt; prefixHi || prefixType == O3_BLOCK_O3) {</span>
                    // extend the existing column down, we will be discarding it anyway
<span class="fc" id="L1830">                    srcDataFixSize = srcDataActualBytes + srcDataMaxBytes + Long.BYTES;</span>
<span class="fc" id="L1831">                    srcDataFixAddr = mapRW(ff, srcFixFd, srcDataFixSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1832">                    ff.madvise(srcDataFixAddr, srcDataFixSize, Files.POSIX_MADV_SEQUENTIAL);</span>

<span class="fc bfc" id="L1834" title="All 2 branches covered.">                    if (srcDataActualBytes &gt; 0) {</span>
<span class="fc" id="L1835">                        srcDataVarSize = Unsafe.getUnsafe().getLong(srcDataFixAddr + srcDataActualBytes);</span>
                    }

                    // at bottom of source var column set length of strings to null (-1) for as many strings
                    // as srcDataTop value.
<span class="fc" id="L1840">                    srcDataVarOffset = srcDataVarSize;</span>
                    long reservedBytesForColTopNulls;
<span class="fc bfc" id="L1842" title="All 2 branches covered.">                    if (ColumnType.isString(columnType)) {</span>
                        // We need to reserve null values for every column top value
                        // in the variable len file. Each null value takes 4 bytes for string
<span class="fc" id="L1845">                        reservedBytesForColTopNulls = srcDataTop * Integer.BYTES;</span>
<span class="fc" id="L1846">                        srcDataVarSize += reservedBytesForColTopNulls + srcDataVarSize;</span>
<span class="fc" id="L1847">                        srcDataVarAddr = mapRW(ff, srcVarFd, srcDataVarSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1848">                        ff.madvise(srcDataVarAddr, srcDataVarSize, Files.POSIX_MADV_SEQUENTIAL);</span>

                        // Set var column values to null first srcDataTop times
                        // Next line should be:
                        // Vect.setMemoryInt(srcDataVarAddr + srcDataVarOffset, -1, srcDataTop);
                        // But we can replace it with memset setting each byte to -1
                        // because binary repr of int -1 is 4 bytes of -1
                        // memset is faster than any SIMD implementation we can come with
<span class="fc" id="L1856">                        Vect.memset(srcDataVarAddr + srcDataVarOffset, (int) reservedBytesForColTopNulls, -1);</span>

                        // Copy var column data
<span class="fc" id="L1859">                        Vect.memcpy(srcDataVarAddr + srcDataVarOffset + reservedBytesForColTopNulls, srcDataVarAddr, srcDataVarOffset);</span>

                        // we need to shift copy the original column so that new block points at strings &quot;below&quot; the
                        // nulls we created above
<span class="fc" id="L1863">                        long hiInclusive = srcDataMax - srcDataTop; // STOP. DON'T ADD +1 HERE. srcHi is inclusive, no need to do +1</span>
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">                        assert srcDataFixSize &gt;= srcDataMaxBytes + (hiInclusive + 1) * 8; // make sure enough len mapped</span>
<span class="fc" id="L1865">                        O3Utils.shiftCopyFixedSizeColumnData(</span>
                                -reservedBytesForColTopNulls,
                                srcDataFixAddr,
                                0,
                                hiInclusive,
                                srcDataFixAddr + srcDataMaxBytes
                        );

                        // now set the &quot;empty&quot; bit of fixed size column with references to those
                        // null strings we just added
                        // Call to setVarColumnRefs32Bit must be after shiftCopyFixedSizeColumnData
                        // because data first have to be shifted before overwritten
<span class="fc" id="L1877">                        Vect.setVarColumnRefs32Bit(srcDataFixAddr + srcDataActualBytes, 0, srcDataTop);</span>
<span class="fc" id="L1878">                    } else {</span>
                        // We need to reserve null values for every column top value
                        // in the variable len file. Each null value takes 8 bytes for binary
<span class="fc" id="L1881">                        reservedBytesForColTopNulls = srcDataTop * Long.BYTES;</span>
<span class="fc" id="L1882">                        srcDataVarSize += reservedBytesForColTopNulls + srcDataVarSize;</span>
<span class="fc" id="L1883">                        srcDataVarAddr = mapRW(ff, srcVarFd, srcDataVarSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1884">                        ff.madvise(srcDataVarAddr, srcDataVarSize, Files.POSIX_MADV_SEQUENTIAL);</span>

                        // Set var column values to null first srcDataTop times
                        // Next line should be:
                        // Vect.setMemoryLong(srcDataVarAddr + srcDataVarOffset, -1, srcDataTop);
                        // But we can replace it with memset setting each byte to -1
                        // because binary repr of int -1 is 4 bytes of -1
                        // memset is faster than any SIMD implementation we can come with
<span class="fc" id="L1892">                        Vect.memset(srcDataVarAddr + srcDataVarOffset, (int) reservedBytesForColTopNulls, -1);</span>

                        // Copy var column data
<span class="fc" id="L1895">                        Vect.memcpy(srcDataVarAddr + srcDataVarOffset + reservedBytesForColTopNulls, srcDataVarAddr, srcDataVarOffset);</span>

                        // we need to shift copy the original column so that new block points at strings &quot;below&quot; the
                        // nulls we created above
<span class="fc" id="L1899">                        long hiInclusive = srcDataMax - srcDataTop; // STOP. DON'T ADD +1 HERE. srcHi is inclusive, no need to do +1</span>
<span class="pc bpc" id="L1900" title="1 of 2 branches missed.">                        assert srcDataFixSize &gt;= srcDataMaxBytes + (hiInclusive + 1) * 8; // make sure enough len mapped</span>
<span class="fc" id="L1901">                        O3Utils.shiftCopyFixedSizeColumnData(</span>
                                -reservedBytesForColTopNulls,
                                srcDataFixAddr,
                                0,
                                hiInclusive,
                                srcDataFixAddr + srcDataMaxBytes
                        );

                        // now set the &quot;empty&quot; bit of fixed size column with references to those
                        // null strings we just added
<span class="fc" id="L1911">                        Vect.setVarColumnRefs64Bit(srcDataFixAddr + srcDataActualBytes, 0, srcDataTop);</span>
                    }
<span class="fc" id="L1913">                    srcDataTop = 0;</span>
<span class="fc" id="L1914">                    srcDataFixOffset = srcDataActualBytes;</span>
<span class="fc" id="L1915">                } else {</span>
                    // when we are shuffling &quot;empty&quot; space we can just reduce column top instead
                    // of moving data
<span class="fc" id="L1918">                    Unsafe.getUnsafe().putLong(colTopSinkAddr, srcDataTop);</span>
<span class="fc" id="L1919">                    srcDataFixSize = srcDataActualBytes + Long.BYTES;</span>
<span class="fc" id="L1920">                    srcDataFixAddr = mapRW(ff, srcFixFd, srcDataFixSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1921">                    ff.madvise(srcDataFixAddr, srcDataFixSize, Files.POSIX_MADV_SEQUENTIAL);</span>
<span class="fc" id="L1922">                    srcDataFixOffset = 0;</span>

<span class="fc" id="L1924">                    srcDataVarSize = Unsafe.getUnsafe().getLong(srcDataFixAddr + srcDataFixSize - Long.BYTES);</span>
<span class="fc" id="L1925">                    srcDataVarAddr = mapRO(ff, srcVarFd, srcDataVarSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1926">                    ff.madvise(srcDataVarAddr, srcDataVarSize, Files.POSIX_MADV_SEQUENTIAL);</span>
                }
<span class="fc" id="L1928">            } else {</span>
                // var index column is n+1
<span class="fc" id="L1930">                srcDataFixSize = (srcDataMax + 1) * Long.BYTES;</span>
<span class="fc" id="L1931">                srcDataFixAddr = mapRW(ff, srcFixFd, srcDataFixSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1932">                ff.madvise(srcDataFixAddr, srcDataFixSize, Files.POSIX_MADV_SEQUENTIAL);</span>
<span class="fc" id="L1933">                srcDataFixOffset = 0;</span>

<span class="fc" id="L1935">                srcDataVarSize = Unsafe.getUnsafe().getLong(srcDataFixAddr + srcDataFixSize - Long.BYTES);</span>
<span class="fc" id="L1936">                srcDataVarAddr = mapRO(ff, srcVarFd, srcDataVarSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L1937">                ff.madvise(srcDataVarAddr, srcDataVarSize, Files.POSIX_MADV_SEQUENTIAL);</span>
            }

            // upgrade srcDataTop to offset
<span class="fc" id="L1941">            srcDataTopOffset = srcDataTop * Long.BYTES;</span>

<span class="fc" id="L1943">            iFile(pathToPartition.trimTo(pDirNameLen), columnName, columnNameTxn);</span>
<span class="fc" id="L1944">            dstFixFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L1945">            dstFixSize = (srcOooHi - srcOooLo + 1 + srcDataMax - srcDataTop + 1) * Long.BYTES;</span>
<span class="fc" id="L1946">            dstFixAddr = mapRW(ff, dstFixFd, dstFixSize, MemoryTag.MMAP_O3);</span>
<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">            if (directIoFlag) {</span>
<span class="fc" id="L1948">                ff.fadvise(dstFixFd, 0, dstFixSize, Files.POSIX_FADV_RANDOM);</span>
            } else {
<span class="nc" id="L1950">                ff.madvise(dstFixAddr, dstFixSize, Files.POSIX_MADV_RANDOM);</span>
            }

<span class="fc" id="L1953">            dFile(pathToPartition.trimTo(pDirNameLen), columnName, columnNameTxn);</span>
<span class="fc" id="L1954">            dstVarFd = openRW(ff, pathToPartition, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L1955">            dstVarSize = srcDataVarSize - srcDataVarOffset</span>
<span class="fc" id="L1956">                    + O3Utils.getVarColumnLength(srcOooLo, srcOooHi, srcOooFixAddr);</span>
<span class="fc" id="L1957">            dstVarAddr = mapRW(ff, dstVarFd, dstVarSize, MemoryTag.MMAP_O3);</span>
<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">            if (directIoFlag) {</span>
<span class="fc" id="L1959">                ff.fadvise(dstVarFd, 0, dstVarSize, Files.POSIX_FADV_RANDOM);</span>
            } else {
<span class="nc" id="L1961">                ff.madvise(dstVarAddr, dstVarSize, Files.POSIX_MADV_RANDOM);</span>
            }

<span class="fc bfc" id="L1964" title="All 2 branches covered.">            if (prefixType == O3_BLOCK_DATA) {</span>
<span class="fc" id="L1965">                dstFixAppendOffset1 = (prefixHi - prefixLo + 1 - srcDataTop) * Long.BYTES;</span>
<span class="fc" id="L1966">                prefixHi -= srcDataTop;</span>
            } else {
<span class="fc" id="L1968">                dstFixAppendOffset1 = (prefixHi - prefixLo + 1) * Long.BYTES;</span>
            }

<span class="fc bfc" id="L1971" title="All 4 branches covered.">            if (suffixType == O3_BLOCK_DATA &amp;&amp; srcDataTop &gt; 0) {</span>
<span class="fc" id="L1972">                suffixHi -= srcDataTop;</span>
<span class="fc" id="L1973">                suffixLo -= srcDataTop;</span>
            }

            // configure offsets
<span class="pc bpc" id="L1977" title="1 of 3 branches missed.">            switch (prefixType) {</span>
                case O3_BLOCK_O3:
<span class="fc" id="L1979">                    dstVarAppendOffset1 = O3Utils.getVarColumnLength(prefixLo, prefixHi, srcOooFixAddr);</span>
<span class="fc" id="L1980">                    partCount++;</span>
<span class="fc" id="L1981">                    break;</span>
                case O3_BLOCK_DATA:
<span class="fc" id="L1983">                    dstVarAppendOffset1 = O3Utils.getVarColumnLength(prefixLo, prefixHi, srcDataFixAddr + srcDataFixOffset);</span>
<span class="fc" id="L1984">                    partCount++;</span>
<span class="fc" id="L1985">                    break;</span>
                default:
                    break;
            }

            // offset 2
<span class="pc bpc" id="L1991" title="1 of 4 branches missed.">            if (mergeDataLo &gt; -1 &amp;&amp; mergeOOOLo &gt; -1) {</span>
<span class="fc" id="L1992">                long oooLen = O3Utils.getVarColumnLength(</span>
                        mergeOOOLo,
                        mergeOOOHi,
                        srcOooFixAddr
                );
<span class="fc" id="L1997">                long dataLen = O3Utils.getVarColumnLength(</span>
                        mergeDataLo,
                        mergeDataHi,
                        srcDataFixAddr + srcDataFixOffset - srcDataTop * 8
                );
<span class="fc" id="L2002">                dstFixAppendOffset2 = dstFixAppendOffset1 + (mergeLen * Long.BYTES);</span>
<span class="fc" id="L2003">                dstVarAppendOffset2 = dstVarAppendOffset1 + oooLen + dataLen;</span>
<span class="fc" id="L2004">            } else {</span>
<span class="fc" id="L2005">                dstFixAppendOffset2 = dstFixAppendOffset1;</span>
<span class="fc" id="L2006">                dstVarAppendOffset2 = dstVarAppendOffset1;</span>
            }

<span class="fc bfc" id="L2009" title="All 2 branches covered.">            if (mergeType != O3_BLOCK_NONE) {</span>
<span class="fc" id="L2010">                partCount++;</span>
            }

<span class="fc bfc" id="L2013" title="All 2 branches covered.">            if (suffixType != O3_BLOCK_NONE) {</span>
<span class="fc" id="L2014">                partCount++;</span>
            }
<span class="fc" id="L2016">        } catch (Throwable e) {</span>
<span class="fc" id="L2017">            LOG.error().$(&quot;merge var error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L2018">                    .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L2019">                    .I$();</span>
<span class="fc" id="L2020">            tableWriter.o3BumpErrorCount();</span>
<span class="fc" id="L2021">            O3CopyJob.copyIdleQuick(</span>
                    columnCounter,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcDataFixFd,
                    srcDataFixAddr,
                    srcDataFixSize,
                    srcDataVarFd,
                    srcDataVarAddr,
                    srcDataVarSize,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    dstFixFd,
                    dstFixAddr,
                    dstFixSize,
                    dstVarFd,
                    dstVarAddr,
                    dstVarSize,
                    0,
                    0,
                    tableWriter
            );
<span class="fc" id="L2044">            throw e;</span>
<span class="fc" id="L2045">        }</span>

<span class="fc" id="L2047">        partCounter.set(partCount);</span>
<span class="fc" id="L2048">        publishMultiCopyTasks(</span>
                columnCounter,
                partCounter,
                columnType,
                timestampMergeIndexAddr,
                timestampMergeIndexSize,
                srcDataFixFd,
                srcDataFixAddr,
                srcDataFixOffset,
                srcDataFixSize,
                srcDataVarFd,
                srcDataVarAddr,
                srcDataVarOffset,
                srcDataVarSize,
                srcDataTopOffset,
                srcDataMax,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                oooPartitionMin,
                oooPartitionMax,
                oooPartitionHi,
                prefixType,
                prefixLo,
                prefixHi,
                mergeType,
                mergeDataLo,
                mergeDataHi,
                mergeOOOLo,
                mergeOOOHi,
                suffixType,
                suffixLo,
                suffixHi,
                dstFixFd,
                dstFixAddr,
                dstFixSize,
                dstVarFd,
                dstVarAddr,
                dstVarSize,
                dstFixAppendOffset1,
                dstFixAppendOffset2,
                dstVarAppendOffset1,
                dstVarAppendOffset2,
                0,
                0,
                indexBlockCapacity,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                tableWriter,
                null
        );
<span class="fc" id="L2102">    }</span>

    private static void publishCopyTask(
            AtomicInteger columnCounter,
            @Nullable AtomicInteger partCounter,
            int columnType,
            int blockType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixOffset,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarOffset,
            long srcDataVarSize,
            long srcDataLo,
            long srcDataHi,
            long srcDataTop,
            long srcDataMax,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long srcOooPartitionLo,
            long srcOooPartitionHi,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            int dstFixFd,
            long dstFixAddr,
            long dstFixOffset,
            long dstFixFileOffset,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarOffset,
            long dstVarOffsetEnd,
            long dstVarAdjust,
            long dstVarSize,
            int dstKFd,
            int dstVFd,
            long dstIndexOffset,
            long dstIndexAdjust,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            boolean partitionMutates,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter
    ) {
<span class="fc" id="L2156">        long cursor = tableWriter.getO3CopyPubSeq().next();</span>
<span class="fc bfc" id="L2157" title="All 2 branches covered.">        if (cursor &gt; -1) {</span>
<span class="fc" id="L2158">            publishCopyTaskHarmonized(</span>
                    columnCounter,
                    partCounter,
                    columnType,
                    blockType,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcDataFixFd,
                    srcDataFixAddr,
                    srcDataFixOffset,
                    srcDataFixSize,
                    srcDataVarFd,
                    srcDataVarAddr,
                    srcDataVarOffset,
                    srcDataVarSize,
                    srcDataLo,
                    srcDataHi,
                    srcDataTop,
                    srcDataMax,
                    srcOooFixAddr,
                    srcOooVarAddr,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    srcOooPartitionLo,
                    srcOooPartitionHi,
                    timestampMin,
                    timestampMax,
                    partitionTimestamp,
                    dstFixFd,
                    dstFixAddr,
                    dstFixOffset,
                    dstFixFileOffset,
                    dstFixSize,
                    dstVarFd,
                    dstVarAddr,
                    dstVarOffset,
                    dstVarOffsetEnd,
                    dstVarAdjust,
                    dstVarSize,
                    dstKFd,
                    dstVFd,
                    dstIndexOffset,
                    dstIndexAdjust,
                    indexBlockCapacity,
                    cursor,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    partitionMutates,
                    tableWriter,
                    indexWriter
            );
        } else {
<span class="fc" id="L2212">            publishCopyTaskContended(</span>
                    cursor,
                    columnCounter,
                    partCounter,
                    columnType,
                    blockType,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcDataFixFd,
                    srcDataFixAddr,
                    srcDataFixOffset,
                    srcDataFixSize,
                    srcDataVarFd,
                    srcDataVarAddr,
                    srcDataVarOffset,
                    srcDataVarSize,
                    srcDataTop,
                    srcDataLo,
                    srcDataHi,
                    srcDataMax,
                    srcOooFixAddr,
                    srcOooVarAddr,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    srcOooPartitionLo,
                    srcOooPartitionHi,
                    timestampMin,
                    timestampMax,
                    partitionTimestamp,
                    dstFixFd,
                    dstFixAddr,
                    dstFixOffset,
                    dstFixFileOffset,
                    dstFixSize,
                    dstVarFd,
                    dstVarAddr,
                    dstVarOffset,
                    dstVarOffsetEnd,
                    dstVarAdjust,
                    dstVarSize,
                    dstKFd,
                    dstVFd,
                    dstIndexOffset,
                    dstIndexAdjust,
                    indexBlockCapacity,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    partitionMutates,
                    tableWriter,
                    indexWriter
            );
        }
<span class="fc" id="L2266">    }</span>

    private static void publishCopyTaskContended(
            long cursor,
            AtomicInteger columnCounter,
            @Nullable AtomicInteger partCounter,
            int columnType,
            int blockType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixOffset,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarOffset,
            long srcDataVarSize,
            long srcDataTop,
            long srcDataLo,
            long srcDataHi,
            long srcDataMax,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long srcOooPartitionLo,
            long srcOooPartitionHi,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            int dstFixFd,
            long dstFixAddr,
            long dstFixOffset,
            long dstFixFileOffset,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarOffset,
            long dstVarOffsetEnd,
            long dstVarAdjust,
            long dstVarSize,
            int dstKFd,
            int dstVFd,
            long dstIndexOffset,
            long dstIndexAdjust,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            boolean partitionMutates,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter
    ) {
<span class="fc bfc" id="L2321" title="All 2 branches covered.">        while (cursor == -2) {</span>
<span class="fc" id="L2322">            cursor = tableWriter.getO3CopyPubSeq().next();</span>
        }

<span class="fc bfc" id="L2325" title="All 2 branches covered.">        if (cursor == -1) {</span>
<span class="fc" id="L2326">            O3CopyJob.copy(</span>
                    columnCounter,
                    partCounter,
                    columnType,
                    blockType,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcDataFixFd,
                    srcDataFixAddr,
                    srcDataFixOffset,
                    srcDataFixSize,
                    srcDataVarFd,
                    srcDataVarAddr,
                    srcDataVarOffset,
                    srcDataVarSize,
                    srcDataLo,
                    srcDataHi,
                    srcDataTop,
                    srcDataMax,
                    srcOooFixAddr,
                    srcOooVarAddr,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    srcOooPartitionLo,
                    srcOooPartitionHi,
                    timestampMin,
                    timestampMax,
                    partitionTimestamp,
                    dstFixFd,
                    dstFixAddr,
                    dstFixOffset,
                    dstFixFileOffset,
                    dstFixSize,
                    dstVarFd,
                    dstVarAddr,
                    dstVarOffset,
                    dstVarOffsetEnd,
                    dstVarAdjust,
                    dstVarSize,
                    dstKFd,
                    dstVFd,
                    dstIndexOffset,
                    dstIndexAdjust,
                    indexBlockCapacity,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    partitionMutates,
                    tableWriter,
                    indexWriter
            );
        } else {
<span class="fc" id="L2379">            publishCopyTaskHarmonized(</span>
                    columnCounter,
                    partCounter,
                    columnType,
                    blockType,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcDataFixFd,
                    srcDataFixAddr,
                    srcDataFixOffset,
                    srcDataFixSize,
                    srcDataVarFd,
                    srcDataVarAddr,
                    srcDataVarOffset,
                    srcDataVarSize,
                    srcDataLo,
                    srcDataHi,
                    srcDataTop,
                    srcDataMax,
                    srcOooFixAddr,
                    srcOooVarAddr,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    srcOooPartitionLo,
                    srcOooPartitionHi,
                    timestampMin,
                    timestampMax,
                    partitionTimestamp,
                    dstFixFd,
                    dstFixAddr,
                    dstFixOffset,
                    dstFixFileOffset,
                    dstFixSize,
                    dstVarFd,
                    dstVarAddr,
                    dstVarOffset,
                    dstVarOffsetEnd,
                    dstVarAdjust,
                    dstVarSize,
                    dstKFd,
                    dstVFd,
                    dstIndexOffset,
                    dstIndexAdjust,
                    indexBlockCapacity,
                    cursor,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    partitionMutates,
                    tableWriter,
                    indexWriter
            );
        }
<span class="fc" id="L2433">    }</span>

    private static void publishCopyTaskHarmonized(
            AtomicInteger columnCounter,
            @Nullable AtomicInteger partCounter,
            int columnType,
            int blockType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixOffset,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarOffset,
            long srcDataVarSize,
            long srcDataLo,
            long srcDataHi,
            long srcDataTop,
            long srcDataMax,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long srcOooPartitionLo,
            long srcOooPartitionHi,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            int dstFixFd,
            long dstFixAddr,
            long dstFixOffset,
            long dstFixFileOffset,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarOffset,
            long dstVarOffsetEnd,
            long dstVarAdjust,
            long dstVarSize,
            int dstKFd,
            int dstVFd,
            long dstIndexOffset,
            long dstIndexAdjust,
            int indexBlockCapacity,
            long cursor,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            boolean partitionMutates,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter
    ) {
<span class="fc" id="L2488">        final O3CopyTask task = tableWriter.getO3CopyQueue().get(cursor);</span>
<span class="fc" id="L2489">        task.of(</span>
                columnCounter,
                partCounter,
                columnType,
                blockType,
                timestampMergeIndexAddr,
                timestampMergeIndexSize,
                srcDataFixFd,
                srcDataFixAddr,
                srcDataFixOffset,
                srcDataFixSize,
                srcDataVarFd,
                srcDataVarAddr,
                srcDataVarOffset,
                srcDataVarSize,
                srcDataLo,
                srcDataHi,
                srcDataTop,
                srcDataMax,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                srcOooPartitionLo,
                srcOooPartitionHi,
                timestampMin,
                timestampMax,
                partitionTimestamp,
                dstFixFd,
                dstFixAddr,
                dstFixOffset,
                dstFixFileOffset,
                dstFixSize,
                dstVarFd,
                dstVarAddr,
                dstVarOffset,
                dstVarOffsetEnd,
                dstVarAdjust,
                dstVarSize,
                dstKFd,
                dstVFd,
                dstIndexOffset,
                dstIndexAdjust,
                indexBlockCapacity,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                partitionMutates,
                tableWriter,
                indexWriter
        );
<span class="fc" id="L2541">        tableWriter.getO3CopyPubSeq().done(cursor);</span>
<span class="fc" id="L2542">    }</span>

    private static void publishMultiCopyTasks(
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixOffset,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarOffset,
            long srcDataVarSize,
            long srcDataTopOffset,
            long srcDataMax,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp, // &lt;-- pass thru
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeDataLo,
            long mergeDataHi,
            long mergeOOOLo,
            long mergeOOOHi,
            int suffixType,
            long suffixLo,
            long suffixHi,
            int dstFixFd,
            long dstFixAddr,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarSize,
            long dstFixAppendOffset1,
            long dstFixAppendOffset2,
            long dstVarAppendOffset1,
            long dstVarAppendOffset2,
            int dstKFd,
            int dstVFd,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter
    ) {
<span class="fc" id="L2598">        final boolean partitionMutates = true;</span>
<span class="pc bpc" id="L2599" title="1 of 3 branches missed.">        switch (prefixType) {</span>
            case O3_BLOCK_O3:
<span class="fc" id="L2601">                publishCopyTask(</span>
                        columnCounter,
                        partCounter,
                        columnType,
                        prefixType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataFixFd,
                        srcDataFixAddr,
                        srcDataFixOffset,
                        srcDataFixSize,
                        srcDataVarFd,
                        srcDataVarAddr,
                        srcDataVarOffset,
                        srcDataVarSize,
                        0,
                        0,
                        srcDataTopOffset,
                        srcDataMax,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        prefixLo,
                        prefixHi,
                        srcOooMax,
                        srcOooLo,
                        srcOooHi,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        dstFixFd,
                        dstFixAddr,
                        0,
                        0,
                        dstFixSize,
                        dstVarFd,
                        dstVarAddr,
                        0,
                        0,
                        0,
                        dstVarSize,
                        dstKFd,
                        dstVFd,
                        0,
                        srcDataTopOffset &gt;&gt; 2,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        partitionMutates,
                        tableWriter,
                        indexWriter
                );
<span class="fc" id="L2653">                break;</span>
            case O3_BLOCK_DATA:
<span class="fc" id="L2655">                publishCopyTask(</span>
                        columnCounter,
                        partCounter,
                        columnType,
                        prefixType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataFixFd,
                        srcDataFixAddr,
                        srcDataFixOffset,
                        srcDataFixSize,
                        srcDataVarFd,
                        srcDataVarAddr,
                        srcDataVarOffset,
                        srcDataVarSize,
                        prefixLo,
                        prefixHi,
                        srcDataTopOffset,
                        srcDataMax,
                        0,
                        0,
                        0,
                        0,
                        srcOooMax,
                        srcOooLo,
                        srcOooHi,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        dstFixFd,
                        dstFixAddr,
                        0,
                        0,
                        dstFixSize,
                        dstVarFd,
                        dstVarAddr,
                        0,
                        0,
                        0,
                        dstVarSize,
                        dstKFd,
                        dstVFd,
                        0,
                        srcDataTopOffset &gt;&gt; 2,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        partitionMutates,
                        tableWriter,
                        indexWriter
                );
<span class="fc" id="L2707">                break;</span>
            default:
                break;
        }

<span class="fc bfc" id="L2712" title="All 4 branches covered.">        switch (mergeType) {</span>
            case O3_BLOCK_O3:
<span class="fc" id="L2714">                publishCopyTask(</span>
                        columnCounter,
                        partCounter,
                        columnType,
                        mergeType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataFixFd,
                        srcDataFixAddr,
                        srcDataFixOffset,
                        srcDataFixSize,
                        srcDataVarFd,
                        srcDataVarAddr,
                        srcDataVarOffset,
                        srcDataVarSize,
                        0, 0, srcDataTopOffset,
                        srcDataMax,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        mergeOOOLo,
                        mergeOOOHi,
                        srcOooMax,
                        srcOooLo,
                        srcOooHi,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        dstFixFd,
                        dstFixAddr,
                        dstFixAppendOffset1,
                        dstFixAppendOffset1,
                        dstFixSize,
                        dstVarFd,
                        dstVarAddr,
                        dstVarAppendOffset1,
                        dstVarAppendOffset2,
                        0,
                        dstVarSize,
                        dstKFd,
                        dstVFd,
                        0,
                        srcDataTopOffset &gt;&gt; 2,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        partitionMutates,
                        tableWriter,
                        indexWriter
                );
<span class="fc" id="L2764">                break;</span>
            case O3_BLOCK_DATA:
<span class="fc" id="L2766">                publishCopyTask(</span>
                        columnCounter,
                        partCounter,
                        columnType,
                        mergeType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataFixFd,
                        srcDataFixAddr,
                        srcDataFixOffset,
                        srcDataFixSize,
                        srcDataVarFd,
                        srcDataVarAddr,
                        srcDataVarOffset,
                        srcDataVarSize,
                        mergeDataLo,
                        mergeDataHi,
                        srcDataTopOffset,
                        srcDataMax,
                        0,
                        0,
                        0,
                        0,
                        srcOooMax,
                        srcOooLo,
                        srcOooHi,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        dstFixFd,
                        dstFixAddr,
                        dstFixAppendOffset1,
                        dstFixAppendOffset1,
                        dstFixSize,
                        dstVarFd,
                        dstVarAddr,
                        dstVarAppendOffset1,
                        dstVarAppendOffset2,
                        0,
                        dstVarSize,
                        dstKFd,
                        dstVFd,
                        0,
                        srcDataTopOffset &gt;&gt; 2,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        partitionMutates,
                        tableWriter,
                        indexWriter
                );
<span class="fc" id="L2818">                break;</span>
            case O3_BLOCK_MERGE:
<span class="fc" id="L2820">                publishCopyTask(</span>
                        columnCounter,
                        partCounter,
                        columnType,
                        mergeType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataFixFd,
                        srcDataFixAddr,
                        srcDataFixOffset,
                        srcDataFixSize,
                        srcDataVarFd,
                        srcDataVarAddr,
                        srcDataVarOffset,
                        srcDataVarSize,
                        mergeDataLo,
                        mergeDataHi,
                        srcDataTopOffset,
                        srcDataMax,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        mergeOOOLo,
                        mergeOOOHi,
                        srcOooMax,
                        srcOooLo,
                        srcOooHi,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        dstFixFd,
                        dstFixAddr,
                        dstFixAppendOffset1,
                        dstFixAppendOffset1,
                        dstFixSize,
                        dstVarFd,
                        dstVarAddr,
                        dstVarAppendOffset1,
                        dstVarAppendOffset2,
                        0,
                        dstVarSize,
                        dstKFd,
                        dstVFd,
                        0,
                        srcDataTopOffset &gt;&gt; 2,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        partitionMutates,
                        tableWriter,
                        indexWriter
                );
<span class="fc" id="L2872">                break;</span>
            default:
                break;
        }

<span class="fc bfc" id="L2877" title="All 3 branches covered.">        switch (suffixType) {</span>
            case O3_BLOCK_O3:
<span class="fc" id="L2879">                publishCopyTask(</span>
                        columnCounter,
                        partCounter,
                        columnType,
                        suffixType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataFixFd,
                        srcDataFixAddr,
                        srcDataFixOffset,
                        srcDataFixSize,
                        srcDataVarFd,
                        srcDataVarAddr,
                        srcDataVarOffset,
                        srcDataVarSize,
                        0,
                        0,
                        srcDataTopOffset,
                        srcDataMax,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        suffixLo,
                        suffixHi,
                        srcOooMax,
                        srcOooLo,
                        srcOooHi,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        dstFixFd,
                        dstFixAddr,
                        dstFixAppendOffset2,
                        dstFixAppendOffset2,
                        dstFixSize,
                        dstVarFd,
                        dstVarAddr,
                        dstVarAppendOffset2,
                        0,
                        0,
                        dstVarSize,
                        dstKFd,
                        dstVFd,
                        0,
                        srcDataTopOffset &gt;&gt; 2,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        partitionMutates,
                        tableWriter,
                        indexWriter
                );
<span class="fc" id="L2931">                break;</span>
            case O3_BLOCK_DATA:
<span class="fc" id="L2933">                publishCopyTask(</span>
                        columnCounter,
                        partCounter,
                        columnType,
                        suffixType,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataFixFd,
                        srcDataFixAddr,
                        srcDataFixOffset,
                        srcDataFixSize,
                        srcDataVarFd,
                        srcDataVarAddr,
                        srcDataVarOffset,
                        srcDataVarSize,
                        suffixLo,
                        suffixHi,
                        srcDataTopOffset,
                        srcDataMax,
                        0,
                        0,
                        0,
                        0,
                        srcOooMax,
                        srcOooLo,
                        srcOooHi,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        dstFixFd,
                        dstFixAddr,
                        dstFixAppendOffset2,
                        dstFixAppendOffset2,
                        dstFixSize,
                        dstVarFd,
                        dstVarAddr,
                        dstVarAppendOffset2,
                        0,
                        0,
                        dstVarSize,
                        dstKFd,
                        dstVFd,
                        0,
                        srcDataTopOffset &gt;&gt; 2,
                        indexBlockCapacity,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        partitionMutates,
                        tableWriter,
                        indexWriter
                );
<span class="fc" id="L2985">                break;</span>
            default:
                break;
        }
<span class="fc" id="L2989">    }</span>

    @Override
    protected boolean doRun(int workerId, long cursor, RunStatus runStatus) {
<span class="fc" id="L2993">        openColumn(queue.get(cursor), cursor, subSeq);</span>
<span class="fc" id="L2994">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>