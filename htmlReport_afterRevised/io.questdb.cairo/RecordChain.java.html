<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RecordChain.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">RecordChain.java</span></div><h1>RecordChain.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.cairo.sql.AnalyticSPI;
import io.questdb.cairo.sql.Record;
import io.questdb.cairo.sql.RecordCursor;
import io.questdb.cairo.sql.SymbolTableSource;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryARW;
import io.questdb.std.*;
import io.questdb.std.str.CharSink;
import org.jetbrains.annotations.NotNull;

import java.io.Closeable;

public class RecordChain implements Closeable, RecordCursor, Mutable, RecordSinkSPI, AnalyticSPI, Reopenable {

    private final long[] columnOffsets;
    private final long fixOffset;
    private final MemoryARW mem;
<span class="fc" id="L44">    private final RecordChainRecord recordA = new RecordChainRecord();</span>
<span class="fc" id="L45">    private final RecordChainRecord recordB = new RecordChainRecord();</span>
    private final RecordSink recordSink;
    private final long varOffset;
<span class="fc" id="L48">    private long nextRecordOffset = -1L;</span>
    private RecordChainRecord recordC;
    private long recordOffset;
    private SymbolTableSource symbolTableResolver;
<span class="fc" id="L52">    private long varAppendOffset = 0L;</span>

    public RecordChain(
            @Transient @NotNull ColumnTypes columnTypes,
            @NotNull RecordSink recordSink,
            long pageSize,
            int maxPages
<span class="fc" id="L59">    ) {</span>
<span class="fc" id="L60">        this.mem = Vm.getARWInstance(pageSize, maxPages, MemoryTag.NATIVE_RECORD_CHAIN);</span>
<span class="fc" id="L61">        this.recordSink = recordSink;</span>
<span class="fc" id="L62">        int count = columnTypes.getColumnCount();</span>
<span class="fc" id="L63">        long varOffset = 0L;</span>
<span class="fc" id="L64">        long fixOffset = 0L;</span>

<span class="fc" id="L66">        this.columnOffsets = new long[count];</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L68">            int type = columnTypes.getColumnType(i);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">            if (ColumnType.isVariableLength(type)) {</span>
<span class="fc" id="L70">                columnOffsets[i] = varOffset;</span>
<span class="fc" id="L71">                varOffset += 8;</span>
            } else {
<span class="fc" id="L73">                columnOffsets[i] = fixOffset;</span>
<span class="fc" id="L74">                fixOffset += ColumnType.sizeOf(type);</span>
            }
        }
<span class="fc" id="L77">        this.varOffset = varOffset;</span>
<span class="fc" id="L78">        this.fixOffset = fixOffset;</span>
<span class="fc" id="L79">    }</span>

    public long addressOf(long offset) {
<span class="fc" id="L82">        return mem.addressOf(offset);</span>
    }

    public long beginRecord(long prevOffset) {
        // no next record
<span class="fc" id="L87">        mem.putLong(varAppendOffset, -1);</span>
<span class="fc" id="L88">        recordOffset = varAppendOffset;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (prevOffset != -1) {</span>
<span class="fc" id="L90">            mem.putLong(prevOffset, recordOffset);</span>
        }
<span class="fc" id="L92">        mem.jumpTo(rowToDataOffset(recordOffset + varOffset));</span>
<span class="fc" id="L93">        varAppendOffset = rowToDataOffset(recordOffset + varOffset + fixOffset);</span>
<span class="fc" id="L94">        return recordOffset;</span>
    }

    @Override
    public void clear() {
<span class="fc" id="L99">        mem.close();</span>
<span class="fc" id="L100">        nextRecordOffset = -1L;</span>
<span class="fc" id="L101">        varAppendOffset = 0L;</span>
<span class="fc" id="L102">    }</span>

    @Override
    public void close() {
<span class="fc" id="L106">        clear();</span>
<span class="fc" id="L107">        symbolTableResolver = null;</span>
<span class="fc" id="L108">    }</span>

    @Override
    public long getAddress(long recordOffset, int columnIndex) {
<span class="fc" id="L112">        return addressOf(getOffsetOfColumn(recordOffset, columnIndex));</span>
    }

    public long getOffsetOfColumn(long recordOffset, int columnIndex) {
<span class="fc" id="L116">        return rowToDataOffset(recordOffset) + varOffset + columnOffsets[columnIndex];</span>
    }

    @Override
    public Record getRecord() {
<span class="fc" id="L121">        return recordA;</span>
    }

    @Override
    public Record getRecordAt(long recordOffset) {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (recordC == null) {</span>
<span class="nc" id="L127">            recordC = new RecordChainRecord();</span>
        }
<span class="nc" id="L129">        recordC.of(rowToDataOffset(recordOffset));</span>
<span class="nc" id="L130">        return recordC;</span>
    }

    @Override
    public Record getRecordB() {
<span class="fc" id="L135">        return recordB;</span>
    }

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (nextRecordOffset != -1) {</span>
<span class="fc" id="L141">            final long offset = nextRecordOffset;</span>
<span class="fc" id="L142">            nextRecordOffset = mem.getLong(nextRecordOffset);</span>
<span class="fc" id="L143">            recordA.of(rowToDataOffset(offset));</span>
<span class="fc" id="L144">            return true;</span>
        }
<span class="fc" id="L146">        return false;</span>
    }

    public void of(long nextRecordOffset) {
<span class="fc" id="L150">        this.nextRecordOffset = nextRecordOffset;</span>
<span class="fc" id="L151">    }</span>

    public long put(Record record, long prevRecordOffset) {
<span class="fc" id="L154">        long offset = beginRecord(prevRecordOffset);</span>
<span class="fc" id="L155">        recordSink.copy(record, this);</span>
<span class="fc" id="L156">        return offset;</span>
    }

    @Override
    public void putBin(BinarySequence value) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L162">            putNull();</span>
        } else {
<span class="fc" id="L164">            long offset = mem.getAppendOffset();</span>
<span class="fc" id="L165">            mem.putLong(rowToDataOffset(recordOffset), varAppendOffset);</span>
<span class="fc" id="L166">            recordOffset += 8;</span>
<span class="fc" id="L167">            mem.jumpTo(varAppendOffset);</span>
<span class="fc" id="L168">            mem.putBin(value);</span>
<span class="fc" id="L169">            varAppendOffset = mem.getAppendOffset();</span>
<span class="fc" id="L170">            mem.jumpTo(offset);</span>
        }
<span class="fc" id="L172">    }</span>

    @Override
    public void putBool(boolean value) {
<span class="fc" id="L176">        mem.putBool(value);</span>
<span class="fc" id="L177">    }</span>

    @Override
    public void putByte(byte value) {
<span class="fc" id="L181">        mem.putByte(value);</span>
<span class="fc" id="L182">    }</span>

    @Override
    public void putChar(char value) {
<span class="fc" id="L186">        mem.putChar(value);</span>
<span class="fc" id="L187">    }</span>

    @Override
    public void putDate(long date) {
<span class="fc" id="L191">        putLong(date);</span>
<span class="fc" id="L192">    }</span>

    @Override
    public void putDouble(double value) {
<span class="fc" id="L196">        mem.putDouble(value);</span>
<span class="fc" id="L197">    }</span>

    @Override
    public void putFloat(float value) {
<span class="fc" id="L201">        mem.putFloat(value);</span>
<span class="fc" id="L202">    }</span>

    @Override
    public void putInt(int value) {
<span class="fc" id="L206">        mem.putInt(value);</span>
<span class="fc" id="L207">    }</span>

    @Override
    public void putLong(long value) {
<span class="fc" id="L211">        mem.putLong(value);</span>
<span class="fc" id="L212">    }</span>

    @Override
    public void putLong128(long lo, long hi) {
<span class="fc" id="L216">        mem.putLong128(lo, hi);</span>
<span class="fc" id="L217">    }</span>

    @Override
    public void putLong256(Long256 value) {
<span class="fc" id="L221">        mem.putLong256(value);</span>
<span class="fc" id="L222">    }</span>

    @Override
    public void putRecord(Record value) {
        // noop
<span class="nc" id="L227">    }</span>

    @Override
    public void putShort(short value) {
<span class="fc" id="L231">        mem.putShort(value);</span>
<span class="fc" id="L232">    }</span>

    @Override
    public void putStr(CharSequence value) {
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L237">            mem.putLong(rowToDataOffset(recordOffset), varAppendOffset);</span>
<span class="fc" id="L238">            recordOffset += 8;</span>
<span class="fc" id="L239">            mem.putStr(varAppendOffset, value);</span>
<span class="fc" id="L240">            varAppendOffset += Vm.getStorageLength(value.length());</span>
        } else {
<span class="fc" id="L242">            putNull();</span>
        }
<span class="fc" id="L244">    }</span>

    @Override
    public void putStr(CharSequence value, int lo, int hi) {
<span class="nc" id="L248">        final int len = hi - lo;</span>
<span class="nc" id="L249">        mem.putLong(rowToDataOffset(recordOffset), varAppendOffset);</span>
<span class="nc" id="L250">        recordOffset += 8;</span>
<span class="nc" id="L251">        mem.putStr(varAppendOffset, value, lo, len);</span>
<span class="nc" id="L252">        varAppendOffset += Vm.getStorageLength(len);</span>
<span class="nc" id="L253">    }</span>

    @Override
    public void putTimestamp(long value) {
<span class="fc" id="L257">        putLong(value);</span>
<span class="fc" id="L258">    }</span>

    @Override
    public void recordAt(Record record, long row) {
<span class="fc" id="L262">        ((RecordChainRecord) record).of(rowToDataOffset(row));</span>
<span class="fc" id="L263">    }</span>

    @Override
    public void reopen() {
        //nothing to do here
<span class="fc" id="L268">    }</span>

    public void setSymbolTableResolver(SymbolTableSource resolver) {
<span class="fc" id="L271">        this.symbolTableResolver = resolver;</span>
<span class="fc" id="L272">    }</span>

    @Override
    public long size() {
<span class="fc" id="L276">        return -1;</span>
    }

    @Override
    public void skip(int bytes) {
<span class="fc" id="L281">        mem.skip(bytes);</span>
<span class="fc" id="L282">    }</span>

    @Override
    public void toTop() {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (mem.getAppendOffset() == 0) {</span>
<span class="fc" id="L287">            nextRecordOffset = -1L;</span>
        } else {
<span class="fc" id="L289">            nextRecordOffset = 0L;</span>
        }
<span class="fc" id="L291">    }</span>

    private static long rowToDataOffset(long row) {
<span class="fc" id="L294">        return row + 8;</span>
    }

    private void putNull() {
<span class="fc" id="L298">        mem.putLong(rowToDataOffset(recordOffset), TableUtils.NULL_LEN);</span>
<span class="fc" id="L299">        recordOffset += 8;</span>
<span class="fc" id="L300">    }</span>

<span class="fc" id="L302">    private class RecordChainRecord implements Record {</span>
        long baseOffset;
        long fixedOffset;

        @Override
        public BinarySequence getBin(int col) {
<span class="fc" id="L308">            long offset = varWidthColumnOffset(col);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">            return offset == -1 ? null : mem.getBin(offset);</span>
        }

        @Override
        public long getBinLen(int col) {
<span class="fc" id="L314">            long offset = varWidthColumnOffset(col);</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">            return offset == -1 ? TableUtils.NULL_LEN : mem.getLong(offset);</span>
        }

        @Override
        public boolean getBool(int col) {
<span class="fc" id="L320">            return mem.getBool(fixedWithColumnOffset(col));</span>
        }

        @Override
        public byte getByte(int col) {
<span class="fc" id="L325">            return mem.getByte(fixedWithColumnOffset(col));</span>
        }

        @Override
        public char getChar(int col) {
<span class="fc" id="L330">            return mem.getChar(fixedWithColumnOffset(col));</span>
        }

        @Override
        public double getDouble(int col) {
<span class="fc" id="L335">            return mem.getDouble(fixedWithColumnOffset(col));</span>
        }

        @Override
        public float getFloat(int col) {
<span class="fc" id="L340">            return mem.getFloat(fixedWithColumnOffset(col));</span>
        }

        @Override
        public byte getGeoByte(int col) {
            // No column tops, return byte from mem.
<span class="fc" id="L346">            return mem.getByte(fixedWithColumnOffset(col));</span>
        }

        @Override
        public int getGeoInt(int col) {
            // No column tops, return int from mem.
<span class="fc" id="L352">            return mem.getInt(fixedWithColumnOffset(col));</span>
        }

        @Override
        public long getGeoLong(int col) {
            // No column tops, return long from mem.
<span class="fc" id="L358">            return mem.getLong(fixedWithColumnOffset(col));</span>
        }

        @Override
        public short getGeoShort(int col) {
            // No column tops, return short from mem.
<span class="fc" id="L364">            return mem.getShort(fixedWithColumnOffset(col));</span>
        }

        @Override
        public int getInt(int col) {
<span class="fc" id="L369">            return mem.getInt(fixedWithColumnOffset(col));</span>
        }

        @Override
        public long getLong(int col) {
<span class="fc" id="L374">            return mem.getLong(fixedWithColumnOffset(col));</span>
        }

        @Override
        public long getLong128Hi(int col) {
<span class="fc" id="L379">            return mem.getLong(fixedWithColumnOffset(col) + Long.BYTES);</span>
        }

        @Override
        public long getLong128Lo(int col) {
<span class="fc" id="L384">            return mem.getLong(fixedWithColumnOffset(col));</span>
        }

        @Override
        public void getLong256(int col, CharSink sink) {
<span class="fc" id="L389">            mem.getLong256(fixedWithColumnOffset(col), sink);</span>
<span class="fc" id="L390">        }</span>

        @Override
        public Long256 getLong256A(int col) {
<span class="fc" id="L394">            return mem.getLong256A(fixedWithColumnOffset(col));</span>
        }

        @Override
        public Long256 getLong256B(int col) {
<span class="fc" id="L399">            return mem.getLong256B(fixedWithColumnOffset(col));</span>
        }

        @Override
        public long getRowId() {
<span class="fc" id="L404">            return baseOffset - 8;</span>
        }

        @Override
        public short getShort(int col) {
<span class="fc" id="L409">            return mem.getShort(fixedWithColumnOffset(col));</span>
        }

        @Override
        public CharSequence getStr(int col) {
<span class="fc" id="L414">            long offset = varWidthColumnOffset(col);</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            assert offset &gt; -2;</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            return offset == -1 ? null : mem.getStr(offset);</span>
        }

        @Override
        public CharSequence getStrB(int col) {
<span class="fc" id="L421">            long offset = varWidthColumnOffset(col);</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">            assert offset &gt; -2;</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">            return offset == -1 ? null : mem.getStr2(offset);</span>
        }

        @Override
        public int getStrLen(int col) {
<span class="fc" id="L428">            final long offset = varWidthColumnOffset(col);</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">            if (offset &gt; -1) {</span>
<span class="fc" id="L430">                return mem.getInt(offset);</span>
            }
<span class="fc" id="L432">            return TableUtils.NULL_LEN;</span>
        }

        @Override
        public CharSequence getSym(int col) {
<span class="fc" id="L437">            return symbolTableResolver.getSymbolTable(col).valueOf(getInt(col));</span>
        }

        @Override
        public CharSequence getSymB(int col) {
<span class="fc" id="L442">            return symbolTableResolver.getSymbolTable(col).valueBOf(getInt(col));</span>
        }

        private long fixedWithColumnOffset(int index) {
<span class="fc" id="L446">            return fixedOffset + columnOffsets[index];</span>
        }

        private void of(long offset) {
<span class="fc" id="L450">            this.baseOffset = offset;</span>
<span class="fc" id="L451">            this.fixedOffset = offset + varOffset;</span>
<span class="fc" id="L452">        }</span>

        private long varWidthColumnOffset(int index) {
<span class="fc" id="L455">            return mem.getLong(baseOffset + columnOffsets[index]);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>