<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColumnType.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">ColumnType.java</span></div><h1>ColumnType.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.std.IntObjHashMap;
import io.questdb.std.Long256;
import io.questdb.std.LowerCaseAsciiCharSequenceIntHashMap;
import io.questdb.std.Numbers;
import io.questdb.std.str.StringSink;

// ColumnType layout - 32bit
//
// | PGWire format | Extra type information | Type discriminant (tag) |
// +---------------+------------------------+-------------------------+
// |    1 bit      |        23 bits         |         8 bits          |
// +---------------+------------------------+-------------------------+

/**
 * Column types as numeric (integer) values
 */
public final class ColumnType {
    public static final short ARRAY_STRING = 27;
    public static final short BINARY = 18;
    public static final short BOOLEAN = 1;
    public static final short BYTE = 2;
    public static final short CHAR = 4;
    public static final short CURSOR = 20;
    public static final short DATE = 7;
    public static final short DOUBLE = 10;
    public static final short FLOAT = 9;
    public static final short GEOBYTE = 14;
    public static final int GEOBYTE_MAX_BITS = 7;
    //geohash bits &lt;-&gt; backing primitive types bit boundaries
    public static final int GEOBYTE_MIN_BITS = 1;
    // This type is not stored, it is used on function arguments to resolve overloads.
    // We also build overload matrix, which logic relies on the fact GEOHASH value has to be
    // inside the MAX type value.
    public static final short GEOHASH = 23;
    public static final short GEOINT = 16;
    public static final int GEOINT_MAX_BITS = 31;
    public static final int GEOINT_MIN_BITS = 16;
    public static final short GEOLONG = 17;
    public static final int GEOLONG_MIN_BITS = 32;
    public static final short GEOSHORT = 15;
    public static final int GEOSHORT_MAX_BITS = 15;
    public static final int GEOSHORT_MIN_BITS = 8;
    public static final int GEO_HASH_MAX_BITS_LENGTH = 60;
    public static final int GEOLONG_MAX_BITS = GEO_HASH_MAX_BITS_LENGTH;
    public static final short INT = 5;
    public static final short LONG = 6;
    public static final short LONG128 = 24; // Limited support, few tests only
    public static final short LONG256 = 13;
    public static final int NO_OVERLOAD = 10000;
    public static final short NULL = 29;
    // Overload matrix algo depends on the fact that MAX == NULL
    public static final short MAX = NULL;
    public static final short TYPES_SIZE = MAX + 1;
<span class="fc" id="L80">    private static final int[] TYPE_SIZE_POW2 = new int[TYPES_SIZE];</span>
<span class="fc" id="L81">    private static final int[] TYPE_SIZE = new int[TYPES_SIZE];</span>
    public static final short PARAMETER = 28;
    public static final short RECORD = 22;
    // PG specific types to work with 3rd party software with canned catalogue queries
    public static final short REGCLASS = 25;
    public static final short REGPROCEDURE = 26;
    public static final short SHORT = 3;
    public static final short STRING = 11;
    public static final short SYMBOL = 12;
    public static final short TIMESTAMP = 8;
    public static final short UNDEFINED = 0;
    public static final short UUID = 19;
    public static final short VAR_ARG = 21;
    // column type version as written to the metadata file
    public static final int VERSION = 426;
    static final int[] GEO_TYPE_SIZE_POW2;
    private static final int BITS_OFFSET = 8;
    // this value has to be larger than MAX type and be power of 2
    private static final int OVERLOAD_MATRIX_SIZE = 32;
    private static final int TYPE_FLAG_DESIGNATED_TIMESTAMP = (1 &lt;&lt; 17);
    private static final int TYPE_FLAG_GEO_HASH = (1 &lt;&lt; 16);
<span class="fc" id="L102">    private static final LowerCaseAsciiCharSequenceIntHashMap nameTypeMap = new LowerCaseAsciiCharSequenceIntHashMap();</span>
    // For function overload the priority is taken from left to right
<span class="fc" id="L104">    private static final short[][] overloadPriority = {</span>
            /* 0 UNDEFINED  */  {DOUBLE, FLOAT, STRING, LONG, TIMESTAMP, DATE, INT, CHAR, SHORT, BYTE, BOOLEAN}
            /* 1  BOOLEAN   */, {BOOLEAN}
            /* 2  BYTE      */, {BYTE, SHORT, INT, LONG, FLOAT, DOUBLE}
            /* 3  SHORT     */, {SHORT, INT, LONG, FLOAT, DOUBLE}
            /* 4  CHAR      */, {CHAR, STRING}
            /* 5  INT       */, {INT, LONG, FLOAT, DOUBLE, TIMESTAMP, DATE}
            /* 6  LONG      */, {LONG, DOUBLE, TIMESTAMP, DATE}
            /* 7  DATE      */, {DATE, TIMESTAMP, LONG}
            /* 8  TIMESTAMP */, {TIMESTAMP, LONG}
            /* 9  FLOAT     */, {FLOAT, DOUBLE}
            /* 10 DOUBLE    */, {DOUBLE}
            /* 11 STRING    */, {STRING, CHAR, DOUBLE, LONG, INT, FLOAT, SHORT, BYTE}
            /* 12 SYMBOL    */, {SYMBOL, STRING}
            /* 13 LONG256   */, {LONG256}
            /* 14 GEOBYTE   */, {GEOBYTE, GEOSHORT, GEOINT, GEOLONG, GEOHASH}
            /* 15 GEOSHORT  */, {GEOSHORT, GEOINT, GEOLONG, GEOHASH}
            /* 16 GEOINT    */, {GEOINT, GEOLONG, GEOHASH}
            /* 17 GEOLONG   */, {GEOLONG, GEOHASH}
            /* 18 BINARY    */, {BINARY}
            /* 19 UUID      */, {UUID, STRING}
    };
    private static final int[] overloadPriorityMatrix;
<span class="fc" id="L127">    private static final IntObjHashMap&lt;String&gt; typeNameMap = new IntObjHashMap&lt;&gt;();</span>

    private ColumnType() {
    }

    public static int getGeoHashBits(int type) {
<span class="fc" id="L133">        return (byte) ((type &gt;&gt; BITS_OFFSET) &amp; 0xFF);</span>
    }

    public static int getGeoHashTypeWithBits(int bits) {
<span class="pc bpc" id="L137" title="2 of 4 branches missed.">        assert bits &gt; 0 &amp;&amp; bits &lt;= GEO_HASH_MAX_BITS_LENGTH;</span>
        // this logic relies on GeoHash type value to be clustered together
<span class="fc" id="L139">        return mkGeoHashType(bits, (short) (GEOBYTE + pow2SizeOfBits(bits)));</span>
    }

    public static boolean isAssignableFrom(int fromType, int toType) {
<span class="fc bfc" id="L143" title="All 4 branches covered.">        return isToSameOrWider(fromType, toType) || isNarrowingCast(fromType, toType);</span>
    }

    public static boolean isBinary(int columnType) {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        return columnType == BINARY;</span>
    }

    public static boolean isBoolean(int columnType) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">        return columnType == ColumnType.BOOLEAN;</span>
    }

    public static boolean isBuiltInWideningCast(int fromType, int toType) {
        // This method returns true when a cast is not needed from type to type
        // because of the way typed functions are implemented.
        // For example IntFunction has getDouble() method implemented and does not need
        // additional wrap function to CAST to double.
        // This is usually case for widening conversions.
<span class="fc bfc" id="L160" title="All 18 branches covered.">        return (fromType &gt;= BYTE</span>
                &amp;&amp; toType &gt;= BYTE
                &amp;&amp; toType &lt;= DOUBLE
                &amp;&amp; fromType &lt; toType)
                || fromType == NULL
                // char can be short and short can be char for symmetry
                || (fromType == CHAR &amp;&amp; toType == SHORT)
                || (fromType == TIMESTAMP &amp;&amp; toType == LONG)
                ;
    }

    public static boolean isChar(int columnType) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">        return columnType == CHAR;</span>
    }

    public static boolean isCursor(int columnType) {
<span class="fc bfc" id="L176" title="All 2 branches covered.">        return columnType == CURSOR;</span>
    }

    public static boolean isDesignatedTimestamp(int type) {
<span class="fc bfc" id="L180" title="All 2 branches covered.">        return (type &amp; TYPE_FLAG_DESIGNATED_TIMESTAMP) != 0;</span>
    }

    public static boolean isDouble(int columnType) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        return columnType == DOUBLE;</span>
    }

    public static boolean isGeoHash(int columnType) {
<span class="fc bfc" id="L188" title="All 2 branches covered.">        return (columnType &amp; TYPE_FLAG_GEO_HASH) != 0;</span>
    }

    public static boolean isInt(int columnType) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">        return columnType == ColumnType.INT;</span>
    }

    public static boolean isNull(int columnType) {
<span class="fc bfc" id="L196" title="All 2 branches covered.">        return columnType == NULL;</span>
    }

    public static boolean isString(int columnType) {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        return columnType == STRING;</span>
    }

    public static boolean isSymbol(int columnType) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        return columnType == SYMBOL;</span>
    }

    public static boolean isSymbolOrString(int columnType) {
<span class="fc bfc" id="L208" title="All 4 branches covered.">        return columnType == SYMBOL || columnType == STRING;</span>
    }

    public static boolean isTimestamp(int columnType) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">        return columnType == TIMESTAMP;</span>
    }

    public static boolean isToSameOrWider(int fromType, int toType) {
<span class="fc bfc" id="L216" title="All 4 branches covered.">        return ((toType == fromType || tagOf(fromType) == tagOf(toType)) &amp;&amp;</span>
                (
<span class="pc bpc" id="L218" title="1 of 4 branches missed.">                        getGeoHashBits(fromType) &gt;= getGeoHashBits(toType) || getGeoHashBits(fromType) == 0</span>
                ))
<span class="fc bfc" id="L220" title="All 2 branches covered.">                || isBuiltInWideningCast(fromType, toType)</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">                || isStringCast(fromType, toType)</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">                || isGeoHashWideningCast(fromType, toType)</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">                || isImplicitParsingCast(fromType, toType);</span>
    }

    public static boolean isUndefined(int columnType) {
<span class="fc bfc" id="L227" title="All 2 branches covered.">        return columnType == UNDEFINED;</span>
    }

    public static boolean isVariableLength(int columnType) {
<span class="fc bfc" id="L231" title="All 4 branches covered.">        return columnType == STRING || columnType == BINARY;</span>
    }

    public static String nameOf(int columnType) {
<span class="fc" id="L235">        final int index = typeNameMap.keyIndex(columnType);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (index &gt; -1) {</span>
<span class="fc" id="L237">            return &quot;unknown&quot;;</span>
        }
<span class="fc" id="L239">        return typeNameMap.valueAtQuick(index);</span>
    }

    public static int overloadDistance(short from, short to) {
<span class="fc" id="L243">        final int fromTag = tagOf(from);</span>
<span class="fc" id="L244">        final int toTag = tagOf(to);</span>
        // Functions cannot accept UNDEFINED type (signature is not supported)
        // this check is just in case
<span class="fc bfc" id="L247" title="All 2 branches covered.">        assert toTag &gt; UNDEFINED : &quot;Undefined not supported in overloads&quot;;</span>
<span class="fc" id="L248">        return overloadPriorityMatrix[OVERLOAD_MATRIX_SIZE * fromTag + toTag];</span>
    }

    public static int pow2SizeOf(int columnType) {
<span class="fc" id="L252">        return TYPE_SIZE_POW2[tagOf(columnType)];</span>
    }

    public static int pow2SizeOfBits(int bits) {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        assert bits &lt;= GEO_HASH_MAX_BITS_LENGTH;</span>
<span class="fc" id="L257">        return GEO_TYPE_SIZE_POW2[bits];</span>
    }

    public static int setDesignatedTimestampBit(int tsType, boolean designated) {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (designated) {</span>
<span class="fc" id="L262">            return tsType | TYPE_FLAG_DESIGNATED_TIMESTAMP;</span>
        } else {
<span class="nc" id="L264">            return tsType &amp; ~(TYPE_FLAG_DESIGNATED_TIMESTAMP);</span>
        }
    }

    public static int sizeOf(int columnType) {
<span class="fc" id="L269">        short tag = tagOf(columnType); // tagOf</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (tag &lt; TYPES_SIZE) {</span>
<span class="fc" id="L271">            return TYPE_SIZE[tag];</span>
        }
<span class="fc" id="L273">        return -1;</span>
    }

    public static short tagOf(int type) {
<span class="fc" id="L277">        return (short) (type &amp; 0xFF);</span>
    }

    public static short tagOf(CharSequence name) {
<span class="fc" id="L281">        return (short) nameTypeMap.get(name);</span>
    }

    public static int typeOf(CharSequence name) {
<span class="fc" id="L285">        return nameTypeMap.get(name);</span>
    }

    public static int variableColumnLengthBytes(int columnType) {
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (columnType == ColumnType.STRING) {</span>
<span class="fc" id="L290">            return Integer.BYTES;</span>
        }
<span class="nc bnc" id="L292" title="All 2 branches missed.">        assert columnType == ColumnType.BINARY;</span>
<span class="nc" id="L293">        return Long.BYTES;</span>
    }

    private static short indexOf(short[] list, short value) {
<span class="fc bfc" id="L297" title="All 2 branches covered.">        for (short i = 0; i &lt; list.length; i++) {</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">            if (list[i] == value) {</span>
<span class="fc" id="L299">                return i;</span>
            }
        }
<span class="fc" id="L302">        return -1;</span>
    }

    private static boolean isGeoHashWideningCast(int fromType, int toType) {
<span class="fc" id="L306">        final int toTag = tagOf(toType);</span>
<span class="fc" id="L307">        final int fromTag = tagOf(fromType);</span>
<span class="fc bfc" id="L308" title="All 24 branches covered.">        return (fromTag == GEOLONG &amp;&amp; toTag == GEOINT)</span>
                || (fromTag == GEOLONG &amp;&amp; toTag == GEOSHORT)
                || (fromTag == GEOLONG &amp;&amp; toTag == GEOBYTE)
                || (fromTag == GEOINT &amp;&amp; toTag == GEOSHORT)
                || (fromTag == GEOINT &amp;&amp; toTag == GEOBYTE)
                || (fromTag == GEOSHORT &amp;&amp; toTag == GEOBYTE);
    }

    private static boolean isImplicitParsingCast(int fromType, int toType) {
<span class="fc" id="L317">        final int toTag = tagOf(toType);</span>
<span class="pc bpc" id="L318" title="1 of 30 branches missed.">        return (fromType == CHAR &amp;&amp; toTag == GEOBYTE &amp;&amp; getGeoHashBits(toType) &lt; 6)</span>
                || (fromType == STRING &amp;&amp; toTag == GEOBYTE)
                || (fromType == STRING &amp;&amp; toTag == GEOSHORT)
                || (fromType == STRING &amp;&amp; toTag == GEOINT)
                || (fromType == STRING &amp;&amp; toTag == GEOLONG)
                || (fromType == STRING &amp;&amp; toTag == TIMESTAMP)
                || (fromType == SYMBOL &amp;&amp; toTag == TIMESTAMP)
                ;
    }

    private static boolean isNarrowingCast(int fromType, int toType) {
<span class="pc bpc" id="L329" title="8 of 74 branches missed.">        return (fromType == DOUBLE &amp;&amp; (toType == FLOAT || (toType &gt;= BYTE &amp;&amp; toType &lt;= LONG)))</span>
                || (fromType == FLOAT &amp;&amp; toType &gt;= BYTE &amp;&amp; toType &lt;= LONG)
                || (fromType == LONG &amp;&amp; toType &gt;= BYTE &amp;&amp; toType &lt;= INT)
                || (fromType == INT &amp;&amp; toType &gt;= BYTE &amp;&amp; toType &lt;= SHORT)
                || (fromType == SHORT &amp;&amp; toType == BYTE)
                || (fromType == CHAR &amp;&amp; toType == BYTE)
                || (fromType == STRING &amp;&amp; toType == BYTE)
                || (fromType == STRING &amp;&amp; toType == SHORT)
                || (fromType == STRING &amp;&amp; toType == INT)
                || (fromType == STRING &amp;&amp; toType == LONG)
                || (fromType == STRING &amp;&amp; toType == DATE)
                || (fromType == STRING &amp;&amp; toType == TIMESTAMP)
                || (fromType == STRING &amp;&amp; toType == FLOAT)
                || (fromType == STRING &amp;&amp; toType == DOUBLE)
                || (fromType == STRING &amp;&amp; toType == CHAR)
                || (fromType == STRING &amp;&amp; toType == UUID)
                ;
    }

    private static boolean isStringCast(int fromType, int toType) {
<span class="fc bfc" id="L349" title="All 20 branches covered.">        return (fromType == STRING &amp;&amp; toType == SYMBOL)</span>
                || (fromType == SYMBOL &amp;&amp; toType == STRING)
                || (fromType == CHAR &amp;&amp; toType == SYMBOL)
                || (fromType == CHAR &amp;&amp; toType == STRING)
                || (fromType == UUID &amp;&amp; toType == STRING);
    }

    private static int mkGeoHashType(int bits, short baseType) {
<span class="fc" id="L357">        return (baseType &amp; ~(0xFF &lt;&lt; BITS_OFFSET)) | (bits &lt;&lt; BITS_OFFSET) | TYPE_FLAG_GEO_HASH; // bit 16 is GeoHash flag</span>
    }

    static {
<span class="fc" id="L361">        overloadPriorityMatrix = new int[OVERLOAD_MATRIX_SIZE * OVERLOAD_MATRIX_SIZE];</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (short i = UNDEFINED; i &lt; MAX; i++) {</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            for (short j = BOOLEAN; j &lt;= MAX; j++) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">                if (i &lt; overloadPriority.length) {</span>
<span class="fc" id="L365">                    int index = indexOf(overloadPriority[i], j);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">                    overloadPriorityMatrix[OVERLOAD_MATRIX_SIZE * i + j] = index != -1 ? index : NO_OVERLOAD;</span>
<span class="fc" id="L367">                } else {</span>
<span class="fc" id="L368">                    overloadPriorityMatrix[OVERLOAD_MATRIX_SIZE * i + j] = NO_OVERLOAD;</span>
                }
            }
        }
    }

    static {
<span class="fc" id="L375">        GEO_TYPE_SIZE_POW2 = new int[GEO_HASH_MAX_BITS_LENGTH + 1];</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        for (int bits = 1; bits &lt;= GEO_HASH_MAX_BITS_LENGTH; bits++) {</span>
<span class="fc" id="L377">            GEO_TYPE_SIZE_POW2[bits] = Numbers.msb(Numbers.ceilPow2(((bits + Byte.SIZE) &amp; -Byte.SIZE)) &gt;&gt; 3);</span>
        }

<span class="fc" id="L380">        typeNameMap.put(BOOLEAN, &quot;BOOLEAN&quot;);</span>
<span class="fc" id="L381">        typeNameMap.put(BYTE, &quot;BYTE&quot;);</span>
<span class="fc" id="L382">        typeNameMap.put(DOUBLE, &quot;DOUBLE&quot;);</span>
<span class="fc" id="L383">        typeNameMap.put(FLOAT, &quot;FLOAT&quot;);</span>
<span class="fc" id="L384">        typeNameMap.put(INT, &quot;INT&quot;);</span>
<span class="fc" id="L385">        typeNameMap.put(LONG, &quot;LONG&quot;);</span>
<span class="fc" id="L386">        typeNameMap.put(SHORT, &quot;SHORT&quot;);</span>
<span class="fc" id="L387">        typeNameMap.put(CHAR, &quot;CHAR&quot;);</span>
<span class="fc" id="L388">        typeNameMap.put(STRING, &quot;STRING&quot;);</span>
<span class="fc" id="L389">        typeNameMap.put(SYMBOL, &quot;SYMBOL&quot;);</span>
<span class="fc" id="L390">        typeNameMap.put(BINARY, &quot;BINARY&quot;);</span>
<span class="fc" id="L391">        typeNameMap.put(DATE, &quot;DATE&quot;);</span>
<span class="fc" id="L392">        typeNameMap.put(PARAMETER, &quot;PARAMETER&quot;);</span>
<span class="fc" id="L393">        typeNameMap.put(TIMESTAMP, &quot;TIMESTAMP&quot;);</span>
<span class="fc" id="L394">        typeNameMap.put(LONG256, &quot;LONG256&quot;);</span>
<span class="fc" id="L395">        typeNameMap.put(UUID, &quot;UUID&quot;);</span>
<span class="fc" id="L396">        typeNameMap.put(LONG128, &quot;LONG128&quot;);</span>
<span class="fc" id="L397">        typeNameMap.put(CURSOR, &quot;CURSOR&quot;);</span>
<span class="fc" id="L398">        typeNameMap.put(RECORD, &quot;RECORD&quot;);</span>
<span class="fc" id="L399">        typeNameMap.put(VAR_ARG, &quot;VARARG&quot;);</span>
<span class="fc" id="L400">        typeNameMap.put(GEOHASH, &quot;GEOHASH&quot;);</span>
<span class="fc" id="L401">        typeNameMap.put(REGCLASS, &quot;regclass&quot;);</span>
<span class="fc" id="L402">        typeNameMap.put(REGPROCEDURE, &quot;regprocedure&quot;);</span>
<span class="fc" id="L403">        typeNameMap.put(ARRAY_STRING, &quot;text[]&quot;);</span>

<span class="fc" id="L405">        nameTypeMap.put(&quot;boolean&quot;, BOOLEAN);</span>
<span class="fc" id="L406">        nameTypeMap.put(&quot;byte&quot;, BYTE);</span>
<span class="fc" id="L407">        nameTypeMap.put(&quot;double&quot;, DOUBLE);</span>
<span class="fc" id="L408">        nameTypeMap.put(&quot;float&quot;, FLOAT);</span>
<span class="fc" id="L409">        nameTypeMap.put(&quot;int&quot;, INT);</span>
<span class="fc" id="L410">        nameTypeMap.put(&quot;long&quot;, LONG);</span>
<span class="fc" id="L411">        nameTypeMap.put(&quot;short&quot;, SHORT);</span>
<span class="fc" id="L412">        nameTypeMap.put(&quot;char&quot;, CHAR);</span>
<span class="fc" id="L413">        nameTypeMap.put(&quot;string&quot;, STRING);</span>
<span class="fc" id="L414">        nameTypeMap.put(&quot;symbol&quot;, SYMBOL);</span>
<span class="fc" id="L415">        nameTypeMap.put(&quot;binary&quot;, BINARY);</span>
<span class="fc" id="L416">        nameTypeMap.put(&quot;date&quot;, DATE);</span>
<span class="fc" id="L417">        nameTypeMap.put(&quot;parameter&quot;, PARAMETER);</span>
<span class="fc" id="L418">        nameTypeMap.put(&quot;timestamp&quot;, TIMESTAMP);</span>
<span class="fc" id="L419">        nameTypeMap.put(&quot;cursor&quot;, CURSOR);</span>
<span class="fc" id="L420">        nameTypeMap.put(&quot;long256&quot;, LONG256);</span>
<span class="fc" id="L421">        nameTypeMap.put(&quot;uuid&quot;, UUID);</span>
<span class="fc" id="L422">        nameTypeMap.put(&quot;long128&quot;, LONG128);</span>
<span class="fc" id="L423">        nameTypeMap.put(&quot;geohash&quot;, GEOHASH);</span>
<span class="fc" id="L424">        nameTypeMap.put(&quot;text&quot;, STRING);</span>
<span class="fc" id="L425">        nameTypeMap.put(&quot;smallint&quot;, SHORT);</span>
<span class="fc" id="L426">        nameTypeMap.put(&quot;bigint&quot;, LONG);</span>
<span class="fc" id="L427">        nameTypeMap.put(&quot;real&quot;, FLOAT);</span>
<span class="fc" id="L428">        nameTypeMap.put(&quot;bytea&quot;, STRING);</span>
<span class="fc" id="L429">        nameTypeMap.put(&quot;varchar&quot;, STRING);</span>
<span class="fc" id="L430">        nameTypeMap.put(&quot;regclass&quot;, REGCLASS);</span>
<span class="fc" id="L431">        nameTypeMap.put(&quot;regprocedure&quot;, REGPROCEDURE);</span>
<span class="fc" id="L432">        nameTypeMap.put(&quot;text[]&quot;, ARRAY_STRING);</span>

<span class="fc" id="L434">        StringSink sink = new StringSink();</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        for (int b = 1; b &lt;= GEO_HASH_MAX_BITS_LENGTH; b++) {</span>
<span class="fc" id="L436">            sink.clear();</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (b % 5 != 0) {</span>
<span class="fc" id="L438">                sink.put(&quot;GEOHASH(&quot;).put(b).put(&quot;b)&quot;);</span>
            } else {
<span class="fc" id="L440">                sink.put(&quot;GEOHASH(&quot;).put(b / 5).put(&quot;c)&quot;);</span>
            }
<span class="fc" id="L442">            String name = sink.toString();</span>
<span class="fc" id="L443">            int type = getGeoHashTypeWithBits(b);</span>
<span class="fc" id="L444">            typeNameMap.put(type, name);</span>
<span class="fc" id="L445">            nameTypeMap.put(name, type);</span>
        }

<span class="fc" id="L448">        TYPE_SIZE_POW2[UNDEFINED] = -1;</span>
<span class="fc" id="L449">        TYPE_SIZE_POW2[BOOLEAN] = 0;</span>
<span class="fc" id="L450">        TYPE_SIZE_POW2[BYTE] = 0;</span>
<span class="fc" id="L451">        TYPE_SIZE_POW2[SHORT] = 1;</span>
<span class="fc" id="L452">        TYPE_SIZE_POW2[CHAR] = 1;</span>
<span class="fc" id="L453">        TYPE_SIZE_POW2[FLOAT] = 2;</span>
<span class="fc" id="L454">        TYPE_SIZE_POW2[INT] = 2;</span>
<span class="fc" id="L455">        TYPE_SIZE_POW2[SYMBOL] = 2;</span>
<span class="fc" id="L456">        TYPE_SIZE_POW2[DOUBLE] = 3;</span>
<span class="fc" id="L457">        TYPE_SIZE_POW2[STRING] = -1;</span>
<span class="fc" id="L458">        TYPE_SIZE_POW2[LONG] = 3;</span>
<span class="fc" id="L459">        TYPE_SIZE_POW2[DATE] = 3;</span>
<span class="fc" id="L460">        TYPE_SIZE_POW2[TIMESTAMP] = 3;</span>
<span class="fc" id="L461">        TYPE_SIZE_POW2[LONG256] = 5;</span>
<span class="fc" id="L462">        TYPE_SIZE_POW2[GEOBYTE] = 0;</span>
<span class="fc" id="L463">        TYPE_SIZE_POW2[GEOSHORT] = 1;</span>
<span class="fc" id="L464">        TYPE_SIZE_POW2[GEOINT] = 2;</span>
<span class="fc" id="L465">        TYPE_SIZE_POW2[GEOLONG] = 3;</span>
<span class="fc" id="L466">        TYPE_SIZE_POW2[BINARY] = 2;</span>
<span class="fc" id="L467">        TYPE_SIZE_POW2[PARAMETER] = -1;</span>
<span class="fc" id="L468">        TYPE_SIZE_POW2[CURSOR] = -1;</span>
<span class="fc" id="L469">        TYPE_SIZE_POW2[VAR_ARG] = -1;</span>
<span class="fc" id="L470">        TYPE_SIZE_POW2[RECORD] = -1;</span>
<span class="fc" id="L471">        TYPE_SIZE_POW2[NULL] = -1;</span>
<span class="fc" id="L472">        TYPE_SIZE_POW2[LONG128] = 4;</span>
<span class="fc" id="L473">        TYPE_SIZE_POW2[UUID] = 4;</span>

<span class="fc" id="L475">        TYPE_SIZE[UNDEFINED] = -1;</span>
<span class="fc" id="L476">        TYPE_SIZE[BOOLEAN] = Byte.BYTES;</span>
<span class="fc" id="L477">        TYPE_SIZE[BYTE] = Byte.BYTES;</span>
<span class="fc" id="L478">        TYPE_SIZE[SHORT] = Short.BYTES;</span>
<span class="fc" id="L479">        TYPE_SIZE[CHAR] = Character.BYTES;</span>
<span class="fc" id="L480">        TYPE_SIZE[FLOAT] = Float.BYTES;</span>
<span class="fc" id="L481">        TYPE_SIZE[INT] = Integer.BYTES;</span>
<span class="fc" id="L482">        TYPE_SIZE[SYMBOL] = Integer.BYTES;</span>
<span class="fc" id="L483">        TYPE_SIZE[STRING] = 0;</span>
<span class="fc" id="L484">        TYPE_SIZE[DOUBLE] = Double.BYTES;</span>
<span class="fc" id="L485">        TYPE_SIZE[LONG] = Long.BYTES;</span>
<span class="fc" id="L486">        TYPE_SIZE[DATE] = Long.BYTES;</span>
<span class="fc" id="L487">        TYPE_SIZE[TIMESTAMP] = Long.BYTES;</span>
<span class="fc" id="L488">        TYPE_SIZE[LONG256] = Long256.BYTES;</span>
<span class="fc" id="L489">        TYPE_SIZE[GEOBYTE] = Byte.BYTES;</span>
<span class="fc" id="L490">        TYPE_SIZE[GEOSHORT] = Short.BYTES;</span>
<span class="fc" id="L491">        TYPE_SIZE[GEOINT] = Integer.BYTES;</span>
<span class="fc" id="L492">        TYPE_SIZE[GEOLONG] = Long.BYTES;</span>
<span class="fc" id="L493">        TYPE_SIZE[BINARY] = 0;</span>
<span class="fc" id="L494">        TYPE_SIZE[PARAMETER] = -1;</span>
<span class="fc" id="L495">        TYPE_SIZE[CURSOR] = -1;</span>
<span class="fc" id="L496">        TYPE_SIZE[VAR_ARG] = -1;</span>
<span class="fc" id="L497">        TYPE_SIZE[RECORD] = -1;</span>
<span class="fc" id="L498">        TYPE_SIZE[UUID] = 2 * Long.BYTES;</span>
<span class="fc" id="L499">        TYPE_SIZE[NULL] = 0;</span>
<span class="fc" id="L500">        TYPE_SIZE[LONG128] = 2 * Long.BYTES;</span>
<span class="fc" id="L501">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>