<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColumnPurgeOperator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">ColumnPurgeOperator.java</span></div><h1>ColumnPurgeOperator.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.*;
import io.questdb.std.datetime.microtime.MicrosecondClock;
import io.questdb.std.str.Path;
import io.questdb.tasks.ColumnPurgeTask;

import java.io.Closeable;

import static io.questdb.cairo.TableUtils.TXN_FILE_NAME;

public class ColumnPurgeOperator implements Closeable {
<span class="fc" id="L39">    private static final Log LOG = LogFactory.getLog(ColumnPurgeOperator.class);</span>
<span class="fc" id="L40">    private final LongList completedRowIds = new LongList();</span>
    private final FilesFacade ff;
    private final MicrosecondClock microClock;
<span class="fc" id="L43">    private final Path path = new Path();</span>
    private final int pathRootLen;
    private final TableWriter purgeLogWriter;
    private final String updateCompleteColumnName;
    private final int updateCompleteColumnWriterIndex;
    private long longBytes;
    private int pathTableLen;
<span class="fc" id="L50">    private int purgeLogPartitionFd = -1;</span>
<span class="fc" id="L51">    private long purgeLogPartitionTimestamp = Long.MAX_VALUE;</span>
    private TxReader txReader;
    private TxnScoreboard txnScoreboard;

<span class="fc" id="L55">    public ColumnPurgeOperator(CairoConfiguration configuration, TableWriter purgeLogWriter, String updateCompleteColumnName) {</span>
<span class="fc" id="L56">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L57">        this.purgeLogWriter = purgeLogWriter;</span>
<span class="fc" id="L58">        this.updateCompleteColumnName = updateCompleteColumnName;</span>
<span class="fc" id="L59">        this.updateCompleteColumnWriterIndex = purgeLogWriter.getMetadata().getColumnIndex(updateCompleteColumnName);</span>
<span class="fc" id="L60">        path.of(configuration.getRoot());</span>
<span class="fc" id="L61">        pathRootLen = path.length();</span>
<span class="fc" id="L62">        txnScoreboard = new TxnScoreboard(ff, configuration.getTxnScoreboardEntryCount());</span>
<span class="fc" id="L63">        txReader = new TxReader(ff);</span>
<span class="fc" id="L64">        microClock = configuration.getMicrosecondClock();</span>
<span class="fc" id="L65">        longBytes = Unsafe.malloc(Long.BYTES, MemoryTag.NATIVE_COLUMN_PURGE);</span>
<span class="fc" id="L66">    }</span>

<span class="fc" id="L68">    public ColumnPurgeOperator(CairoConfiguration configuration) {</span>
<span class="fc" id="L69">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L70">        this.purgeLogWriter = null;</span>
<span class="fc" id="L71">        this.updateCompleteColumnName = null;</span>
<span class="fc" id="L72">        this.updateCompleteColumnWriterIndex = -1;</span>
<span class="fc" id="L73">        path.of(configuration.getRoot());</span>
<span class="fc" id="L74">        pathRootLen = path.length();</span>
<span class="fc" id="L75">        txnScoreboard = null;</span>
<span class="fc" id="L76">        txReader = null;</span>
<span class="fc" id="L77">        microClock = configuration.getMicrosecondClock();</span>
<span class="fc" id="L78">        longBytes = 0;</span>
<span class="fc" id="L79">    }</span>

    @Override
    public void close() {
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (longBytes != 0L) {</span>
<span class="fc" id="L84">            Unsafe.free(longBytes, Long.BYTES, MemoryTag.NATIVE_COLUMN_PURGE);</span>
<span class="fc" id="L85">            longBytes = 0;</span>
        }
<span class="fc" id="L87">        closePurgeLogCompleteFile();</span>
<span class="fc" id="L88">        Misc.free(path);</span>
<span class="fc" id="L89">        txnScoreboard = Misc.free(txnScoreboard);</span>
<span class="fc" id="L90">    }</span>

    public boolean purge(ColumnPurgeTask task) {
        try {
<span class="fc" id="L94">            boolean done = purge0(task, ScoreboardUseMode.INTERNAL);</span>
<span class="fc" id="L95">            setCompletionTimestamp(completedRowIds, microClock.getTicks());</span>
<span class="fc" id="L96">            return done;</span>
<span class="nc" id="L97">        } catch (Throwable ex) {</span>
            // Can be some IO exception
<span class="nc" id="L99">            LOG.error().$(&quot;could not purge&quot;).$(ex).$();</span>
<span class="nc" id="L100">            return false;</span>
        }
    }

    public boolean purge(ColumnPurgeTask task, TableReader tableReader) {
        try {
<span class="fc" id="L106">            txReader = tableReader.getTxFile();</span>
<span class="fc" id="L107">            txnScoreboard = tableReader.getTxnScoreboard();</span>
<span class="fc" id="L108">            return purge0(task, ScoreboardUseMode.EXTERNAL);</span>
<span class="nc" id="L109">        } catch (Throwable ex) {</span>
            // Can be some IO exception
<span class="nc" id="L111">            LOG.error().$(&quot;could not purge&quot;).$(ex).$();</span>
<span class="nc" id="L112">            return false;</span>
        }
    }

    public void purgeExclusive(ColumnPurgeTask task) {
        try {
<span class="fc" id="L118">            purge0(task, ScoreboardUseMode.EXCLUSIVE);</span>
<span class="nc" id="L119">        } catch (Throwable ex) {</span>
            // Can be some IO exception
<span class="nc" id="L121">            LOG.error().$(&quot;could not purge&quot;).$(ex).$();</span>
<span class="fc" id="L122">        }</span>
<span class="fc" id="L123">    }</span>

    private static boolean couldNotRemove(FilesFacade ff, Path path) {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (ff.remove(path)) {</span>
<span class="fc" id="L127">            return false;</span>
        }

<span class="fc" id="L130">        final int errno = ff.errno();</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (ff.exists(path)) {</span>
<span class="fc" id="L133">            LOG.info().$(&quot;cannot delete file, will retry [path=&quot;).$(path).$(&quot;, errno=&quot;).$(errno).I$();</span>
<span class="fc" id="L134">            return true;</span>
        }

        // file did not exist, we don't care of the error
<span class="fc" id="L138">        return false;</span>
    }

    private boolean checkScoreboardHasReadersBeforeUpdate(long columnVersion, ColumnPurgeTask task) {
<span class="fc" id="L142">        long updateTxn = task.getUpdateTxn();</span>
        try {
<span class="fc bfc" id="L144" title="All 2 branches covered.">            return !txnScoreboard.isRangeAvailable(columnVersion + 1, updateTxn);</span>
<span class="nc" id="L145">        } catch (CairoException ex) {</span>
            // Scoreboard can be over allocated, don't stall purge because of that, re-schedule another run instead
<span class="nc" id="L147">            LOG.error().$(&quot;cannot lock last txn in scoreboard, column purge will re-run [table=&quot;)</span>
<span class="nc" id="L148">                    .utf8(task.getTableName().getTableName())</span>
<span class="nc" id="L149">                    .$(&quot;, txn=&quot;).$(updateTxn)</span>
<span class="nc" id="L150">                    .$(&quot;, error=&quot;).$(ex.getFlyweightMessage())</span>
<span class="nc" id="L151">                    .$(&quot;, errno=&quot;).$(ex.getErrno()).I$();</span>
<span class="nc" id="L152">            return true;</span>
        }
    }

    private void closePurgeLogCompleteFile() {
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (ff.close(purgeLogPartitionFd)) {</span>
<span class="fc" id="L158">            LOG.info().$(&quot;closed purge log complete file [fd=&quot;).$(purgeLogPartitionFd).I$();</span>
<span class="fc" id="L159">            purgeLogPartitionFd = -1;</span>
        }
<span class="fc" id="L161">    }</span>

    private boolean openScoreboardAndTxn(ColumnPurgeTask task, ScoreboardUseMode scoreboardUseMode) {
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (scoreboardUseMode == ScoreboardUseMode.INTERNAL) {</span>
<span class="fc" id="L165">            txnScoreboard.ofRO(path.trimTo(pathTableLen));</span>
        }

        // In exclusive mode we still need to check that purge will delete column in correct table,
        // e.g. table is not truncated after the update happened
<span class="pc bpc" id="L170" title="1 of 4 branches missed.">        if (scoreboardUseMode == ScoreboardUseMode.INTERNAL || scoreboardUseMode == ScoreboardUseMode.EXCLUSIVE) {</span>
<span class="fc" id="L171">            int tableId = readTableId(path);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (tableId != task.getTableId()) {</span>
<span class="fc" id="L173">                LOG.info().$(&quot;cannot purge orphan table [path=&quot;).utf8(path.trimTo(pathTableLen)).I$();</span>
<span class="fc" id="L174">                return false;</span>
            }

<span class="fc" id="L177">            path.trimTo(pathTableLen).concat(TXN_FILE_NAME);</span>
<span class="fc" id="L178">            txReader.ofRO(path.$(), task.getPartitionBy());</span>
<span class="fc" id="L179">            txReader.unsafeLoadAll();</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            if (txReader.getTruncateVersion() != task.getTruncateVersion()) {</span>
<span class="nc" id="L181">                LOG.info().$(&quot;cannot purge, purge request overlaps with truncate [path=&quot;).$(path.trimTo(pathTableLen)).I$();</span>
<span class="nc" id="L182">                return false;</span>
            }
        }

<span class="fc" id="L186">        return true;</span>
    }

    private boolean purge0(ColumnPurgeTask task, final ScoreboardUseMode scoreboardMode) {

<span class="fc" id="L191">        LOG.info().$(&quot;purging [table=&quot;).utf8(task.getTableName().getTableName())</span>
<span class="fc" id="L192">                .$(&quot;, column=&quot;).utf8(task.getColumnName())</span>
<span class="fc" id="L193">                .$(&quot;, tableId=&quot;).$(task.getTableId())</span>
<span class="fc" id="L194">                .I$();</span>

<span class="fc" id="L196">        setTablePath(task.getTableName());</span>

<span class="fc" id="L198">        final LongList updatedColumnInfo = task.getUpdatedColumnInfo();</span>
<span class="fc" id="L199">        long minUnlockedTxnRangeStarts = Long.MAX_VALUE;</span>
<span class="fc" id="L200">        boolean allDone = true;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        boolean setupScoreboard = scoreboardMode != ScoreboardUseMode.EXTERNAL;</span>

        try {
<span class="fc" id="L204">            completedRowIds.clear();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">            for (int i = 0, n = updatedColumnInfo.size(); i &lt; n; i += ColumnPurgeTask.BLOCK_SIZE) {</span>
<span class="fc" id="L206">                final long columnVersion = updatedColumnInfo.getQuick(i + ColumnPurgeTask.OFFSET_COLUMN_VERSION);</span>
<span class="fc" id="L207">                final long partitionTimestamp = updatedColumnInfo.getQuick(i + ColumnPurgeTask.OFFSET_PARTITION_TIMESTAMP);</span>
<span class="fc" id="L208">                final long partitionTxnName = updatedColumnInfo.getQuick(i + ColumnPurgeTask.OFFSET_PARTITION_NAME_TXN);</span>
<span class="fc" id="L209">                final long updateRowId = updatedColumnInfo.getQuick(i + ColumnPurgeTask.OFFSET_UPDATE_ROW_ID);</span>

<span class="fc" id="L211">                setUpPartitionPath(task.getPartitionBy(), partitionTimestamp, partitionTxnName);</span>
<span class="fc" id="L212">                int pathTrimToPartition = path.length();</span>

<span class="fc" id="L214">                TableUtils.dFile(path, task.getColumnName(), columnVersion);</span>

                // perform existence check ahead of trying to remove files

<span class="fc bfc" id="L218" title="All 2 branches covered.">                if (!ff.exists(path)) {</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                    if (ColumnType.isVariableLength(task.getColumnType())) {</span>
<span class="fc" id="L220">                        path.trimTo(pathTrimToPartition);</span>
<span class="fc" id="L221">                        TableUtils.iFile(path, task.getColumnName(), columnVersion);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">                        if (!ff.exists(path)) {</span>
<span class="fc" id="L223">                            completedRowIds.add(updateRowId);</span>
<span class="fc" id="L224">                            continue;</span>
                        }
                    } else {
                        // Files already deleted, move to the next partition
<span class="fc" id="L228">                        completedRowIds.add(updateRowId);</span>
<span class="fc" id="L229">                        continue;</span>
                    }
                }

<span class="fc bfc" id="L233" title="All 2 branches covered.">                if (setupScoreboard) {</span>
                    // Setup scoreboard lazily because columns we're purging
                    // may not exist, including the entire table. Setting up
                    // scoreboard ahead of checking file existence would fail in those
                    // cases.
<span class="fc bfc" id="L238" title="All 2 branches covered.">                    if (!openScoreboardAndTxn(task, scoreboardMode)) {</span>
                        // current table state precludes us from purging its columns
                        // nothing to do here
<span class="fc" id="L241">                        completedRowIds.add(updateRowId);</span>
<span class="fc" id="L242">                        continue;</span>
                    }
                    // we would have mutated the path by checking state of the table
                    // we will have to re-setup that
<span class="fc" id="L246">                    setUpPartitionPath(task.getPartitionBy(), partitionTimestamp, partitionTxnName);</span>
<span class="fc" id="L247">                    TableUtils.dFile(path, task.getColumnName(), columnVersion);</span>
<span class="fc" id="L248">                    setupScoreboard = false;</span>
                }

<span class="pc bpc" id="L251" title="1 of 2 branches missed.">                if (txReader.isPartitionReadOnlyByPartitionTimestamp(partitionTimestamp)) {</span>
                    // txReader is either open because scoreboardMode == ScoreboardUseMode.EXTERNAL
                    // or it was open by openScoreboardAndTxn
<span class="nc" id="L254">                    LOG.info().$(&quot;skipping purge of read-only partition [path=&quot;).utf8(path.$())</span>
<span class="nc" id="L255">                            .$(&quot;, column=&quot;).utf8(task.getColumnName())</span>
<span class="nc" id="L256">                            .I$();</span>
<span class="nc" id="L257">                    completedRowIds.add(updateRowId);</span>
<span class="nc" id="L258">                    continue;</span>
                }

<span class="fc bfc" id="L261" title="All 2 branches covered.">                if (columnVersion &lt; minUnlockedTxnRangeStarts) {</span>
<span class="fc bfc" id="L262" title="All 4 branches covered.">                    if (scoreboardMode != ScoreboardUseMode.EXCLUSIVE &amp;&amp; checkScoreboardHasReadersBeforeUpdate(columnVersion, task)) {</span>
                        // Reader lock still exists
<span class="fc" id="L264">                        allDone = false;</span>
<span class="fc" id="L265">                        LOG.debug().$(&quot;cannot purge, version is in use [path=&quot;).$(path).I$();</span>
<span class="fc" id="L266">                        continue;</span>
                    } else {
<span class="fc" id="L268">                        minUnlockedTxnRangeStarts = columnVersion;</span>
                    }
                }

<span class="fc" id="L272">                LOG.info().$(&quot;purging [path=&quot;).$(path).I$();</span>

                // No readers looking at the column version, files can be deleted
<span class="fc bfc" id="L275" title="All 2 branches covered.">                if (couldNotRemove(ff, path)) {</span>
<span class="fc" id="L276">                    allDone = false;</span>
<span class="fc" id="L277">                    continue;</span>
                }

<span class="fc bfc" id="L280" title="All 2 branches covered.">                if (ColumnType.isVariableLength(task.getColumnType())) {</span>
<span class="fc" id="L281">                    path.trimTo(pathTrimToPartition);</span>
<span class="fc" id="L282">                    TableUtils.iFile(path, task.getColumnName(), columnVersion);</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">                    if (couldNotRemove(ff, path)) {</span>
<span class="fc" id="L285">                        allDone = false;</span>
<span class="fc" id="L286">                        continue;</span>
                    }
                }

                // Check if it's symbol, try remove .k and .v files in the partition
<span class="fc bfc" id="L291" title="All 2 branches covered.">                if (ColumnType.isSymbol(task.getColumnType())) {</span>
<span class="fc" id="L292">                    path.trimTo(pathTrimToPartition);</span>
<span class="fc" id="L293">                    BitmapIndexUtils.keyFileName(path, task.getColumnName(), columnVersion);</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                    if (couldNotRemove(ff, path)) {</span>
<span class="nc" id="L295">                        allDone = false;</span>
<span class="nc" id="L296">                        continue;</span>
                    }

<span class="fc" id="L299">                    path.trimTo(pathTrimToPartition);</span>
<span class="fc" id="L300">                    BitmapIndexUtils.valueFileName(path, task.getColumnName(), columnVersion);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">                    if (couldNotRemove(ff, path)) {</span>
<span class="nc" id="L302">                        allDone = false;</span>
<span class="nc" id="L303">                        continue;</span>
                    }
                }
<span class="fc" id="L306">                completedRowIds.add(updateRowId);</span>
            }
        } finally {
<span class="fc bfc" id="L309" title="All 2 branches covered.">            if (scoreboardMode != ScoreboardUseMode.EXTERNAL) {</span>
<span class="fc" id="L310">                Misc.free(txnScoreboard);</span>
<span class="fc" id="L311">                Misc.free(txReader);</span>
            }
        }

<span class="fc" id="L315">        return allDone;</span>
    }

    private int readTableId(Path path) {
<span class="fc" id="L319">        final int INVALID_TABLE_ID = Integer.MIN_VALUE;</span>
<span class="fc" id="L320">        int fd = ff.openRO(path.trimTo(pathTableLen).concat(TableUtils.META_FILE_NAME).$());</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (fd &lt; 0) {</span>
<span class="nc" id="L322">            return INVALID_TABLE_ID;</span>
        }
        try {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">            if (ff.read(fd, longBytes, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) != Integer.BYTES) {</span>
<span class="nc" id="L326">                return INVALID_TABLE_ID;</span>
            }
<span class="fc" id="L328">            return Unsafe.getUnsafe().getInt(longBytes);</span>
        } finally {
<span class="fc" id="L330">            ff.close(fd);</span>
        }
    }

    private void reopenPurgeLogPartition(int partitionIndex, long partitionTimestamp) {
<span class="fc" id="L335">        path.trimTo(pathRootLen);</span>
<span class="fc" id="L336">        path.concat(purgeLogWriter.getTableToken());</span>
<span class="fc" id="L337">        long partitionNameTxn = purgeLogWriter.getPartitionNameTxn(partitionIndex);</span>
<span class="fc" id="L338">        TableUtils.setPathForPartition(</span>
                path,
<span class="fc" id="L340">                purgeLogWriter.getPartitionBy(),</span>
                partitionTimestamp,
                false
        );
<span class="fc" id="L344">        TableUtils.txnPartitionConditionally(path, partitionNameTxn);</span>
<span class="fc" id="L345">        TableUtils.dFile(</span>
                path,
                updateCompleteColumnName,
<span class="fc" id="L348">                purgeLogWriter.getColumnNameTxn(partitionTimestamp, updateCompleteColumnWriterIndex)</span>
        );
<span class="fc" id="L350">        closePurgeLogCompleteFile();</span>
<span class="fc" id="L351">        purgeLogPartitionFd = TableUtils.openRW(ff, path.$(), LOG, purgeLogWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L352">        purgeLogPartitionTimestamp = partitionTimestamp;</span>
<span class="fc" id="L353">        LOG.info().$(&quot;reopened purge log complete file [path=&quot;).$(path).$(&quot;, fd=&quot;).$(purgeLogPartitionFd).I$();</span>
<span class="fc" id="L354">    }</span>

    private void setCompletionTimestamp(LongList completedRecordIds, long timeMicro) {
        // This is in-place update for known record ids of completed column in column version cleanup log table
        try {
<span class="fc" id="L359">            Unsafe.getUnsafe().putLong(longBytes, timeMicro);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            for (int rec = 0, n = completedRecordIds.size(); rec &lt; n; rec++) {</span>
<span class="fc" id="L361">                long recordId = completedRecordIds.getQuick(rec);</span>
<span class="fc" id="L362">                int partitionIndex = Rows.toPartitionIndex(recordId);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">                if (rec == 0) {</span>
                    // Assumption is that all records belong to same partition
                    // this is how the records are added to the table in ColumnPurgeJob
                    // e.g. all records about the same column updated have identical timestamp
<span class="fc" id="L367">                    final long partitionTimestamp = purgeLogWriter.getPartitionTimestamp(partitionIndex);</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                    if (purgeLogPartitionTimestamp != partitionTimestamp) {</span>
<span class="fc" id="L369">                        reopenPurgeLogPartition(partitionIndex, partitionTimestamp);</span>
                    }
                }
<span class="fc" id="L372">                long rowId = Rows.toLocalRowID(recordId);</span>
<span class="fc" id="L373">                long offset = rowId * Long.BYTES;</span>

<span class="pc bpc" id="L375" title="1 of 2 branches missed.">                if (ff.write(purgeLogPartitionFd, longBytes, Long.BYTES, rowId * Long.BYTES) != Long.BYTES) {</span>
<span class="nc" id="L376">                    int errno = ff.errno();</span>
<span class="nc" id="L377">                    long length = ff.length(purgeLogPartitionFd);</span>
<span class="nc" id="L378">                    LOG.error().$(&quot;could not mark record as purged [errno=&quot;).$(errno)</span>
<span class="nc" id="L379">                            .$(&quot;, writeOffset=&quot;).$(offset)</span>
<span class="nc" id="L380">                            .$(&quot;, fd=&quot;).$(purgeLogPartitionFd)</span>
<span class="nc" id="L381">                            .$(&quot;, fileSize=&quot;).$(length).I$();</span>
                    // Re-open of the file next run in case something went wrong.
<span class="nc" id="L383">                    purgeLogPartitionTimestamp = -1;</span>
                }
            }
<span class="fc" id="L386">        } catch (CairoException ex) {</span>
<span class="fc" id="L387">            LOG.error().$(&quot;could not update completion timestamp&quot;).$((Throwable) ex).$();</span>
<span class="fc" id="L388">        }</span>
<span class="fc" id="L389">    }</span>

    private void setTablePath(TableToken tableName) {
<span class="fc" id="L392">        path.trimTo(pathRootLen).concat(tableName);</span>
<span class="fc" id="L393">        pathTableLen = path.length();</span>
<span class="fc" id="L394">    }</span>

    private void setUpPartitionPath(int partitionBy, long partitionTimestamp, long partitionTxnName) {
<span class="fc" id="L397">        path.trimTo(pathTableLen);</span>
<span class="fc" id="L398">        TableUtils.setPathForPartition(path, partitionBy, partitionTimestamp, false);</span>
<span class="fc" id="L399">        TableUtils.txnPartitionConditionally(path, partitionTxnName);</span>
<span class="fc" id="L400">    }</span>

<span class="fc" id="L402">    private enum ScoreboardUseMode {</span>
<span class="fc" id="L403">        INTERNAL,</span>
<span class="fc" id="L404">        EXTERNAL,</span>
<span class="fc" id="L405">        EXCLUSIVE</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>