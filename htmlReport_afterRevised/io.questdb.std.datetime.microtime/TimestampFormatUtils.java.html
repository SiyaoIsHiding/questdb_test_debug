<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TimestampFormatUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.std.datetime.microtime</a> &gt; <span class="el_source">TimestampFormatUtils.java</span></div><h1>TimestampFormatUtils.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.std.datetime.microtime;

import io.questdb.std.*;
import io.questdb.std.datetime.DateFormat;
import io.questdb.std.datetime.DateLocale;
import io.questdb.std.datetime.DateLocaleFactory;
import io.questdb.std.str.CharSink;

import static io.questdb.std.datetime.TimeZoneRuleFactory.RESOLUTION_MICROS;

<span class="nc" id="L35">public class TimestampFormatUtils {</span>
    public static final DateFormat GREEDY_MILLIS1_UTC_FORMAT;
    public static final DateFormat GREEDY_MILLIS2_UTC_FORMAT;
    public static final int HOUR_24 = 2;
    public static final int HOUR_AM = 0;
    public static final int HOUR_PM = 1;
    public static final DateFormat NANOS_UTC_FORMAT;
    public static final DateFormat PG_TIMESTAMP_FORMAT;
    public static final DateFormat PG_TIMESTAMP_MILLI_TIME_Z_FORMAT;
    public static final DateFormat PG_TIMESTAMP_TIME_Z_FORMAT;
    public static final DateFormat SEC_UTC_FORMAT;
    public static final int TIMESTAMP_FORMAT_MIN_LENGTH;
    public static final DateFormat USEC_UTC_FORMAT;
    public static final DateFormat UTC_FORMAT;
    public static final String UTC_PATTERN = &quot;yyyy-MM-ddTHH:mm:ss.SSSz&quot;;
<span class="fc" id="L50">    public static final DateLocale enLocale = DateLocaleFactory.INSTANCE.getLocale(&quot;en&quot;);</span>
    private static final DateFormat[] FORMATS;
    private static final String GREEDY_MILLIS1_UTC_PATTERN = &quot;yyyy-MM-ddTHH:mm:ss.Sz&quot;;
    private static final String GREEDY_MILLIS2_UTC_PATTERN = &quot;yyyy-MM-ddTHH:mm:ss.SSz&quot;;
    private static final DateFormat HTTP_FORMAT;
    private static final String PG_TIMESTAMP_MILLI_TIME_Z_PATTERN = &quot;y-MM-dd HH:mm:ss.SSSz&quot;;
    private static final String SEC_UTC_PATTERN = &quot;yyyy-MM-ddTHH:mm:ssz&quot;;
    private static final String USEC_UTC_PATTERN = &quot;yyyy-MM-ddTHH:mm:ss.SSSUUUz&quot;;
    static int prevCenturyLow;
    static long referenceYear;
    static int thisCenturyLimit;
    static int thisCenturyLow;
    @SuppressWarnings({&quot;FieldCanBeLocal&quot;, &quot;unused&quot;})
    private static long newYear;

    public static int adjustYear(int year) {
<span class="fc" id="L66">        return thisCenturyLow + year;</span>
    }

    public static void append0(CharSink sink, int val) {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (Math.abs(val) &lt; 10) {</span>
<span class="fc" id="L71">            sink.put('0');</span>
        }
<span class="fc" id="L73">        Numbers.append(sink, val);</span>
<span class="fc" id="L74">    }</span>

    public static void append00(CharSink sink, int val) {
<span class="fc" id="L77">        int v = Math.abs(val);</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (v &lt; 10) {</span>
<span class="fc" id="L79">            sink.put('0').put('0');</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        } else if (v &lt; 100) {</span>
<span class="fc" id="L81">            sink.put('0');</span>
        }
<span class="fc" id="L83">        Numbers.append(sink, val);</span>
<span class="fc" id="L84">    }</span>

    public static void append00000(CharSink sink, int val) {
<span class="fc" id="L87">        int v = Math.abs(val);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (v &lt; 10) {</span>
<span class="fc" id="L89">            sink.put('0').put('0').put('0').put('0').put('0');</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        } else if (v &lt; 100) {</span>
<span class="fc" id="L91">            sink.put('0').put('0').put('0').put('0');</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        } else if (v &lt; 1000) {</span>
<span class="fc" id="L93">            sink.put('0').put('0').put('0');</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        } else if (v &lt; 10000) {</span>
<span class="fc" id="L95">            sink.put('0').put('0');</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        } else if (v &lt; 100000) {</span>
<span class="fc" id="L97">            sink.put('0');</span>
        }
<span class="fc" id="L99">        Numbers.append(sink, val);</span>
<span class="fc" id="L100">    }</span>

    public static void appendAmPm(CharSink sink, int hour, DateLocale locale) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (hour &lt; 12) {</span>
<span class="fc" id="L104">            sink.put(locale.getAMPM(0));</span>
        } else {
<span class="fc" id="L106">            sink.put(locale.getAMPM(1));</span>
        }
<span class="fc" id="L108">    }</span>

    // YYYY-MM-DDThh:mm:ss.mmmZ
    public static void appendDateTime(CharSink sink, long micros) {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (micros == Long.MIN_VALUE) {</span>
<span class="nc" id="L113">            return;</span>
        }
<span class="fc" id="L115">        UTC_FORMAT.format(micros, null, &quot;Z&quot;, sink);</span>
<span class="fc" id="L116">    }</span>

    // YYYY-MM-DDThh:mm:ss.mmmuuuZ
    public static void appendDateTimeUSec(CharSink sink, long micros) {
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (micros == Long.MIN_VALUE) {</span>
<span class="fc" id="L121">            return;</span>
        }
<span class="fc" id="L123">        USEC_UTC_FORMAT.format(micros, null, &quot;Z&quot;, sink);</span>
<span class="fc" id="L124">    }</span>

    public static void appendEra(CharSink sink, int year, DateLocale locale) {
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (year &lt; 0) {</span>
<span class="fc" id="L128">            sink.put(locale.getEra(0));</span>
        } else {
<span class="fc" id="L130">            sink.put(locale.getEra(1));</span>
        }
<span class="fc" id="L132">    }</span>

    public static void appendHour12(CharSink sink, int hour) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (hour &lt; 12) {</span>
<span class="fc" id="L136">            sink.put(hour);</span>
        } else {
<span class="fc" id="L138">            sink.put(hour - 12);</span>
        }
<span class="fc" id="L140">    }</span>

    public static void appendHour121(CharSink sink, int hour) {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (hour &lt; 12) {</span>
<span class="fc" id="L144">            sink.put(hour + 1);</span>
        } else {
<span class="fc" id="L146">            sink.put(hour - 11);</span>
        }
<span class="fc" id="L148">    }</span>

    public static void appendHour121Padded(CharSink sink, int hour) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (hour &lt; 12) {</span>
<span class="fc" id="L152">            append0(sink, hour + 1);</span>
        } else {
<span class="fc" id="L154">            append0(sink, hour - 11);</span>
        }
<span class="fc" id="L156">    }</span>

    public static void appendHour12Padded(CharSink sink, int hour) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (hour &lt; 12) {</span>
<span class="fc" id="L160">            append0(sink, hour);</span>
        } else {
<span class="fc" id="L162">            append0(sink, hour - 12);</span>
        }
<span class="fc" id="L164">    }</span>

    public static void appendYear(CharSink sink, int val) {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        Numbers.append(sink, val != 0 ? val : 1);</span>
<span class="fc" id="L168">    }</span>

    public static void appendYear0(CharSink sink, int val) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (Math.abs(val) &lt; 10) {</span>
<span class="fc" id="L172">            sink.put('0');</span>
        }
<span class="fc" id="L174">        appendYear(sink, val);</span>
<span class="fc" id="L175">    }</span>

    public static void appendYear00(CharSink sink, int val) {
<span class="fc" id="L178">        int v = Math.abs(val);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (v &lt; 10) {</span>
<span class="fc" id="L180">            sink.put('0').put('0');</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        } else if (v &lt; 100) {</span>
<span class="fc" id="L182">            sink.put('0');</span>
        }
<span class="fc" id="L184">        appendYear(sink, val);</span>
<span class="fc" id="L185">    }</span>

    public static void appendYear000(CharSink sink, int val) {
<span class="fc" id="L188">        int v = Math.abs(val);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (v &lt; 10) {</span>
<span class="fc" id="L190">            sink.put('0').put('0').put('0');</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        } else if (v &lt; 100) {</span>
<span class="nc" id="L192">            sink.put('0').put('0');</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        } else if (v &lt; 1000) {</span>
<span class="fc" id="L194">            sink.put('0');</span>
        }
<span class="fc" id="L196">        appendYear(sink, val);</span>
<span class="fc" id="L197">    }</span>

    public static void assertChar(char c, CharSequence in, int pos, int hi) throws NumericException {
<span class="fc" id="L200">        assertRemaining(pos, hi);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (in.charAt(pos) != c) {</span>
<span class="fc" id="L202">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L204">    }</span>

    public static void assertNoTail(int pos, int hi) throws NumericException {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (pos &lt; hi) {</span>
<span class="fc" id="L208">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L210">    }</span>

    public static void assertRemaining(int pos, int hi) throws NumericException {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (pos &lt; hi) {</span>
<span class="fc" id="L214">            return;</span>
        }
<span class="fc" id="L216">        throw NumericException.INSTANCE;</span>
    }

    public static int assertString(CharSequence delimiter, int len, CharSequence in, int pos, int hi) throws NumericException {
<span class="pc bpc" id="L220" title="1 of 4 branches missed.">        if (delimiter.charAt(0) == '\'' &amp;&amp; delimiter.charAt(len - 1) == '\'') {</span>
<span class="fc" id="L221">            assertRemaining(pos + len - 3, hi);</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if (!Chars.equals(delimiter, 1, len - 1, in, pos, pos + len - 2)) {</span>
<span class="nc" id="L223">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L225">            return pos + len - 2;</span>
        } else {
<span class="fc" id="L227">            assertRemaining(pos + len - 1, hi);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (!Chars.equals(delimiter, in, pos, pos + len)) {</span>
<span class="fc" id="L229">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L231">            return pos + len;</span>
        }
    }

    public static long compute(
            DateLocale locale,
            int era,
            int year,
            int month,
            int week,
            int day,
            int hour,
            int minute,
            int second,
            int millis,
            int micros,
            int timezone,
            long offset,
            int hourType
    ) throws NumericException {

<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (era == 0) {</span>
<span class="fc" id="L253">            year = -(year - 1);</span>
        }

<span class="fc" id="L256">        boolean leap = Timestamps.isLeapYear(year);</span>

        // wrong month
<span class="fc bfc" id="L259" title="All 4 branches covered.">        if (month &lt; 1 || month &gt; 12) {</span>
<span class="fc" id="L260">            throw NumericException.INSTANCE;</span>
        }

<span class="fc bfc" id="L263" title="All 3 branches covered.">        switch (hourType) {</span>
            case HOUR_PM:
<span class="fc" id="L265">                hour += 12;</span>
            case HOUR_24:
                // wrong hour
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">                if (hour &lt; 0 || hour &gt; 23) {</span>
<span class="fc" id="L269">                    throw NumericException.INSTANCE;</span>
                }
                break;
            default:
                // wrong 12-hour clock hour
<span class="pc bpc" id="L274" title="1 of 4 branches missed.">                if (hour &lt; 0 || hour &gt; 11) {</span>
<span class="fc" id="L275">                    throw NumericException.INSTANCE;</span>
                }
        }

        // wrong day of month
<span class="pc bpc" id="L280" title="1 of 4 branches missed.">        if (day &lt; 1 || day &gt; Timestamps.getDaysPerMonth(month, leap)) {</span>
<span class="fc" id="L281">            throw NumericException.INSTANCE;</span>
        }

<span class="pc bpc" id="L284" title="1 of 4 branches missed.">        if (minute &lt; 0 || minute &gt; 59) {</span>
<span class="fc" id="L285">            throw NumericException.INSTANCE;</span>
        }

<span class="pc bpc" id="L288" title="1 of 4 branches missed.">        if (second &lt; 0 || second &gt; 59) {</span>
<span class="fc" id="L289">            throw NumericException.INSTANCE;</span>
        }

<span class="fc bfc" id="L292" title="All 6 branches covered.">        if ((week &lt;= 0 &amp;&amp; week != -1) || week &gt; Timestamps.getWeeks(year)) {</span>
<span class="fc" id="L293">            throw NumericException.INSTANCE;</span>
        }

        // calculate year, month, and day of ISO week
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (week != -1) {</span>
<span class="fc" id="L298">            long firstDayOfIsoWeekMicros = Timestamps.yearMicros(year, Timestamps.isLeapYear(year)) +</span>
                    (week - 1) * Timestamps.WEEK_MICROS +
<span class="fc" id="L300">                    Timestamps.getIsoYearDayOffset(year) * Timestamps.DAY_MICROS;</span>
<span class="fc" id="L301">            month = Timestamps.getMonthOfYear(firstDayOfIsoWeekMicros);</span>
<span class="fc bfc" id="L302" title="All 4 branches covered.">            year += (week == 1 &amp;&amp; Timestamps.getIsoYearDayOffset(year) &lt; 0) ? -1 : 0;</span>
<span class="fc" id="L303">            day = Timestamps.getDayOfMonth(firstDayOfIsoWeekMicros, year, month, Timestamps.isLeapYear(year));</span>
        }

<span class="fc" id="L306">        long datetime = Timestamps.yearMicros(year, leap)</span>
<span class="fc" id="L307">                + Timestamps.monthOfYearMicros(month, leap)</span>
                + (day - 1) * Timestamps.DAY_MICROS
                + hour * Timestamps.HOUR_MICROS
                + minute * Timestamps.MINUTE_MICROS
                + second * Timestamps.SECOND_MICROS
                + (long) millis * Timestamps.MILLI_MICROS
                + micros;

<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (timezone &gt; -1) {</span>
<span class="fc" id="L316">            datetime -= locale.getZoneRules(timezone, RESOLUTION_MICROS).getOffset(datetime, year, leap);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        } else if (offset &gt; Long.MIN_VALUE) {</span>
<span class="fc" id="L318">            datetime -= offset;</span>
        }

<span class="fc" id="L321">        return datetime;</span>
    }

    // YYYY-MM-DD
    public static void formatDashYYYYMMDD(CharSink sink, long millis) {
<span class="fc" id="L326">        int y = Timestamps.getYear(millis);</span>
<span class="fc" id="L327">        boolean l = Timestamps.isLeapYear(y);</span>
<span class="fc" id="L328">        int m = Timestamps.getMonthOfYear(millis, y, l);</span>
<span class="fc" id="L329">        Numbers.append(sink, y);</span>
<span class="fc" id="L330">        append0(sink.put('-'), m);</span>
<span class="fc" id="L331">        append0(sink.put('-'), Timestamps.getDayOfMonth(millis, y, m, l));</span>
<span class="fc" id="L332">    }</span>

    public static void formatHTTP(CharSink sink, long millis) {
<span class="fc" id="L335">        HTTP_FORMAT.format(millis, enLocale, &quot;GMT&quot;, sink);</span>
<span class="fc" id="L336">    }</span>

    // YYYY-MM
    public static void formatYYYYMM(CharSink sink, long millis) {
<span class="fc" id="L340">        int y = Timestamps.getYear(millis);</span>
<span class="fc" id="L341">        int m = Timestamps.getMonthOfYear(millis, y, Timestamps.isLeapYear(y));</span>
<span class="fc" id="L342">        Numbers.append(sink, y);</span>
<span class="fc" id="L343">        append0(sink.put('-'), m);</span>
<span class="fc" id="L344">    }</span>

    // YYYYMMDD
    public static void formatYYYYMMDD(CharSink sink, long millis) {
<span class="fc" id="L348">        int y = Timestamps.getYear(millis);</span>
<span class="fc" id="L349">        boolean l = Timestamps.isLeapYear(y);</span>
<span class="fc" id="L350">        int m = Timestamps.getMonthOfYear(millis, y, l);</span>
<span class="fc" id="L351">        Numbers.append(sink, y);</span>
<span class="fc" id="L352">        append0(sink, m);</span>
<span class="fc" id="L353">        append0(sink, Timestamps.getDayOfMonth(millis, y, m, l));</span>
<span class="fc" id="L354">    }</span>

    public static long getReferenceYear() {
<span class="fc" id="L357">        return referenceYear;</span>
    }

    public static void init() {
<span class="fc" id="L361">    }</span>

    public static long parseDateTime(CharSequence seq) throws NumericException {
<span class="fc" id="L364">        return NANOS_UTC_FORMAT.parse(seq, 0, seq.length(), enLocale);</span>
    }

    // YYYY-MM-DDThh:mm:ss.mmmZ
    public static long parseTimestamp(CharSequence seq) throws NumericException {
<span class="fc" id="L369">        return parseTimestamp(seq, 0, seq.length());</span>
    }

    // YYYY-MM-DDThh:mm:ss.mmmnnn
    public static long parseUTCTimestamp(CharSequence seq) throws NumericException {
<span class="fc" id="L374">        return USEC_UTC_FORMAT.parse(seq, 0, seq.length(), enLocale);</span>
    }

    public static long parseYearGreedy(CharSequence in, int pos, int hi) throws NumericException {
<span class="fc" id="L378">        long l = Numbers.parseIntSafely(in, pos, hi);</span>
<span class="fc" id="L379">        int len = Numbers.decodeHighInt(l);</span>
        int year;
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (len == 2) {</span>
<span class="fc" id="L382">            year = adjustYear(Numbers.decodeLowInt(l));</span>
        } else {
<span class="fc" id="L384">            year = Numbers.decodeLowInt(l);</span>
        }

<span class="fc" id="L387">        return Numbers.encodeLowHighInts(year, len);</span>
    }

    public static long tryParse(CharSequence s, int lo, int lim) throws NumericException {
<span class="fc" id="L391">        return parseTimestamp(s, lo, lim);</span>
    }

    public static void updateReferenceYear(long micros) {
<span class="fc" id="L395">        referenceYear = micros;</span>

<span class="fc" id="L397">        int referenceYear = Timestamps.getYear(micros);</span>
<span class="fc" id="L398">        int centuryOffset = referenceYear % 100;</span>
<span class="fc" id="L399">        thisCenturyLimit = centuryOffset + 20;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (thisCenturyLimit &gt; 100) {</span>
<span class="fc" id="L401">            thisCenturyLimit = thisCenturyLimit % 100;</span>
<span class="fc" id="L402">            thisCenturyLow = referenceYear - centuryOffset + 100;</span>
        } else {
<span class="fc" id="L404">            thisCenturyLow = referenceYear - centuryOffset;</span>
        }
<span class="fc" id="L406">        prevCenturyLow = thisCenturyLow - 100;</span>
<span class="fc" id="L407">        newYear = Timestamps.endOfYear(referenceYear);</span>
<span class="fc" id="L408">    }</span>

    private static long parseTimestamp(CharSequence value, int lo, int hi) throws NumericException {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        for (int i = 0, n = FORMATS.length; i &lt; n; i++) {</span>
            try {
<span class="fc" id="L413">                return FORMATS[i].parse(value, lo, hi, enLocale);</span>
<span class="fc" id="L414">            } catch (NumericException ignore) {</span>
            }
        }
<span class="fc" id="L417">        throw NumericException.INSTANCE;</span>
    }

    static {
<span class="fc" id="L421">        updateReferenceYear(Os.currentTimeMicros());</span>
<span class="fc" id="L422">        TimestampFormatCompiler compiler = new TimestampFormatCompiler();</span>
<span class="fc" id="L423">        HTTP_FORMAT = compiler.compile(&quot;E, d MMM yyyy HH:mm:ss Z&quot;);</span>
<span class="fc" id="L424">        PG_TIMESTAMP_FORMAT = compiler.compile(&quot;y-MM-dd HH:mm:ss.SSSUUU&quot;);</span>
<span class="fc" id="L425">        PG_TIMESTAMP_TIME_Z_FORMAT = compiler.compile(&quot;y-MM-dd HH:mm:ssz&quot;);</span>
<span class="fc" id="L426">        NANOS_UTC_FORMAT = compiler.compile(&quot;yyyy-MM-ddTHH:mm:ss.SSSUUUNNNz&quot;);</span>

<span class="fc" id="L428">        String[] patterns = new String[]{</span>
                PG_TIMESTAMP_MILLI_TIME_Z_PATTERN,
                GREEDY_MILLIS1_UTC_PATTERN,
                USEC_UTC_PATTERN,
                SEC_UTC_PATTERN,
                GREEDY_MILLIS2_UTC_PATTERN,
                UTC_PATTERN
        };
<span class="fc" id="L436">        FORMATS = new DateFormat[patterns.length];</span>
<span class="fc" id="L437">        CharSequenceObjHashMap&lt;DateFormat&gt; dateFormats = new CharSequenceObjHashMap&lt;&gt;();</span>
<span class="fc" id="L438">        int patternMinLength = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">        for (int i = 0; i &lt; patterns.length; i++) {</span>
<span class="fc" id="L440">            String pattern = patterns[i];</span>
<span class="fc" id="L441">            DateFormat format = compiler.compile(pattern);</span>
<span class="fc" id="L442">            dateFormats.put(pattern, format);</span>
<span class="fc" id="L443">            FORMATS[i] = format;</span>
<span class="fc" id="L444">            patternMinLength = Math.min(patternMinLength, pattern.length());</span>
        }
<span class="fc" id="L446">        TIMESTAMP_FORMAT_MIN_LENGTH = patternMinLength;</span>
<span class="fc" id="L447">        PG_TIMESTAMP_MILLI_TIME_Z_FORMAT = dateFormats.get(PG_TIMESTAMP_MILLI_TIME_Z_PATTERN);</span>
<span class="fc" id="L448">        GREEDY_MILLIS1_UTC_FORMAT = dateFormats.get(GREEDY_MILLIS1_UTC_PATTERN);</span>
<span class="fc" id="L449">        USEC_UTC_FORMAT = dateFormats.get(USEC_UTC_PATTERN);</span>
<span class="fc" id="L450">        SEC_UTC_FORMAT = dateFormats.get(SEC_UTC_PATTERN);</span>
<span class="fc" id="L451">        GREEDY_MILLIS2_UTC_FORMAT = dateFormats.get(GREEDY_MILLIS2_UTC_PATTERN);</span>
<span class="fc" id="L452">        UTC_FORMAT = dateFormats.get(UTC_PATTERN);</span>
<span class="fc" id="L453">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>