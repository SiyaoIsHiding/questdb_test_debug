<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IODispatcherLinux.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.network</a> &gt; <span class="el_source">IODispatcherLinux.java</span></div><h1>IODispatcherLinux.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.network;

import io.questdb.std.LongMatrix;

<span class="nc" id="L29">public class IODispatcherLinux&lt;C extends IOContext&gt; extends AbstractIODispatcher&lt;C&gt; {</span>
    private static final int EVM_DEADLINE = 1;
    private static final int EVM_ID = 0;
    private static final int EVM_OPERATION_ID = 2;
    private static final int OPM_ID = 3;
<span class="nc" id="L34">    protected final LongMatrix pendingEvents = new LongMatrix(3);</span>
    private final Epoll epoll;
    // the final ids are shifted by 1 bit which is reserved to distinguish socket operations (0) and suspend events (1);
    // id 0 is reserved for operations on the server fd
<span class="nc" id="L38">    private long idSeq = 1;</span>

    public IODispatcherLinux(
            IODispatcherConfiguration configuration,
            IOContextFactory&lt;C&gt; ioContextFactory
    ) {
<span class="nc" id="L44">        super(configuration, ioContextFactory);</span>
<span class="nc" id="L45">        this.epoll = new Epoll(configuration.getEpollFacade(), configuration.getEventCapacity());</span>
<span class="nc" id="L46">        registerListenerFd();</span>
<span class="nc" id="L47">    }</span>

    @Override
    public void close() {
<span class="nc" id="L51">        super.close();</span>
<span class="nc" id="L52">        this.epoll.close();</span>
<span class="nc" id="L53">        LOG.info().$(&quot;closed&quot;).$();</span>
<span class="nc" id="L54">    }</span>

    private static boolean isEventId(long id) {
<span class="nc bnc" id="L57" title="All 2 branches missed.">        return (id &amp; 1) == 1;</span>
    }

    private void doDisconnect(C context, long id, int reason) {
<span class="nc" id="L61">        final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (suspendEvent != null) {</span>
            // yes, we can do a binary search over EVM_OPERATION_ID since
            // these ref ids are monotonically growing
<span class="nc" id="L65">            int eventRow = pendingEvents.binarySearch(id, EVM_OPERATION_ID);</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">            if (eventRow &lt; 0) {</span>
<span class="nc" id="L67">                LOG.critical().$(&quot;internal error: suspend event not found [id=&quot;).$(id).I$();</span>
            } else {
<span class="nc" id="L69">                final long eventId = pendingEvents.get(eventRow, EVM_ID);</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">                if (epoll.control(suspendEvent.getFd(), eventId, EpollAccessor.EPOLL_CTL_DEL, 0) &lt; 0) {</span>
<span class="nc" id="L71">                    LOG.critical().$(&quot;internal error: epoll_ctl remove suspend event failure [eventId=&quot;).$(eventId)</span>
<span class="nc" id="L72">                            .$(&quot;, err=&quot;).$(nf.errno()).I$();</span>
                }
<span class="nc" id="L74">                pendingEvents.deleteRow(eventRow);</span>
            }
        }
<span class="nc" id="L77">        doDisconnect(context, reason);</span>
<span class="nc" id="L78">    }</span>

    private void enqueuePending(int watermark) {
<span class="nc bnc" id="L81" title="All 2 branches missed.">        for (int i = watermark, sz = pending.size(), offset = 0; i &lt; sz; i++, offset += EpollAccessor.SIZEOF_EVENT) {</span>
<span class="nc" id="L82">            final long id = pending.get(i, OPM_ID);</span>
<span class="nc" id="L83">            if (</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">                    epoll.control(</span>
<span class="nc" id="L85">                            (int) pending.get(i, OPM_FD),</span>
                            id,
                            EpollAccessor.EPOLL_CTL_ADD,
<span class="nc bnc" id="L88" title="All 2 branches missed.">                            initialBias == IODispatcherConfiguration.BIAS_READ ? EpollAccessor.EPOLLIN : EpollAccessor.EPOLLOUT</span>
                    ) &lt; 0
            ) {
<span class="nc" id="L91">                LOG.critical().$(&quot;internal error: epoll_ctl failure [id=&quot;).$(id)</span>
<span class="nc" id="L92">                        .$(&quot;, err=&quot;).$(nf.errno()).I$();</span>
            }
        }
<span class="nc" id="L95">    }</span>

    private boolean handleSocketOperation(long id) {
        // find row in pending for two reasons:
        // 1. find payload
        // 2. remove row from pending, remaining rows will be timed out
<span class="nc" id="L101">        final int row = pending.binarySearch(id, OPM_ID);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (row &lt; 0) {</span>
<span class="nc" id="L103">            LOG.critical().$(&quot;internal error: epoll returned unexpected id [id=&quot;).$(id).I$();</span>
<span class="nc" id="L104">            return false;</span>
        }

<span class="nc" id="L107">        final C context = pending.get(row);</span>
<span class="nc" id="L108">        final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (suspendEvent != null) {</span>
            // the operation is suspended, check if we have a client disconnect
<span class="nc bnc" id="L111" title="All 2 branches missed.">            if (testConnection(context.getFd())) {</span>
<span class="nc" id="L112">                doDisconnect(context, id, DISCONNECT_SRC_PEER_DISCONNECT);</span>
<span class="nc" id="L113">                pending.deleteRow(row);</span>
<span class="nc" id="L114">                return true;</span>
            }
        } else {
<span class="nc" id="L117">            publishOperation(</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                    (epoll.getEvent() &amp; EpollAccessor.EPOLLIN) &gt; 0 ? IOOperation.READ : IOOperation.WRITE,</span>
                    context
            );
<span class="nc" id="L121">            pending.deleteRow(row);</span>
<span class="nc" id="L122">            return true;</span>
        }
<span class="nc" id="L124">        return false;</span>
    }

    private void handleSuspendEvent(long id) {
<span class="nc" id="L128">        final int eventsRow = pendingEvents.binarySearch(id, EVM_ID);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (eventsRow &lt; 0) {</span>
<span class="nc" id="L130">            LOG.critical().$(&quot;internal error: epoll returned unexpected event id [eventId=&quot;).$(id).I$();</span>
<span class="nc" id="L131">            return;</span>
        }

<span class="nc" id="L134">        final long opId = pendingEvents.get(eventsRow, EVM_OPERATION_ID);</span>
<span class="nc" id="L135">        final int row = pending.binarySearch(opId, OPM_ID);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (row &lt; 0) {</span>
<span class="nc" id="L137">            LOG.critical().$(&quot;internal error: suspended operation not found [id=&quot;).$(opId).$(&quot;, eventId=&quot;).$(id).I$();</span>
<span class="nc" id="L138">            return;</span>
        }

<span class="nc" id="L141">        final int operation = (int) pending.get(row, OPM_OPERATION);</span>
<span class="nc" id="L142">        final C context = pending.get(row);</span>
<span class="nc" id="L143">        final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        assert suspendEvent != null;</span>

<span class="nc" id="L146">        resumeOperation(context, opId, operation);</span>
<span class="nc" id="L147">        pendingEvents.deleteRow(eventsRow);</span>
<span class="nc" id="L148">    }</span>

    private long nextEventId() {
<span class="nc" id="L151">        return (idSeq++ &lt;&lt; 1) + 1;</span>
    }

    private long nextOpId() {
<span class="nc" id="L155">        return idSeq++ &lt;&lt; 1;</span>
    }

    private void processIdleConnections(long idleTimestamp) {
<span class="nc" id="L159">        int count = 0;</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">        for (int i = 0, n = pending.size(); i &lt; n &amp;&amp; pending.get(i, OPM_TIMESTAMP) &lt; idleTimestamp; i++, count++) {</span>
<span class="nc" id="L161">            doDisconnect(pending.get(i), pending.get(i, OPM_ID), DISCONNECT_SRC_IDLE);</span>
        }
<span class="nc" id="L163">        pending.zapTop(count);</span>
<span class="nc" id="L164">    }</span>

    private boolean processRegistrations(long timestamp) {
<span class="nc" id="L167">        boolean useful = false;</span>
        long cursor;
<span class="nc bnc" id="L169" title="All 2 branches missed.">        while ((cursor = interestSubSeq.next()) &gt; -1) {</span>
<span class="nc" id="L170">            IOEvent&lt;C&gt; event = interestQueue.get(cursor);</span>
<span class="nc" id="L171">            C context = event.context;</span>
<span class="nc" id="L172">            int requestedOperation = event.operation;</span>
<span class="nc" id="L173">            interestSubSeq.done(cursor);</span>

<span class="nc" id="L175">            useful = true;</span>
<span class="nc" id="L176">            final long opId = nextOpId();</span>
<span class="nc" id="L177">            final int fd = context.getFd();</span>
<span class="nc" id="L178">            int operation = requestedOperation;</span>
<span class="nc" id="L179">            LOG.debug().$(&quot;processing registration [fd=&quot;).$(fd)</span>
<span class="nc" id="L180">                    .$(&quot;, op=&quot;).$(operation)</span>
<span class="nc" id="L181">                    .$(&quot;, id=&quot;).$(opId).I$();</span>

<span class="nc" id="L183">            final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (suspendEvent != null) {</span>
                // if the operation was suspended, we request a read to be able to detect a client disconnect 
<span class="nc" id="L186">                operation = IOOperation.READ;</span>
            }

<span class="nc" id="L189">            int opRow = pending.addRow();</span>
<span class="nc" id="L190">            pending.set(opRow, OPM_TIMESTAMP, timestamp);</span>
<span class="nc" id="L191">            pending.set(opRow, OPM_FD, fd);</span>
<span class="nc" id="L192">            pending.set(opRow, OPM_ID, opId);</span>
<span class="nc" id="L193">            pending.set(opRow, OPM_OPERATION, requestedOperation);</span>
<span class="nc" id="L194">            pending.set(opRow, context);</span>

            // we re-arm epoll globally, in that even when we disconnect
            // because we have to remove FD from epoll
<span class="nc bnc" id="L198" title="All 2 branches missed.">            final int epollOp = operation == IOOperation.READ ? EpollAccessor.EPOLLIN : EpollAccessor.EPOLLOUT;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (epoll.control(fd, opId, EpollAccessor.EPOLL_CTL_MOD, epollOp) &lt; 0) {</span>
<span class="nc" id="L200">                LOG.critical().$(&quot;internal error: epoll_ctl modify operation failure [id=&quot;).$(opId)</span>
<span class="nc" id="L201">                        .$(&quot;, err=&quot;).$(nf.errno()).I$();</span>
            }

<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (suspendEvent != null) {</span>
                // ok, the operation was suspended, so we need to track the suspend event
<span class="nc" id="L206">                final long eventId = nextEventId();</span>
<span class="nc" id="L207">                LOG.debug().$(&quot;registering suspend event [fd=&quot;).$(fd)</span>
<span class="nc" id="L208">                        .$(&quot;, op=&quot;).$(operation)</span>
<span class="nc" id="L209">                        .$(&quot;, eventId=&quot;).$(eventId)</span>
<span class="nc" id="L210">                        .$(&quot;, suspendedOpId=&quot;).$(opId)</span>
<span class="nc" id="L211">                        .$(&quot;, deadline=&quot;).$(suspendEvent.getDeadline()).I$();</span>

<span class="nc" id="L213">                int eventRow = pendingEvents.addRow();</span>
<span class="nc" id="L214">                pendingEvents.set(eventRow, EVM_ID, eventId);</span>
<span class="nc" id="L215">                pendingEvents.set(eventRow, EVM_OPERATION_ID, opId);</span>
<span class="nc" id="L216">                pendingEvents.set(eventRow, EVM_DEADLINE, suspendEvent.getDeadline());</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">                if (epoll.control(suspendEvent.getFd(), eventId, EpollAccessor.EPOLL_CTL_ADD, EpollAccessor.EPOLLIN) &lt; 0) {</span>
<span class="nc" id="L219">                    LOG.critical().$(&quot;internal error: epoll_ctl add suspend event failure [id=&quot;).$(eventId)</span>
<span class="nc" id="L220">                            .$(&quot;, err=&quot;).$(nf.errno()).I$();</span>
                }
            }
<span class="nc" id="L223">        }</span>
<span class="nc" id="L224">        return useful;</span>
    }

    private void processSuspendEventDeadlines(long timestamp) {
<span class="nc" id="L228">        int count = 0;</span>
<span class="nc bnc" id="L229" title="All 4 branches missed.">        for (int i = 0, n = pendingEvents.size(); i &lt; n &amp;&amp; pendingEvents.get(i, EVM_DEADLINE) &lt; timestamp; i++, count++) {</span>
<span class="nc" id="L230">            final long eventId = pendingEvents.get(i, EVM_ID);</span>
<span class="nc" id="L231">            final long opId = pendingEvents.get(i, EVM_OPERATION_ID);</span>
<span class="nc" id="L232">            final int pendingRow = pending.binarySearch(opId, OPM_ID);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (pendingRow &lt; 0) {</span>
<span class="nc" id="L234">                LOG.critical().$(&quot;internal error: failed to find operation for expired suspend event [id=&quot;).$(opId).I$();</span>
<span class="nc" id="L235">                continue;</span>
            }
            // First, remove the suspend event from the epoll interest list.
<span class="nc" id="L238">            final C context = pending.get(pendingRow);</span>
<span class="nc" id="L239">            final int operation = (int) pending.get(pendingRow, OPM_OPERATION);</span>
<span class="nc" id="L240">            final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            assert suspendEvent != null;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (epoll.control(suspendEvent.getFd(), eventId, EpollAccessor.EPOLL_CTL_DEL, 0) &lt; 0) {</span>
<span class="nc" id="L243">                LOG.critical().$(&quot;internal error: epoll_ctl remove suspend event failure [eventId=&quot;).$(eventId)</span>
<span class="nc" id="L244">                        .$(&quot;, err=&quot;).$(nf.errno()).I$();</span>
            }
            // Next, resume the original operation and close the event.
<span class="nc" id="L247">            resumeOperation(context, opId, operation);</span>
        }
<span class="nc" id="L249">        pendingEvents.zapTop(count);</span>
<span class="nc" id="L250">    }</span>

    private void resumeOperation(C context, long id, int operation) {
        // to resume a socket operation, we simply re-arm epoll
<span class="nc" id="L254">        if (</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                epoll.control(</span>
<span class="nc" id="L256">                        context.getFd(),</span>
                        id,
                        EpollAccessor.EPOLL_CTL_MOD,
<span class="nc bnc" id="L259" title="All 2 branches missed.">                        operation == IOOperation.READ ? EpollAccessor.EPOLLIN : EpollAccessor.EPOLLOUT</span>
                ) &lt; 0
        ) {
<span class="nc" id="L262">            LOG.critical().$(&quot;internal error: epoll_ctl operation mod failure [id=&quot;).$(id)</span>
<span class="nc" id="L263">                    .$(&quot;, err=&quot;).$(nf.errno()).I$();</span>
        }
<span class="nc" id="L265">        context.clearSuspendEvent();</span>
<span class="nc" id="L266">    }</span>

    @Override
    protected void pendingAdded(int index) {
<span class="nc" id="L270">        pending.set(index, OPM_ID, nextOpId());</span>
<span class="nc" id="L271">    }</span>

    @Override
    protected void registerListenerFd() {
<span class="nc" id="L275">        this.epoll.listen(serverFd);</span>
<span class="nc" id="L276">    }</span>

    @Override
    protected boolean runSerially() {
        // todo: introduce fairness factor
        //  current worker impl will still proceed to execute another job even if this one was useful
        //  we should see if we can stay inside of this method until we have a completely idle iteration
        //  at the same time we should hog this thread in case we are always 'useful', we can probably
        //  introduce a loop count after which we always exit
<span class="nc" id="L285">        boolean useful = false;</span>

<span class="nc" id="L287">        final long timestamp = clock.getTicks();</span>
<span class="nc" id="L288">        processDisconnects(timestamp);</span>
<span class="nc" id="L289">        final int n = epoll.poll();</span>
<span class="nc" id="L290">        int watermark = pending.size();</span>
<span class="nc" id="L291">        int offset = 0;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (n &gt; 0) {</span>
            // check all activated FDs
<span class="nc" id="L294">            LOG.debug().$(&quot;epoll [n=&quot;).$(n).$(']').$();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L296">                epoll.setOffset(offset);</span>
<span class="nc" id="L297">                offset += EpollAccessor.SIZEOF_EVENT;</span>
<span class="nc" id="L298">                final long id = epoll.getData();</span>
                // this is server socket, accept if there aren't too many already
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (id == 0) {</span>
<span class="nc" id="L301">                    accept(timestamp);</span>
<span class="nc" id="L302">                    useful = true;</span>
<span class="nc" id="L303">                    continue;</span>
                }
<span class="nc bnc" id="L305" title="All 2 branches missed.">                if (isEventId(id)) {</span>
<span class="nc" id="L306">                    handleSuspendEvent(id);</span>
<span class="nc" id="L307">                    continue;</span>
                }
<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (handleSocketOperation(id)) {</span>
<span class="nc" id="L310">                    useful = true;</span>
<span class="nc" id="L311">                    watermark--;</span>
                }
            }
        }

        // process rows over watermark (new connections)
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (watermark &lt; pending.size()) {</span>
<span class="nc" id="L318">            enqueuePending(watermark);</span>
        }

        // process timed out suspend events and resume the original operations
<span class="nc bnc" id="L322" title="All 4 branches missed.">        if (pendingEvents.size() &gt; 0 &amp;&amp; pendingEvents.get(0, EVM_DEADLINE) &lt; timestamp) {</span>
<span class="nc" id="L323">            processSuspendEventDeadlines(timestamp);</span>
        }

        // process timed out connections
<span class="nc" id="L327">        final long idleTimestamp = timestamp - idleConnectionTimeout;</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">        if (pending.size() &gt; 0 &amp;&amp; pending.get(0, OPM_TIMESTAMP) &lt; idleTimestamp) {</span>
<span class="nc" id="L329">            processIdleConnections(idleTimestamp);</span>
<span class="nc" id="L330">            useful = true;</span>
        }

<span class="nc bnc" id="L333" title="All 4 branches missed.">        return processRegistrations(timestamp) || useful;</span>
    }

    @Override
    protected void unregisterListenerFd() {
<span class="nc" id="L338">        this.epoll.removeListen(serverFd);</span>
<span class="nc" id="L339">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>