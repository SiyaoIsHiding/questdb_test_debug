<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FastFloatMath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.std.fastdouble</a> &gt; <span class="el_source">FastFloatMath.java</span></div><h1>FastFloatMath.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.std.fastdouble;

import static io.questdb.std.fastdouble.FastDoubleMath.*;

/**
 * This class complements {@link FastDoubleMath} with methods for
 * converting {@code FloatingPointLiteral} productions to floats.
 * &lt;p&gt;
 * See {@link io.questdb.std.fastdouble} for a description of
 * {@code FloatingPointLiteral}.
 */
class FastFloatMath {
    /**
     * Bias used in the exponent of a float.
     */
    private static final int FLOAT_EXPONENT_BIAS = 127;
    private final static int FLOAT_MAX_EXPONENT_POWER_OF_TEN = 38;
    private final static int FLOAT_MAX_EXPONENT_POWER_OF_TWO = Float.MAX_EXPONENT;
    private final static int FLOAT_MIN_EXPONENT_POWER_OF_TEN = -45;
    private final static int FLOAT_MIN_EXPONENT_POWER_OF_TWO = Float.MIN_EXPONENT;
    /**
     * Precomputed powers of ten from 10^0 to 10^10. These
     * can be represented exactly using the float type.
     */
<span class="fc" id="L49">    private static final float[] FLOAT_POWER_OF_TEN = {</span>
            1e0f, 1e1f, 1e2f, 1e3f, 1e4f, 1e5f, 1e6f, 1e7f, 1e8f, 1e9f, 1e10f};
    /**
     * The number of bits in the significand, including the implicit bit.
     */
    private static final int FLOAT_SIGNIFICAND_WIDTH = 24;

    /**
     * Don't let anyone instantiate this class.
     */
    private FastFloatMath() {

    }

    static float decFloatLiteralToFloat(boolean isNegative, long significand, int exponent,
                                        boolean isSignificandTruncated,
                                        int exponentOfTruncatedSignificand) {
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (significand == 0) {</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">            return isNegative ? -0.0f : 0.0f;</span>
        }

        final float result;
<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (isSignificandTruncated) {</span>

            // We have too many digits. We may have to round up.
            // To know whether rounding up is needed, we may have to examine up to 768 digits.

            // There are cases, in which rounding has no effect.
<span class="fc bfc" id="L77" title="All 4 branches covered.">            if (FLOAT_MIN_EXPONENT_POWER_OF_TEN &lt;= exponentOfTruncatedSignificand</span>
                    &amp;&amp; exponentOfTruncatedSignificand &lt;= FLOAT_MAX_EXPONENT_POWER_OF_TEN) {
<span class="fc" id="L79">                float withoutRounding = tryDecToFloatWithFastAlgorithm(isNegative, significand, exponentOfTruncatedSignificand);</span>
<span class="fc" id="L80">                float roundedUp = tryDecToFloatWithFastAlgorithm(isNegative, significand + 1, exponentOfTruncatedSignificand);</span>
<span class="pc bpc" id="L81" title="1 of 4 branches missed.">                if (!Float.isNaN(withoutRounding) &amp;&amp; roundedUp == withoutRounding) {</span>
<span class="fc" id="L82">                    return withoutRounding;</span>
                }
            }

            // We have to take a slow path.
            //return Double.parseDouble(str.toString());
<span class="fc" id="L88">            result = Float.NaN;</span>


<span class="fc bfc" id="L91" title="All 4 branches covered.">        } else if (FLOAT_MIN_EXPONENT_POWER_OF_TEN &lt;= exponent &amp;&amp; exponent &lt;= FLOAT_MAX_EXPONENT_POWER_OF_TEN) {</span>
<span class="fc" id="L92">            result = tryDecToFloatWithFastAlgorithm(isNegative, significand, exponent);</span>
        } else {
<span class="fc" id="L94">            result = Float.NaN;</span>
        }
<span class="fc" id="L96">        return result;</span>
    }

    static float hexFloatLiteralToFloat(boolean isNegative, long significand, int exponent,
                                        boolean isSignificandTruncated,
                                        int exponentOfTruncatedSignificand) {
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (significand == 0) {</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">            return isNegative ? -0.0f : 0.0f;</span>
        }
        final float result;
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (isSignificandTruncated) {</span>

            // We have too many digits. We may have to round up.
            // To know whether rounding up is needed, we may have to examine up to 768 digits.

            // There are cases, in which rounding has no effect.
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">            if (FLOAT_MIN_EXPONENT_POWER_OF_TWO &lt;= exponentOfTruncatedSignificand &amp;&amp; exponentOfTruncatedSignificand &lt;= FLOAT_MAX_EXPONENT_POWER_OF_TWO) {</span>
<span class="fc" id="L113">                float withoutRounding = tryHexToFloatWithFastAlgorithm(isNegative, significand, exponentOfTruncatedSignificand);</span>
<span class="fc" id="L114">                float roundedUp = tryHexToFloatWithFastAlgorithm(isNegative, significand + 1, exponentOfTruncatedSignificand);</span>
<span class="pc bpc" id="L115" title="3 of 4 branches missed.">                if (!Double.isNaN(withoutRounding) &amp;&amp; roundedUp == withoutRounding) {</span>
<span class="nc" id="L116">                    return withoutRounding;</span>
                }
            }

            // We have to take a slow path.
<span class="fc" id="L121">            result = Float.NaN;</span>

<span class="fc bfc" id="L123" title="All 4 branches covered.">        } else if (FLOAT_MIN_EXPONENT_POWER_OF_TWO &lt;= exponent &amp;&amp; exponent &lt;= FLOAT_MAX_EXPONENT_POWER_OF_TWO) {</span>
<span class="fc" id="L124">            result = tryHexToFloatWithFastAlgorithm(isNegative, significand, exponent);</span>
        } else {
<span class="fc" id="L126">            result = Float.NaN;</span>
        }
<span class="fc" id="L128">        return result;</span>
    }

    /**
     * Attempts to compute {@literal digits * 10^(power)} exactly;
     * and if &quot;negative&quot; is true, negate the result.
     * &lt;p&gt;
     * This function will only work in some cases, when it does not work it
     * returns null. This should work *most of the time* (like 99% of the time).
     * We assume that power is in the
     * [{@value FastDoubleMath#DOUBLE_MIN_EXPONENT_POWER_OF_TEN},
     * {@value FastDoubleMath#DOUBLE_MAX_EXPONENT_POWER_OF_TEN}]
     * interval: the caller is responsible for this check.
     *
     * @param isNegative whether the number is negative
     * @param digits     uint64 the digits of the number
     * @param power      int32 the exponent of the number
     * @return the computed double on success, {@link Double#NaN} on failure
     */
    static float tryDecToFloatWithFastAlgorithm(boolean isNegative, long digits, int power) {

        // we start with a fast path
<span class="fc bfc" id="L150" title="All 6 branches covered.">        if (-10 &lt;= power &amp;&amp; power &lt;= 10 &amp;&amp; Long.compareUnsigned(digits, (1L &lt;&lt; FLOAT_SIGNIFICAND_WIDTH) - 1L) &lt;= 0) {</span>
            // convert the integer into a float. This is lossless since
            // 0 &lt;= i &lt;= 2^24 - 1.
<span class="fc" id="L153">            float d = (float) digits;</span>
            //
            // The general idea is as follows.
            // If 0 &lt;= s &lt; 2^24 and if 10^0 &lt;= p &lt;= 10^10 then
            // 1) Both s and p can be represented exactly as 32-bit floating-point values
            // 2) Because s and p can be represented exactly as floating-point values,
            // then s * p and s / p will produce correctly rounded values.
            //
<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (power &lt; 0) {</span>
<span class="fc" id="L162">                d = d / FLOAT_POWER_OF_TEN[-power];</span>
            } else {
<span class="fc" id="L164">                d = d * FLOAT_POWER_OF_TEN[power];</span>
            }
<span class="fc bfc" id="L166" title="All 2 branches covered.">            return (isNegative) ? -d : d;</span>
        }


        // The fast path has now failed, so we are falling back on the slower path.

        // We are going to need to do some 64-bit arithmetic to get a more precise product.
        // We use a table lookup approach.
        // It is safe because
        // power &gt;= DOUBLE_MIN_EXPONENT_POWER_OF_TEN
        // and power &lt;= DOUBLE_MAX_EXPONENT_POWER_OF_TEN
        // We recover the mantissa of the power, it has a leading 1. It is always
        // rounded down.
<span class="fc" id="L179">        long factorMantissa = MANTISSA_64[power - DOUBLE_MIN_EXPONENT_POWER_OF_TEN];</span>


        // The exponent is 127 + 64 + power
        //     + floor(log(5**power)/log(2)).
        // The 127 is the exponent bias.
        // The 64 comes from the fact that we use a 64-bit word.
        //
        // Computing floor(log(5**power)/log(2)) could be
        // slow. Instead ,we use a fast function.
        //
        // For power in (-400,350), we have that
        // (((152170 + 65536) * power ) &gt;&gt; 16);
        // is equal to
        //  floor(log(5**power)/log(2)) + power when power &gt;= 0
        // and it is equal to
        //  ceil(log(5**-power)/log(2)) + power when power &lt; 0
        //
        //
        // The 65536 is (1&lt;&lt;16) and corresponds to
        // (65536 * power) &gt;&gt; 16 ---&gt; power
        //
        // ((152170 * power ) &gt;&gt; 16) is equal to
        // floor(log(5**power)/log(2))
        //
        // Note that this is not magic: 152170/(1&lt;&lt;16) is
        // approximately equal to log(5)/log(2).
        // The 1&lt;&lt;16 value is a power of two; we could use a
        // larger power of 2 if we wanted to.
        //
<span class="fc" id="L209">        long exponent = (((152170L + 65536L) * power) &gt;&gt; 16) + FLOAT_EXPONENT_BIAS + 64;</span>
        // We want the most significant bit of digits to be 1. Shift if needed.
<span class="fc" id="L211">        int lz = Long.numberOfLeadingZeros(digits);</span>
<span class="fc" id="L212">        digits &lt;&lt;= lz;</span>
        // We want the most significant 64 bits of the product. We know
        // this will be non-zero because the most significant bit of i is
        // 1.
        //before Java 18
<span class="fc" id="L217">        long x01 = digits &amp; 0xffffffffL, x11 = digits &gt;&gt;&gt; 32;</span>
<span class="fc" id="L218">        long y01 = factorMantissa &amp; 0xffffffffL, y11 = factorMantissa &gt;&gt;&gt; 32;</span>
<span class="fc" id="L219">        long p111 = x11 * y11, p011 = x01 * y11;</span>
<span class="fc" id="L220">        long p101 = x11 * y01, p001 = x01 * y01;</span>

        // 64-bit product + two 32-bit values
<span class="fc" id="L223">        long middle1 = p101 + (p001 &gt;&gt;&gt; 32) + (p011 &amp; 0xffffffffL);</span>
<span class="fc" id="L224">        long lower = (middle1 &lt;&lt; 32) | (p001 &amp; 0xffffffffL);</span>
<span class="fc" id="L225">        long upper = p111 + (middle1 &gt;&gt;&gt; 32) + (p011 &gt;&gt;&gt; 32);</span>
        // We know that upper has at most one leading zero because
        // both i and factor_mantissa have a leading one. This means
        // that the result is at least as large as ((1&lt;&lt;63)*(1&lt;&lt;63))/(1&lt;&lt;64).

        // As long as the first 39 bits of &quot;upper&quot; are not &quot;1&quot;, then we
        // know that we have an exact computed value for the leading
        // 25 bits because any imprecision would play out as a +1, in
        // the worst case.
        // Having 25 bits is necessary because
        // we need 24 bits for the mantissa, but we have to have one rounding bit, and
        // we can waste a bit if the most significant bit of the product is zero.
        // We expect this next branch to be rarely taken (say 1% of the time).
        // When (upper &amp;0x3FFFFFFFFF) == 0x3FFFFFFFFF, it can be common for
        // lower + i &lt; lower to be true (proba. much higher than 1%).
<span class="pc bpc" id="L240" title="1 of 4 branches missed.">        if ((upper &amp; 0x3_FFFFF_FFFFL) == 0x3_FFFFF_FFFFL &amp;&amp; Long.compareUnsigned(lower + digits, lower) &lt; 0) {</span>
<span class="fc" id="L241">            long factor_mantissa_low =</span>
                    MANTISSA_128[power - DOUBLE_MIN_EXPONENT_POWER_OF_TEN];
            // next, we compute the 64-bit x 128-bit multiplication, getting a 192-bit
            // result (three 64-bit values)
            //before Java 18
<span class="fc" id="L246">            long x0 = digits &amp; 0xffffffffL, x1 = digits &gt;&gt;&gt; 32;</span>
<span class="fc" id="L247">            long y0 = factor_mantissa_low &amp; 0xffffffffL, y1 = factor_mantissa_low &gt;&gt;&gt; 32;</span>
<span class="fc" id="L248">            long p11 = x1 * y1, p01 = x0 * y1;</span>
<span class="fc" id="L249">            long p10 = x1 * y0, p00 = x0 * y0;</span>

            // 64-bit product + two 32-bit values
<span class="fc" id="L252">            long middle = p10 + (p00 &gt;&gt;&gt; 32) + (p01 &amp; 0xffffffffL);</span>
<span class="fc" id="L253">            long product_low = (middle &lt;&lt; 32) | (p00 &amp; 0xffffffffL);</span>
<span class="fc" id="L254">            long product_middle2 = p11 + (middle &gt;&gt;&gt; 32) + (p01 &gt;&gt;&gt; 32);</span>
<span class="fc" id="L255">            long product_high = upper;</span>
<span class="fc" id="L256">            long product_middle = lower + product_middle2;</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if (Long.compareUnsigned(product_middle, lower) &lt; 0) {</span>
<span class="nc" id="L258">                product_high++; // overflow carry</span>
            }


            // we want to check whether mantissa *i + i would affect our result
            // This does happen, e.g. with 7.3177701707893310e+15 ????
<span class="pc bpc" id="L264" title="1 of 4 branches missed.">            if (((product_middle + 1 == 0) &amp;&amp; ((product_high &amp; 0x7_FFFFF_FFFFL) == 0x7_FFFFF_FFFFL) &amp;&amp;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                    (product_low + Long.compareUnsigned(digits, product_low) &lt; 0))) { // let us be prudent and bail out.</span>
<span class="fc" id="L266">                return Float.NaN;</span>
            }
<span class="fc" id="L268">            upper = product_high;</span>
            //lower = product_middle;
        }

        // The final mantissa should be 24 bits with a leading 1.
        // We shift it so that it occupies 25 bits with a leading 1.
<span class="fc" id="L274">        long upperbit = upper &gt;&gt;&gt; 63;</span>
<span class="fc" id="L275">        long mantissa = upper &gt;&gt;&gt; (upperbit + 38);</span>
<span class="fc" id="L276">        lz += (int) (1 ^ upperbit);</span>
        // Here we have mantissa &lt; (1&lt;&lt;25).
        //assert mantissa &lt; (1&lt;&lt;25);

        // We have to round to even. The &quot;to even&quot; part
        // is only a problem when we are right in between two floating-point values
        // which we guard against.
        // If we have lots of trailing zeros, we may fall right between two
        // floating-point values.
<span class="fc bfc" id="L285" title="All 6 branches covered.">        if (((upper &amp; 0x3_FFFFF_FFFFL) == 0x3_FFFFF_FFFFL)</span>
                || ((upper &amp; 0x3_FFFFF_FFFFL) == 0) &amp;&amp; (mantissa &amp; 3) == 1) {
            // if mantissa &amp; 1 == 1 we might need to round up.
            //
            // Scenarios:
            // 1. We are not in the middle. Then we should round up.
            //
            // 2. We are right in the middle. Whether we round up depends
            // on the last significant bit: if it is &quot;one&quot; then we round
            // up (round to even) otherwise, we do not.
            //
            // So if the last significant bit is 1, we can safely round up.
            // Hence, we only need to bail out if (mantissa &amp; 3) == 1.
            // Otherwise, we may need more accuracy or analysis to determine whether
            // we are exactly between two floating-point numbers.
            // It can be triggered with 1e23. ??
            // Note: because the factor_mantissa and factor_mantissa_low are
            // almost always rounded down (except for small positive powers),
            // almost always should round up.
<span class="fc" id="L304">            return Float.NaN;</span>
        }

<span class="fc" id="L307">        mantissa += 1;</span>
<span class="fc" id="L308">        mantissa &gt;&gt;&gt;= 1;</span>

        // Here we have mantissa &lt; (1&lt;&lt;24), unless there was an overflow
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (mantissa &gt;= (1L &lt;&lt; FLOAT_SIGNIFICAND_WIDTH)) {</span>
            // This will happen when parsing values such as 7.2057594037927933e+16 ??
<span class="fc" id="L313">            mantissa = (1L &lt;&lt; (FLOAT_SIGNIFICAND_WIDTH - 1));</span>
<span class="fc" id="L314">            lz--; // undo previous addition</span>
        }

<span class="fc" id="L317">        mantissa &amp;= ~(1L &lt;&lt; (FLOAT_SIGNIFICAND_WIDTH - 1));</span>


<span class="fc" id="L320">        long real_exponent = exponent - lz;</span>
        // we have to check that real_exponent is in range, otherwise we bail out
<span class="fc bfc" id="L322" title="All 4 branches covered.">        if ((real_exponent &lt; 1) || (real_exponent &gt; FLOAT_MAX_EXPONENT_POWER_OF_TWO + FLOAT_EXPONENT_BIAS)) {</span>
<span class="fc" id="L323">            return Float.NaN;</span>
        }

<span class="fc" id="L326">        int bits = (int) (mantissa | real_exponent &lt;&lt; (FLOAT_SIGNIFICAND_WIDTH - 1)</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                | (isNegative ? 1L &lt;&lt; 31 : 0));</span>
<span class="fc" id="L328">        return Float.intBitsToFloat(bits);</span>
    }

    static float tryHexToFloatWithFastAlgorithm(boolean isNegative, long digits, int power) {
<span class="pc bpc" id="L332" title="2 of 4 branches missed.">        if (digits == 0 || power &lt; Float.MIN_EXPONENT - 54) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            return isNegative ? -0.0f : 0.0f;</span>
        }
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (power &gt; Float.MAX_EXPONENT) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            return isNegative ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;</span>
        }

        // we start with a fast path
        // We try to mimic the fast described by Clinger WD for decimal
        // float number literals. How to read floating point numbers accurately.
        // ACM SIGPLAN Notices. 1990
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (Long.compareUnsigned(digits, 0x1fffffffffffffL) &lt;= 0) {</span>
            // convert the integer into a double. This is lossless since
            // 0 &lt;= i &lt;= 2^53 - 1.
<span class="fc" id="L346">            float d = (float) digits;</span>
            //
            // The general idea is as follows.
            // If 0 &lt;= s &lt; 2^53  then
            // 1) Both s and p can be represented exactly as 64-bit floating-point
            // values (binary64).
            // 2) Because s and p can be represented exactly as floating-point values,
            // then s * p will produce correctly rounded values.
            //
<span class="fc" id="L355">            d = d * Math.scalb(1f, power);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (isNegative) {</span>
<span class="fc" id="L357">                d = -d;</span>
            }
<span class="fc" id="L359">            return d;</span>
        }

        // The fast path has failed
<span class="fc" id="L363">        return Float.NaN;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>