<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractNoRecordSampleByCursor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.engine.groupby</a> &gt; <span class="el_source">AbstractNoRecordSampleByCursor.java</span></div><h1>AbstractNoRecordSampleByCursor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.engine.groupby;

import io.questdb.cairo.map.MapValue;
import io.questdb.cairo.sql.Record;
import io.questdb.cairo.sql.*;
import io.questdb.griffin.PlanSink;
import io.questdb.griffin.SqlException;
import io.questdb.griffin.SqlExecutionContext;
import io.questdb.griffin.engine.functions.GroupByFunction;
import io.questdb.griffin.engine.functions.SymbolFunction;
import io.questdb.griffin.engine.functions.TimestampFunction;
import io.questdb.std.Misc;
import io.questdb.std.ObjList;
import org.jetbrains.annotations.Nullable;

public abstract class AbstractNoRecordSampleByCursor extends AbstractSampleByCursor {
    protected final ObjList&lt;GroupByFunction&gt; groupByFunctions;
    protected final GroupByFunctionsUpdater groupByFunctionsUpdater;
    protected final int timestampIndex;
    private final ObjList&lt;Function&gt; recordFunctions;
    protected RecordCursor baseCursor;
    protected Record baseRecord;
    protected SqlExecutionCircuitBreaker circuitBreaker;
    // this epoch is generally the same as `sampleLocalEpoch` except for cases where
    // sampler passed thru Daytime Savings Transition date
    // diverging values tell `filling` implementations not to fill this gap
    protected long nextSampleLocalEpoch;
    protected long sampleLocalEpoch;
    protected long topTzOffset;
    private boolean areTimestampsInitialized;
    private boolean isNotKeyedLoopInitialized;
    private long topLocalEpoch;
    private long topNextDst;

    public AbstractNoRecordSampleByCursor(
            ObjList&lt;Function&gt; recordFunctions,
            int timestampIndex, // index of timestamp column in base cursor
            TimestampSampler timestampSampler,
            ObjList&lt;GroupByFunction&gt; groupByFunctions,
            GroupByFunctionsUpdater groupByFunctionsUpdater,
            Function timezoneNameFunc,
            int timezoneNameFuncPos,
            Function offsetFunc,
            int offsetFuncPos
    ) {
<span class="fc" id="L70">        super(timestampSampler, timezoneNameFunc, timezoneNameFuncPos, offsetFunc, offsetFuncPos);</span>
<span class="fc" id="L71">        this.timestampIndex = timestampIndex;</span>
<span class="fc" id="L72">        this.recordFunctions = recordFunctions;</span>
<span class="fc" id="L73">        this.groupByFunctions = groupByFunctions;</span>
<span class="fc" id="L74">        this.groupByFunctionsUpdater = groupByFunctionsUpdater;</span>
<span class="fc" id="L75">    }</span>

    @Override
    public void close() {
<span class="fc" id="L79">        Misc.free(baseCursor);</span>
<span class="fc" id="L80">        Misc.clearObjList(groupByFunctions);</span>
<span class="fc" id="L81">        circuitBreaker = null;</span>
<span class="fc" id="L82">    }</span>

    @Override
    public SymbolTable getSymbolTable(int columnIndex) {
<span class="fc" id="L86">        return (SymbolTable) recordFunctions.getQuick(columnIndex);</span>
    }

    @Override
    public SymbolTable newSymbolTable(int columnIndex) {
<span class="fc" id="L91">        return ((SymbolFunction) recordFunctions.getQuick(columnIndex)).newSymbolTable();</span>
    }

    public void of(RecordCursor baseCursor, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L95">        prevDst = Long.MIN_VALUE;</span>
<span class="fc" id="L96">        parseParams(baseCursor, executionContext);</span>
<span class="fc" id="L97">        topNextDst = nextDstUtc;</span>
<span class="fc" id="L98">        this.baseCursor = baseCursor;</span>
<span class="fc" id="L99">        baseRecord = baseCursor.getRecord();</span>
<span class="fc" id="L100">        circuitBreaker = executionContext.getCircuitBreaker();</span>
<span class="fc" id="L101">        isNotKeyedLoopInitialized = false;</span>
<span class="fc" id="L102">        areTimestampsInitialized = false;</span>
<span class="fc" id="L103">    }</span>

    @Override
    public long size() {
<span class="fc" id="L107">        return -1;</span>
    }

    @Override
    public void toTop() {
<span class="fc" id="L112">        GroupByUtils.toTop(recordFunctions);</span>
<span class="fc" id="L113">        baseCursor.toTop();</span>
<span class="fc" id="L114">        localEpoch = topLocalEpoch;</span>
<span class="fc" id="L115">        sampleLocalEpoch = nextSampleLocalEpoch = topLocalEpoch;</span>
        // timezone offset is liable to change when we pass over DST edges
<span class="fc" id="L117">        tzOffset = topTzOffset;</span>
<span class="fc" id="L118">        prevDst = Long.MIN_VALUE;</span>
<span class="fc" id="L119">        nextDstUtc = topNextDst;</span>
<span class="fc" id="L120">        baseRecord = baseCursor.getRecord();</span>
<span class="fc" id="L121">        isNotKeyedLoopInitialized = false;</span>
<span class="fc" id="L122">        areTimestampsInitialized = false;</span>
<span class="fc" id="L123">    }</span>

    private void kludge(long newTzOffset) {
        // time moved forward, we need to make sure we move our sample boundary
<span class="fc" id="L127">        sampleLocalEpoch += (newTzOffset - tzOffset);</span>
<span class="fc" id="L128">        nextSampleLocalEpoch = sampleLocalEpoch;</span>
<span class="fc" id="L129">        tzOffset = newTzOffset;</span>
<span class="fc" id="L130">    }</span>

    protected long adjustDst(long timestamp, @Nullable MapValue mapValue, long nextSampleTimestamp) {
<span class="fc" id="L133">        final long utcTimestamp = timestamp - tzOffset;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (utcTimestamp &lt; nextDstUtc) {</span>
<span class="fc" id="L135">            return timestamp;</span>
        }
<span class="fc" id="L137">        final long newTzOffset = rules.getOffset(utcTimestamp);</span>
<span class="fc" id="L138">        prevDst = nextDstUtc;</span>
<span class="fc" id="L139">        nextDstUtc = rules.getNextDST(utcTimestamp);</span>
        // check if DST takes this timestamp back &quot;before&quot; the nextSampleTimestamp
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (timestamp - (tzOffset - newTzOffset) &lt; nextSampleTimestamp) {</span>
            // time moved backwards, we need to check if we should be collapsing this
            // hour into previous period or not
<span class="fc" id="L144">            updateValueWhenClockMovesBack(mapValue);</span>
<span class="fc" id="L145">            nextSampleLocalEpoch = timestampSampler.round(timestamp);</span>
<span class="fc" id="L146">            localEpoch = nextSampleLocalEpoch;</span>
<span class="fc" id="L147">            sampleLocalEpoch += (newTzOffset - tzOffset);</span>
<span class="fc" id="L148">            tzOffset = newTzOffset;</span>
<span class="fc" id="L149">            return Long.MIN_VALUE;</span>
        }
<span class="fc" id="L151">        kludge(newTzOffset);</span>

        // time moved forward, we need to make sure we move our sample boundary
<span class="fc" id="L154">        return utcTimestamp + newTzOffset;</span>
    }

    protected void adjustDstInFlight(long utcEpoch) {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (utcEpoch &lt; nextDstUtc) {</span>
<span class="fc" id="L159">            return;</span>
        }
<span class="fc" id="L161">        final long daylightSavings = rules.getOffset(utcEpoch);</span>
<span class="fc" id="L162">        prevDst = nextDstUtc;</span>
<span class="fc" id="L163">        nextDstUtc = rules.getNextDST(utcEpoch);</span>
<span class="fc" id="L164">        kludge(daylightSavings);</span>
<span class="fc" id="L165">    }</span>

    protected long getBaseRecordTimestamp() {
<span class="fc" id="L168">        return baseRecord.getTimestamp(timestampIndex) + tzOffset;</span>
    }

    protected void initTimestamps() {
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (areTimestampsInitialized) {</span>
<span class="fc" id="L173">            return;</span>
        }

<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (!baseCursor.hasNext()) {</span>
<span class="fc" id="L177">            baseRecord = null;</span>
<span class="fc" id="L178">            return;</span>
        }

<span class="fc" id="L181">        final long timestamp = baseRecord.getTimestamp(timestampIndex);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (rules != null) {</span>
<span class="fc" id="L183">            tzOffset = rules.getOffset(timestamp);</span>
<span class="fc" id="L184">            nextDstUtc = rules.getNextDST(timestamp);</span>
        }

<span class="fc bfc" id="L187" title="All 4 branches covered.">        if (tzOffset == 0 &amp;&amp; fixedOffset == Long.MIN_VALUE) {</span>
            // this is the default path, we align time intervals to the first observation
<span class="fc" id="L189">            timestampSampler.setStart(timestamp);</span>
        } else {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            timestampSampler.setStart(fixedOffset != Long.MIN_VALUE ? fixedOffset : 0L);</span>
        }
<span class="fc" id="L193">        topTzOffset = tzOffset;</span>
<span class="fc" id="L194">        topNextDst = nextDstUtc;</span>
<span class="fc" id="L195">        topLocalEpoch = localEpoch = timestampSampler.round(timestamp + tzOffset);</span>
<span class="fc" id="L196">        sampleLocalEpoch = nextSampleLocalEpoch = localEpoch;</span>
<span class="fc" id="L197">        areTimestampsInitialized = true;</span>
<span class="fc" id="L198">    }</span>

    protected void nextSamplePeriod(long timestamp) {
<span class="fc" id="L201">        localEpoch = timestampSampler.round(timestamp);</span>
        // Sometimes rounding, especially around Days can throw localEpoch
        // to the &quot;before&quot; previous DST. When this happens we need to compensate for
        // tzOffset subtraction at the time of delivery of the timestamp to client
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (localEpoch - tzOffset &lt; prevDst) {</span>
<span class="fc" id="L206">            localEpoch += tzOffset;</span>
        }
<span class="fc" id="L208">        GroupByUtils.toTop(groupByFunctions);</span>
<span class="fc" id="L209">    }</span>

    protected boolean notKeyedLoop(MapValue mapValue) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (!isNotKeyedLoopInitialized) {</span>
<span class="fc" id="L213">            sampleLocalEpoch = localEpoch;</span>
<span class="fc" id="L214">            nextSampleLocalEpoch = localEpoch;</span>
            // looks like we need to populate key map
            // at the start of this loop 'lastTimestamp' will be set to timestamp
            // of first record in base cursor
<span class="fc" id="L218">            groupByFunctionsUpdater.updateNew(mapValue, baseRecord);</span>
<span class="fc" id="L219">            isNotKeyedLoopInitialized = true;</span>
        }

<span class="fc" id="L222">        long next = timestampSampler.nextTimestamp(localEpoch);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        while (baseCursor.hasNext()) {</span>
<span class="fc" id="L224">            long timestamp = getBaseRecordTimestamp();</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (timestamp &lt; next) {</span>
<span class="fc" id="L226">                circuitBreaker.statefulThrowExceptionIfTripped();</span>

<span class="fc" id="L228">                adjustDstInFlight(timestamp - tzOffset);</span>
<span class="fc" id="L229">                groupByFunctionsUpdater.updateExisting(mapValue, baseRecord);</span>
            } else {
                // timestamp changed, make sure we keep the value of 'lastTimestamp'
                // unchanged. Timestamp columns uses this variable
                // When map is exhausted we would assign 'next' to 'lastTimestamp'
                // and build another map
<span class="fc" id="L235">                timestamp = adjustDst(timestamp, mapValue, next);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">                if (timestamp != Long.MIN_VALUE) {</span>
<span class="fc" id="L237">                    nextSamplePeriod(timestamp);</span>
<span class="fc" id="L238">                    isNotKeyedLoopInitialized = false;</span>
<span class="fc" id="L239">                    return true;</span>
                }
            }
<span class="fc" id="L242">        }</span>
        // opportunity, after we stream map that's it
<span class="fc" id="L244">        baseRecord = null;</span>
<span class="fc" id="L245">        isNotKeyedLoopInitialized = false;</span>
<span class="fc" id="L246">        return true;</span>
    }

    protected void updateValueWhenClockMovesBack(MapValue value) {
<span class="fc" id="L250">        groupByFunctionsUpdater.updateExisting(value, baseRecord);</span>
<span class="fc" id="L251">    }</span>

<span class="fc" id="L253">    protected class TimestampFunc extends TimestampFunction implements Function {</span>

        @Override
        public long getTimestamp(Record rec) {
<span class="fc" id="L257">            return sampleLocalEpoch - tzOffset;</span>
        }

        @Override
        public boolean isReadThreadSafe() {
<span class="nc" id="L262">            return false;</span>
        }

        @Override
        public void toPlan(PlanSink sink) {
<span class="nc" id="L267">            sink.val(&quot;Timestamp&quot;);</span>
<span class="nc" id="L268">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>