<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TextImportProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.http.processors</a> &gt; <span class="el_source">TextImportProcessor.java</span></div><h1>TextImportProcessor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.http.processors;

import io.questdb.cairo.*;
import io.questdb.cairo.sql.RecordMetadata;
import io.questdb.cutlass.http.*;
import io.questdb.cutlass.http.ex.RetryOperationException;
import io.questdb.cutlass.text.Atomicity;
import io.questdb.cutlass.text.TextException;
import io.questdb.cutlass.text.TextLoadWarning;
import io.questdb.cutlass.text.TextLoader;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.network.NoSpaceLeftInResponseBufferException;
import io.questdb.network.PeerDisconnectedException;
import io.questdb.network.PeerIsSlowToReadException;
import io.questdb.network.ServerDisconnectException;
import io.questdb.std.*;
import io.questdb.std.str.CharSink;
import io.questdb.std.str.StringSink;

import java.io.Closeable;

import static io.questdb.cutlass.text.TextLoadWarning.*;

public class TextImportProcessor implements HttpRequestProcessor, HttpMultipartContentListener, Closeable {
    static final int MESSAGE_UNKNOWN = 3;
    static final int RESPONSE_PREFIX = 1;
<span class="fc" id="L52">    private static final CharSequence CONTENT_TYPE_JSON = &quot;application/json; charset=utf-8&quot;;</span>
<span class="fc" id="L53">    private static final CharSequence CONTENT_TYPE_TEXT = &quot;text/plain; charset=utf-8&quot;;</span>
<span class="fc" id="L54">    private final static Log LOG = LogFactory.getLog(TextImportProcessor.class);</span>
    // Local value has to be static because each thread will have its own instance of
    // processor. For different threads to lookup the same value from local value map the key,
    // which is LV, has to be the same between processor instances
<span class="fc" id="L58">    private static final LocalValue&lt;TextImportProcessorState&gt; LV = new LocalValue&lt;&gt;();</span>
    private static final int MESSAGE_DATA = 2;
    private static final int MESSAGE_SCHEMA = 1;
    private static final String OVERRIDDEN_FROM_TABLE = &quot;From Table&quot;;
    private static final int RESPONSE_COLUMN = 2;
    private static final int RESPONSE_COMPLETE = 6;
    private static final int RESPONSE_DONE = 5;
    private static final int RESPONSE_ERROR = 4;
    private static final int RESPONSE_SUFFIX = 3;
    private static final int TO_STRING_COL1_PAD = 15;
    private static final int TO_STRING_COL2_PAD = 50;
    private static final int TO_STRING_COL3_PAD = 15;
    private static final int TO_STRING_COL4_PAD = 7;
    private static final int TO_STRING_COL5_PAD = 12;
<span class="fc" id="L72">    private static final CharSequenceIntHashMap atomicityParamMap = new CharSequenceIntHashMap();</span>
    private final CairoEngine engine;
    private HttpConnectionContext transientContext;
    private TextImportProcessorState transientState;

<span class="fc" id="L77">    public TextImportProcessor(CairoEngine cairoEngine) {</span>
<span class="fc" id="L78">        this.engine = cairoEngine;</span>
<span class="fc" id="L79">    }</span>

    @Override
    public void close() {
<span class="fc" id="L83">    }</span>

    @Override
    public void failRequest(HttpConnectionContext context, HttpException e) throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="nc" id="L87">        sendErrorAndThrowDisconnect(((FlyweightMessageContainer) e).getFlyweightMessage());</span>
<span class="nc" id="L88">    }</span>

    @Override
    public void onChunk(long lo, long hi)
            throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (hi &gt; lo) {</span>
            try {
<span class="fc" id="L95">                transientState.lo = lo;</span>
<span class="fc" id="L96">                transientState.hi = hi;</span>
<span class="fc" id="L97">                transientState.textLoader.parse(lo, hi, transientContext.getCairoSecurityContext());</span>
<span class="fc bfc" id="L98" title="All 4 branches covered.">                if (transientState.messagePart == MESSAGE_DATA &amp;&amp; !transientState.analysed) {</span>
<span class="fc" id="L99">                    transientState.analysed = true;</span>
<span class="fc" id="L100">                    transientState.textLoader.setState(TextLoader.LOAD_DATA);</span>
                }
<span class="fc" id="L102">            } catch (EntryUnavailableException e) {</span>
<span class="fc" id="L103">                throw RetryOperationException.INSTANCE;</span>
<span class="fc" id="L104">            } catch (TextException | CairoException | CairoError e) {</span>
<span class="nc" id="L105">                sendErrorAndThrowDisconnect(e.getFlyweightMessage());</span>
<span class="fc" id="L106">            }</span>
        }
<span class="fc" id="L108">    }</span>

    @Override
    public void onPartBegin(HttpRequestHeader partHeader) throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="fc" id="L112">        final CharSequence contentDisposition = partHeader.getContentDispositionName();</span>
<span class="fc" id="L113">        LOG.debug().$(&quot;part begin [name=&quot;).$(contentDisposition).$(']').$();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (Chars.equalsNc(&quot;data&quot;, contentDisposition)) {</span>

<span class="fc" id="L116">            final HttpRequestHeader rh = transientContext.getRequestHeader();</span>
<span class="fc" id="L117">            CharSequence name = rh.getUrlParam(&quot;name&quot;);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            if (name == null) {</span>
<span class="fc" id="L119">                name = partHeader.getContentDispositionFilename();</span>
            }

<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (name == null) {</span>
<span class="nc" id="L123">                sendErrorAndThrowDisconnect(&quot;no file name given&quot;);</span>
            }

<span class="fc" id="L126">            CharSequence partitionedBy = rh.getUrlParam(&quot;partitionBy&quot;);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (partitionedBy == null) {</span>
<span class="fc" id="L128">                partitionedBy = &quot;NONE&quot;;</span>
            }
<span class="fc" id="L130">            int partitionBy = PartitionBy.fromString(partitionedBy);</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">            if (partitionBy == -1) {</span>
<span class="nc" id="L132">                sendErrorAndThrowDisconnect(&quot;invalid partitionBy&quot;);</span>
            }

<span class="fc" id="L135">            CharSequence timestampColumn = rh.getUrlParam(&quot;timestamp&quot;);</span>
<span class="pc bpc" id="L136" title="1 of 4 branches missed.">            if (PartitionBy.isPartitioned(partitionBy) &amp;&amp; timestampColumn == null) {</span>
<span class="nc" id="L137">                sendErrorAndThrowDisconnect(&quot;when specifying partitionBy you must also specify timestamp&quot;);</span>
            }

<span class="fc" id="L140">            transientState.analysed = false;</span>
<span class="fc" id="L141">            transientState.textLoader.configureDestination(</span>
                    name,
<span class="fc" id="L143">                    Chars.equalsNc(&quot;true&quot;, rh.getUrlParam(&quot;overwrite&quot;)),</span>
<span class="fc" id="L144">                    Chars.equalsNc(&quot;true&quot;, rh.getUrlParam(&quot;durable&quot;)),</span>
<span class="fc" id="L145">                    getAtomicity(rh.getUrlParam(&quot;atomicity&quot;)),</span>
                    partitionBy,
                    timestampColumn,
                    null
            );

<span class="fc" id="L151">            CharSequence o3MaxLagChars = rh.getUrlParam(&quot;o3MaxLag&quot;);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">            if (o3MaxLagChars != null) {</span>
                try {
<span class="fc" id="L154">                    long o3MaxLag = Numbers.parseLong(o3MaxLagChars);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                    if (o3MaxLag &gt;= 0) {</span>
<span class="fc" id="L156">                        transientState.textLoader.setO3MaxLag(o3MaxLag);</span>
                    }
<span class="fc" id="L158">                } catch (NumericException e) {</span>
<span class="nc" id="L159">                    sendErrorAndThrowDisconnect(&quot;invalid o3MaxLag value, must be a long&quot;);</span>
<span class="fc" id="L160">                }</span>
            }

<span class="fc" id="L163">            CharSequence maxUncommittedRowsChars = rh.getUrlParam(&quot;maxUncommittedRows&quot;);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (maxUncommittedRowsChars != null) {</span>
                try {
<span class="fc" id="L166">                    int maxUncommittedRows = Numbers.parseInt(maxUncommittedRowsChars);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                    if (maxUncommittedRows &gt;= 0) {</span>
<span class="fc" id="L168">                        transientState.textLoader.setMaxUncommittedRows(maxUncommittedRows);</span>
                    }
<span class="fc" id="L170">                } catch (NumericException e) {</span>
<span class="nc" id="L171">                    sendErrorAndThrowDisconnect(&quot;invalid maxUncommittedRows, must be an int&quot;);</span>
<span class="fc" id="L172">                }</span>
            }

<span class="fc" id="L175">            transientState.textLoader.setForceHeaders(Chars.equalsNc(&quot;true&quot;, rh.getUrlParam(&quot;forceHeader&quot;)));</span>
<span class="fc" id="L176">            transientState.textLoader.setSkipLinesWithExtraValues(Chars.equalsNc(&quot;true&quot;, rh.getUrlParam(&quot;skipLev&quot;)));</span>
<span class="fc" id="L177">            CharSequence delimiter = rh.getUrlParam(&quot;delimiter&quot;);</span>
<span class="pc bpc" id="L178" title="1 of 4 branches missed.">            if (delimiter != null &amp;&amp; delimiter.length() == 1) {</span>
<span class="fc" id="L179">                transientState.textLoader.configureColumnDelimiter((byte) delimiter.charAt(0));</span>
            }
<span class="fc" id="L181">            transientState.textLoader.setState(TextLoader.ANALYZE_STRUCTURE);</span>

<span class="fc" id="L183">            transientState.forceHeader = Chars.equalsNc(&quot;true&quot;, rh.getUrlParam(&quot;forceHeader&quot;));</span>
<span class="fc" id="L184">            transientState.messagePart = MESSAGE_DATA;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        } else if (Chars.equalsNc(&quot;schema&quot;, contentDisposition)) {</span>
<span class="fc" id="L186">            transientState.textLoader.setState(TextLoader.LOAD_JSON_METADATA);</span>
<span class="fc" id="L187">            transientState.messagePart = MESSAGE_SCHEMA;</span>
        } else {
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if (partHeader.getContentDisposition() == null) {</span>
<span class="nc" id="L190">                sendErrorAndThrowDisconnect(&quot;'Content-Disposition' multipart header missing'&quot;);</span>
            } else {
<span class="nc" id="L192">                sendErrorAndThrowDisconnect(&quot;invalid value in 'Content-Disposition' multipart header&quot;);</span>
            }
        }
<span class="fc" id="L195">    }</span>

    @Override
    public void onPartEnd() throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
        try {
<span class="fc" id="L200">            LOG.debug().$(&quot;part end&quot;).$();</span>
<span class="fc" id="L201">            transientState.textLoader.wrapUp();</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            if (transientState.messagePart == MESSAGE_DATA) {</span>
<span class="fc" id="L203">                sendResponse(transientContext);</span>
            }
<span class="nc" id="L205">        } catch (TextException | CairoException | CairoError e) {</span>
<span class="nc" id="L206">            sendErrorAndThrowDisconnect(e.getFlyweightMessage());</span>
<span class="fc" id="L207">        }</span>
<span class="fc" id="L208">    }</span>

    // This processor implements HttpMultipartContentListener, methods of which
    // have neither context nor dispatcher. During &quot;chunk&quot; processing we may need
    // to send something back to client, or disconnect them. To do that we need
    // these transient references. resumeRecv() will set them and they will remain
    // valid during multipart events.

    @Override
    public void onRequestComplete(HttpConnectionContext context) {
<span class="fc" id="L218">        transientState.clear();</span>
<span class="fc" id="L219">    }</span>

    @Override
    public void onRequestRetry(
            HttpConnectionContext context
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="fc" id="L225">        this.transientContext = context;</span>
<span class="fc" id="L226">        this.transientState = LV.get(context);</span>
<span class="fc" id="L227">        onChunk(transientState.lo, transientState.hi);</span>
<span class="fc" id="L228">    }</span>

    @Override
    public void resumeRecv(HttpConnectionContext context) {
<span class="fc" id="L232">        this.transientContext = context;</span>
<span class="fc" id="L233">        this.transientState = LV.get(context);</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (this.transientState == null) {</span>
<span class="fc" id="L235">            LOG.debug().$(&quot;new text state&quot;).$();</span>
<span class="fc" id="L236">            LV.set(context, this.transientState = new TextImportProcessorState(engine));</span>
<span class="fc" id="L237">            transientState.json = isJson(context);</span>
        }
<span class="fc" id="L239">    }</span>

    @Override
    public void resumeSend(
            HttpConnectionContext context
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="fc" id="L245">        context.resumeResponseSend();</span>
<span class="fc" id="L246">        doResumeSend(LV.get(context), context.getChunkedResponseSocket());</span>
<span class="fc" id="L247">    }</span>

    private static int getAtomicity(CharSequence name) {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="fc" id="L251">            return Atomicity.SKIP_COL;</span>
        }

<span class="nc" id="L254">        int atomicity = atomicityParamMap.get(name);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        return atomicity == -1 ? Atomicity.SKIP_COL : atomicity;</span>
    }

    private static void pad(CharSink b, int w, long value) {
<span class="fc" id="L259">        int len = (int) Math.log10(value);</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (len &lt; 0) {</span>
<span class="fc" id="L261">            len = 0;</span>
        }
<span class="fc" id="L263">        replicate(b, ' ', w - len - 1);</span>
<span class="fc" id="L264">        b.put(value);</span>
<span class="fc" id="L265">        b.put(&quot;  |&quot;);</span>
<span class="fc" id="L266">    }</span>

    private static CharSink pad(CharSink b, int w, CharSequence value) {
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        int pad = value == null ? w : w - value.length();</span>
<span class="fc" id="L270">        replicate(b, ' ', pad);</span>

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">            if (pad &lt; 0) {</span>
<span class="nc" id="L274">                b.put(&quot;...&quot;).put(value.subSequence(-pad + 3, value.length()));</span>
            } else {
<span class="fc" id="L276">                b.put(value);</span>
            }
        }

<span class="fc" id="L280">        b.put(&quot;  |&quot;);</span>

<span class="fc" id="L282">        return b;</span>
    }

    private static void replicate(CharSink b, char c, int times) {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (int i = 0; i &lt; times; i++) {</span>
<span class="fc" id="L287">            b.put(c);</span>
        }
<span class="fc" id="L289">    }</span>

    private static void resumeJson(TextImportProcessorState state, HttpChunkedResponseSocket socket) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L292">        final TextLoaderCompletedState completeState = state.completeState;</span>
<span class="fc" id="L293">        final RecordMetadata metadata = completeState.getMetadata();</span>
<span class="fc" id="L294">        final LongList errors = completeState.getColumnErrorCounts();</span>


<span class="pc bpc" id="L297" title="4 of 5 branches missed.">        switch (state.responseState) {</span>
            case RESPONSE_PREFIX:
<span class="fc" id="L299">                long totalRows = completeState.getParsedLineCount();</span>
<span class="fc" id="L300">                long importedRows = completeState.getWrittenLineCount();</span>
<span class="fc" id="L301">                socket.put('{')</span>
<span class="fc" id="L302">                        .putQuoted(&quot;status&quot;).put(':').putQuoted(&quot;OK&quot;).put(',')</span>
<span class="fc" id="L303">                        .putQuoted(&quot;location&quot;).put(':').encodeUtf8AndQuote(completeState.getTableName()).put(',')</span>
<span class="fc" id="L304">                        .putQuoted(&quot;rowsRejected&quot;).put(':').put(totalRows - importedRows + completeState.getErrorLineCount()).put(',')</span>
<span class="fc" id="L305">                        .putQuoted(&quot;rowsImported&quot;).put(':').put(importedRows).put(',')</span>
<span class="fc" id="L306">                        .putQuoted(&quot;header&quot;).put(':').put(completeState.isForceHeaders()).put(',');</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">                if (completeState.getWarnings() != TextLoadWarning.NONE) {</span>
<span class="fc" id="L308">                    final int warningFlags = completeState.getWarnings();</span>
<span class="fc" id="L309">                    socket.putQuoted(&quot;warnings&quot;).put(':').put('[');</span>
<span class="fc" id="L310">                    boolean isFirst = true;</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                    if ((warningFlags &amp; TextLoadWarning.TIMESTAMP_MISMATCH) != TextLoadWarning.NONE) {</span>
<span class="fc" id="L312">                        isFirst = false;</span>
<span class="fc" id="L313">                        socket.putQuoted(&quot;Existing table timestamp column is used&quot;);</span>
                    }
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                    if ((warningFlags &amp; PARTITION_TYPE_MISMATCH) != TextLoadWarning.NONE) {</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                        if (!isFirst) socket.put(',');</span>
<span class="fc" id="L317">                        socket.putQuoted(&quot;Existing table PartitionBy is used&quot;);</span>
                    }
<span class="fc" id="L319">                    socket.put(']').put(',');</span>
                }
<span class="fc" id="L321">                socket.putQuoted(&quot;columns&quot;).put(':').put('[');</span>
<span class="fc" id="L322">                state.responseState = RESPONSE_COLUMN;</span>
                // fall through
            case RESPONSE_COLUMN:
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">                if (metadata != null) {</span>
<span class="fc" id="L326">                    final int columnCount = metadata.getColumnCount();</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                    for (; state.columnIndex &lt; columnCount; state.columnIndex++) {</span>
<span class="fc" id="L328">                        socket.bookmark();</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">                        if (state.columnIndex &gt; 0) {</span>
<span class="fc" id="L330">                            socket.put(',');</span>
                        }
<span class="fc" id="L332">                        socket.put('{').</span>
<span class="fc" id="L333">                                putQuoted(&quot;name&quot;).put(':').putQuoted(metadata.getColumnName(state.columnIndex)).put(',').</span>
<span class="fc" id="L334">                                putQuoted(&quot;type&quot;).put(':').putQuoted(ColumnType.nameOf(metadata.getColumnType(state.columnIndex))).put(',').</span>
<span class="fc" id="L335">                                putQuoted(&quot;size&quot;).put(':').put(ColumnType.sizeOf(metadata.getColumnType(state.columnIndex))).put(',').</span>
<span class="fc" id="L336">                                putQuoted(&quot;errors&quot;).put(':').put(errors.getQuick(state.columnIndex));</span>
<span class="fc" id="L337">                        socket.put('}');</span>
                    }
                }
<span class="fc" id="L340">                state.responseState = RESPONSE_SUFFIX;</span>
                // fall through
            case RESPONSE_SUFFIX:
<span class="fc" id="L343">                socket.bookmark();</span>
<span class="fc" id="L344">                socket.put(']').put('}');</span>
<span class="fc" id="L345">                state.responseState = RESPONSE_COMPLETE;</span>
<span class="fc" id="L346">                socket.sendChunk(true);</span>
<span class="fc" id="L347">                break;</span>
            case RESPONSE_DONE:
<span class="nc" id="L349">                state.responseState = RESPONSE_COMPLETE;</span>
<span class="nc" id="L350">                socket.done();</span>
<span class="nc" id="L351">                break;</span>
            default:
                break;
        }
<span class="fc" id="L355">    }</span>

    private static void resumeText(TextImportProcessorState state, HttpChunkedResponseSocket socket) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L358">        final TextLoaderCompletedState textLoaderCompletedState = state.completeState;</span>
<span class="fc" id="L359">        final RecordMetadata metadata = textLoaderCompletedState.getMetadata();</span>
<span class="fc" id="L360">        LongList errors = textLoaderCompletedState.getColumnErrorCounts();</span>


<span class="pc bpc" id="L363" title="3 of 5 branches missed.">        switch (state.responseState) {</span>
            case RESPONSE_PREFIX:
<span class="fc" id="L365">                sep(socket);</span>
<span class="fc" id="L366">                socket.put('|');</span>
<span class="fc" id="L367">                pad(socket, TO_STRING_COL1_PAD, &quot;Location:&quot;);</span>
<span class="fc" id="L368">                pad(socket, TO_STRING_COL2_PAD, textLoaderCompletedState.getTableName());</span>
<span class="fc" id="L369">                pad(socket, TO_STRING_COL3_PAD, &quot;Pattern&quot;);</span>
<span class="fc" id="L370">                pad(socket, TO_STRING_COL4_PAD, &quot;Locale&quot;);</span>
<span class="fc" id="L371">                pad(socket, TO_STRING_COL5_PAD, &quot;Errors&quot;).put(Misc.EOL);</span>


<span class="fc" id="L374">                socket.put('|');</span>
<span class="fc" id="L375">                pad(socket, TO_STRING_COL1_PAD, &quot;Partition by&quot;);</span>
<span class="fc" id="L376">                pad(socket, TO_STRING_COL2_PAD, PartitionBy.toString(textLoaderCompletedState.getPartitionBy()));</span>
<span class="fc" id="L377">                pad(socket, TO_STRING_COL3_PAD, &quot;&quot;);</span>
<span class="fc" id="L378">                pad(socket, TO_STRING_COL4_PAD, &quot;&quot;);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                if (hasFlag(textLoaderCompletedState.getWarnings(), PARTITION_TYPE_MISMATCH)) {</span>
<span class="fc" id="L380">                    pad(socket, TO_STRING_COL5_PAD, OVERRIDDEN_FROM_TABLE);</span>
                } else {
<span class="fc" id="L382">                    pad(socket, TO_STRING_COL5_PAD, &quot;&quot;);</span>
                }
<span class="fc" id="L384">                socket.put(Misc.EOL);</span>

<span class="fc" id="L386">                socket.put('|');</span>
<span class="fc" id="L387">                pad(socket, TO_STRING_COL1_PAD, &quot;Timestamp&quot;);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">                pad(socket, TO_STRING_COL2_PAD, textLoaderCompletedState.getTimestampCol() == null ? &quot;NONE&quot; : textLoaderCompletedState.getTimestampCol());</span>
<span class="fc" id="L389">                pad(socket, TO_STRING_COL3_PAD, &quot;&quot;);</span>
<span class="fc" id="L390">                pad(socket, TO_STRING_COL4_PAD, &quot;&quot;);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">                if (hasFlag(textLoaderCompletedState.getWarnings(), TIMESTAMP_MISMATCH)) {</span>
<span class="fc" id="L392">                    pad(socket, TO_STRING_COL5_PAD, OVERRIDDEN_FROM_TABLE);</span>
                } else {
<span class="fc" id="L394">                    pad(socket, TO_STRING_COL5_PAD, &quot;&quot;);</span>
                }
<span class="fc" id="L396">                socket.put(Misc.EOL);</span>

<span class="fc" id="L398">                sep(socket);</span>

<span class="fc" id="L400">                socket.put('|');</span>
<span class="fc" id="L401">                pad(socket, TO_STRING_COL1_PAD, &quot;Rows handled&quot;);</span>
<span class="fc" id="L402">                pad(socket, TO_STRING_COL2_PAD, textLoaderCompletedState.getParsedLineCount() + textLoaderCompletedState.getErrorLineCount());</span>
<span class="fc" id="L403">                pad(socket, TO_STRING_COL3_PAD, &quot;&quot;);</span>
<span class="fc" id="L404">                pad(socket, TO_STRING_COL4_PAD, &quot;&quot;);</span>
<span class="fc" id="L405">                pad(socket, TO_STRING_COL5_PAD, &quot;&quot;).put(Misc.EOL);</span>
<span class="fc" id="L406">                socket.put('|');</span>
<span class="fc" id="L407">                pad(socket, TO_STRING_COL1_PAD, &quot;Rows imported&quot;);</span>
<span class="fc" id="L408">                pad(socket, TO_STRING_COL2_PAD, textLoaderCompletedState.getWrittenLineCount());</span>
<span class="fc" id="L409">                pad(socket, TO_STRING_COL3_PAD, &quot;&quot;);</span>
<span class="fc" id="L410">                pad(socket, TO_STRING_COL4_PAD, &quot;&quot;);</span>
<span class="fc" id="L411">                pad(socket, TO_STRING_COL5_PAD, &quot;&quot;).put(Misc.EOL);</span>
<span class="fc" id="L412">                sep(socket);</span>

<span class="fc" id="L414">                state.responseState = RESPONSE_COLUMN;</span>
                // fall through
            case RESPONSE_COLUMN:

<span class="fc bfc" id="L418" title="All 2 branches covered.">                if (metadata != null) {</span>
<span class="fc" id="L419">                    final int columnCount = metadata.getColumnCount();</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">                    for (; state.columnIndex &lt; columnCount; state.columnIndex++) {</span>
<span class="fc" id="L422">                        socket.bookmark();</span>
<span class="fc" id="L423">                        socket.put('|');</span>
<span class="fc" id="L424">                        pad(socket, TO_STRING_COL1_PAD, state.columnIndex);</span>
<span class="fc" id="L425">                        pad(socket, TO_STRING_COL2_PAD, metadata.getColumnName(state.columnIndex));</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">                        if (!metadata.isColumnIndexed(state.columnIndex)) {</span>
<span class="fc" id="L427">                            pad(socket, TO_STRING_COL3_PAD + TO_STRING_COL4_PAD + 3, ColumnType.nameOf(metadata.getColumnType(state.columnIndex)));</span>
                        } else {
<span class="fc" id="L429">                            StringSink sink = Misc.getThreadLocalBuilder();</span>
<span class="fc" id="L430">                            sink.put(&quot;(idx/&quot;).put(metadata.getIndexValueBlockCapacity(state.columnIndex)).put(&quot;) &quot;);</span>
<span class="fc" id="L431">                            sink.put(ColumnType.nameOf(metadata.getColumnType(state.columnIndex)));</span>
<span class="fc" id="L432">                            pad(socket, TO_STRING_COL3_PAD + TO_STRING_COL4_PAD + 3, sink);</span>
                        }
<span class="fc" id="L434">                        pad(socket, TO_STRING_COL5_PAD, errors.getQuick(state.columnIndex));</span>
<span class="fc" id="L435">                        socket.put(Misc.EOL);</span>
                    }
                }
<span class="fc" id="L438">                state.responseState = RESPONSE_SUFFIX;</span>
                // fall through
            case RESPONSE_SUFFIX:
<span class="fc" id="L441">                socket.bookmark();</span>
<span class="fc" id="L442">                sep(socket);</span>
<span class="fc" id="L443">                state.responseState = RESPONSE_COMPLETE;</span>
<span class="fc" id="L444">                socket.sendChunk(true);</span>
<span class="fc" id="L445">                break;</span>
            case RESPONSE_DONE:
<span class="nc" id="L447">                state.responseState = RESPONSE_COMPLETE;</span>
<span class="nc" id="L448">                socket.done();</span>
<span class="nc" id="L449">                break;</span>
            default:
                break;
        }
<span class="fc" id="L453">    }</span>

    private static void sep(CharSink b) {
<span class="fc" id="L456">        b.put('+');</span>
<span class="fc" id="L457">        replicate(b, '-', TO_STRING_COL1_PAD + TO_STRING_COL2_PAD + TO_STRING_COL3_PAD + TO_STRING_COL4_PAD + TO_STRING_COL5_PAD + 14);</span>
<span class="fc" id="L458">        b.put(&quot;+\r\n&quot;);</span>
<span class="fc" id="L459">    }</span>

    private void doResumeSend(
            TextImportProcessorState state,
            HttpChunkedResponseSocket socket
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
        try {
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (state.errorMessage != null) {</span>
<span class="nc" id="L467">                resumeError(state, socket);</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">            } else if (state.json) {</span>
<span class="fc" id="L469">                resumeJson(state, socket);</span>
            } else {
<span class="fc" id="L471">                resumeText(state, socket);</span>
            }
<span class="nc" id="L473">        } catch (NoSpaceLeftInResponseBufferException ignored) {</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">            if (socket.resetToBookmark()) {</span>
<span class="nc" id="L475">                socket.sendChunk(false);</span>
            } else {
                // what we have here is out unit of data, column value or query
                // is larger that response content buffer
                // all we can do in this scenario is to log appropriately
                // and disconnect socket
<span class="nc" id="L481">                socket.shutdownWrite();</span>
<span class="nc" id="L482">                throw ServerDisconnectException.INSTANCE;</span>
            }
<span class="fc" id="L484">        }</span>

<span class="fc" id="L486">        state.clear();</span>
<span class="fc" id="L487">    }</span>

    private boolean isJson(HttpConnectionContext transientContext) {
<span class="fc" id="L490">        return Chars.equalsNc(&quot;json&quot;, transientContext.getRequestHeader().getUrlParam(&quot;fmt&quot;));</span>
    }

    private void resumeError(TextImportProcessorState state, HttpChunkedResponseSocket socket) throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="fc bfc" id="L494" title="All 2 branches covered.">        if (state.responseState == RESPONSE_ERROR) {</span>
<span class="fc" id="L495">            socket.bookmark();</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">            if (state.json) {</span>
<span class="fc" id="L497">                socket.put('{').putQuoted(&quot;status&quot;).put(':').encodeUtf8AndQuote(state.errorMessage).put('}');</span>
            } else {
<span class="fc" id="L499">                socket.encodeUtf8(state.errorMessage);</span>
            }
<span class="fc" id="L501">            state.responseState = RESPONSE_DONE;</span>
<span class="fc" id="L502">            socket.sendChunk(true);</span>
        }
<span class="fc" id="L504">        socket.shutdownWrite();</span>
<span class="fc" id="L505">        throw ServerDisconnectException.INSTANCE;</span>
    }

    private void sendErr(HttpConnectionContext context, CharSequence message, HttpChunkedResponseSocket socket) throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="fc" id="L509">        final TextImportProcessorState state = LV.get(context);</span>
<span class="fc" id="L510">        state.responseState = RESPONSE_ERROR;</span>
<span class="fc" id="L511">        state.errorMessage = message;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (state.json) {</span>
<span class="fc" id="L513">            socket.status(200, CONTENT_TYPE_JSON);</span>
        } else {
<span class="fc" id="L515">            socket.status(200, CONTENT_TYPE_TEXT);</span>
        }
<span class="fc" id="L517">        socket.sendHeader();</span>
<span class="fc" id="L518">        socket.sendChunk(false);</span>
<span class="nc" id="L519">        resumeError(state, socket);</span>
<span class="nc" id="L520">    }</span>

    private void sendErrorAndThrowDisconnect(CharSequence message)
            throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="fc" id="L524">        transientState.snapshotStateAndCloseWriter();</span>
<span class="fc" id="L525">        final HttpChunkedResponseSocket socket = transientContext.getChunkedResponseSocket();</span>
<span class="nc" id="L526">        sendErr(transientContext, message, socket);</span>
<span class="nc" id="L527">    }</span>

    private void sendResponse(HttpConnectionContext context)
            throws PeerDisconnectedException, PeerIsSlowToReadException, ServerDisconnectException {
<span class="fc" id="L531">        final TextImportProcessorState state = LV.get(context);</span>
<span class="fc" id="L532">        final HttpChunkedResponseSocket socket = context.getChunkedResponseSocket();</span>

        // Copy written state to state, text loader, parser can be closed before re-attempt to send the response
<span class="fc" id="L535">        state.snapshotStateAndCloseWriter();</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">        if (state.state == TextImportProcessorState.STATE_OK) {</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">            if (state.json) {</span>
<span class="fc" id="L538">                socket.status(200, CONTENT_TYPE_JSON);</span>
            } else {
<span class="fc" id="L540">                socket.status(200, CONTENT_TYPE_TEXT);</span>
            }
<span class="fc" id="L542">            socket.sendHeader();</span>
<span class="fc" id="L543">            doResumeSend(state, socket);</span>
        } else {
<span class="nc" id="L545">            sendErr(context, state.stateMessage, context.getChunkedResponseSocket());</span>
        }
<span class="fc" id="L547">    }</span>

    static {
<span class="fc" id="L550">        atomicityParamMap.put(&quot;skipRow&quot;, Atomicity.SKIP_ROW);</span>
<span class="fc" id="L551">        atomicityParamMap.put(&quot;abort&quot;, Atomicity.SKIP_ALL);</span>
<span class="fc" id="L552">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>