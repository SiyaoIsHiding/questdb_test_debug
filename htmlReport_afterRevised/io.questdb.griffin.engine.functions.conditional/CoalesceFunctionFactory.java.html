<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoalesceFunctionFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.engine.functions.conditional</a> &gt; <span class="el_source">CoalesceFunctionFactory.java</span></div><h1>CoalesceFunctionFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.engine.functions.conditional;

import io.questdb.cairo.CairoConfiguration;
import io.questdb.cairo.ColumnType;
import io.questdb.cairo.sql.Function;
import io.questdb.cairo.sql.Record;
import io.questdb.griffin.FunctionFactory;
import io.questdb.griffin.SqlException;
import io.questdb.griffin.SqlExecutionContext;
import io.questdb.griffin.engine.functions.*;
import io.questdb.std.*;
import io.questdb.std.str.CharSink;

<span class="fc" id="L38">public class CoalesceFunctionFactory implements FunctionFactory {</span>
    @Override
    public String getSignature() {
<span class="fc" id="L41">        return &quot;coalesce(V)&quot;;</span>
    }

    @Override
    public Function newInstance(
            int position,
            ObjList&lt;Function&gt; args,
            IntList argPositions,
            CairoConfiguration configuration,
            SqlExecutionContext sqlExecutionContext
    ) throws SqlException {
<span class="fc bfc" id="L52" title="All 2 branches covered.">        if (args.size() &lt; 2) {</span>
<span class="fc" id="L53">            throw SqlException.$(position, &quot;coalesce can be used with 2 or more arguments&quot;);</span>
        }
<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (args.size() &gt; 2) {</span>
            // copy, args collection will be reused by sql parser
<span class="fc" id="L57">            args = new ObjList&lt;&gt;(args);</span>
        }

        // Similar to CASE function.
        // compute return type in this loop
<span class="fc" id="L62">        final int argsSize = args.size();</span>
<span class="fc" id="L63">        int returnType = -1;</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        for (int i = 0; i &lt; argsSize; i++) {</span>
<span class="fc" id="L65">            returnType = CaseCommon.getCommonType(returnType, args.getQuick(i).getType(), argPositions.getQuick(i));</span>
        }
<span class="fc bfc" id="L67" title="All 11 branches covered.">        switch (ColumnType.tagOf(returnType)) {</span>
            case ColumnType.DOUBLE:
<span class="fc bfc" id="L69" title="All 2 branches covered.">                return argsSize == 2 ? new TwoDoubleCoalesceFunction(args) : new DoubleCoalesceFunction(args, argsSize);</span>
            case ColumnType.DATE:
<span class="fc bfc" id="L71" title="All 2 branches covered.">                return argsSize == 2 ? new TwoDateCoalesceFunction(args) : new DateCoalesceFunction(args, argsSize);</span>
            case ColumnType.TIMESTAMP:
<span class="fc bfc" id="L73" title="All 2 branches covered.">                return argsSize == 2 ? new TwoTimestampCoalesceFunction(args) : new TimestampCoalesceFunction(args);</span>
            case ColumnType.LONG:
<span class="fc bfc" id="L75" title="All 2 branches covered.">                return argsSize == 2 ? new TwoLongCoalesceFunction(args) : new LongCoalesceFunction(args, argsSize);</span>
            case ColumnType.LONG256:
<span class="fc bfc" id="L77" title="All 2 branches covered.">                return argsSize == 2 ? new TwoLong256CoalesceFunction(args) : new Long256CoalesceFunction(args);</span>
            case ColumnType.INT:
<span class="fc bfc" id="L79" title="All 2 branches covered.">                return argsSize == 2 ? new TwoIntCoalesceFunction(args) : new IntCoalesceFunction(args, argsSize);</span>
            case ColumnType.FLOAT:
<span class="fc bfc" id="L81" title="All 2 branches covered.">                return argsSize == 2 ? new TwoFloatCoalesceFunction(args) : new FloatCoalesceFunction(args, argsSize);</span>
            case ColumnType.STRING:
            case ColumnType.SYMBOL:
<span class="fc bfc" id="L84" title="All 2 branches covered.">                if (argsSize == 2) {</span>
<span class="fc" id="L85">                    int type0 = ColumnType.tagOf(args.getQuick(0).getType());</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">                    if (type0 != ColumnType.tagOf(args.getQuick(1).getType())) {</span>
<span class="fc" id="L87">                        return new TwoSymStrCoalesceFunction(args);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">                    } else if (type0 == ColumnType.SYMBOL) {</span>
<span class="fc" id="L89">                        return new TwoSymCoalesceFunction(args);</span>
                    } else {
<span class="fc" id="L91">                        return new TwoStrCoalesceFunction(args);</span>
                    }
                }
<span class="fc" id="L94">                return new SymStrCoalesceFunction(args, argsSize);</span>
            case ColumnType.UUID:
<span class="fc bfc" id="L96" title="All 2 branches covered.">                return argsSize == 2 ? new TwoUuidCoalesceFunction(args) : new UuidCoalesceFunction(args, argsSize);</span>
            case ColumnType.BOOLEAN:
            case ColumnType.SHORT:
            case ColumnType.BYTE:
            case ColumnType.CHAR:
                // Null on these data types not supported
<span class="fc" id="L102">                return args.getQuick(0);</span>
            default:
<span class="fc" id="L104">                throw SqlException.$(position, &quot;coalesce cannot be used with &quot;)</span>
<span class="fc" id="L105">                        .put(ColumnType.nameOf(returnType))</span>
<span class="fc" id="L106">                        .put(&quot; data type&quot;);</span>
        }
    }

    private static boolean isNotNull(Long256 value) {
<span class="pc bpc" id="L111" title="2 of 4 branches missed.">        return value != null &amp;&amp;</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">                value != Long256Impl.NULL_LONG256 &amp;&amp; (value.getLong0() != Numbers.LONG_NaN ||</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                value.getLong1() != Numbers.LONG_NaN ||</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">                value.getLong2() != Numbers.LONG_NaN ||</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                value.getLong3() != Numbers.LONG_NaN);</span>
    }

    private interface BinaryCoalesceFunction extends BinaryFunction {
        @Override
        default String getName() {
<span class="nc" id="L121">            return &quot;coalesce&quot;;</span>
        }
    }

    private interface MultiArgCoalesceFunction extends MultiArgFunction {
        @Override
        default String getName() {
<span class="fc" id="L128">            return &quot;coalesce&quot;;</span>
        }
    }

    private static class DateCoalesceFunction extends DateFunction implements MultiArgCoalesceFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

<span class="fc" id="L136">        public DateCoalesceFunction(ObjList&lt;Function&gt; args, int size) {</span>
<span class="fc" id="L137">            this.args = args;</span>
<span class="fc" id="L138">            this.size = size;</span>
<span class="fc" id="L139">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L143">            return args;</span>
        }

        @Override
        public long getDate(Record rec) {
<span class="fc bfc" id="L148" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L149">                long value = args.getQuick(i).getDate(rec);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">                if (value != Numbers.LONG_NaN) {</span>
<span class="fc" id="L151">                    return value;</span>
                }
            }
<span class="fc" id="L154">            return Numbers.LONG_NaN;</span>
        }
    }

    private static class DoubleCoalesceFunction extends DoubleFunction implements MultiArgCoalesceFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

<span class="fc" id="L162">        public DoubleCoalesceFunction(ObjList&lt;Function&gt; args, int size) {</span>
<span class="fc" id="L163">            this.args = args;</span>
<span class="fc" id="L164">            this.size = size;</span>
<span class="fc" id="L165">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L169">            return args;</span>
        }

        @Override
        public double getDouble(Record rec) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L175">                double value = args.getQuick(i).getDouble(rec);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                if (value == value) {</span>
<span class="fc" id="L177">                    return value;</span>
                }
            }
<span class="fc" id="L180">            return Double.NaN;</span>
        }
    }

    private static class FloatCoalesceFunction extends FloatFunction implements MultiArgCoalesceFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

<span class="fc" id="L188">        public FloatCoalesceFunction(ObjList&lt;Function&gt; args, int size) {</span>
<span class="fc" id="L189">            this.args = args;</span>
<span class="fc" id="L190">            this.size = size;</span>
<span class="fc" id="L191">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L195">            return args;</span>
        }

        @Override
        public float getFloat(Record rec) {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L201">                float value = args.getQuick(i).getFloat(rec);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                if (value == value) {</span>
<span class="fc" id="L203">                    return value;</span>
                }
            }
<span class="fc" id="L206">            return Float.NaN;</span>
        }
    }

    private static class IntCoalesceFunction extends IntFunction implements MultiArgCoalesceFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

        public IntCoalesceFunction(ObjList&lt;Function&gt; args, int size) {
<span class="fc" id="L215">            super();</span>
<span class="fc" id="L216">            this.args = args;</span>
<span class="fc" id="L217">            this.size = size;</span>
<span class="fc" id="L218">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L222">            return args;</span>
        }

        @Override
        public int getInt(Record rec) {
<span class="fc bfc" id="L227" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L228">                int value = args.getQuick(i).getInt(rec);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if (value != Numbers.INT_NaN) {</span>
<span class="fc" id="L230">                    return value;</span>
                }
            }
<span class="fc" id="L233">            return Numbers.INT_NaN;</span>
        }
    }

    private static class Long256CoalesceFunction extends Long256Function implements MultiArgCoalesceFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

<span class="fc" id="L241">        public Long256CoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="fc" id="L242">            this.args = args;</span>
<span class="fc" id="L243">            this.size = args.size();</span>
<span class="fc" id="L244">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L248">            return args;</span>
        }

        @Override
        public void getLong256(Record rec, CharSink sink) {
<span class="fc bfc" id="L253" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L254">                Long256 value = args.getQuick(i).getLong256A(rec);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">                if (isNotNull(value)) {</span>
<span class="fc" id="L256">                    Numbers.appendLong256(value.getLong0(), value.getLong1(), value.getLong2(), value.getLong3(), sink);</span>
<span class="fc" id="L257">                    return;</span>
                }
            }
<span class="fc" id="L260">        }</span>

        @Override
        public Long256 getLong256A(Record rec) {
<span class="fc" id="L264">            Long256 value = Long256Impl.NULL_LONG256;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L266">                value = args.getQuick(i).getLong256A(rec);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (isNotNull(value)) {</span>
<span class="fc" id="L268">                    return value;</span>
                }
            }
<span class="fc" id="L271">            return value;</span>
        }

        @Override
        public Long256 getLong256B(Record rec) {
<span class="fc" id="L276">            Long256 value = Long256Impl.NULL_LONG256;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L278">                value = args.getQuick(i).getLong256B(rec);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">                if (isNotNull(value)) {</span>
<span class="fc" id="L280">                    return value;</span>
                }
            }
<span class="fc" id="L283">            return value;</span>
        }
    }

    public static class LongCoalesceFunction extends LongFunction implements MultiArgCoalesceFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

<span class="fc" id="L291">        public LongCoalesceFunction(ObjList&lt;Function&gt; args, int size) {</span>
<span class="fc" id="L292">            this.args = args;</span>
<span class="fc" id="L293">            this.size = size;</span>
<span class="fc" id="L294">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L298">            return args;</span>
        }

        @Override
        public long getLong(Record rec) {
            long value;
<span class="fc bfc" id="L304" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L305">                value = args.getQuick(i).getLong(rec);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                if (value != Numbers.LONG_NaN) {</span>
<span class="fc" id="L307">                    return value;</span>
                }
            }
<span class="fc" id="L310">            return Numbers.LONG_NaN;</span>
        }
    }

    private static class SymStrCoalesceFunction extends StrFunction implements MultiArgCoalesceFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

<span class="fc" id="L318">        public SymStrCoalesceFunction(ObjList&lt;Function&gt; args, int size) {</span>
<span class="fc" id="L319">            this.args = args;</span>
<span class="fc" id="L320">            this.size = size;</span>
<span class="fc" id="L321">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L325">            return args;</span>
        }


        @Override
        public CharSequence getStr(Record rec) {
<span class="fc bfc" id="L331" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L332">                Function arg = args.getQuick(i);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                CharSequence value = (ColumnType.isSymbol(arg.getType())) ? arg.getSymbol(rec) : arg.getStr(rec);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                if (value != null) {</span>
<span class="fc" id="L335">                    return value;</span>
                }
            }
<span class="fc" id="L338">            return null;</span>
        }

        @Override
        public CharSequence getStrB(Record rec) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L344">                Function arg = args.getQuick(i);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                CharSequence value = (ColumnType.isSymbol(arg.getType())) ? arg.getSymbolB(rec) : arg.getStrB(rec);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                if (value != null) {</span>
<span class="fc" id="L347">                    return value;</span>
                }
            }
<span class="fc" id="L350">            return null;</span>
        }
    }

    private static class TimestampCoalesceFunction extends TimestampFunction implements MultiArgCoalesceFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

<span class="fc" id="L358">        public TimestampCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="fc" id="L359">            this.args = args;</span>
<span class="fc" id="L360">            this.size = args.size();</span>
<span class="fc" id="L361">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L365">            return args;</span>
        }

        @Override
        public long getTimestamp(Record rec) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L371">                long value = args.getQuick(i).getTimestamp(rec);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">                if (value != Numbers.LONG_NaN) {</span>
<span class="fc" id="L373">                    return value;</span>
                }
            }
<span class="fc" id="L376">            return Numbers.LONG_NaN;</span>
        }
    }

<span class="fc" id="L380">    private static class TwoDateCoalesceFunction extends DateFunction implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L384">        public TwoDateCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L386">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L387">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L388">        }</span>

        @Override
        public long getDate(Record rec) {
<span class="fc" id="L392">            long value = args0.getDate(rec);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">            if (value != Numbers.LONG_NaN) {</span>
<span class="fc" id="L394">                return value;</span>
            }
<span class="fc" id="L396">            return args1.getDate(rec);</span>
        }

        @Override
        public Function getLeft() {
<span class="fc" id="L401">            return args0;</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L406">            return args1;</span>
        }
    }

<span class="fc" id="L410">    private static class TwoDoubleCoalesceFunction extends DoubleFunction implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L414">        public TwoDoubleCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L416">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L417">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L418">        }</span>

        @Override
        public double getDouble(Record rec) {
<span class="fc" id="L422">            double value = args0.getDouble(rec);</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (value == value) {</span>
<span class="fc" id="L424">                return value;</span>
            }
<span class="fc" id="L426">            return args1.getDouble(rec);</span>
        }

        @Override
        public Function getLeft() {
<span class="fc" id="L431">            return args0;</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L436">            return args1;</span>
        }
    }

<span class="fc" id="L440">    private static class TwoFloatCoalesceFunction extends FloatFunction implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L444">        public TwoFloatCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L446">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L447">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L448">        }</span>

        @Override
        public float getFloat(Record rec) {
<span class="fc" id="L452">            float value = args0.getFloat(rec);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">            if (value == value) {</span>
<span class="fc" id="L454">                return value;</span>
            }
<span class="fc" id="L456">            return args1.getFloat(rec);</span>
        }

        @Override
        public Function getLeft() {
<span class="fc" id="L461">            return args0;</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L466">            return args1;</span>
        }
    }

<span class="fc" id="L470">    private static class TwoIntCoalesceFunction extends IntFunction implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L474">        public TwoIntCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L476">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L477">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L478">        }</span>

        @Override
        public int getInt(Record rec) {
<span class="fc" id="L482">            int value = args0.getInt(rec);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (value != Numbers.INT_NaN) {</span>
<span class="fc" id="L484">                return value;</span>
            }
<span class="fc" id="L486">            return args1.getInt(rec);</span>
        }

        @Override
        public Function getLeft() {
<span class="fc" id="L491">            return args0;</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L496">            return args1;</span>
        }
    }

<span class="fc" id="L500">    private static class TwoLong256CoalesceFunction extends Long256Function implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L504">        public TwoLong256CoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L506">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L507">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L508">        }</span>

        @Override
        public Function getLeft() {
<span class="fc" id="L512">            return args0;</span>
        }

        @Override
        public void getLong256(Record rec, CharSink sink) {
<span class="fc" id="L517">            Long256 value = args0.getLong256A(rec);</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">            if (!isNotNull(value)) {</span>
<span class="fc" id="L519">                value = args1.getLong256A(rec);</span>
            }
<span class="fc" id="L521">            Numbers.appendLong256(value.getLong0(), value.getLong1(), value.getLong2(), value.getLong3(), sink);</span>
<span class="fc" id="L522">        }</span>

        @Override
        public Long256 getLong256A(Record rec) {
<span class="fc" id="L526">            Long256 value = args0.getLong256A(rec);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            if (isNotNull(value)) {</span>
<span class="fc" id="L528">                return value;</span>
            }
<span class="fc" id="L530">            return args1.getLong256A(rec);</span>
        }

        @Override
        public Long256 getLong256B(Record rec) {
<span class="fc" id="L535">            Long256 value = args0.getLong256B(rec);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (isNotNull(value)) {</span>
<span class="fc" id="L537">                return value;</span>
            }
<span class="fc" id="L539">            return args1.getLong256B(rec);</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L544">            return args1;</span>
        }
    }

<span class="fc" id="L548">    public static class TwoLongCoalesceFunction extends LongFunction implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L552">        public TwoLongCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L554">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L555">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L556">        }</span>

        @Override
        public Function getLeft() {
<span class="fc" id="L560">            return args0;</span>
        }

        @Override
        public long getLong(Record rec) {
<span class="fc" id="L565">            long value = args0.getLong(rec);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">            if (value != Numbers.LONG_NaN) {</span>
<span class="fc" id="L567">                return value;</span>
            }
<span class="fc" id="L569">            return args1.getLong(rec);</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L574">            return args1;</span>
        }
    }

<span class="fc" id="L578">    private static class TwoStrCoalesceFunction extends StrFunction implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L582">        public TwoStrCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L584">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L585">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L586">        }</span>

        @Override
        public Function getLeft() {
<span class="fc" id="L590">            return args0;</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L595">            return args1;</span>
        }

        @Override
        public CharSequence getStr(Record rec) {
<span class="fc" id="L600">            CharSequence value = args0.getStr(rec);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L602">                return value;</span>
            }
<span class="fc" id="L604">            return args1.getStr(rec);</span>
        }

        @Override
        public CharSequence getStrB(Record rec) {
<span class="fc" id="L609">            CharSequence value = args0.getStrB(rec);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L611">                return value;</span>
            }
<span class="fc" id="L613">            return args1.getStrB(rec);</span>
        }
    }

<span class="fc" id="L617">    private static class TwoSymCoalesceFunction extends StrFunction implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L621">        public TwoSymCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L623">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L624">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L625">        }</span>

        @Override
        public Function getLeft() {
<span class="fc" id="L629">            return args0;</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L634">            return args1;</span>
        }

        @Override
        public CharSequence getStr(Record rec) {
<span class="fc" id="L639">            CharSequence value = args0.getSymbol(rec);</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L641">                return value;</span>
            }
<span class="fc" id="L643">            return args1.getSymbol(rec);</span>
        }

        @Override
        public CharSequence getStrB(Record rec) {
<span class="fc" id="L648">            CharSequence value = args0.getSymbolB(rec);</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L650">                return value;</span>
            }
<span class="fc" id="L652">            return args1.getSymbolB(rec);</span>
        }
    }

<span class="fc" id="L656">    private static class TwoSymStrCoalesceFunction extends StrFunction implements BinaryCoalesceFunction {</span>
        private final boolean arg1IsSymbol;
        private final Function args0;
        private final boolean args0IsSymbol;
        private final Function args1;

<span class="fc" id="L662">        public TwoSymStrCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L664">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L665">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L666">            this.args0IsSymbol = ColumnType.isSymbol(args0.getType());</span>
<span class="fc" id="L667">            this.arg1IsSymbol = ColumnType.isSymbol(args1.getType());</span>
<span class="fc" id="L668">        }</span>

        @Override
        public Function getLeft() {
<span class="fc" id="L672">            return args0;</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L677">            return args1;</span>
        }

        @Override
        public CharSequence getStr(Record rec) {
<span class="fc bfc" id="L682" title="All 2 branches covered.">            CharSequence value = args0IsSymbol ? args0.getSymbol(rec) : args0.getStr(rec);</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L684">                return value;</span>
            }
<span class="fc bfc" id="L686" title="All 2 branches covered.">            return arg1IsSymbol ? args1.getSymbol(rec) : args1.getStr(rec);</span>
        }

        @Override
        public CharSequence getStrB(Record rec) {
<span class="fc bfc" id="L691" title="All 2 branches covered.">            CharSequence value = args0IsSymbol ? args0.getSymbolB(rec) : args0.getStrB(rec);</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L693">                return value;</span>
            }
<span class="fc bfc" id="L695" title="All 2 branches covered.">            return arg1IsSymbol ? args1.getSymbolB(rec) : args1.getStrB(rec);</span>
        }
    }

<span class="fc" id="L699">    private static class TwoTimestampCoalesceFunction extends TimestampFunction implements BinaryCoalesceFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L703">        public TwoTimestampCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L705">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L706">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L707">        }</span>

        @Override
        public Function getLeft() {
<span class="fc" id="L711">            return args0;</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L716">            return args1;</span>
        }

        @Override
        public long getTimestamp(Record rec) {
<span class="fc" id="L721">            long value = args0.getTimestamp(rec);</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">            if (value != Numbers.LONG_NaN) {</span>
<span class="fc" id="L723">                return value;</span>
            }
<span class="fc" id="L725">            return args1.getTimestamp(rec);</span>
        }
    }

<span class="fc" id="L729">    private static class TwoUuidCoalesceFunction extends UuidFunction implements BinaryFunction {</span>
        private final Function args0;
        private final Function args1;

<span class="fc" id="L733">        public TwoUuidCoalesceFunction(ObjList&lt;Function&gt; args) {</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">            assert args.size() == 2;</span>
<span class="fc" id="L735">            this.args0 = args.getQuick(0);</span>
<span class="fc" id="L736">            this.args1 = args.getQuick(1);</span>
<span class="fc" id="L737">        }</span>

        @Override
        public Function getLeft() {
<span class="fc" id="L741">            return args0;</span>
        }

        @Override
        public long getLong128Hi(Record rec) {
<span class="fc" id="L746">            long hi0 = args0.getLong128Hi(rec);</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">            if (hi0 != Numbers.LONG_NaN) {</span>
<span class="fc" id="L748">                return hi0; // if hi is not NaN then we know Long128 is not null</span>
            }
<span class="fc" id="L750">            long lo0 = args0.getLong128Lo(rec);</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">            if (lo0 != Numbers.LONG_NaN) {</span>
<span class="nc" id="L752">                return hi0; // if lo is not NaN then we know Long128 is not null and we can return hi0 even if it is NaN</span>
            }
            // ok, both hi and lo are NaN, we use the value from the second argument
<span class="fc" id="L755">            return args1.getLong128Hi(rec);</span>
        }

        @Override
        public long getLong128Lo(Record rec) {
<span class="fc" id="L760">            long lo0 = args0.getLong128Lo(rec);</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">            if (lo0 != Numbers.LONG_NaN) {</span>
<span class="fc" id="L762">                return lo0; // lo is not NaN -&gt; Long128 is not null, that's easy</span>
            }
<span class="fc" id="L764">            long hi0 = args0.getLong128Hi(rec);</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">            if (hi0 != Numbers.LONG_NaN) {</span>
<span class="nc" id="L766">                return lo0; // hi is not NaN  -&gt; Long128 is not null -&gt; we can return lo even if it is NaN</span>
            }
            // ok, both hi and lo are NaN, we use the value from the second argument
<span class="fc" id="L769">            return args1.getLong128Lo(rec);</span>
        }

        @Override
        public Function getRight() {
<span class="fc" id="L774">            return args1;</span>
        }
    }

    private static class UuidCoalesceFunction extends UuidFunction implements MultiArgFunction {
        private final ObjList&lt;Function&gt; args;
        private final int size;

<span class="fc" id="L782">        public UuidCoalesceFunction(ObjList&lt;Function&gt; args, int argsSize) {</span>
<span class="fc" id="L783">            this.args = args;</span>
<span class="fc" id="L784">            this.size = argsSize;</span>
<span class="fc" id="L785">        }</span>

        @Override
        public ObjList&lt;Function&gt; getArgs() {
<span class="fc" id="L789">            return args;</span>
        }

        @Override
        public long getLong128Hi(Record rec) {
<span class="fc" id="L794">            long value = Numbers.LONG_NaN;</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L796">                value = args.getQuick(i).getLong128Hi(rec);</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">                if (value != Numbers.LONG_NaN) {</span>
<span class="fc" id="L798">                    return value;</span>
                }
<span class="fc" id="L800">                long lo = args.getQuick(i).getLong128Lo(rec);</span>
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">                if (lo != Numbers.LONG_NaN) {</span>
<span class="nc" id="L802">                    return value;</span>
                }
            }
<span class="fc" id="L805">            return value;</span>
        }

        @Override
        public long getLong128Lo(Record rec) {
<span class="fc" id="L810">            long value = Numbers.LONG_NaN;</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L812">                value = args.getQuick(i).getLong128Lo(rec);</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">                if (value != Numbers.LONG_NaN) {</span>
<span class="fc" id="L814">                    return value;</span>
                }
<span class="fc" id="L816">                long hi = args.getQuick(i).getLong128Hi(rec);</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">                if (hi != Numbers.LONG_NaN) {</span>
<span class="nc" id="L818">                    return value;</span>
                }
            }
<span class="fc" id="L821">            return value;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>