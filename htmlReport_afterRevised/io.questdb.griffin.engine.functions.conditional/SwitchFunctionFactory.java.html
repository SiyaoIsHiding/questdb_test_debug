<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SwitchFunctionFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.engine.functions.conditional</a> &gt; <span class="el_source">SwitchFunctionFactory.java</span></div><h1>SwitchFunctionFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.engine.functions.conditional;

import io.questdb.cairo.CairoConfiguration;
import io.questdb.cairo.ColumnType;
import io.questdb.cairo.sql.Function;
import io.questdb.cairo.sql.Record;
import io.questdb.griffin.FunctionFactory;
import io.questdb.griffin.SqlException;
import io.questdb.griffin.SqlExecutionContext;
import io.questdb.griffin.engine.functions.constants.Constants;
import io.questdb.std.*;

<span class="fc" id="L37">public class SwitchFunctionFactory implements FunctionFactory {</span>

<span class="fc" id="L39">    private static final IntMethod GET_BYTE = SwitchFunctionFactory::getByte;</span>
<span class="fc" id="L40">    private static final IntMethod GET_CHAR = SwitchFunctionFactory::getChar;</span>
<span class="fc" id="L41">    private static final LongMethod GET_DATE = SwitchFunctionFactory::getDate;</span>
<span class="fc" id="L42">    private static final IntMethod GET_INT = SwitchFunctionFactory::getInt;</span>
<span class="fc" id="L43">    private static final LongMethod GET_LONG = SwitchFunctionFactory::getLong;</span>
<span class="fc" id="L44">    private static final IntMethod GET_SHORT = SwitchFunctionFactory::getShort;</span>
<span class="fc" id="L45">    private static final CharSequenceMethod GET_STRING = SwitchFunctionFactory::getString;</span>
<span class="fc" id="L46">    private static final CharSequenceMethod GET_SYMBOL = SwitchFunctionFactory::getSymbol;</span>
<span class="fc" id="L47">    private static final LongMethod GET_TIMESTAMP = SwitchFunctionFactory::getTimestamp;</span>

    @Override
    public String getSignature() {
<span class="fc" id="L51">        return &quot;switch(V)&quot;;</span>
    }

    @Override
    public Function newInstance(int position, ObjList&lt;Function&gt; args, IntList argPositions, CairoConfiguration configuration, SqlExecutionContext sqlExecutionContext) throws SqlException {
<span class="fc" id="L56">        int n = args.size();</span>

<span class="fc" id="L58">        final Function keyFunction = args.getQuick(0);</span>
<span class="fc" id="L59">        final int keyType = keyFunction.getType();</span>
        final Function elseBranch;
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (n % 2 == 0) {</span>
<span class="fc" id="L62">            elseBranch = args.getLast();</span>
<span class="fc" id="L63">            n--;</span>
        } else {
<span class="fc" id="L65">            elseBranch = null;</span>
        }

<span class="fc" id="L68">        int returnType = -1;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (int i = 1; i &lt; n; i += 2) {</span>
<span class="fc" id="L70">            final Function keyFunc = args.getQuick(i);</span>
<span class="fc" id="L71">            final int keyArgType = keyFunc.getType();</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">            if (!keyFunc.isConstant()) {</span>
<span class="fc" id="L73">                throw SqlException.$(argPositions.getQuick(i), &quot;constant expected&quot;);</span>
            }

<span class="pc bpc" id="L76" title="1 of 2 branches missed.">            if (!ColumnType.isAssignableFrom(keyArgType, keyType)) {</span>
<span class="nc" id="L77">                throw SqlException.position(argPositions.getQuick(i))</span>
<span class="nc" id="L78">                        .put(&quot;type mismatch [expected=&quot;).put(ColumnType.nameOf(keyType))</span>
<span class="nc" id="L79">                        .put(&quot;, actual=&quot;).put(ColumnType.nameOf(keyArgType))</span>
<span class="nc" id="L80">                        .put(']');</span>
            }

            // determine common return type
<span class="fc" id="L84">            final Function value = args.getQuick(i + 1);</span>
<span class="fc" id="L85">            returnType = CaseCommon.getCommonType(returnType, value.getType(), argPositions.getQuick(i + 1));</span>
        }

        // another loop to create cast functions and replace current value function
        // start with 2 to avoid offsetting each function position
<span class="fc bfc" id="L90" title="All 2 branches covered.">        for (int i = 2; i &lt; n; i += 2) {</span>
<span class="fc" id="L91">            args.setQuick(i,</span>
<span class="fc" id="L92">                    CaseCommon.getCastFunction(</span>
<span class="fc" id="L93">                            args.getQuick(i),</span>
<span class="fc" id="L94">                            argPositions.getQuick(i),</span>
                            returnType,
                            configuration,
                            sqlExecutionContext
                    )
            );
        }

<span class="fc bfc" id="L102" title="All 11 branches covered.">        switch (ColumnType.tagOf(keyType)) {</span>
            case ColumnType.CHAR:
<span class="fc" id="L104">                return getIntKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_CHAR);</span>
            case ColumnType.INT:
<span class="fc" id="L106">                return getIntKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_INT);</span>
            case ColumnType.BYTE:
<span class="fc" id="L108">                return getIntKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_BYTE);</span>
            case ColumnType.SHORT:
<span class="fc" id="L110">                return getIntKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_SHORT);</span>
            case ColumnType.LONG:
<span class="fc" id="L112">                return getLongKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_LONG);</span>
            case ColumnType.DATE:
<span class="fc" id="L114">                return getLongKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_DATE);</span>
            case ColumnType.TIMESTAMP:
<span class="fc" id="L116">                return getLongKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_TIMESTAMP);</span>
            case ColumnType.BOOLEAN:
<span class="fc" id="L118">                return getIfElseFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch);</span>
            case ColumnType.STRING:
<span class="fc" id="L120">                return getCharSequenceKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_STRING);</span>
            case ColumnType.SYMBOL:
<span class="fc" id="L122">                return getCharSequenceKeyedFunction(args, argPositions, position, n, keyFunction, returnType, elseBranch, GET_SYMBOL);</span>
            default:
<span class="fc" id="L124">                throw SqlException.</span>
<span class="fc" id="L125">                        $(argPositions.getQuick(0), &quot;type &quot;)</span>
<span class="fc" id="L126">                        .put(ColumnType.nameOf(keyType))</span>
<span class="fc" id="L127">                        .put(&quot; is not supported in 'switch' type of 'case' statement&quot;);</span>
        }
    }

    private static byte getByte(Function function, Record record) {
<span class="fc" id="L132">        return function.getByte(record);</span>
    }

    private static char getChar(Function function, Record record) {
<span class="fc" id="L136">        return function.getChar(record);</span>
    }

    private static long getDate(Function function, Record record) {
<span class="fc" id="L140">        return function.getDate(record);</span>
    }

    private static int getInt(Function function, Record record) {
<span class="fc" id="L144">        return function.getInt(record);</span>
    }

    private static long getLong(Function function, Record record) {
<span class="fc" id="L148">        return function.getLong(record);</span>
    }

    private static short getShort(Function function, Record record) {
<span class="fc" id="L152">        return function.getShort(record);</span>
    }

    private static CharSequence getString(Function function, Record record) {
<span class="fc" id="L156">        return function.getStr(record);</span>
    }

    private static CharSequence getSymbol(Function function, Record record) {
<span class="fc" id="L160">        return function.getSymbol(record);</span>
    }

    private static long getTimestamp(Function function, Record record) {
<span class="fc" id="L164">        return function.getTimestamp(record);</span>
    }

    private Function getCharSequenceKeyedFunction(
            ObjList&lt;Function&gt; args,
            IntList argPositions,
            int position,
            int n,
            Function keyFunction,
            int valueType,
            Function elseBranch,
            CharSequenceMethod method
    ) throws SqlException {
<span class="fc" id="L177">        final CharSequenceObjHashMap&lt;Function&gt; map = new CharSequenceObjHashMap&lt;&gt;();</span>
<span class="fc" id="L178">        final ObjList&lt;Function&gt; argsToPoke = new ObjList&lt;&gt;();</span>
<span class="fc" id="L179">        Function nullFunc = null;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (int i = 1; i &lt; n; i += 2) {</span>
<span class="fc" id="L181">            final Function fun = args.getQuick(i);</span>
<span class="fc" id="L182">            final CharSequence key = method.getKey(fun, null);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (key == null) {</span>
<span class="fc" id="L184">                nullFunc = args.getQuick(i + 1);</span>
            } else {
<span class="fc" id="L186">                final int index = map.keyIndex(key);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                if (index &lt; 0) {</span>
<span class="fc" id="L188">                    throw SqlException.$(argPositions.getQuick(i), &quot;duplicate branch&quot;);</span>
                }
<span class="fc" id="L190">                map.putAt(index, key, args.getQuick(i + 1));</span>
<span class="fc" id="L191">                argsToPoke.add(args.getQuick(i + 1));</span>
            }
        }

<span class="fc" id="L195">        final Function elseB = getElseFunction(valueType, elseBranch);</span>
        final CaseFunctionPicker picker;
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (nullFunc == null) {</span>
<span class="fc" id="L198">            picker = record -&gt; {</span>
<span class="fc" id="L199">                final CharSequence value = method.getKey(keyFunction, record);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">                if (value != null) {</span>
<span class="fc" id="L201">                    final int index = map.keyIndex(value);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                    if (index &lt; 0) {</span>
<span class="fc" id="L203">                        return map.valueAtQuick(index);</span>
                    }
                }
<span class="fc" id="L206">                return elseB;</span>
            };
        } else {
<span class="fc" id="L209">            final Function nullFuncRef = nullFunc;</span>
<span class="fc" id="L210">            picker = record -&gt; {</span>
<span class="fc" id="L211">                final CharSequence value = method.getKey(keyFunction, record);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                if (value == null) {</span>
<span class="fc" id="L213">                    return nullFuncRef;</span>
                }
<span class="fc" id="L215">                final int index = map.keyIndex(value);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                if (index &lt; 0) {</span>
<span class="fc" id="L217">                    return map.valueAtQuick(index);</span>
                }
<span class="fc" id="L219">                return elseB;</span>
            };
<span class="fc" id="L221">            argsToPoke.add(nullFunc);</span>
        }
<span class="fc" id="L223">        argsToPoke.add(elseB);</span>
<span class="fc" id="L224">        argsToPoke.add(keyFunction);</span>
<span class="fc" id="L225">        return CaseCommon.getCaseFunction(position, valueType, picker, argsToPoke);</span>
    }

    private Function getElseFunction(int valueType, Function elseBranch) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">        return elseBranch != null ? elseBranch : Constants.getNullConstant(valueType);</span>
    }

    private Function getIfElseFunction(
            ObjList&lt;Function&gt; args,
            IntList argPositions,
            int position,
            int n,
            Function keyFunction,
            int returnType,
            Function elseBranch
    ) throws SqlException {
        final CaseFunctionPicker picker;
        final ObjList&lt;Function&gt; argsToPoke;
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (n == 3) {</span>
            // only one conditional branch
<span class="fc" id="L245">            boolean value = args.getQuick(1).getBool(null);</span>
<span class="fc" id="L246">            final Function branch = args.getQuick(2);</span>

<span class="fc" id="L248">            final Function elseB = getElseFunction(returnType, elseBranch);</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (value) {</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">                picker = record -&gt; keyFunction.getBool(record) ? branch : elseB;</span>
            } else {
<span class="fc bfc" id="L253" title="All 2 branches covered.">                picker = record -&gt; keyFunction.getBool(record) ? elseB : branch;</span>
            }

<span class="fc" id="L256">            argsToPoke = new ObjList&lt;&gt;();</span>
<span class="fc" id="L257">            argsToPoke.add(keyFunction);</span>
<span class="fc" id="L258">            argsToPoke.add(elseB);</span>
<span class="fc" id="L259">            argsToPoke.add(branch);</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">        } else if (n == 5) {</span>
<span class="fc" id="L262">            final boolean a = args.getQuick(1).getBool(null);</span>
<span class="fc" id="L263">            final Function branchA = args.getQuick(2);</span>
<span class="fc" id="L264">            final boolean b = args.getQuick(3).getBool(null);</span>
<span class="fc" id="L265">            final Function branchB = args.getQuick(4);</span>

<span class="fc bfc" id="L267" title="All 8 branches covered.">            if (a &amp;&amp; b || !a &amp;&amp; !b) {</span>
<span class="fc" id="L268">                throw SqlException.$(argPositions.getQuick(3), &quot;duplicate branch&quot;);</span>
            }

<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (a) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                picker = record -&gt; keyFunction.getBool(record) ? branchA : branchB;</span>
            } else {
<span class="fc bfc" id="L274" title="All 2 branches covered.">                picker = record -&gt; keyFunction.getBool(record) ? branchB : branchA;</span>
            }

<span class="fc" id="L277">            argsToPoke = new ObjList&lt;&gt;();</span>
<span class="fc" id="L278">            argsToPoke.add(keyFunction);</span>
<span class="fc" id="L279">            argsToPoke.add(branchA);</span>
<span class="fc" id="L280">            argsToPoke.add(branchB);</span>
<span class="fc" id="L281">        } else {</span>
<span class="fc" id="L282">            throw SqlException.$(argPositions.getQuick(5), &quot;too many branches&quot;);</span>
        }

<span class="fc" id="L285">        return CaseCommon.getCaseFunction(position, returnType, picker, argsToPoke);</span>
    }

    private Function getIntKeyedFunction(
            ObjList&lt;Function&gt; args,
            IntList argPositions,
            int position,
            int n,
            Function keyFunction,
            int valueType,
            Function elseBranch,
            IntMethod intMethod
    ) throws SqlException {
<span class="fc" id="L298">        final IntObjHashMap&lt;Function&gt; map = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L299">        final ObjList&lt;Function&gt; argsToPoke = new ObjList&lt;&gt;();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        for (int i = 1; i &lt; n; i += 2) {</span>
<span class="fc" id="L301">            final Function fun = args.getQuick(i);</span>
<span class="fc" id="L302">            final int key = intMethod.getKey(fun, null);</span>
<span class="fc" id="L303">            final int index = map.keyIndex(key);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if (index &lt; 0) {</span>
<span class="fc" id="L305">                throw SqlException.$(argPositions.getQuick(i), &quot;duplicate branch&quot;);</span>
            }
<span class="fc" id="L307">            map.putAt(index, key, args.getQuick(i + 1));</span>
<span class="fc" id="L308">            argsToPoke.add(args.getQuick(i + 1));</span>
        }

<span class="fc" id="L311">        final Function elseB = getElseFunction(valueType, elseBranch);</span>
<span class="fc" id="L312">        final CaseFunctionPicker picker = record -&gt; {</span>
<span class="fc" id="L313">            final int index = map.keyIndex(intMethod.getKey(keyFunction, record));</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">            if (index &lt; 0) {</span>
<span class="fc" id="L315">                return map.valueAtQuick(index);</span>
            }
<span class="fc" id="L317">            return elseB;</span>
        };

<span class="fc" id="L320">        argsToPoke.add(elseB);</span>
<span class="fc" id="L321">        argsToPoke.add(keyFunction);</span>

<span class="fc" id="L323">        return CaseCommon.getCaseFunction(position, valueType, picker, argsToPoke);</span>
    }

    private Function getLongKeyedFunction(
            ObjList&lt;Function&gt; args,
            IntList argPositions,
            int position,
            int n,
            Function keyFunction,
            int valueType,
            Function elseBranch,
            LongMethod longMethod
    ) throws SqlException {
<span class="fc" id="L336">        final LongObjHashMap&lt;Function&gt; map = new LongObjHashMap&lt;&gt;();</span>
<span class="fc" id="L337">        final ObjList&lt;Function&gt; argsToPoke = new ObjList&lt;&gt;();</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (int i = 1; i &lt; n; i += 2) {</span>
<span class="fc" id="L339">            final Function fun = args.getQuick(i);</span>
<span class="fc" id="L340">            final long key = longMethod.getKey(fun, null);</span>
<span class="fc" id="L341">            final int index = map.keyIndex(key);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">            if (index &lt; 0) {</span>
<span class="fc" id="L343">                throw SqlException.$(argPositions.getQuick(i), &quot;duplicate branch&quot;);</span>
            }
<span class="fc" id="L345">            map.putAt(index, key, args.getQuick(i + 1));</span>
<span class="fc" id="L346">            argsToPoke.add(args.getQuick(i + 1));</span>
        }

<span class="fc" id="L349">        final Function elseB = getElseFunction(valueType, elseBranch);</span>
<span class="fc" id="L350">        final CaseFunctionPicker picker = record -&gt; {</span>
<span class="fc" id="L351">            final int index = map.keyIndex(longMethod.getKey(keyFunction, record));</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (index &lt; 0) {</span>
<span class="fc" id="L353">                return map.valueAtQuick(index);</span>
            }
<span class="fc" id="L355">            return elseB;</span>
        };
<span class="fc" id="L357">        argsToPoke.add(elseB);</span>
<span class="fc" id="L358">        argsToPoke.add(keyFunction);</span>

<span class="fc" id="L360">        return CaseCommon.getCaseFunction(position, valueType, picker, argsToPoke);</span>
    }

    @FunctionalInterface
    private interface CharSequenceMethod {
        CharSequence getKey(Function function, Record record);
    }

    @FunctionalInterface
    private interface IntMethod {
        int getKey(Function function, Record record);
    }

    @FunctionalInterface
    private interface LongMethod {
        long getKey(Function function, Record record);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>