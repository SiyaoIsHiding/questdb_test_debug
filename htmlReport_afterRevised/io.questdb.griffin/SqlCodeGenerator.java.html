<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlCodeGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin</a> &gt; <span class="el_source">SqlCodeGenerator.java</span></div><h1>SqlCodeGenerator.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin;

import io.questdb.cairo.*;
import io.questdb.cairo.map.RecordValueSink;
import io.questdb.cairo.map.RecordValueSinkFactory;
import io.questdb.cairo.sql.Record;
import io.questdb.cairo.sql.*;
import io.questdb.cairo.sql.async.PageFrameReduceTask;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryCARW;
import io.questdb.griffin.engine.*;
import io.questdb.griffin.engine.analytic.AnalyticFunction;
import io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory;
import io.questdb.griffin.engine.functions.GroupByFunction;
import io.questdb.griffin.engine.functions.SymbolFunction;
import io.questdb.griffin.engine.functions.bind.IndexedParameterLinkFunction;
import io.questdb.griffin.engine.functions.bind.NamedParameterLinkFunction;
import io.questdb.griffin.engine.functions.cast.*;
import io.questdb.griffin.engine.functions.columns.*;
import io.questdb.griffin.engine.functions.constants.*;
import io.questdb.griffin.engine.groupby.*;
import io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory;
import io.questdb.griffin.engine.groupby.vect.*;
import io.questdb.griffin.engine.join.*;
import io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory;
import io.questdb.griffin.engine.orderby.RecordComparatorCompiler;
import io.questdb.griffin.engine.orderby.SortedLightRecordCursorFactory;
import io.questdb.griffin.engine.orderby.SortedRecordCursorFactory;
import io.questdb.griffin.engine.table.*;
import io.questdb.griffin.engine.union.*;
import io.questdb.griffin.model.*;
import io.questdb.jit.CompiledFilter;
import io.questdb.jit.CompiledFilterIRSerializer;
import io.questdb.jit.JitUtil;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.Closeable;
import java.util.ArrayDeque;

import static io.questdb.cairo.sql.DataFrameCursorFactory.ORDER_ANY;
import static io.questdb.griffin.SqlKeywords.*;
import static io.questdb.griffin.model.ExpressionNode.FUNCTION;
import static io.questdb.griffin.model.ExpressionNode.LITERAL;
import static io.questdb.griffin.model.ExpressionNode.CONSTANT;
import static io.questdb.griffin.model.QueryModel.*;

public class SqlCodeGenerator implements Mutable, Closeable {
    public static final int GKK_HOUR_INT = 1;
    public static final int GKK_VANILLA_INT = 0;
<span class="fc" id="L78">    private static final ModelOperator BACKUP_WHERE_CLAUSE = QueryModel::backupWhereClause;</span>
<span class="fc" id="L79">    private static final VectorAggregateFunctionConstructor COUNT_CONSTRUCTOR = (keyKind, columnIndex, workerCount) -&gt; new CountVectorAggregateFunction(keyKind);</span>
<span class="fc" id="L80">    private static final FullFatJoinGenerator CREATE_FULL_FAT_AS_OF_JOIN = SqlCodeGenerator::createFullFatAsOfJoin;</span>
<span class="fc" id="L81">    private static final FullFatJoinGenerator CREATE_FULL_FAT_LT_JOIN = SqlCodeGenerator::createFullFatLtJoin;</span>
<span class="fc" id="L82">    private static final Log LOG = LogFactory.getLog(SqlCodeGenerator.class);</span>
<span class="fc" id="L83">    private static final ModelOperator RESTORE_WHERE_CLAUSE = QueryModel::restoreWhereClause;</span>
<span class="fc" id="L84">    private static final SetRecordCursorFactoryConstructor SET_EXCEPT_CONSTRUCTOR = ExceptRecordCursorFactory::new;</span>
<span class="fc" id="L85">    private static final SetRecordCursorFactoryConstructor SET_INTERSECT_CONSTRUCTOR = IntersectRecordCursorFactory::new;</span>
<span class="fc" id="L86">    private static final SetRecordCursorFactoryConstructor SET_UNION_CONSTRUCTOR = UnionRecordCursorFactory::new;</span>
<span class="fc" id="L87">    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; avgConstructors = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L88">    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; countConstructors = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L89">    private static final boolean[] joinsRequiringTimestamp = new boolean[JOIN_MAX + 1];</span>
<span class="fc" id="L90">    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; ksumConstructors = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L91">    private static final IntHashSet limitTypes = new IntHashSet();</span>
<span class="fc" id="L92">    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; maxConstructors = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L93">    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; minConstructors = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L94">    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; nsumConstructors = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L95">    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; sumConstructors = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L96">    private final ArrayColumnTypes arrayColumnTypes = new ArrayColumnTypes();</span>
<span class="fc" id="L97">    private final BytecodeAssembler asm = new BytecodeAssembler();</span>
    private final CairoConfiguration configuration;
<span class="fc" id="L99">    private final ObjList&lt;TableColumnMetadata&gt; deferredAnalyticMetadata = new ObjList&lt;&gt;();</span>
    private final boolean enableJitDebug;
    private final CairoEngine engine;
<span class="fc" id="L102">    private final EntityColumnFilter entityColumnFilter = new EntityColumnFilter();</span>
    private final ObjectPool&lt;ExpressionNode&gt; expressionNodePool;
    private final FunctionParser functionParser;
<span class="fc" id="L105">    private final IntList groupByFunctionPositions = new IntList();</span>
<span class="fc" id="L106">    private final ObjObjHashMap&lt;IntList, ObjList&lt;AnalyticFunction&gt;&gt; groupedAnalytic = new ObjObjHashMap&lt;&gt;();</span>
<span class="fc" id="L107">    private final IntHashSet intHashSet = new IntHashSet();</span>
<span class="fc" id="L108">    private final ObjectPool&lt;IntList&gt; intListPool = new ObjectPool&lt;&gt;(IntList::new, 4);</span>
    private final MemoryCARW jitIRMem;
<span class="fc" id="L110">    private final CompiledFilterIRSerializer jitIRSerializer = new CompiledFilterIRSerializer();</span>
<span class="fc" id="L111">    private final ArrayColumnTypes keyTypes = new ArrayColumnTypes();</span>
    // this list is used to generate record sinks
<span class="fc" id="L113">    private final ListColumnFilter listColumnFilterA = new ListColumnFilter();</span>
<span class="fc" id="L114">    private final ListColumnFilter listColumnFilterB = new ListColumnFilter();</span>
<span class="fc" id="L115">    private final LongList prefixes = new LongList();</span>
    private final RecordComparatorCompiler recordComparatorCompiler;
<span class="fc" id="L117">    private final IntList recordFunctionPositions = new IntList();</span>
    private final WeakClosableObjectPool&lt;PageFrameReduceTask&gt; reduceTaskPool;

<span class="fc" id="L120">    private final ArrayDeque&lt;ExpressionNode&gt; sqlNodeStack = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L121">    private final WhereClauseSymbolEstimator symbolEstimator = new WhereClauseSymbolEstimator();</span>
<span class="fc" id="L122">    private final IntList tempAggIndex = new IntList();</span>
<span class="fc" id="L123">    private final IntList tempKeyIndex = new IntList();</span>
<span class="fc" id="L124">    private final IntList tempKeyIndexesInBase = new IntList();</span>
<span class="fc" id="L125">    private final IntList tempKeyKinds = new IntList();</span>
<span class="fc" id="L126">    private final GenericRecordMetadata tempMetadata = new GenericRecordMetadata();</span>
<span class="fc" id="L127">    private final IntList tempSymbolSkewIndexes = new IntList();</span>
<span class="fc" id="L128">    private final ObjList&lt;VectorAggregateFunction&gt; tempVaf = new ObjList&lt;&gt;();</span>
<span class="fc" id="L129">    private final IntList tempVecConstructorArgIndexes = new IntList();</span>
<span class="fc" id="L130">    private final ObjList&lt;VectorAggregateFunctionConstructor&gt; tempVecConstructors = new ObjList&lt;&gt;();</span>
<span class="fc" id="L131">    private final ArrayColumnTypes valueTypes = new ArrayColumnTypes();</span>
<span class="fc" id="L132">    private final WhereClauseParser whereClauseParser = new WhereClauseParser();</span>
<span class="fc" id="L133">    private boolean enableJitNullChecks = true;</span>
<span class="fc" id="L134">    private boolean fullFatJoins = false;</span>

    public SqlCodeGenerator(
            CairoEngine engine,
            CairoConfiguration configuration,
            FunctionParser functionParser,
            ObjectPool&lt;ExpressionNode&gt; expressionNodePool
<span class="fc" id="L141">    ) {</span>
<span class="fc" id="L142">        this.engine = engine;</span>
<span class="fc" id="L143">        this.configuration = configuration;</span>
<span class="fc" id="L144">        this.functionParser = functionParser;</span>
<span class="fc" id="L145">        this.recordComparatorCompiler = new RecordComparatorCompiler(asm);</span>
<span class="fc" id="L146">        this.enableJitDebug = configuration.isSqlJitDebugEnabled();</span>
<span class="fc" id="L147">        this.jitIRMem = Vm.getCARWInstance(configuration.getSqlJitIRMemoryPageSize(),</span>
<span class="fc" id="L148">                configuration.getSqlJitIRMemoryMaxPages(), MemoryTag.NATIVE_JIT);</span>
        // Pre-touch JIT IR memory to avoid false positive memory leak detections.
<span class="fc" id="L150">        jitIRMem.putByte((byte) 0);</span>
<span class="fc" id="L151">        jitIRMem.truncate();</span>
<span class="fc" id="L152">        this.expressionNodePool = expressionNodePool;</span>
<span class="fc" id="L153">        this.reduceTaskPool = new WeakClosableObjectPool&lt;&gt;(</span>
<span class="fc" id="L154">                () -&gt; new PageFrameReduceTask(configuration),</span>
<span class="fc" id="L155">                configuration.getPageFrameReduceTaskPoolCapacity()</span>
        );
<span class="fc" id="L157">    }</span>

    @Override
    public void clear() {
<span class="fc" id="L161">        whereClauseParser.clear();</span>
<span class="fc" id="L162">        symbolEstimator.clear();</span>
<span class="fc" id="L163">        intListPool.clear();</span>
<span class="fc" id="L164">    }</span>

    @Override
    public void close() {
<span class="fc" id="L168">        Misc.free(jitIRMem);</span>
<span class="fc" id="L169">        Misc.free(reduceTaskPool);</span>
<span class="fc" id="L170">    }</span>

    @NotNull
    public Function compileBooleanFilter(
            ExpressionNode expr,
            RecordMetadata metadata,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L178">        final Function filter = functionParser.parseFunction(expr, metadata, executionContext);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (ColumnType.isBoolean(filter.getType())) {</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            return filter;</span>
        }
<span class="fc" id="L182">        Misc.free(filter);</span>
<span class="fc" id="L183">        throw SqlException.$(expr.position, &quot;boolean expression expected&quot;);</span>
    }

    public RecordCursorFactory generate(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L187">        return generateQuery(model, executionContext, true);</span>
    }

    public RecordCursorFactory generateExplain(QueryModel model, RecordCursorFactory factory, int format) {
<span class="fc" id="L191">        RecordCursorFactory recordCursorFactory = new RecordCursorFactoryStub(model, factory);</span>
<span class="fc" id="L192">        return new ExplainPlanFactory(recordCursorFactory, format);</span>
    }

    public RecordCursorFactory generateExplain(ExplainModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L196">        ExecutionModel innerModel = model.getInnerExecutionModel();</span>
<span class="fc" id="L197">        QueryModel queryModel = innerModel.getQueryModel();</span>
        RecordCursorFactory factory;
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (queryModel != null) {</span>
<span class="fc" id="L200">            factory = generate(queryModel, executionContext);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (innerModel.getModelType() != QUERY) {</span>
<span class="fc" id="L202">                factory = new RecordCursorFactoryStub(innerModel, factory);</span>
            }
        } else {
<span class="fc" id="L205">            factory = new RecordCursorFactoryStub(innerModel, null);</span>
        }

<span class="fc" id="L208">        return new ExplainPlanFactory(factory, model.getFormat());</span>
    }

    private static boolean allGroupsFirstLastWithSingleSymbolFilter(QueryModel model, RecordMetadata metadata) {
<span class="fc" id="L212">        final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (int i = 0, n = columns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L214">            final QueryColumn column = columns.getQuick(i);</span>
<span class="fc" id="L215">            final ExpressionNode node = column.getAst();</span>

<span class="fc bfc" id="L217" title="All 2 branches covered.">            if (node.type != ExpressionNode.LITERAL) {</span>
<span class="fc" id="L218">                ExpressionNode columnAst = column.getAst();</span>
<span class="fc" id="L219">                CharSequence token = columnAst.token;</span>
<span class="fc bfc" id="L220" title="All 4 branches covered.">                if (!SqlKeywords.isFirstKeyword(token) &amp;&amp; !SqlKeywords.isLastKeyword(token)) {</span>
<span class="fc" id="L221">                    return false;</span>
                }

<span class="pc bpc" id="L224" title="1 of 4 branches missed.">                if (columnAst.rhs.type != ExpressionNode.LITERAL || metadata.getColumnIndex(columnAst.rhs.token) &lt; 0) {</span>
<span class="fc" id="L225">                    return false;</span>
                }
            }
        }

<span class="fc" id="L230">        return true;</span>
    }

    private static RecordCursorFactory createFullFatAsOfJoin(CairoConfiguration configuration,
                                                             RecordMetadata metadata,
                                                             RecordCursorFactory masterFactory,
                                                             RecordCursorFactory slaveFactory,
                                                             @Transient ColumnTypes mapKeyTypes,
                                                             @Transient ColumnTypes mapValueTypes,
                                                             @Transient ColumnTypes slaveColumnTypes,
                                                             RecordSink masterKeySink,
                                                             RecordSink slaveKeySink,
                                                             int columnSplit,
                                                             RecordValueSink slaveValueSink,
                                                             IntList columnIndex,
                                                             JoinContext joinContext) {
<span class="fc" id="L246">        return new AsOfJoinRecordCursorFactory(configuration, metadata, masterFactory, slaveFactory, mapKeyTypes, mapValueTypes, slaveColumnTypes, masterKeySink, slaveKeySink, columnSplit, slaveValueSink, columnIndex, joinContext);</span>
    }

    private static RecordCursorFactory createFullFatLtJoin(CairoConfiguration configuration,
                                                           RecordMetadata metadata,
                                                           RecordCursorFactory masterFactory,
                                                           RecordCursorFactory slaveFactory,
                                                           @Transient ColumnTypes mapKeyTypes,
                                                           @Transient ColumnTypes mapValueTypes,
                                                           @Transient ColumnTypes slaveColumnTypes,
                                                           RecordSink masterKeySink,
                                                           RecordSink slaveKeySink,
                                                           int columnSplit,
                                                           RecordValueSink slaveValueSink,
                                                           IntList columnIndex,
                                                           JoinContext joinContext) {
<span class="fc" id="L262">        return new LtJoinRecordCursorFactory(configuration, metadata, masterFactory, slaveFactory, mapKeyTypes, mapValueTypes, slaveColumnTypes, masterKeySink, slaveKeySink, columnSplit, slaveValueSink, columnIndex, joinContext);</span>
    }

    private static int getOrderByDirectionOrDefault(QueryModel model, int index) {
<span class="fc" id="L266">        IntList direction = model.getOrderByDirectionAdvice();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (index &gt;= direction.size()) {</span>
<span class="fc" id="L268">            return ORDER_DIRECTION_ASCENDING;</span>
        }
<span class="fc" id="L270">        return model.getOrderByDirectionAdvice().getQuick(index);</span>
    }

    private VectorAggregateFunctionConstructor assembleFunctionReference(RecordMetadata metadata, ExpressionNode ast) {
        int columnIndex;
<span class="pc bpc" id="L275" title="1 of 8 branches missed.">        if (ast.type == FUNCTION &amp;&amp; ast.paramCount == 1 &amp;&amp; SqlKeywords.isSumKeyword(ast.token) &amp;&amp; ast.rhs.type == LITERAL) {</span>
<span class="fc" id="L276">            columnIndex = metadata.getColumnIndex(ast.rhs.token);</span>
<span class="fc" id="L277">            tempVecConstructorArgIndexes.add(columnIndex);</span>
<span class="fc" id="L278">            return sumConstructors.get(metadata.getColumnType(columnIndex));</span>
<span class="pc bpc" id="L279" title="2 of 10 branches missed.">        } else if (ast.type == FUNCTION &amp;&amp; SqlKeywords.isCountKeyword(ast.token) &amp;&amp;</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">                (ast.paramCount == 0 || (ast.paramCount == 1 &amp;&amp; ast.rhs.type == CONSTANT &amp;&amp; !isNullKeyword(ast.rhs.token)))) {</span>
            // count() is a no-arg function, count(1) is the same as count(*)
<span class="fc" id="L282">            tempVecConstructorArgIndexes.add(-1);</span>
<span class="fc" id="L283">            return COUNT_CONSTRUCTOR;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        } else if (isSingleColumnFunction(ast, &quot;count&quot;)) {</span>
<span class="fc" id="L285">            columnIndex = metadata.getColumnIndex(ast.rhs.token);</span>
<span class="fc" id="L286">            tempVecConstructorArgIndexes.add(columnIndex);</span>
<span class="fc" id="L287">            return countConstructors.get(metadata.getColumnType(columnIndex));</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        } else if (isSingleColumnFunction(ast, &quot;ksum&quot;)) {</span>
<span class="fc" id="L289">            columnIndex = metadata.getColumnIndex(ast.rhs.token);</span>
<span class="fc" id="L290">            tempVecConstructorArgIndexes.add(columnIndex);</span>
<span class="fc" id="L291">            return ksumConstructors.get(metadata.getColumnType(columnIndex));</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">        } else if (isSingleColumnFunction(ast, &quot;nsum&quot;)) {</span>
<span class="fc" id="L293">            columnIndex = metadata.getColumnIndex(ast.rhs.token);</span>
<span class="fc" id="L294">            tempVecConstructorArgIndexes.add(columnIndex);</span>
<span class="fc" id="L295">            return nsumConstructors.get(metadata.getColumnType(columnIndex));</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        } else if (isSingleColumnFunction(ast, &quot;avg&quot;)) {</span>
<span class="fc" id="L297">            columnIndex = metadata.getColumnIndex(ast.rhs.token);</span>
<span class="fc" id="L298">            tempVecConstructorArgIndexes.add(columnIndex);</span>
<span class="fc" id="L299">            return avgConstructors.get(metadata.getColumnType(columnIndex));</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        } else if (isSingleColumnFunction(ast, &quot;min&quot;)) {</span>
<span class="fc" id="L301">            columnIndex = metadata.getColumnIndex(ast.rhs.token);</span>
<span class="fc" id="L302">            tempVecConstructorArgIndexes.add(columnIndex);</span>
<span class="fc" id="L303">            return minConstructors.get(metadata.getColumnType(columnIndex));</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">        } else if (isSingleColumnFunction(ast, &quot;max&quot;)) {</span>
<span class="fc" id="L305">            columnIndex = metadata.getColumnIndex(ast.rhs.token);</span>
<span class="fc" id="L306">            tempVecConstructorArgIndexes.add(columnIndex);</span>
<span class="fc" id="L307">            return maxConstructors.get(metadata.getColumnType(columnIndex));</span>
        }
<span class="fc" id="L309">        return null;</span>
    }

    private boolean assembleKeysAndFunctionReferences(
            ObjList&lt;QueryColumn&gt; columns,
            RecordMetadata metadata,
            boolean checkLiterals
    ) {
<span class="fc" id="L317">        tempVaf.clear();</span>
<span class="fc" id="L318">        tempMetadata.clear();</span>
<span class="fc" id="L319">        tempSymbolSkewIndexes.clear();</span>
<span class="fc" id="L320">        tempVecConstructors.clear();</span>
<span class="fc" id="L321">        tempVecConstructorArgIndexes.clear();</span>
<span class="fc" id="L322">        tempAggIndex.clear();</span>

<span class="fc bfc" id="L324" title="All 2 branches covered.">        for (int i = 0, n = columns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L325">            final QueryColumn qc = columns.getQuick(i);</span>
<span class="fc" id="L326">            final ExpressionNode ast = qc.getAst();</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (ast.type == LITERAL) {</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">                if (checkLiterals) {</span>
<span class="fc" id="L329">                    final int columnIndex = metadata.getColumnIndex(ast.token);</span>
<span class="fc" id="L330">                    final int type = metadata.getColumnType(columnIndex);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">                    if (ColumnType.isInt(type)) {</span>
<span class="fc" id="L332">                        tempKeyIndexesInBase.add(columnIndex);</span>
<span class="fc" id="L333">                        tempKeyIndex.add(i);</span>
<span class="fc" id="L334">                        arrayColumnTypes.add(ColumnType.INT);</span>
<span class="fc" id="L335">                        tempKeyKinds.add(GKK_VANILLA_INT);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                    } else if (ColumnType.isSymbol(type)) {</span>
<span class="fc" id="L337">                        tempKeyIndexesInBase.add(columnIndex);</span>
<span class="fc" id="L338">                        tempKeyIndex.add(i);</span>
<span class="fc" id="L339">                        tempSymbolSkewIndexes.extendAndSet(i, columnIndex);</span>
<span class="fc" id="L340">                        arrayColumnTypes.add(ColumnType.SYMBOL);</span>
<span class="fc" id="L341">                        tempKeyKinds.add(GKK_VANILLA_INT);</span>
                    } else {
<span class="fc" id="L343">                        return false;</span>
                    }
<span class="fc" id="L345">                }</span>
            } else {
<span class="fc" id="L347">                final VectorAggregateFunctionConstructor constructor = assembleFunctionReference(metadata, ast);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (constructor != null) {</span>
<span class="fc" id="L349">                    tempVecConstructors.add(constructor);</span>
<span class="fc" id="L350">                    tempAggIndex.add(i);</span>
                } else {
<span class="fc" id="L352">                    return false;</span>
                }
            }
        }
<span class="fc" id="L356">        return true;</span>
    }

    private void backupWhereClause(ExpressionNode node) {
<span class="fc" id="L360">        processNodeQueryModels(node, BACKUP_WHERE_CLAUSE);</span>
<span class="fc" id="L361">    }</span>

    // Check if lo, hi is set and lo &gt;=0 while hi &lt; 0 (meaning - return whole result set except some rows at start and some at the end)
    // because such case can't really be optimized by topN/bottomN
    private boolean canBeOptimized(QueryModel model, SqlExecutionContext context, Function loFunc, Function hiFunc) {
<span class="pc bpc" id="L366" title="1 of 4 branches missed.">        if (model.getLimitLo() == null &amp;&amp; model.getLimitHi() == null) {</span>
<span class="fc" id="L367">            return false;</span>
        }

<span class="pc bpc" id="L370" title="2 of 6 branches missed.">        if (loFunc != null &amp;&amp; loFunc.isConstant()</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">                &amp;&amp; hiFunc != null &amp;&amp; hiFunc.isConstant()) {</span>
            try {
<span class="fc" id="L373">                loFunc.init(null, context);</span>
<span class="fc" id="L374">                hiFunc.init(null, context);</span>

<span class="fc bfc" id="L376" title="All 4 branches covered.">                return !(loFunc.getLong(null) &gt;= 0 &amp;&amp; hiFunc.getLong(null) &lt; 0);</span>
<span class="nc" id="L377">            } catch (SqlException ex) {</span>
<span class="nc" id="L378">                LOG.error().$(&quot;Failed to initialize lo or hi functions [&quot;).$(&quot;error=&quot;).$(ex.getMessage()).I$();</span>
            }
        }

<span class="fc" id="L382">        return true;</span>
    }

    private boolean checkIfSetCastIsRequired(RecordMetadata metadataA, RecordMetadata metadataB, boolean symbolDisallowed) {
<span class="fc" id="L386">        int columnCount = metadataA.getColumnCount();</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        assert columnCount == metadataB.getColumnCount();</span>

<span class="fc bfc" id="L389" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L390">            int typeA = metadataA.getColumnType(i);</span>
<span class="fc" id="L391">            int typeB = metadataB.getColumnType(i);</span>
<span class="fc bfc" id="L392" title="All 6 branches covered.">            if (typeA != typeB || (typeA == ColumnType.SYMBOL &amp;&amp; symbolDisallowed)) {</span>
<span class="fc" id="L393">                return true;</span>
            }
        }
<span class="fc" id="L396">        return false;</span>
    }

    @Nullable
    private Function compileFilter(
            IntrinsicModel intrinsicModel,
            RecordMetadata readerMeta,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (intrinsicModel.filter != null) {</span>
<span class="fc" id="L406">            return compileBooleanFilter(intrinsicModel.filter, readerMeta, executionContext);</span>
        }
<span class="fc" id="L408">        return null;</span>
    }

    private @Nullable ObjList&lt;Function&gt; compileWorkerFilterConditionally(
            boolean condition,
            int workerCount,
            ExpressionNode filterExpr,
            RecordMetadata metadata,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (condition) {</span>
<span class="fc" id="L419">            ObjList&lt;Function&gt; workerFilters = new ObjList&lt;&gt;();</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">            for (int i = 0; i &lt; workerCount; i++) {</span>
<span class="fc" id="L421">                restoreWhereClause(filterExpr);//restore original filters in node query models</span>
<span class="fc" id="L422">                workerFilters.extendAndSet(i, compileBooleanFilter(filterExpr, metadata, executionContext));</span>
            }
<span class="fc" id="L424">            return workerFilters;</span>
        }
<span class="fc" id="L426">        return null;</span>
    }

    private RecordCursorFactory createAsOfJoin(
            RecordMetadata metadata,
            RecordCursorFactory master,
            RecordSink masterKeySink,
            RecordCursorFactory slave,
            RecordSink slaveKeySink,
            int columnSplit,
            JoinContext joinContext
    ) {
<span class="fc" id="L438">        valueTypes.clear();</span>
<span class="fc" id="L439">        valueTypes.add(ColumnType.LONG);</span>
<span class="fc" id="L440">        valueTypes.add(ColumnType.LONG);</span>

<span class="fc" id="L442">        return new AsOfJoinLightRecordCursorFactory(</span>
                configuration,
                metadata,
                master,
                slave,
                keyTypes,
                valueTypes,
                masterKeySink,
                slaveKeySink,
                columnSplit,
                joinContext
        );
    }

    @NotNull
    private RecordCursorFactory createFullFatJoin(
            RecordCursorFactory master,
            RecordMetadata masterMetadata,
            CharSequence masterAlias,
            RecordCursorFactory slave,
            RecordMetadata slaveMetadata,
            CharSequence slaveAlias,
            int joinPosition,
            FullFatJoinGenerator generator,
            JoinContext joinContext
    ) throws SqlException {

        // create hash set of key columns to easily find them
<span class="fc" id="L470">        intHashSet.clear();</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        for (int i = 0, n = listColumnFilterA.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L472">            intHashSet.add(listColumnFilterA.getColumnIndexFactored(i));</span>
        }

        // map doesn't support variable length types in map value, which is ok
        // when we join tables on strings - technically string is the key,
        // and we do not need to store it in value, but we will still reject
        //
        // never mind, this is a stop-gap measure until I understand the problem
        // fully

<span class="fc bfc" id="L482" title="All 2 branches covered.">        for (int k = 0, m = slaveMetadata.getColumnCount(); k &lt; m; k++) {</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (intHashSet.excludes(k)) {</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">                if (ColumnType.isVariableLength(slaveMetadata.getColumnType(k))) {</span>
<span class="fc" id="L485">                    throw SqlException</span>
<span class="fc" id="L486">                            .position(joinPosition).put(&quot;right side column '&quot;)</span>
<span class="fc" id="L487">                            .put(slaveMetadata.getColumnName(k)).put(&quot;' is of unsupported type&quot;);</span>
                }
            }
        }

<span class="fc" id="L492">        RecordSink masterSink = RecordSinkFactory.getInstance(</span>
                asm,
                masterMetadata,
                listColumnFilterB,
                true
        );

        // This metadata allocates native memory, it has to be closed in case join
        // generation is unsuccessful. The exception can be thrown anywhere between
        // try...catch
<span class="fc" id="L502">        JoinRecordMetadata metadata = new JoinRecordMetadata(</span>
                configuration,
<span class="fc" id="L504">                masterMetadata.getColumnCount() + slaveMetadata.getColumnCount()</span>
        );

        try {

            // metadata will have master record verbatim
<span class="fc" id="L510">            metadata.copyColumnMetadataFrom(masterAlias, masterMetadata);</span>

            // slave record is split across key and value of map
            // the rationale is not to store columns twice
            // especially when map value does not support variable
            // length types


<span class="fc" id="L518">            final IntList columnIndex = new IntList(slaveMetadata.getColumnCount());</span>
            // In map record value columns go first, so at this stage
            // we add to metadata all slave columns that are not keys.
            // Add same columns to filter while we are in this loop.
<span class="fc" id="L522">            listColumnFilterB.clear();</span>
<span class="fc" id="L523">            valueTypes.clear();</span>
<span class="fc" id="L524">            ArrayColumnTypes slaveTypes = new ArrayColumnTypes();</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">            if (slaveMetadata instanceof AbstractRecordMetadata) {</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                for (int i = 0, n = slaveMetadata.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                    if (intHashSet.excludes(i)) {</span>
<span class="fc" id="L528">                        final TableColumnMetadata m = ((AbstractRecordMetadata) slaveMetadata).getColumnMetadata(i);</span>
<span class="fc" id="L529">                        metadata.add(slaveAlias, m);</span>
<span class="fc" id="L530">                        listColumnFilterB.add(i + 1);</span>
<span class="fc" id="L531">                        columnIndex.add(i);</span>
<span class="fc" id="L532">                        valueTypes.add(m.getType());</span>
<span class="fc" id="L533">                        slaveTypes.add(m.getType());</span>
                    }
                }

                // now add key columns to metadata
<span class="fc bfc" id="L538" title="All 2 branches covered.">                for (int i = 0, n = listColumnFilterA.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L539">                    int index = listColumnFilterA.getColumnIndexFactored(i);</span>
<span class="fc" id="L540">                    final TableColumnMetadata m = ((AbstractRecordMetadata) slaveMetadata).getColumnMetadata(index);</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">                    if (ColumnType.isSymbol(m.getType())) {</span>
<span class="fc" id="L542">                        metadata.add(</span>
                                slaveAlias,
<span class="fc" id="L544">                                m.getName(),</span>
                                ColumnType.STRING,
                                false,
                                0,
                                false,
                                null
                        );
<span class="fc" id="L551">                        slaveTypes.add(ColumnType.STRING);</span>
                    } else {
<span class="fc" id="L553">                        metadata.add(slaveAlias, m);</span>
<span class="fc" id="L554">                        slaveTypes.add(m.getType());</span>
                    }
<span class="fc" id="L556">                    columnIndex.add(index);</span>
                }
            } else {
<span class="nc bnc" id="L559" title="All 2 branches missed.">                for (int i = 0, n = slaveMetadata.getColumnCount(); i &lt; n; i++) {</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                    if (intHashSet.excludes(i)) {</span>
<span class="nc" id="L561">                        int type = slaveMetadata.getColumnType(i);</span>
<span class="nc" id="L562">                        metadata.add(</span>
                                slaveAlias,
<span class="nc" id="L564">                                slaveMetadata.getColumnName(i),</span>
                                type,
<span class="nc" id="L566">                                slaveMetadata.isColumnIndexed(i),</span>
<span class="nc" id="L567">                                slaveMetadata.getIndexValueBlockCapacity(i),</span>
<span class="nc" id="L568">                                slaveMetadata.isSymbolTableStatic(i),</span>
<span class="nc" id="L569">                                slaveMetadata.getMetadata(i)</span>
                        );
<span class="nc" id="L571">                        listColumnFilterB.add(i + 1);</span>
<span class="nc" id="L572">                        columnIndex.add(i);</span>
<span class="nc" id="L573">                        valueTypes.add(type);</span>
<span class="nc" id="L574">                        slaveTypes.add(type);</span>
                    }
                }

                // now add key columns to metadata
<span class="nc bnc" id="L579" title="All 2 branches missed.">                for (int i = 0, n = listColumnFilterA.getColumnCount(); i &lt; n; i++) {</span>
<span class="nc" id="L580">                    int index = listColumnFilterA.getColumnIndexFactored(i);</span>
<span class="nc" id="L581">                    int type = slaveMetadata.getColumnType(index);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                    if (ColumnType.isSymbol(type)) {</span>
<span class="nc" id="L583">                        type = ColumnType.STRING;</span>
                    }
<span class="nc" id="L585">                    metadata.add(</span>
                            slaveAlias,
<span class="nc" id="L587">                            slaveMetadata.getColumnName(index),</span>
                            type,
<span class="nc" id="L589">                            slaveMetadata.isColumnIndexed(i),</span>
<span class="nc" id="L590">                            slaveMetadata.getIndexValueBlockCapacity(i),</span>
<span class="nc" id="L591">                            slaveMetadata.isSymbolTableStatic(i),</span>
<span class="nc" id="L592">                            slaveMetadata.getMetadata(i)</span>
                    );
<span class="nc" id="L594">                    columnIndex.add(index);</span>
<span class="nc" id="L595">                    slaveTypes.add(type);</span>
                }
            }


<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (masterMetadata.getTimestampIndex() != -1) {</span>
<span class="fc" id="L601">                metadata.setTimestampIndex(masterMetadata.getTimestampIndex());</span>
            }

<span class="pc bpc" id="L604" title="1 of 2 branches missed.">            return generator.create(</span>
                    configuration,
                    metadata,
                    master,
                    slave,
                    keyTypes,
                    valueTypes,
                    slaveTypes,
                    masterSink,
<span class="fc" id="L613">                    RecordSinkFactory.getInstance(</span>
                            asm,
                            slaveMetadata,
                            listColumnFilterA,
                            true
                    ),
<span class="fc" id="L619">                    masterMetadata.getColumnCount(),</span>
<span class="fc" id="L620">                    RecordValueSinkFactory.getInstance(asm, slaveMetadata, listColumnFilterB),</span>
                    columnIndex,
                    joinContext
            );

<span class="fc" id="L625">        } catch (Throwable e) {</span>
<span class="fc" id="L626">            Misc.free(metadata);</span>
<span class="fc" id="L627">            throw e;</span>
        }
    }

    private RecordCursorFactory createHashJoin(
            RecordMetadata metadata,
            RecordCursorFactory master,
            RecordCursorFactory slave,
            int joinType,
            Function filter,
            JoinContext context
    ) {
        /*
         * JoinContext provides the following information:
         * a/bIndexes - index of model where join column is coming from
         * a/bNames - name of columns in respective models, these column names are not prefixed with table aliases
         * a/bNodes - the original column references, that can include table alias. Sometimes it doesn't when column name is unambiguous
         *
         * a/b are &quot;inverted&quot; in that &quot;a&quot; for slave and &quot;b&quot; for master
         *
         * The issue is when we use model indexes and vanilla column names they would only work on single-table
         * record cursor but original names with prefixed columns will only work with JoinRecordMetadata
         */
<span class="fc" id="L650">        final RecordMetadata masterMetadata = master.getMetadata();</span>
<span class="fc" id="L651">        final RecordMetadata slaveMetadata = slave.getMetadata();</span>
<span class="fc" id="L652">        final RecordSink masterKeySink = RecordSinkFactory.getInstance(</span>
                asm,
                masterMetadata,
                listColumnFilterB,
                true
        );

<span class="fc" id="L659">        final RecordSink slaveKeySink = RecordSinkFactory.getInstance(</span>
                asm,
                slaveMetadata,
                listColumnFilterA,
                true
        );

<span class="fc" id="L666">        valueTypes.clear();</span>
<span class="fc" id="L667">        valueTypes.add(ColumnType.LONG);</span>
<span class="fc" id="L668">        valueTypes.add(ColumnType.LONG);</span>

<span class="fc bfc" id="L670" title="All 4 branches covered.">        if (slave.recordCursorSupportsRandomAccess() &amp;&amp; !fullFatJoins) {</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (joinType == JOIN_INNER) {</span>
<span class="fc" id="L672">                return new HashJoinLightRecordCursorFactory(</span>
                        configuration,
                        metadata,
                        master,
                        slave,
                        keyTypes,
                        valueTypes,
                        masterKeySink,
                        slaveKeySink,
<span class="fc" id="L681">                        masterMetadata.getColumnCount(),</span>
                        context
                );
            }

<span class="fc bfc" id="L686" title="All 2 branches covered.">            if (filter != null) {</span>
<span class="fc" id="L687">                return new HashOuterJoinFilteredLightRecordCursorFactory(</span>
                        configuration,
                        metadata,
                        master,
                        slave,
                        keyTypes,
                        valueTypes,
                        masterKeySink,
                        slaveKeySink,
<span class="fc" id="L696">                        masterMetadata.getColumnCount(),</span>
                        filter,
                        context
                );
            }

<span class="fc" id="L702">            return new HashOuterJoinLightRecordCursorFactory(</span>
                    configuration,
                    metadata,
                    master,
                    slave,
                    keyTypes,
                    valueTypes,
                    masterKeySink,
                    slaveKeySink,
<span class="fc" id="L711">                    masterMetadata.getColumnCount(),</span>
                    context
            );
        }

<span class="fc" id="L716">        entityColumnFilter.of(slaveMetadata.getColumnCount());</span>
<span class="fc" id="L717">        RecordSink slaveSink = RecordSinkFactory.getInstance(</span>
                asm,
                slaveMetadata,
                entityColumnFilter,
                false
        );

<span class="fc bfc" id="L724" title="All 2 branches covered.">        if (joinType == JOIN_INNER) {</span>
<span class="fc" id="L725">            return new HashJoinRecordCursorFactory(</span>
                    configuration,
                    metadata,
                    master,
                    slave,
                    keyTypes,
                    valueTypes,
                    masterKeySink,
                    slaveKeySink,
                    slaveSink,
<span class="fc" id="L735">                    masterMetadata.getColumnCount(),</span>
                    context
            );
        }

<span class="fc bfc" id="L740" title="All 2 branches covered.">        if (filter != null) {</span>
<span class="fc" id="L741">            return new HashOuterJoinFilteredRecordCursorFactory(</span>
                    configuration,
                    metadata,
                    master,
                    slave,
                    keyTypes,
                    valueTypes,
                    masterKeySink,
                    slaveKeySink,
                    slaveSink,
<span class="fc" id="L751">                    masterMetadata.getColumnCount(),</span>
                    filter,
                    context
            );
        }

<span class="fc" id="L757">        return new HashOuterJoinRecordCursorFactory(</span>
                configuration,
                metadata,
                master,
                slave,
                keyTypes,
                valueTypes,
                masterKeySink,
                slaveKeySink,
                slaveSink,
<span class="fc" id="L767">                masterMetadata.getColumnCount(),</span>
                context
        );
    }

    @NotNull
    private JoinRecordMetadata createJoinMetadata(
            CharSequence masterAlias,
            RecordMetadata masterMetadata,
            CharSequence slaveAlias,
            RecordMetadata slaveMetadata
    ) {
<span class="fc" id="L779">        return createJoinMetadata(</span>
                masterAlias,
                masterMetadata,
                slaveAlias,
                slaveMetadata,
<span class="fc" id="L784">                masterMetadata.getTimestampIndex()</span>
        );
    }

    @NotNull
    private JoinRecordMetadata createJoinMetadata(
            CharSequence masterAlias,
            RecordMetadata masterMetadata,
            CharSequence slaveAlias,
            RecordMetadata slaveMetadata,
            int timestampIndex
    ) {
        JoinRecordMetadata metadata;
<span class="fc" id="L797">        metadata = new JoinRecordMetadata(</span>
                configuration,
<span class="fc" id="L799">                masterMetadata.getColumnCount() + slaveMetadata.getColumnCount()</span>
        );

<span class="fc" id="L802">        metadata.copyColumnMetadataFrom(masterAlias, masterMetadata);</span>
<span class="fc" id="L803">        metadata.copyColumnMetadataFrom(slaveAlias, slaveMetadata);</span>

<span class="fc bfc" id="L805" title="All 2 branches covered.">        if (timestampIndex != -1) {</span>
<span class="fc" id="L806">            metadata.setTimestampIndex(timestampIndex);</span>
        }
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">        return metadata;</span>
    }

    private RecordCursorFactory createLtJoin(
            RecordMetadata metadata,
            RecordCursorFactory master,
            RecordSink masterKeySink,
            RecordCursorFactory slave,
            RecordSink slaveKeySink,
            int columnSplit,
            JoinContext joinContext
    ) {
<span class="fc" id="L820">        valueTypes.clear();</span>
<span class="fc" id="L821">        valueTypes.add(ColumnType.LONG);</span>
<span class="fc" id="L822">        valueTypes.add(ColumnType.LONG);</span>

<span class="fc" id="L824">        return new LtJoinLightRecordCursorFactory(</span>
                configuration,
                metadata,
                master,
                slave,
                keyTypes,
                valueTypes,
                masterKeySink,
                slaveKeySink,
                columnSplit,
                joinContext
        );
    }

    private RecordCursorFactory createSpliceJoin(
            RecordMetadata metadata,
            RecordCursorFactory master,
            RecordSink masterKeySink,
            RecordCursorFactory slave,
            RecordSink slaveKeySink,
            int columnSplit,
            JoinContext context
    ) {
<span class="fc" id="L847">        valueTypes.clear();</span>
<span class="fc" id="L848">        valueTypes.add(ColumnType.LONG); // master previous</span>
<span class="fc" id="L849">        valueTypes.add(ColumnType.LONG); // master current</span>
<span class="fc" id="L850">        valueTypes.add(ColumnType.LONG); // slave previous</span>
<span class="fc" id="L851">        valueTypes.add(ColumnType.LONG); // slave current</span>

<span class="fc" id="L853">        return new SpliceJoinLightRecordCursorFactory(</span>
                configuration,
                metadata,
                master,
                slave,
                keyTypes,
                valueTypes,
                masterKeySink,
                slaveKeySink,
                columnSplit,
                context
        );
    }

    private ObjList&lt;Function&gt; generateCastFunctions(
            RecordMetadata castToMetadata,
            RecordMetadata castFromMetadata,
            int modelPosition
    ) throws SqlException {
<span class="fc" id="L872">        int columnCount = castToMetadata.getColumnCount();</span>
<span class="fc" id="L873">        ObjList&lt;Function&gt; castFunctions = new ObjList&lt;&gt;();</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L875">            int toType = castToMetadata.getColumnType(i);</span>
<span class="fc" id="L876">            int fromType = castFromMetadata.getColumnType(i);</span>
<span class="fc" id="L877">            int toTag = ColumnType.tagOf(toType);</span>
<span class="fc" id="L878">            int fromTag = ColumnType.tagOf(fromType);</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">            if (fromTag == ColumnType.NULL) {</span>
<span class="fc" id="L880">                castFunctions.add(NullConstant.NULL);</span>
            } else {
<span class="pc bpc" id="L882" title="2 of 20 branches missed.">                switch (toTag) {</span>
                    case ColumnType.BOOLEAN:
<span class="fc" id="L884">                        castFunctions.add(new BooleanColumn(i));</span>
<span class="fc" id="L885">                        break;</span>
                    case ColumnType.BYTE:
<span class="fc" id="L887">                        castFunctions.add(new ByteColumn(i));</span>
<span class="fc" id="L888">                        break;</span>
                    case ColumnType.SHORT:
<span class="pc bpc" id="L890" title="1 of 4 branches missed.">                        switch (fromTag) {</span>
                            // BOOLEAN will not be cast to CHAR
                            // in cast of BOOLEAN -&gt; CHAR combination both will be cast to STRING
                            case ColumnType.BYTE:
<span class="fc" id="L894">                                castFunctions.add(new ByteColumn(i));</span>
<span class="fc" id="L895">                                break;</span>
                            case ColumnType.CHAR:
<span class="fc" id="L897">                                castFunctions.add(new CharColumn(i));</span>
<span class="fc" id="L898">                                break;</span>
                            case ColumnType.SHORT:
<span class="fc" id="L900">                                castFunctions.add(new ShortColumn(i));</span>
                                break;
                            // wider types are not possible here
                            // SHORT will be cast to wider types, not other way around
                            // Wider types tested are: SHORT, INT, LONG, FLOAT, DOUBLE, DATE, TIMESTAMP, SYMBOL, STRING, LONG256
                            // GEOBYTE, GEOSHORT, GEOINT, GEOLONG
                        }
<span class="fc" id="L907">                        break;</span>
                    case ColumnType.CHAR:
<span class="pc bpc" id="L909" title="1 of 3 branches missed.">                        switch (fromTag) {</span>
                            // BOOLEAN will not be cast to CHAR
                            // in cast of BOOLEAN -&gt; CHAR combination both will be cast to STRING
                            case ColumnType.BYTE:
<span class="fc" id="L913">                                castFunctions.add(new CastByteToCharFunctionFactory.CastByteToCharFunction(new ByteColumn(i)));</span>
<span class="fc" id="L914">                                break;</span>
                            case ColumnType.CHAR:
<span class="fc" id="L916">                                castFunctions.add(new CharColumn(i));</span>
<span class="fc" id="L917">                                break;</span>
                            // wider types are not possible here
                            // CHAR will be cast to wider types, not other way around
                            // Wider types tested are: SHORT, INT, LONG, FLOAT, DOUBLE, DATE, TIMESTAMP, SYMBOL, STRING, LONG256
                            // GEOBYTE, GEOSHORT, GEOINT, GEOLONG
                            default:

                        }
<span class="nc" id="L925">                        break;</span>
                    case ColumnType.INT:
<span class="pc bpc" id="L927" title="1 of 5 branches missed.">                        switch (fromTag) {</span>
                            // BOOLEAN will not be cast to INT
                            // in cast of BOOLEAN -&gt; INT combination both will be cast to STRING
                            case ColumnType.BYTE:
<span class="fc" id="L931">                                castFunctions.add(new ByteColumn(i));</span>
<span class="fc" id="L932">                                break;</span>
                            case ColumnType.SHORT:
<span class="fc" id="L934">                                castFunctions.add(new ShortColumn(i));</span>
<span class="fc" id="L935">                                break;</span>
                            case ColumnType.CHAR:
<span class="fc" id="L937">                                castFunctions.add(new CharColumn(i));</span>
<span class="fc" id="L938">                                break;</span>
                            case ColumnType.INT:
<span class="fc" id="L940">                                castFunctions.add(new IntColumn(i));</span>
                                break;
                            // wider types are not possible here
                            // INT will be cast to wider types, not other way around
                            // Wider types tested are: LONG, FLOAT, DOUBLE, DATE, TIMESTAMP, SYMBOL, STRING, LONG256
                            // GEOBYTE, GEOSHORT, GEOINT, GEOLONG
                        }
<span class="fc" id="L947">                        break;</span>
                    case ColumnType.LONG:
<span class="fc bfc" id="L949" title="All 6 branches covered.">                        switch (fromTag) {</span>
                            // BOOLEAN will not be cast to LONG
                            // in cast of BOOLEAN -&gt; LONG combination both will be cast to STRING
                            case ColumnType.BYTE:
<span class="fc" id="L953">                                castFunctions.add(new ByteColumn(i));</span>
<span class="fc" id="L954">                                break;</span>
                            case ColumnType.SHORT:
<span class="fc" id="L956">                                castFunctions.add(new ShortColumn(i));</span>
<span class="fc" id="L957">                                break;</span>
                            case ColumnType.CHAR:
<span class="fc" id="L959">                                castFunctions.add(new CharColumn(i));</span>
<span class="fc" id="L960">                                break;</span>
                            case ColumnType.INT:
<span class="fc" id="L962">                                castFunctions.add(new IntColumn(i));</span>
<span class="fc" id="L963">                                break;</span>
                            case ColumnType.LONG:
<span class="fc" id="L965">                                castFunctions.add(new LongColumn(i));</span>
<span class="fc" id="L966">                                break;</span>
                            default:
<span class="fc" id="L968">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="fc" id="L970">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                                // wider types are not possible here
                                // LONG will be cast to wider types, not other way around
                                // Wider types tested are: FLOAT, DOUBLE, DATE, TIMESTAMP, SYMBOL, STRING, LONG256
                                // GEOBYTE, GEOSHORT, GEOINT, GEOLONG
                        }
                        break;
                    case ColumnType.DATE:
<span class="fc bfc" id="L981" title="All 2 branches covered.">                        if (fromTag == ColumnType.DATE) {</span>
<span class="fc" id="L982">                            castFunctions.add(new DateColumn(i));</span>
                        } else {
<span class="fc" id="L984">                            throw SqlException.unsupportedCast(</span>
                                    modelPosition,
<span class="fc" id="L986">                                    castFromMetadata.getColumnName(i),</span>
                                    fromType,
                                    toType
                            );
                        }
                        break;
                    case ColumnType.UUID:
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">                        assert fromTag == ColumnType.UUID;</span>
<span class="fc" id="L994">                        castFunctions.add(new UuidColumn(i));</span>
<span class="fc" id="L995">                        break;</span>
                    case ColumnType.TIMESTAMP:
<span class="fc bfc" id="L997" title="All 3 branches covered.">                        switch (fromTag) {</span>
                            case ColumnType.DATE:
<span class="fc" id="L999">                                castFunctions.add(new CastDateToTimestampFunctionFactory.CastDateToTimestampFunction(new DateColumn(i)));</span>
<span class="fc" id="L1000">                                break;</span>
                            case ColumnType.TIMESTAMP:
<span class="fc" id="L1002">                                castFunctions.add(new TimestampColumn(i));</span>
<span class="fc" id="L1003">                                break;</span>
                            default:
<span class="fc" id="L1005">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="fc" id="L1007">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                        }
                        break;
                    case ColumnType.FLOAT:
<span class="fc bfc" id="L1014" title="All 6 branches covered.">                        switch (fromTag) {</span>
                            case ColumnType.BYTE:
<span class="fc" id="L1016">                                castFunctions.add(new ByteColumn(i));</span>
<span class="fc" id="L1017">                                break;</span>
                            case ColumnType.SHORT:
<span class="fc" id="L1019">                                castFunctions.add(new ShortColumn(i));</span>
<span class="fc" id="L1020">                                break;</span>
                            case ColumnType.INT:
<span class="fc" id="L1022">                                castFunctions.add(new IntColumn(i));</span>
<span class="fc" id="L1023">                                break;</span>
                            case ColumnType.LONG:
<span class="fc" id="L1025">                                castFunctions.add(new LongColumn(i));</span>
<span class="fc" id="L1026">                                break;</span>
                            case ColumnType.FLOAT:
<span class="fc" id="L1028">                                castFunctions.add(new FloatColumn(i));</span>
<span class="fc" id="L1029">                                break;</span>
                            default:
<span class="fc" id="L1031">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="fc" id="L1033">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                        }
                        break;
                    case ColumnType.DOUBLE:
<span class="fc bfc" id="L1040" title="All 7 branches covered.">                        switch (fromTag) {</span>
                            case ColumnType.BYTE:
<span class="fc" id="L1042">                                castFunctions.add(new ByteColumn(i));</span>
<span class="fc" id="L1043">                                break;</span>
                            case ColumnType.SHORT:
<span class="fc" id="L1045">                                castFunctions.add(new ShortColumn(i));</span>
<span class="fc" id="L1046">                                break;</span>
                            case ColumnType.INT:
<span class="fc" id="L1048">                                castFunctions.add(new IntColumn(i));</span>
<span class="fc" id="L1049">                                break;</span>
                            case ColumnType.LONG:
<span class="fc" id="L1051">                                castFunctions.add(new LongColumn(i));</span>
<span class="fc" id="L1052">                                break;</span>
                            case ColumnType.FLOAT:
<span class="fc" id="L1054">                                castFunctions.add(new FloatColumn(i));</span>
<span class="fc" id="L1055">                                break;</span>
                            case ColumnType.DOUBLE:
<span class="fc" id="L1057">                                castFunctions.add(new DoubleColumn(i));</span>
<span class="fc" id="L1058">                                break;</span>
                            default:
<span class="fc" id="L1060">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="fc" id="L1062">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                        }
                        break;
                    case ColumnType.STRING:
<span class="pc bpc" id="L1069" title="1 of 20 branches missed.">                        switch (fromTag) {</span>
                            case ColumnType.BOOLEAN:
<span class="fc" id="L1071">                                castFunctions.add(new BooleanColumn(i));</span>
<span class="fc" id="L1072">                                break;</span>
                            case ColumnType.BYTE:
<span class="fc" id="L1074">                                castFunctions.add(new CastByteToStrFunctionFactory.CastByteToStrFunction(new ByteColumn(i)));</span>
<span class="fc" id="L1075">                                break;</span>
                            case ColumnType.SHORT:
<span class="fc" id="L1077">                                castFunctions.add(new CastShortToStrFunctionFactory.CastShortToStrFunction(new ShortColumn(i)));</span>
<span class="fc" id="L1078">                                break;</span>
                            case ColumnType.CHAR:
                                // CharFunction has built-in cast to String
<span class="fc" id="L1081">                                castFunctions.add(new CharColumn(i));</span>
<span class="fc" id="L1082">                                break;</span>
                            case ColumnType.INT:
<span class="fc" id="L1084">                                castFunctions.add(new CastIntToStrFunctionFactory.CastIntToStrFunction(new IntColumn(i)));</span>
<span class="fc" id="L1085">                                break;</span>
                            case ColumnType.LONG:
<span class="fc" id="L1087">                                castFunctions.add(new CastLongToStrFunctionFactory.CastLongToStrFunction(new LongColumn(i)));</span>
<span class="fc" id="L1088">                                break;</span>
                            case ColumnType.DATE:
<span class="fc" id="L1090">                                castFunctions.add(new CastDateToStrFunctionFactory.CastDateToStrFunction(new DateColumn(i)));</span>
<span class="fc" id="L1091">                                break;</span>
                            case ColumnType.TIMESTAMP:
<span class="fc" id="L1093">                                castFunctions.add(new CastTimestampToStrFunctionFactory.CastTimestampToStrFunction(new TimestampColumn(i)));</span>
<span class="fc" id="L1094">                                break;</span>
                            case ColumnType.FLOAT:
<span class="fc" id="L1096">                                castFunctions.add(new CastFloatToStrFunctionFactory.CastFloatToStrFunction(</span>
                                        new FloatColumn(i),
<span class="fc" id="L1098">                                        configuration.getFloatToStrCastScale()</span>
                                ));
<span class="fc" id="L1100">                                break;</span>
                            case ColumnType.DOUBLE:
<span class="fc" id="L1102">                                castFunctions.add(new CastDoubleToStrFunctionFactory.CastDoubleToStrFunction(</span>
                                        new DoubleColumn(i),
<span class="fc" id="L1104">                                        configuration.getDoubleToStrCastScale()</span>
                                ));
<span class="fc" id="L1106">                                break;</span>
                            case ColumnType.STRING:
<span class="fc" id="L1108">                                castFunctions.add(new StrColumn(i));</span>
<span class="fc" id="L1109">                                break;</span>
                            case ColumnType.UUID:
<span class="fc" id="L1111">                                castFunctions.add(new CastUuidToStrFunctionFactory.Func(new UuidColumn(i)));</span>
<span class="fc" id="L1112">                                break;</span>
                            case ColumnType.SYMBOL:
<span class="fc" id="L1114">                                castFunctions.add(</span>
                                        new CastSymbolToStrFunctionFactory.CastSymbolToStrFunction(
<span class="fc" id="L1116">                                                new SymbolColumn(i, castFromMetadata.isSymbolTableStatic(i))</span>
                                        )
                                );
<span class="fc" id="L1119">                                break;</span>
                            case ColumnType.LONG256:
<span class="fc" id="L1121">                                castFunctions.add(</span>
                                        new CastLong256ToStrFunctionFactory.CastLong256ToStrFunction(
                                                new Long256Column(i)
                                        )
                                );
<span class="fc" id="L1126">                                break;</span>
                            case ColumnType.GEOBYTE:
<span class="fc" id="L1128">                                castFunctions.add(</span>
<span class="fc" id="L1129">                                        CastGeoHashToGeoHashFunctionFactory.getGeoByteToStrCastFunction(</span>
                                                new GeoByteColumn(i, toTag),
<span class="fc" id="L1131">                                                ColumnType.getGeoHashBits(fromType)</span>
                                        )
                                );
<span class="fc" id="L1134">                                break;</span>
                            case ColumnType.GEOSHORT:
<span class="fc" id="L1136">                                castFunctions.add(</span>
<span class="fc" id="L1137">                                        CastGeoHashToGeoHashFunctionFactory.getGeoShortToStrCastFunction(</span>
                                                new GeoShortColumn(i, toTag),
<span class="fc" id="L1139">                                                ColumnType.getGeoHashBits(castFromMetadata.getColumnType(i))</span>
                                        )
                                );
<span class="fc" id="L1142">                                break;</span>
                            case ColumnType.GEOINT:
<span class="fc" id="L1144">                                castFunctions.add(</span>
<span class="fc" id="L1145">                                        CastGeoHashToGeoHashFunctionFactory.getGeoIntToStrCastFunction(</span>
                                                new GeoIntColumn(i, toTag),
<span class="fc" id="L1147">                                                ColumnType.getGeoHashBits(castFromMetadata.getColumnType(i))</span>
                                        )
                                );
<span class="fc" id="L1150">                                break;</span>
                            case ColumnType.GEOLONG:
<span class="fc" id="L1152">                                castFunctions.add(</span>
<span class="fc" id="L1153">                                        CastGeoHashToGeoHashFunctionFactory.getGeoLongToStrCastFunction(</span>
                                                new GeoLongColumn(i, toTag),
<span class="fc" id="L1155">                                                ColumnType.getGeoHashBits(castFromMetadata.getColumnType(i))</span>
                                        )
                                );
<span class="fc" id="L1158">                                break;</span>
                            case ColumnType.BINARY:
<span class="fc" id="L1160">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="fc" id="L1162">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                        }
<span class="fc" id="L1167">                        break;</span>
                    case ColumnType.SYMBOL:
<span class="nc" id="L1169">                        castFunctions.add(new CastSymbolToStrFunctionFactory.CastSymbolToStrFunction(</span>
                                new SymbolColumn(
                                        i,
<span class="nc" id="L1172">                                        castFromMetadata.isSymbolTableStatic(i)</span>
                                )));
<span class="nc" id="L1174">                        break;</span>
                    case ColumnType.LONG256:
<span class="fc" id="L1176">                        castFunctions.add(new Long256Column(i));</span>
<span class="fc" id="L1177">                        break;</span>
                    case ColumnType.GEOBYTE:
<span class="pc bpc" id="L1179" title="1 of 6 branches missed.">                        switch (fromTag) {</span>
                            case ColumnType.STRING:
<span class="fc" id="L1181">                                castFunctions.add(</span>
<span class="fc" id="L1182">                                        CastStrToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                toType,
                                                new StrColumn(i)
                                        )
                                );
<span class="fc" id="L1188">                                break;</span>
                            case ColumnType.GEOBYTE:
<span class="fc" id="L1190">                                castFunctions.add(new GeoByteColumn(i, fromType));</span>
<span class="fc" id="L1191">                                break;</span>
                            case ColumnType.GEOSHORT:
<span class="fc" id="L1193">                                castFunctions.add(</span>
<span class="fc" id="L1194">                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                new GeoShortColumn(i, fromType),
                                                toType,
                                                fromType
                                        )
                                );
<span class="fc" id="L1201">                                break;</span>
                            case ColumnType.GEOINT:
<span class="fc" id="L1203">                                castFunctions.add(</span>
<span class="fc" id="L1204">                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                new GeoIntColumn(i, fromType),
                                                toType,
                                                fromType
                                        )
                                );
<span class="fc" id="L1211">                                break;</span>
                            case ColumnType.GEOLONG:
<span class="fc" id="L1213">                                castFunctions.add(</span>
<span class="fc" id="L1214">                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                new GeoLongColumn(i, fromType),
                                                toType,
                                                fromType
                                        )
                                );
<span class="fc" id="L1221">                                break;</span>
                            default:
<span class="nc" id="L1223">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="nc" id="L1225">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                        }
                        break;
                    case ColumnType.GEOSHORT:
<span class="pc bpc" id="L1232" title="1 of 5 branches missed.">                        switch (fromTag) {</span>
                            case ColumnType.STRING:
<span class="fc" id="L1234">                                castFunctions.add(</span>
<span class="fc" id="L1235">                                        CastStrToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                toType,
                                                new StrColumn(i)
                                        )
                                );
<span class="fc" id="L1241">                                break;</span>
                            case ColumnType.GEOSHORT:
<span class="fc" id="L1243">                                castFunctions.add(new GeoShortColumn(i, toType));</span>
<span class="fc" id="L1244">                                break;</span>
                            case ColumnType.GEOINT:
<span class="fc" id="L1246">                                castFunctions.add(</span>
<span class="fc" id="L1247">                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                new GeoIntColumn(i, fromType),
                                                toType,
                                                fromType
                                        )
                                );
<span class="fc" id="L1254">                                break;</span>
                            case ColumnType.GEOLONG:
<span class="fc" id="L1256">                                castFunctions.add(</span>
<span class="fc" id="L1257">                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                new GeoLongColumn(i, fromType),
                                                toType,
                                                fromType
                                        )
                                );
<span class="fc" id="L1264">                                break;</span>
                            default:
<span class="nc" id="L1266">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="nc" id="L1268">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                        }
                        break;
                    case ColumnType.GEOINT:
<span class="pc bpc" id="L1275" title="1 of 4 branches missed.">                        switch (fromTag) {</span>
                            case ColumnType.STRING:
<span class="fc" id="L1277">                                castFunctions.add(</span>
<span class="fc" id="L1278">                                        CastStrToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                toType,
                                                new StrColumn(i)
                                        )
                                );
<span class="fc" id="L1284">                                break;</span>
                            case ColumnType.GEOINT:
<span class="fc" id="L1286">                                castFunctions.add(new GeoIntColumn(i, fromType));</span>
<span class="fc" id="L1287">                                break;</span>
                            case ColumnType.GEOLONG:
<span class="fc" id="L1289">                                castFunctions.add(</span>
<span class="fc" id="L1290">                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                new GeoLongColumn(i, fromType),
                                                toType,
                                                fromType
                                        )
                                );
<span class="fc" id="L1297">                                break;</span>
                            default:
<span class="nc" id="L1299">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="nc" id="L1301">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                        }
                        break;
                    case ColumnType.GEOLONG:
<span class="pc bpc" id="L1308" title="1 of 3 branches missed.">                        switch (fromTag) {</span>
                            case ColumnType.STRING:
<span class="fc" id="L1310">                                castFunctions.add(</span>
<span class="fc" id="L1311">                                        CastStrToGeoHashFunctionFactory.newInstance(</span>
                                                0,
                                                toType,
                                                new StrColumn(i)
                                        )
                                );
<span class="fc" id="L1317">                                break;</span>
                            case ColumnType.GEOLONG:
<span class="fc" id="L1319">                                castFunctions.add(new GeoLongColumn(i, fromType));</span>
<span class="fc" id="L1320">                                break;</span>
                            default:
<span class="nc" id="L1322">                                throw SqlException.unsupportedCast(</span>
                                        modelPosition,
<span class="nc" id="L1324">                                        castFromMetadata.getColumnName(i),</span>
                                        fromType,
                                        toType
                                );
                        }
                        break;
                    case ColumnType.BINARY:
<span class="fc" id="L1331">                        castFunctions.add(new BinColumn(i));</span>
                        break;
                }
            }
        }
<span class="fc" id="L1336">        return castFunctions;</span>
    }

    private RecordCursorFactory generateFilter(RecordCursorFactory factory, QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L1340">        final ExpressionNode filter = model.getWhereClause();</span>
<span class="fc bfc" id="L1341" title="All 2 branches covered.">        return filter == null ? factory : generateFilter0(factory, model, executionContext, filter);</span>
    }

    @NotNull
    private RecordCursorFactory generateFilter0(
            RecordCursorFactory factory,
            QueryModel model,
            SqlExecutionContext executionContext,
            ExpressionNode filterExpr
    ) throws SqlException {
<span class="fc" id="L1351">        backupWhereClause(filterExpr);//back up in case filters need to be compiled again</span>
<span class="fc" id="L1352">        model.setWhereClause(null);</span>

        final Function filter;
        try {
<span class="fc" id="L1356">            filter = compileBooleanFilter(filterExpr, factory.getMetadata(), executionContext);</span>
<span class="fc" id="L1357">        } catch (Throwable e) {</span>
<span class="fc" id="L1358">            Misc.free(factory);</span>
<span class="fc" id="L1359">            throw e;</span>
<span class="fc" id="L1360">        }</span>

<span class="fc bfc" id="L1362" title="All 2 branches covered.">        if (filter.isConstant()) {</span>
            try {
<span class="fc bfc" id="L1364" title="All 2 branches covered.">                if (filter.getBool(null)) {</span>
<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">                    return factory;</span>
                }
<span class="fc" id="L1367">                RecordMetadata metadata = factory.getMetadata();</span>
<span class="pc bpc" id="L1368" title="1 of 2 branches missed.">                assert (metadata instanceof GenericRecordMetadata);</span>
<span class="fc" id="L1369">                Misc.free(factory);</span>
<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">                return new EmptyTableRecordCursorFactory(metadata);</span>
            } finally {
<span class="fc" id="L1372">                filter.close();</span>
            }
        }

<span class="fc" id="L1376">        final boolean enableParallelFilter = executionContext.isParallelFilterEnabled();</span>
<span class="fc" id="L1377">        final boolean preTouchColumns = configuration.isSqlParallelFilterPreTouchEnabled();</span>
<span class="fc bfc" id="L1378" title="All 4 branches covered.">        if (enableParallelFilter &amp;&amp; factory.supportPageFrameCursor()) {</span>

<span class="fc bfc" id="L1380" title="All 2 branches covered.">            final boolean useJit = executionContext.getJitMode() != SqlJitMode.JIT_MODE_DISABLED</span>
<span class="fc bfc" id="L1381" title="All 4 branches covered.">                    &amp;&amp; (!model.isUpdate() || executionContext.isWalApplication());</span>
<span class="pc bpc" id="L1382" title="2 of 4 branches missed.">            final boolean canCompile = factory.supportPageFrameCursor() &amp;&amp; JitUtil.isJitSupported();</span>
<span class="pc bpc" id="L1383" title="1 of 4 branches missed.">            if (useJit &amp;&amp; canCompile) {</span>
<span class="nc" id="L1384">                CompiledFilter jitFilter = null;</span>
                try {
                    int jitOptions;
<span class="nc" id="L1387">                    final ObjList&lt;Function&gt; bindVarFunctions = new ObjList&lt;&gt;();</span>
<span class="nc" id="L1388">                    try (PageFrameCursor cursor = factory.getPageFrameCursor(executionContext, ORDER_ANY)) {</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">                        final boolean forceScalar = executionContext.getJitMode() == SqlJitMode.JIT_MODE_FORCE_SCALAR;</span>
<span class="nc" id="L1390">                        jitIRSerializer.of(jitIRMem, executionContext, factory.getMetadata(), cursor, bindVarFunctions);</span>
<span class="nc" id="L1391">                        jitOptions = jitIRSerializer.serialize(filterExpr, forceScalar, enableJitDebug, enableJitNullChecks);</span>
                    }

<span class="nc" id="L1394">                    jitFilter = new CompiledFilter();</span>
<span class="nc" id="L1395">                    jitFilter.compile(jitIRMem, jitOptions);</span>

<span class="nc" id="L1397">                    final Function limitLoFunction = getLimitLoFunctionOnly(model, executionContext);</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">                    final int limitLoPos = model.getLimitAdviceLo() != null ? model.getLimitAdviceLo().position : 0;</span>

<span class="nc" id="L1400">                    LOG.info()</span>
<span class="nc" id="L1401">                            .$(&quot;JIT enabled for (sub)query [tableName=&quot;).utf8(model.getName())</span>
<span class="nc" id="L1402">                            .$(&quot;, fd=&quot;).$(executionContext.getRequestFd()).$(']').$();</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                    return new AsyncJitFilteredRecordCursorFactory(</span>
                            configuration,
<span class="nc" id="L1405">                            executionContext.getMessageBus(),</span>
                            factory,
                            bindVarFunctions,
                            filter,
<span class="nc" id="L1409">                            compileWorkerFilterConditionally(</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">                                    !filter.isReadThreadSafe(),</span>
<span class="nc" id="L1411">                                    executionContext.getSharedWorkerCount(),</span>
                                    filterExpr,
<span class="nc" id="L1413">                                    factory.getMetadata(),</span>
                                    executionContext
                            ),
                            jitFilter,
                            reduceTaskPool,
                            limitLoFunction,
                            limitLoPos,
                            preTouchColumns,
<span class="nc" id="L1421">                            executionContext.getSharedWorkerCount()</span>
                    );
<span class="nc" id="L1423">                } catch (SqlException | LimitOverflowException ex) {</span>
<span class="nc" id="L1424">                    Misc.free(jitFilter);</span>
<span class="nc" id="L1425">                    LOG.debug()</span>
<span class="nc" id="L1426">                            .$(&quot;JIT cannot be applied to (sub)query [tableName=&quot;).utf8(model.getName())</span>
<span class="nc" id="L1427">                            .$(&quot;, ex=&quot;).$(ex.getFlyweightMessage())</span>
<span class="nc" id="L1428">                            .$(&quot;, fd=&quot;).$(executionContext.getRequestFd()).$(']').$();</span>
                } finally {
<span class="nc" id="L1430">                    jitIRSerializer.clear();</span>
<span class="nc" id="L1431">                    jitIRMem.truncate();</span>
                }
            }

            // Use Java filter.
            final Function limitLoFunction;
            try {
<span class="fc" id="L1438">                limitLoFunction = getLimitLoFunctionOnly(model, executionContext);</span>
<span class="nc" id="L1439">            } catch (Throwable e) {</span>
<span class="nc" id="L1440">                Misc.free(filter);</span>
<span class="nc" id="L1441">                Misc.free(factory);</span>
<span class="nc" id="L1442">                throw e;</span>
<span class="fc" id="L1443">            }</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">            final int limitLoPos = model.getLimitAdviceLo() != null ? model.getLimitAdviceLo().position : 0;</span>
<span class="fc" id="L1445">            return new AsyncFilteredRecordCursorFactory(</span>
                    configuration,
<span class="fc" id="L1447">                    executionContext.getMessageBus(),</span>
                    factory,
                    filter,
                    reduceTaskPool,
<span class="fc" id="L1451">                    compileWorkerFilterConditionally(</span>
<span class="fc bfc" id="L1452" title="All 2 branches covered.">                            !filter.isReadThreadSafe(),</span>
<span class="fc" id="L1453">                            executionContext.getSharedWorkerCount(),</span>
                            filterExpr,
<span class="fc" id="L1455">                            factory.getMetadata(),</span>
                            executionContext
                    ),
                    limitLoFunction,
                    limitLoPos,
                    preTouchColumns,
<span class="fc" id="L1461">                    executionContext.getSharedWorkerCount()</span>
            );
        }
<span class="fc" id="L1464">        return new FilteredRecordCursorFactory(factory, filter);</span>
    }

    private RecordCursorFactory generateFunctionQuery(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L1468">        final Function function = model.getTableNameFunction();</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">        if (function != null) {</span>
            // We're transferring ownership of the function's factory to another factory
            // setting function to NULL will prevent double-ownership.
            // We should not release function itself, they typically just a lightweight factory wrapper.
            // Releasing function will also release the factory, which we don't want to happen.
<span class="fc" id="L1474">            model.setTableNameFunction(null);</span>
<span class="fc" id="L1475">            return function.getRecordCursorFactory();</span>
        } else {
            // when function is null we have to recompile it from scratch, including creating new factory
<span class="fc" id="L1478">            return TableUtils.createCursorFunction(functionParser, model, executionContext).getRecordCursorFactory();</span>
        }
    }

    private RecordCursorFactory generateJoins(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L1483">        final ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc" id="L1484">        IntList ordered = model.getOrderedJoinModels();</span>
<span class="fc" id="L1485">        RecordCursorFactory master = null;</span>
<span class="fc" id="L1486">        CharSequence masterAlias = null;</span>

        try {
<span class="fc" id="L1489">            int n = ordered.size();</span>
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">            assert n &gt; 1;</span>
<span class="fc bfc" id="L1491" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1492">                int index = ordered.getQuick(i);</span>
<span class="fc" id="L1493">                QueryModel slaveModel = joinModels.getQuick(index);</span>

<span class="fc bfc" id="L1495" title="All 2 branches covered.">                if (i &gt; 0) {</span>
<span class="fc" id="L1496">                    executionContext.pushTimestampRequiredFlag(joinsRequiringTimestamp[slaveModel.getJoinType()]);</span>
                } else { // i == 0
                    // This is first model in the sequence of joins
                    // TS requirement is symmetrical on both right and left sides
                    // check if next join requires a timestamp
<span class="fc" id="L1501">                    int nextJointType = joinModels.getQuick(ordered.getQuick(1)).getJoinType();</span>
<span class="fc" id="L1502">                    executionContext.pushTimestampRequiredFlag(joinsRequiringTimestamp[nextJointType]);</span>
                }

<span class="fc" id="L1505">                RecordCursorFactory slave = null;</span>
<span class="fc" id="L1506">                boolean releaseSlave = true;</span>
                try {
                    // compile
<span class="fc bfc" id="L1509" title="All 2 branches covered.">                    slave = generateQuery(slaveModel, executionContext, index &gt; 0);</span>

                    // check if this is the root of joins
<span class="fc bfc" id="L1512" title="All 2 branches covered.">                    if (master == null) {</span>
                        // This is an opportunistic check of order by clause
                        // to determine if we can get away ordering main record source only
                        // Ordering main record source could benefit from rowid access thus
                        // making it faster compared to ordering of join record source that
                        // doesn't allow rowid access.
<span class="fc" id="L1518">                        master = slave;</span>
<span class="fc" id="L1519">                        releaseSlave = false;</span>
<span class="fc" id="L1520">                        masterAlias = slaveModel.getName();</span>
                    } else {
                        // not the root, join to &quot;master&quot;
<span class="fc" id="L1523">                        final int joinType = slaveModel.getJoinType();</span>
<span class="fc" id="L1524">                        final RecordMetadata masterMetadata = master.getMetadata();</span>
<span class="fc" id="L1525">                        final RecordMetadata slaveMetadata = slave.getMetadata();</span>
<span class="fc" id="L1526">                        Function filter = null;</span>
                        JoinRecordMetadata joinMetadata;

<span class="fc bfc" id="L1529" title="All 6 branches covered.">                        switch (joinType) {</span>
                            case JOIN_CROSS_LEFT:
<span class="pc bpc" id="L1531" title="1 of 2 branches missed.">                                assert slaveModel.getOuterJoinExpressionClause() != null;</span>
<span class="fc" id="L1532">                                joinMetadata = createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata);</span>
<span class="fc" id="L1533">                                filter = functionParser.parseFunction(slaveModel.getOuterJoinExpressionClause(), joinMetadata, executionContext);</span>

<span class="fc" id="L1535">                                master = new NestedLoopLeftJoinRecordCursorFactory(</span>
                                        joinMetadata,
                                        master,
                                        slave,
<span class="fc" id="L1539">                                        masterMetadata.getColumnCount(),</span>
                                        filter,
<span class="fc" id="L1541">                                        NullRecordFactory.getInstance(slaveMetadata)</span>
                                );
<span class="fc" id="L1543">                                masterAlias = null;</span>
<span class="fc" id="L1544">                                break;</span>
                            case JOIN_CROSS:
<span class="fc" id="L1546">                                validateOuterJoinExpressions(slaveModel, &quot;CROSS&quot;);</span>
<span class="fc" id="L1547">                                master = new CrossJoinRecordCursorFactory(</span>
<span class="fc" id="L1548">                                        createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</span>
                                        master,
                                        slave,
<span class="fc" id="L1551">                                        masterMetadata.getColumnCount()</span>
                                );
<span class="fc" id="L1553">                                masterAlias = null;</span>
<span class="fc" id="L1554">                                break;</span>
                            case JOIN_ASOF:
<span class="fc" id="L1556">                                validateBothTimestamps(slaveModel, masterMetadata, slaveMetadata);</span>
<span class="fc" id="L1557">                                validateOuterJoinExpressions(slaveModel, &quot;ASOF&quot;);</span>
<span class="fc bfc" id="L1558" title="All 2 branches covered.">                                processJoinContext(index == 1, slaveModel.getContext(), masterMetadata, slaveMetadata);</span>
<span class="fc bfc" id="L1559" title="All 4 branches covered.">                                if (slave.recordCursorSupportsRandomAccess() &amp;&amp; !fullFatJoins) {</span>
<span class="pc bpc" id="L1560" title="1 of 4 branches missed.">                                    if (listColumnFilterA.size() &gt; 0 &amp;&amp; listColumnFilterB.size() &gt; 0) {</span>
<span class="fc" id="L1561">                                        master = createAsOfJoin(</span>
<span class="fc" id="L1562">                                                createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</span>
                                                master,
<span class="fc" id="L1564">                                                RecordSinkFactory.getInstance(</span>
                                                        asm,
                                                        masterMetadata,
                                                        listColumnFilterB,
                                                        true
                                                ),
                                                slave,
<span class="fc" id="L1571">                                                RecordSinkFactory.getInstance(</span>
                                                        asm,
                                                        slaveMetadata,
                                                        listColumnFilterA,
                                                        true
                                                ),
<span class="fc" id="L1577">                                                masterMetadata.getColumnCount(),</span>
<span class="fc" id="L1578">                                                slaveModel.getContext()</span>
                                        );
                                    } else {
<span class="fc" id="L1581">                                        master = new AsOfJoinNoKeyRecordCursorFactory(</span>
<span class="fc" id="L1582">                                                createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</span>
                                                master,
                                                slave,
<span class="fc" id="L1585">                                                masterMetadata.getColumnCount()</span>
                                        );
                                    }
                                } else {
<span class="fc" id="L1589">                                    master = createFullFatJoin(</span>
                                            master,
                                            masterMetadata,
                                            masterAlias,
                                            slave,
                                            slaveMetadata,
<span class="fc" id="L1595">                                            slaveModel.getName(),</span>
<span class="fc" id="L1596">                                            slaveModel.getJoinKeywordPosition(),</span>
                                            CREATE_FULL_FAT_AS_OF_JOIN,
<span class="fc" id="L1598">                                            slaveModel.getContext()</span>
                                    );
                                }
<span class="fc" id="L1601">                                masterAlias = null;</span>
                                // if we fail after this step, master will release slave
<span class="fc" id="L1603">                                releaseSlave = false;</span>
<span class="fc" id="L1604">                                validateBothTimestampOrders(master, slave, slaveModel.getJoinKeywordPosition());</span>
<span class="fc" id="L1605">                                break;</span>
                            case JOIN_LT:
<span class="fc" id="L1607">                                validateBothTimestamps(slaveModel, masterMetadata, slaveMetadata);</span>
<span class="fc" id="L1608">                                validateOuterJoinExpressions(slaveModel, &quot;LT&quot;);</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">                                processJoinContext(index == 1, slaveModel.getContext(), masterMetadata, slaveMetadata);</span>
<span class="fc bfc" id="L1610" title="All 4 branches covered.">                                if (slave.recordCursorSupportsRandomAccess() &amp;&amp; !fullFatJoins) {</span>
<span class="pc bpc" id="L1611" title="1 of 4 branches missed.">                                    if (listColumnFilterA.size() &gt; 0 &amp;&amp; listColumnFilterB.size() &gt; 0) {</span>
<span class="fc" id="L1612">                                        master = createLtJoin(</span>
<span class="fc" id="L1613">                                                createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</span>
                                                master,
<span class="fc" id="L1615">                                                RecordSinkFactory.getInstance(</span>
                                                        asm,
                                                        masterMetadata,
                                                        listColumnFilterB,
                                                        true
                                                ),
                                                slave,
<span class="fc" id="L1622">                                                RecordSinkFactory.getInstance(</span>
                                                        asm,
                                                        slaveMetadata,
                                                        listColumnFilterA,
                                                        true
                                                ),
<span class="fc" id="L1628">                                                masterMetadata.getColumnCount(),</span>
<span class="fc" id="L1629">                                                slaveModel.getContext()</span>
                                        );
                                    } else {
<span class="fc" id="L1632">                                        master = new LtJoinNoKeyRecordCursorFactory(</span>
<span class="fc" id="L1633">                                                createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</span>
                                                master,
                                                slave,
<span class="fc" id="L1636">                                                masterMetadata.getColumnCount()</span>
                                        );
                                    }
                                } else {
<span class="fc" id="L1640">                                    master = createFullFatJoin(</span>
                                            master,
                                            masterMetadata,
                                            masterAlias,
                                            slave,
                                            slaveMetadata,
<span class="fc" id="L1646">                                            slaveModel.getName(),</span>
<span class="fc" id="L1647">                                            slaveModel.getJoinKeywordPosition(),</span>
                                            CREATE_FULL_FAT_LT_JOIN,
<span class="fc" id="L1649">                                            slaveModel.getContext()</span>
                                    );
                                }
<span class="fc" id="L1652">                                masterAlias = null;</span>
                                // if we fail after this step, master will release slave
<span class="fc" id="L1654">                                releaseSlave = false;</span>
<span class="fc" id="L1655">                                validateBothTimestampOrders(master, slave, slaveModel.getJoinKeywordPosition());</span>
<span class="fc" id="L1656">                                break;</span>
                            case JOIN_SPLICE:
<span class="fc" id="L1658">                                validateBothTimestamps(slaveModel, masterMetadata, slaveMetadata);</span>
<span class="fc" id="L1659">                                validateOuterJoinExpressions(slaveModel, &quot;SPLICE&quot;);</span>
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">                                processJoinContext(index == 1, slaveModel.getContext(), masterMetadata, slaveMetadata);</span>
<span class="pc bpc" id="L1661" title="3 of 6 branches missed.">                                if (slave.recordCursorSupportsRandomAccess() &amp;&amp; master.recordCursorSupportsRandomAccess() &amp;&amp; !fullFatJoins) {</span>
<span class="fc" id="L1662">                                    master = createSpliceJoin(</span>
                                            // splice join result does not have timestamp
<span class="fc" id="L1664">                                            createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata, -1),</span>
                                            master,
<span class="fc" id="L1666">                                            RecordSinkFactory.getInstance(</span>
                                                    asm,
                                                    masterMetadata,
                                                    listColumnFilterB,
                                                    true
                                            ),
                                            slave,
<span class="fc" id="L1673">                                            RecordSinkFactory.getInstance(</span>
                                                    asm,
                                                    slaveMetadata,
                                                    listColumnFilterA,
                                                    true
                                            ),
<span class="fc" id="L1679">                                            masterMetadata.getColumnCount(),</span>
<span class="fc" id="L1680">                                            slaveModel.getContext()</span>
                                    );
                                    // if we fail after this step, master will release slave
<span class="fc" id="L1683">                                    releaseSlave = false;</span>
<span class="fc" id="L1684">                                    validateBothTimestampOrders(master, slave, slaveModel.getJoinKeywordPosition());</span>
                                } else {
<span class="nc" id="L1686">                                    assert false;</span>
                                }
                                break;
                            default:
<span class="fc bfc" id="L1690" title="All 2 branches covered.">                                processJoinContext(index == 1, slaveModel.getContext(), masterMetadata, slaveMetadata);</span>

<span class="fc" id="L1692">                                joinMetadata = createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata);</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">                                if (slaveModel.getOuterJoinExpressionClause() != null) {</span>
<span class="fc" id="L1694">                                    filter = functionParser.parseFunction(slaveModel.getOuterJoinExpressionClause(), joinMetadata, executionContext);</span>
                                }

<span class="fc bfc" id="L1697" title="All 4 branches covered.">                                if (joinType == JOIN_OUTER &amp;&amp;</span>
<span class="pc bpc" id="L1698" title="1 of 4 branches missed.">                                        filter != null &amp;&amp; filter.isConstant() &amp;&amp; !filter.getBool(null)) {</span>
<span class="fc" id="L1699">                                    Misc.free(slave);</span>
<span class="fc" id="L1700">                                    slave = new EmptyTableRecordCursorFactory(slaveMetadata);</span>
                                }

<span class="fc bfc" id="L1703" title="All 2 branches covered.">                                if (joinType == JOIN_INNER) {</span>
<span class="fc" id="L1704">                                    validateOuterJoinExpressions(slaveModel, &quot;INNER&quot;);</span>
                                }

<span class="fc" id="L1707">                                master = createHashJoin(</span>
                                        joinMetadata,
                                        master,
                                        slave,
                                        joinType,
                                        filter,
<span class="fc" id="L1713">                                        slaveModel.getContext()</span>
                                );
<span class="fc" id="L1715">                                masterAlias = null;</span>
                                break;
                        }
                    }
<span class="fc" id="L1719">                } catch (Throwable th) {</span>
<span class="fc" id="L1720">                    master = Misc.free(master);</span>
<span class="fc bfc" id="L1721" title="All 2 branches covered.">                    if (releaseSlave) {</span>
<span class="fc" id="L1722">                        Misc.free(slave);</span>
                    }
<span class="fc" id="L1724">                    throw th;</span>
                } finally {
<span class="fc" id="L1726">                    executionContext.popTimestampRequiredFlag();</span>
                }

                // check if there are post-filters
<span class="fc" id="L1730">                ExpressionNode filterExpr = slaveModel.getPostJoinWhereClause();</span>
<span class="fc bfc" id="L1731" title="All 2 branches covered.">                if (filterExpr != null) {</span>
<span class="pc bpc" id="L1732" title="2 of 4 branches missed.">                    if (executionContext.isParallelFilterEnabled() &amp;&amp; master.supportPageFrameCursor()) {</span>
<span class="nc" id="L1733">                        final Function filter = compileBooleanFilter(</span>
                                filterExpr,
<span class="nc" id="L1735">                                master.getMetadata(),</span>
                                executionContext
                        );

<span class="nc" id="L1739">                        master = new AsyncFilteredRecordCursorFactory(</span>
                                configuration,
<span class="nc" id="L1741">                                executionContext.getMessageBus(),</span>
                                master,
                                filter,
                                reduceTaskPool,
<span class="nc" id="L1745">                                compileWorkerFilterConditionally(</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">                                        !filter.isReadThreadSafe(),</span>
<span class="nc" id="L1747">                                        executionContext.getSharedWorkerCount(),</span>
                                        filterExpr,
<span class="nc" id="L1749">                                        master.getMetadata(),</span>
                                        executionContext
                                ),
                                null,
                                0,
                                false,
<span class="nc" id="L1755">                                executionContext.getSharedWorkerCount()</span>
                        );
<span class="nc" id="L1757">                    } else {</span>
<span class="fc" id="L1758">                        master = new FilteredRecordCursorFactory(</span>
                                master,
<span class="fc" id="L1760">                                functionParser.parseFunction(filterExpr, master.getMetadata(), executionContext)</span>
                        );
                    }
                }
            }

            // unfortunately we had to go all out to create join metadata
            // now it is time to check if we have constant conditions
<span class="fc" id="L1768">            ExpressionNode constFilter = model.getConstWhereClause();</span>
<span class="fc bfc" id="L1769" title="All 2 branches covered.">            if (constFilter != null) {</span>
<span class="fc" id="L1770">                Function function = functionParser.parseFunction(constFilter, null, executionContext);</span>
<span class="fc bfc" id="L1771" title="All 2 branches covered.">                if (!function.getBool(null)) {</span>
                    // do not copy metadata here
                    // this would have been JoinRecordMetadata, which is new instance anyway
                    // we have to make sure that this metadata is safely transitioned
                    // to empty cursor factory
<span class="fc" id="L1776">                    JoinRecordMetadata metadata = (JoinRecordMetadata) master.getMetadata();</span>
<span class="fc" id="L1777">                    metadata.incrementRefCount();</span>
<span class="fc" id="L1778">                    RecordCursorFactory factory = new EmptyTableRecordCursorFactory(metadata);</span>
<span class="fc" id="L1779">                    Misc.free(master);</span>
<span class="fc" id="L1780">                    return factory;</span>
                }
            }
<span class="fc" id="L1783">            return master;</span>
<span class="fc" id="L1784">        } catch (Throwable e) {</span>
<span class="fc" id="L1785">            Misc.free(master);</span>
<span class="fc" id="L1786">            throw e;</span>
        }
    }

    @NotNull
    private RecordCursorFactory generateLatestBy(RecordCursorFactory factory, QueryModel model) throws SqlException {
<span class="fc" id="L1792">        final ObjList&lt;ExpressionNode&gt; latestBy = model.getLatestBy();</span>
<span class="fc bfc" id="L1793" title="All 2 branches covered.">        if (latestBy.size() == 0) {</span>
<span class="pc bpc" id="L1794" title="1 of 2 branches missed.">            return factory;</span>
        }

        // We require timestamp with any order.
        final int timestampIndex;
        try {
<span class="fc" id="L1800">            timestampIndex = getTimestampIndex(model, factory);</span>
<span class="fc bfc" id="L1801" title="All 2 branches covered.">            if (timestampIndex == -1) {</span>
<span class="fc" id="L1802">                throw SqlException.$(model.getModelPosition(), &quot;latest by query does not provide dedicated TIMESTAMP column&quot;);</span>
            }
<span class="fc" id="L1804">        } catch (Throwable e) {</span>
<span class="fc" id="L1805">            Misc.free(factory);</span>
<span class="fc" id="L1806">            throw e;</span>
<span class="fc" id="L1807">        }</span>

<span class="fc" id="L1809">        final RecordMetadata metadata = factory.getMetadata();</span>
<span class="fc" id="L1810">        prepareLatestByColumnIndexes(latestBy, metadata);</span>

<span class="fc bfc" id="L1812" title="All 2 branches covered.">        if (!factory.recordCursorSupportsRandomAccess()) {</span>
<span class="fc" id="L1813">            return new LatestByRecordCursorFactory(</span>
                    configuration,
                    factory,
<span class="fc" id="L1816">                    RecordSinkFactory.getInstance(asm, metadata, listColumnFilterA, false),</span>
                    keyTypes,
                    timestampIndex
            );
        }

<span class="fc" id="L1822">        boolean orderedByTimestampAsc = false;</span>
<span class="fc" id="L1823">        final QueryModel nested = model.getNestedModel();</span>
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">        assert nested != null;</span>
<span class="fc" id="L1825">        final LowerCaseCharSequenceIntHashMap orderBy = nested.getOrderHash();</span>
<span class="fc" id="L1826">        CharSequence timestampColumn = metadata.getColumnName(timestampIndex);</span>
<span class="fc bfc" id="L1827" title="All 2 branches covered.">        if (orderBy.get(timestampColumn) == QueryModel.ORDER_DIRECTION_ASCENDING) {</span>
            // ORDER BY the timestamp column case.
<span class="fc" id="L1829">            orderedByTimestampAsc = true;</span>
<span class="pc bpc" id="L1830" title="1 of 4 branches missed.">        } else if (timestampIndex == metadata.getTimestampIndex() &amp;&amp; orderBy.size() == 0) {</span>
            // Empty ORDER BY, but the timestamp column in the designated timestamp.
<span class="fc" id="L1832">            orderedByTimestampAsc = true;</span>
        }

<span class="fc" id="L1835">        return new LatestByLightRecordCursorFactory(</span>
                configuration,
                factory,
<span class="fc" id="L1838">                RecordSinkFactory.getInstance(asm, metadata, listColumnFilterA, false),</span>
                keyTypes,
                timestampIndex,
                orderedByTimestampAsc
        );
    }

    @NotNull
    private RecordCursorFactory generateLatestByTableQuery(
            QueryModel model,
            @Transient TableReader reader,
            RecordMetadata metadata,
            TableToken tableToken,
            IntrinsicModel intrinsicModel,
            Function filter,
            SqlExecutionContext executionContext,
            int timestampIndex,
            @NotNull IntList columnIndexes,
            @NotNull IntList columnSizes,
            @NotNull LongList prefixes
    ) throws SqlException {
        final DataFrameCursorFactory dataFrameCursorFactory;
<span class="fc bfc" id="L1860" title="All 2 branches covered.">        if (intrinsicModel.hasIntervalFilters()) {</span>
<span class="fc" id="L1861">            dataFrameCursorFactory = new IntervalBwdDataFrameCursorFactory(</span>
                    tableToken,
<span class="fc" id="L1863">                    model.getTableId(),</span>
<span class="fc" id="L1864">                    model.getTableVersion(),</span>
<span class="fc" id="L1865">                    intrinsicModel.buildIntervalModel(),</span>
                    timestampIndex,
<span class="fc" id="L1867">                    GenericRecordMetadata.deepCopyOf(reader.getMetadata())</span>
            );
        } else {
<span class="fc" id="L1870">            dataFrameCursorFactory = new FullBwdDataFrameCursorFactory(</span>
                    tableToken,
<span class="fc" id="L1872">                    model.getTableId(),</span>
<span class="fc" id="L1873">                    model.getTableVersion(),</span>
<span class="fc" id="L1874">                    GenericRecordMetadata.deepCopyOf(reader.getMetadata())</span>
            );
        }

<span class="pc bpc" id="L1878" title="2 of 4 branches missed.">        assert model.getLatestBy() != null &amp;&amp; model.getLatestBy().size() &gt; 0;</span>
<span class="fc" id="L1879">        ObjList&lt;ExpressionNode&gt; latestBy = new ObjList&lt;&gt;(model.getLatestBy().size());</span>
<span class="fc" id="L1880">        latestBy.addAll(model.getLatestBy());</span>
<span class="fc" id="L1881">        final ExpressionNode latestByNode = latestBy.get(0);</span>
<span class="fc" id="L1882">        final int latestByIndex = metadata.getColumnIndexQuiet(latestByNode.token);</span>
<span class="fc" id="L1883">        final boolean indexed = metadata.isColumnIndexed(latestByIndex);</span>

        // 'latest by' clause takes over the filter and the latest by nodes,
        // so that the later generateFilter() and generateLatestBy() are no-op
<span class="fc" id="L1887">        model.setWhereClause(null);</span>
<span class="fc" id="L1888">        model.getLatestBy().clear();</span>

        // if there are &gt; 1 columns in the latest by statement, we cannot use indexes
<span class="fc bfc" id="L1891" title="All 4 branches covered.">        if (latestBy.size() &gt; 1 || !ColumnType.isSymbol(metadata.getColumnType(latestByIndex))) {</span>
<span class="fc" id="L1892">            boolean symbolKeysOnly = true;</span>
<span class="fc bfc" id="L1893" title="All 2 branches covered.">            for (int i = 0, n = keyTypes.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L1894">                symbolKeysOnly &amp;= ColumnType.isSymbol(keyTypes.getColumnType(i));</span>
            }
<span class="fc bfc" id="L1896" title="All 2 branches covered.">            if (symbolKeysOnly) {</span>
<span class="fc" id="L1897">                final IntList partitionByColumnIndexes = new IntList(listColumnFilterA.size());</span>
<span class="fc bfc" id="L1898" title="All 2 branches covered.">                for (int i = 0, n = listColumnFilterA.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1899">                    partitionByColumnIndexes.add(listColumnFilterA.getColumnIndexFactored(i));</span>
                }
<span class="fc" id="L1901">                final IntList partitionBySymbolCounts = symbolEstimator.estimate(</span>
                        model,
                        intrinsicModel.filter,
                        metadata,
                        partitionByColumnIndexes
                );
<span class="fc" id="L1907">                return new LatestByAllSymbolsFilteredRecordCursorFactory(</span>
                        metadata,
                        configuration,
                        dataFrameCursorFactory,
<span class="fc" id="L1911">                        RecordSinkFactory.getInstance(asm, metadata, listColumnFilterA, false),</span>
                        keyTypes,
                        partitionByColumnIndexes,
                        partitionBySymbolCounts,
                        filter,
                        columnIndexes
                );
            }
<span class="fc" id="L1919">            return new LatestByAllFilteredRecordCursorFactory(</span>
                    metadata,
                    configuration,
                    dataFrameCursorFactory,
<span class="fc" id="L1923">                    RecordSinkFactory.getInstance(asm, metadata, listColumnFilterA, false),</span>
                    keyTypes,
                    filter,
                    columnIndexes
            );
        }

<span class="fc bfc" id="L1930" title="All 2 branches covered.">        if (intrinsicModel.keyColumn != null) {</span>
            // key column must always be the same as latest by column
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">            assert latestByIndex == metadata.getColumnIndexQuiet(intrinsicModel.keyColumn);</span>

<span class="fc bfc" id="L1934" title="All 2 branches covered.">            if (intrinsicModel.keySubQuery != null) {</span>
                final RecordCursorFactory rcf;
                final Record.CharSequenceFunction func;
                try {
<span class="fc" id="L1938">                    rcf = generate(intrinsicModel.keySubQuery, executionContext);</span>
<span class="fc" id="L1939">                    func = validateSubQueryColumnAndGetGetter(intrinsicModel, rcf.getMetadata());</span>
<span class="fc" id="L1940">                } catch (Throwable e) {</span>
<span class="fc" id="L1941">                    Misc.free(dataFrameCursorFactory);</span>
<span class="fc" id="L1942">                    throw e;</span>
<span class="fc" id="L1943">                }</span>

<span class="fc" id="L1945">                return new LatestBySubQueryRecordCursorFactory(</span>
                        configuration,
                        metadata,
                        dataFrameCursorFactory,
                        latestByIndex,
                        rcf,
                        filter,
                        indexed,
                        func,
                        columnIndexes
                );
            }

<span class="fc" id="L1958">            final int nKeyValues = intrinsicModel.keyValueFuncs.size();</span>
<span class="fc" id="L1959">            final int nExcludedKeyValues = intrinsicModel.keyExcludedValueFuncs.size();</span>
<span class="fc bfc" id="L1960" title="All 4 branches covered.">            if (indexed &amp;&amp; nExcludedKeyValues == 0) {</span>
<span class="pc bpc" id="L1961" title="1 of 2 branches missed.">                assert nKeyValues &gt; 0;</span>
                // deal with key values as a list
                // 1. resolve each value of the list to &quot;int&quot;
                // 2. get first row in index for each value (stream)

<span class="fc" id="L1966">                final SymbolMapReader symbolMapReader = reader.getSymbolMapReader(columnIndexes.getQuick(latestByIndex));</span>
                final RowCursorFactory rcf;
<span class="fc bfc" id="L1968" title="All 2 branches covered.">                if (nKeyValues == 1) {</span>
<span class="fc" id="L1969">                    final Function symbolValueFunc = intrinsicModel.keyValueFuncs.get(0);</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">                    final int symbol = symbolValueFunc.isRuntimeConstant()</span>
<span class="fc" id="L1971">                            ? SymbolTable.VALUE_NOT_FOUND</span>
<span class="fc" id="L1972">                            : symbolMapReader.keyOf(symbolValueFunc.getStr(null));</span>

<span class="fc bfc" id="L1974" title="All 2 branches covered.">                    if (filter == null) {</span>
<span class="fc bfc" id="L1975" title="All 2 branches covered.">                        if (symbol == SymbolTable.VALUE_NOT_FOUND) {</span>
<span class="fc" id="L1976">                            rcf = new LatestByValueDeferredIndexedRowCursorFactory(</span>
<span class="fc" id="L1977">                                    columnIndexes.getQuick(latestByIndex),</span>
                                    symbolValueFunc,
                                    false
                            );
                        } else {
<span class="fc" id="L1982">                            rcf = new LatestByValueIndexedRowCursorFactory(</span>
<span class="fc" id="L1983">                                    columnIndexes.getQuick(latestByIndex),</span>
                                    symbol,
                                    false
                            );
                        }
<span class="fc" id="L1988">                        return new DataFrameRecordCursorFactory(</span>
                                configuration,
                                metadata,
                                dataFrameCursorFactory,
                                rcf,
                                false,
                                null,
                                false,
                                columnIndexes,
                                columnSizes,
                                true
                        );
                    }

<span class="fc bfc" id="L2002" title="All 2 branches covered.">                    if (symbol == SymbolTable.VALUE_NOT_FOUND) {</span>
<span class="fc" id="L2003">                        return new LatestByValueDeferredIndexedFilteredRecordCursorFactory(</span>
                                metadata,
                                dataFrameCursorFactory,
                                latestByIndex,
                                symbolValueFunc,
                                filter,
                                columnIndexes
                        );
                    }
<span class="fc" id="L2012">                    return new LatestByValueIndexedFilteredRecordCursorFactory(</span>
                            metadata,
                            dataFrameCursorFactory,
                            latestByIndex,
                            symbol,
                            filter,
                            columnIndexes
                    );
                }

<span class="fc" id="L2022">                return new LatestByValuesIndexedFilteredRecordCursorFactory(</span>
                        configuration,
                        metadata,
                        dataFrameCursorFactory,
                        latestByIndex,
                        intrinsicModel.keyValueFuncs,
                        symbolMapReader,
                        filter,
                        columnIndexes
                );
            }

<span class="pc bpc" id="L2034" title="1 of 4 branches missed.">            assert nKeyValues &gt; 0 || nExcludedKeyValues &gt; 0;</span>

            // we have &quot;latest by&quot; column values, but no index

<span class="fc bfc" id="L2038" title="All 4 branches covered.">            if (nKeyValues &gt; 1 || nExcludedKeyValues &gt; 0) {</span>
<span class="fc" id="L2039">                return new LatestByDeferredListValuesFilteredRecordCursorFactory(</span>
                        configuration,
                        metadata,
                        dataFrameCursorFactory,
                        latestByIndex,
                        intrinsicModel.keyValueFuncs,
                        intrinsicModel.keyExcludedValueFuncs,
                        filter,
                        columnIndexes
                );
            }

<span class="pc bpc" id="L2051" title="1 of 2 branches missed.">            assert nExcludedKeyValues == 0;</span>

            // we have a single symbol key
<span class="fc" id="L2054">            final Function symbolKeyFunc = intrinsicModel.keyValueFuncs.get(0);</span>
<span class="fc" id="L2055">            final SymbolMapReader symbolMapReader = reader.getSymbolMapReader(columnIndexes.getQuick(latestByIndex));</span>
<span class="fc bfc" id="L2056" title="All 2 branches covered.">            final int symbolKey = symbolKeyFunc.isRuntimeConstant()</span>
<span class="fc" id="L2057">                    ? SymbolTable.VALUE_NOT_FOUND</span>
<span class="fc" id="L2058">                    : symbolMapReader.keyOf(symbolKeyFunc.getStr(null));</span>
<span class="fc bfc" id="L2059" title="All 2 branches covered.">            if (symbolKey == SymbolTable.VALUE_NOT_FOUND) {</span>
<span class="fc" id="L2060">                return new LatestByValueDeferredFilteredRecordCursorFactory(</span>
                        metadata,
                        dataFrameCursorFactory,
                        latestByIndex,
                        symbolKeyFunc,
                        filter,
                        columnIndexes
                );
            }

<span class="fc" id="L2070">            return new LatestByValueFilteredRecordCursorFactory(</span>
                    metadata,
                    dataFrameCursorFactory,
                    latestByIndex,
                    symbolKey,
                    filter,
                    columnIndexes
            );
        }
        // we select all values of &quot;latest by&quot; column

<span class="pc bpc" id="L2081" title="1 of 2 branches missed.">        assert intrinsicModel.keyValueFuncs.size() == 0;</span>
        // get the latest rows for all values of &quot;latest by&quot; column

<span class="fc bfc" id="L2084" title="All 4 branches covered.">        if (indexed &amp;&amp; filter == null) {</span>
<span class="fc" id="L2085">            return new LatestByAllIndexedRecordCursorFactory(</span>
                    metadata,
                    configuration,
                    dataFrameCursorFactory,
                    latestByIndex,
                    columnIndexes,
                    prefixes
            );
        } else {
<span class="fc" id="L2094">            return new LatestByDeferredListValuesFilteredRecordCursorFactory(</span>
                    configuration,
                    metadata,
                    dataFrameCursorFactory,
                    latestByIndex,
                    filter,
                    columnIndexes
            );
        }
    }

    private RecordCursorFactory generateLimit(
            RecordCursorFactory factory,
            QueryModel model,
            SqlExecutionContext executionContext
    ) throws SqlException {

<span class="fc bfc" id="L2111" title="All 2 branches covered.">        if (factory.followedLimitAdvice()) {</span>
<span class="fc" id="L2112">            return factory;</span>
        }

<span class="fc" id="L2115">        ExpressionNode limitLo = model.getLimitLo();</span>
<span class="fc" id="L2116">        ExpressionNode limitHi = model.getLimitHi();</span>

        // we've to check model otherwise we could be skipping limit in outer query that's actually different from the one in inner query!
<span class="fc bfc" id="L2119" title="All 8 branches covered.">        if ((limitLo == null &amp;&amp; limitHi == null) || (factory.implementsLimit() &amp;&amp; model.isLimitImplemented())) {</span>
<span class="fc" id="L2120">            return factory;</span>
        }

        try {
<span class="fc" id="L2124">            final Function loFunc = getLoFunction(model, executionContext);</span>
<span class="fc" id="L2125">            final Function hiFunc = getHiFunction(model, executionContext);</span>

<span class="fc" id="L2127">            return new LimitRecordCursorFactory(factory, loFunc, hiFunc);</span>
<span class="fc" id="L2128">        } catch (Throwable e) {</span>
<span class="fc" id="L2129">            Misc.free(factory);</span>
<span class="fc" id="L2130">            throw e;</span>
        }
    }

    private RecordCursorFactory generateNoSelect(
            QueryModel model,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L2138">        ExpressionNode tableNameExpr = model.getTableNameExpr();</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">        if (tableNameExpr != null) {</span>
<span class="fc bfc" id="L2140" title="All 2 branches covered.">            if (tableNameExpr.type == FUNCTION) {</span>
<span class="fc" id="L2141">                return generateFunctionQuery(model, executionContext);</span>
            } else {
<span class="fc" id="L2143">                return generateTableQuery(model, executionContext);</span>
            }
        }
<span class="fc" id="L2146">        return generateSubQuery(model, executionContext);</span>
    }

    private RecordCursorFactory generateOrderBy(
            RecordCursorFactory recordCursorFactory,
            QueryModel model,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc bfc" id="L2154" title="All 2 branches covered.">        if (recordCursorFactory.followedOrderByAdvice()) {</span>
<span class="fc" id="L2155">            return recordCursorFactory;</span>
        }
        try {
<span class="fc" id="L2158">            final LowerCaseCharSequenceIntHashMap orderBy = model.getOrderHash();</span>
<span class="fc" id="L2159">            final ObjList&lt;CharSequence&gt; columnNames = orderBy.keys();</span>
<span class="fc" id="L2160">            final int orderByColumnCount = columnNames.size();</span>

<span class="fc bfc" id="L2162" title="All 2 branches covered.">            if (orderByColumnCount &gt; 0) {</span>

<span class="fc" id="L2164">                final RecordMetadata metadata = recordCursorFactory.getMetadata();</span>
<span class="fc" id="L2165">                final int timestampIndex = metadata.getTimestampIndex();</span>

<span class="fc" id="L2167">                listColumnFilterA.clear();</span>
<span class="fc" id="L2168">                intHashSet.clear();</span>

                // column index sign indicates direction
                // therefore 0 index is not allowed
<span class="fc bfc" id="L2172" title="All 2 branches covered.">                for (int i = 0; i &lt; orderByColumnCount; i++) {</span>
<span class="fc" id="L2173">                    final CharSequence column = columnNames.getQuick(i);</span>
<span class="fc" id="L2174">                    int index = metadata.getColumnIndexQuiet(column);</span>

                    // check if column type is supported
<span class="fc bfc" id="L2177" title="All 2 branches covered.">                    if (ColumnType.isBinary(metadata.getColumnType(index))) {</span>
                        // find position of offending column

<span class="fc" id="L2180">                        ObjList&lt;ExpressionNode&gt; nodes = model.getOrderBy();</span>
<span class="fc" id="L2181">                        int position = 0;</span>
<span class="pc bpc" id="L2182" title="1 of 2 branches missed.">                        for (int j = 0, y = nodes.size(); j &lt; y; j++) {</span>
<span class="pc bpc" id="L2183" title="1 of 2 branches missed.">                            if (Chars.equals(column, nodes.getQuick(i).token)) {</span>
<span class="fc" id="L2184">                                position = nodes.getQuick(i).position;</span>
<span class="fc" id="L2185">                                break;</span>
                            }
                        }
<span class="fc" id="L2188">                        throw SqlException.$(position, &quot;unsupported column type: &quot;).put(ColumnType.nameOf(metadata.getColumnType(index)));</span>
                    }

                    // we also maintain unique set of column indexes for better performance
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">                    if (intHashSet.add(index)) {</span>
<span class="fc bfc" id="L2193" title="All 2 branches covered.">                        if (orderBy.get(column) == QueryModel.ORDER_DIRECTION_DESCENDING) {</span>
<span class="fc" id="L2194">                            listColumnFilterA.add(-index - 1);</span>
                        } else {
<span class="fc" id="L2196">                            listColumnFilterA.add(index + 1);</span>
                        }
                    }
                }

                // if first column index is the same as timestamp of underling record cursor factory
                // we could have two possibilities:
                // 1. if we only have one column to order by - the cursor would already be ordered
                //    by timestamp (either ASC or DESC); we have nothing to do
                // 2. metadata of the new cursor will have the timestamp
<span class="fc bfc" id="L2206" title="All 2 branches covered.">                if (timestampIndex != -1) {</span>
<span class="fc" id="L2207">                    CharSequence column = columnNames.getQuick(0);</span>
<span class="fc" id="L2208">                    int index = metadata.getColumnIndexQuiet(column);</span>
<span class="fc bfc" id="L2209" title="All 2 branches covered.">                    if (index == timestampIndex) {</span>
<span class="fc bfc" id="L2210" title="All 2 branches covered.">                        if (orderByColumnCount == 1) {</span>
<span class="fc bfc" id="L2211" title="All 2 branches covered.">                            if (orderBy.get(column) == QueryModel.ORDER_DIRECTION_ASCENDING) {</span>
<span class="fc" id="L2212">                                return recordCursorFactory;</span>
<span class="pc bpc" id="L2213" title="1 of 2 branches missed.">                            } else if (orderBy.get(column) == ORDER_DIRECTION_DESCENDING &amp;&amp;</span>
<span class="fc bfc" id="L2214" title="All 2 branches covered.">                                    recordCursorFactory.hasDescendingOrder()) {</span>
<span class="fc" id="L2215">                                return recordCursorFactory;</span>
                            }
                        }
                    }
                }

<span class="fc" id="L2221">                RecordMetadata orderedMetadata = GenericRecordMetadata.copyOfSansTimestamp(metadata);</span>
<span class="fc" id="L2222">                final Function loFunc = getLoFunction(model, executionContext);</span>
<span class="fc" id="L2223">                final Function hiFunc = getHiFunction(model, executionContext);</span>

<span class="fc bfc" id="L2225" title="All 2 branches covered.">                if (recordCursorFactory.recordCursorSupportsRandomAccess()) {</span>
<span class="fc bfc" id="L2226" title="All 2 branches covered.">                    if (canBeOptimized(model, executionContext, loFunc, hiFunc)) {</span>
<span class="fc" id="L2227">                        model.setLimitImplemented(true);</span>
<span class="fc" id="L2228">                        return new LimitedSizeSortedLightRecordCursorFactory(</span>
                                configuration,
                                orderedMetadata,
                                recordCursorFactory,
<span class="fc" id="L2232">                                recordComparatorCompiler.compile(metadata, listColumnFilterA),</span>
                                loFunc,
                                hiFunc,
<span class="fc" id="L2235">                                listColumnFilterA.copy()</span>
                        );
                    } else {
<span class="fc" id="L2238">                        return new SortedLightRecordCursorFactory(</span>
                                configuration,
                                orderedMetadata,
                                recordCursorFactory,
<span class="fc" id="L2242">                                recordComparatorCompiler.compile(metadata, listColumnFilterA),</span>
<span class="fc" id="L2243">                                listColumnFilterA.copy()</span>
                        );
                    }
                }

                // when base record cursor does not support random access
                // we have to copy entire record into ordered structure

<span class="fc" id="L2251">                entityColumnFilter.of(orderedMetadata.getColumnCount());</span>
<span class="fc" id="L2252">                return new SortedRecordCursorFactory(</span>
                        configuration,
                        orderedMetadata,
                        recordCursorFactory,
<span class="fc" id="L2256">                        RecordSinkFactory.getInstance(</span>
                                asm,
                                orderedMetadata,
                                entityColumnFilter,
                                false
                        ),
<span class="fc" id="L2262">                        recordComparatorCompiler.compile(metadata, listColumnFilterA),</span>
<span class="fc" id="L2263">                        listColumnFilterA.copy()</span>
                );
            }

<span class="fc" id="L2267">            return recordCursorFactory;</span>
<span class="fc" id="L2268">        } catch (SqlException | CairoException e) {</span>
<span class="fc" id="L2269">            recordCursorFactory.close();</span>
<span class="fc" id="L2270">            throw e;</span>
        }
    }

    private RecordCursorFactory generateQuery(QueryModel model, SqlExecutionContext executionContext, boolean processJoins) throws SqlException {
<span class="fc" id="L2275">        RecordCursorFactory factory = generateQuery0(model, executionContext, processJoins);</span>
<span class="fc bfc" id="L2276" title="All 2 branches covered.">        if (model.getUnionModel() != null) {</span>
<span class="fc" id="L2277">            return generateSetFactory(model, factory, executionContext);</span>
        }

<span class="fc" id="L2280">        return factory;</span>
    }

    private RecordCursorFactory generateQuery0(QueryModel model, SqlExecutionContext executionContext, boolean processJoins) throws SqlException {
<span class="fc" id="L2284">        return generateLimit(</span>
<span class="fc" id="L2285">                generateOrderBy(</span>
<span class="fc" id="L2286">                        generateLatestBy(</span>
<span class="fc" id="L2287">                                generateFilter(</span>
<span class="fc" id="L2288">                                        generateSelect(</span>
                                                model,
                                                executionContext,
                                                processJoins
                                        ),
                                        model,
                                        executionContext
                                ),
                                model
                        ),
                        model,
                        executionContext
                ),
                model,
                executionContext
        );
    }

    @NotNull
    private RecordCursorFactory generateSampleBy(
            QueryModel model,
            SqlExecutionContext executionContext,
            ExpressionNode sampleByNode,
            ExpressionNode sampleByUnits
    ) throws SqlException {
<span class="fc" id="L2313">        final ExpressionNode timezoneName = model.getSampleByTimezoneName();</span>
        final Function timezoneNameFunc;
        final int timezoneNameFuncPos;
<span class="fc" id="L2316">        final ExpressionNode offset = model.getSampleByOffset();</span>
        final Function offsetFunc;
        final int offsetFuncPos;

<span class="fc bfc" id="L2320" title="All 2 branches covered.">        if (timezoneName != null) {</span>
<span class="fc" id="L2321">            timezoneNameFunc = functionParser.parseFunction(</span>
                    timezoneName,
                    EmptyRecordMetadata.INSTANCE,
                    executionContext
            );
<span class="fc" id="L2326">            timezoneNameFuncPos = timezoneName.position;</span>
        } else {
<span class="fc" id="L2328">            timezoneNameFunc = StrConstant.NULL;</span>
<span class="fc" id="L2329">            timezoneNameFuncPos = 0;</span>
        }

<span class="fc bfc" id="L2332" title="All 2 branches covered.">        if (ColumnType.isUndefined(timezoneNameFunc.getType())) {</span>
<span class="fc" id="L2333">            timezoneNameFunc.assignType(ColumnType.STRING, executionContext.getBindVariableService());</span>
<span class="pc bpc" id="L2334" title="1 of 4 branches missed.">        } else if ((!timezoneNameFunc.isConstant() &amp;&amp; !timezoneNameFunc.isRuntimeConstant())</span>
<span class="fc bfc" id="L2335" title="All 2 branches covered.">                || !ColumnType.isAssignableFrom(timezoneNameFunc.getType(), ColumnType.STRING)) {</span>
<span class="fc" id="L2336">            throw SqlException.$(timezoneNameFuncPos, &quot;timezone must be a constant expression of STRING or CHAR type&quot;);</span>
        }

<span class="fc bfc" id="L2339" title="All 2 branches covered.">        if (offset != null) {</span>
<span class="fc" id="L2340">            offsetFunc = functionParser.parseFunction(</span>
                    offset,
                    EmptyRecordMetadata.INSTANCE,
                    executionContext
            );
<span class="fc" id="L2345">            offsetFuncPos = offset.position;</span>
        } else {
<span class="fc" id="L2347">            offsetFunc = StrConstant.NULL;</span>
<span class="fc" id="L2348">            offsetFuncPos = 0;</span>
        }

<span class="fc bfc" id="L2351" title="All 2 branches covered.">        if (ColumnType.isUndefined(offsetFunc.getType())) {</span>
<span class="fc" id="L2352">            offsetFunc.assignType(ColumnType.STRING, executionContext.getBindVariableService());</span>
<span class="pc bpc" id="L2353" title="1 of 4 branches missed.">        } else if ((!offsetFunc.isConstant() &amp;&amp; !offsetFunc.isRuntimeConstant())</span>
<span class="fc bfc" id="L2354" title="All 2 branches covered.">                || !ColumnType.isAssignableFrom(offsetFunc.getType(), ColumnType.STRING)) {</span>
<span class="fc" id="L2355">            throw SqlException.$(offsetFuncPos, &quot;offset must be a constant expression of STRING or CHAR type&quot;);</span>
        }

<span class="fc" id="L2358">        RecordCursorFactory factory = null;</span>
        // We require timestamp with asc order.
        final int timestampIndex;
        // Require timestamp in sub-query when it's not additionally specified as timestamp(col).
<span class="fc bfc" id="L2362" title="All 2 branches covered.">        executionContext.pushTimestampRequiredFlag(model.getTimestamp() == null);</span>
        try {
<span class="fc" id="L2364">            factory = generateSubQuery(model, executionContext);</span>
<span class="fc" id="L2365">            timestampIndex = getTimestampIndex(model, factory);</span>
<span class="fc bfc" id="L2366" title="All 4 branches covered.">            if (timestampIndex == -1 || factory.hasDescendingOrder()) {</span>
<span class="fc" id="L2367">                throw SqlException.$(model.getModelPosition(), &quot;base query does not provide ASC order over dedicated TIMESTAMP column&quot;);</span>
            }
<span class="fc" id="L2369">        } catch (Throwable e) {</span>
<span class="fc" id="L2370">            Misc.free(factory);</span>
<span class="fc" id="L2371">            throw e;</span>
        } finally {
<span class="fc" id="L2373">            executionContext.popTimestampRequiredFlag();</span>
        }

<span class="fc" id="L2376">        final RecordMetadata metadata = factory.getMetadata();</span>
<span class="fc" id="L2377">        final ObjList&lt;ExpressionNode&gt; sampleByFill = model.getSampleByFill();</span>
        final TimestampSampler timestampSampler;
<span class="fc" id="L2379">        final int fillCount = sampleByFill.size();</span>
        try {
<span class="fc bfc" id="L2381" title="All 2 branches covered.">            if (sampleByUnits == null) {</span>
<span class="fc" id="L2382">                timestampSampler = TimestampSamplerFactory.getInstance(sampleByNode.token, sampleByNode.position);</span>
            } else {
<span class="fc" id="L2384">                Function sampleByPeriod = functionParser.parseFunction(</span>
                        sampleByNode,
                        EmptyRecordMetadata.INSTANCE,
                        executionContext
                );
<span class="fc bfc" id="L2389" title="All 6 branches covered.">                if (!sampleByPeriod.isConstant() || (sampleByPeriod.getType() != ColumnType.LONG &amp;&amp; sampleByPeriod.getType() != ColumnType.INT)) {</span>
<span class="fc" id="L2390">                    Misc.free(sampleByPeriod);</span>
<span class="fc" id="L2391">                    throw SqlException.$(sampleByNode.position, &quot;sample by period must be a constant expression of INT or LONG type&quot;);</span>
                }
<span class="fc" id="L2393">                long period = sampleByPeriod.getLong(null);</span>
<span class="fc" id="L2394">                sampleByPeriod.close();</span>
<span class="fc" id="L2395">                timestampSampler = TimestampSamplerFactory.getInstance(period, sampleByUnits.token, sampleByUnits.position);</span>
            }

<span class="fc" id="L2398">            keyTypes.clear();</span>
<span class="fc" id="L2399">            valueTypes.clear();</span>
<span class="fc" id="L2400">            listColumnFilterA.clear();</span>

<span class="fc bfc" id="L2402" title="All 4 branches covered.">            if (fillCount == 1 &amp;&amp; Chars.equalsLowerCaseAscii(sampleByFill.getQuick(0).token, &quot;linear&quot;)) {</span>

<span class="fc" id="L2404">                final int columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L2405">                final ObjList&lt;GroupByFunction&gt; groupByFunctions = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L2406">                final ObjList&lt;Function&gt; recordFunctions = new ObjList&lt;&gt;(columnCount);</span>

<span class="fc" id="L2408">                valueTypes.add(ColumnType.BYTE); // gap flag</span>

<span class="fc" id="L2410">                GroupByUtils.prepareGroupByFunctions(</span>
                        model,
                        metadata,
                        functionParser,
                        executionContext,
                        groupByFunctions,
                        groupByFunctionPositions,
                        valueTypes
                );

<span class="fc" id="L2420">                final GenericRecordMetadata groupByMetadata = new GenericRecordMetadata();</span>
<span class="fc" id="L2421">                GroupByUtils.prepareGroupByRecordFunctions(</span>
                        model,
                        metadata,
                        listColumnFilterA,
                        groupByFunctions,
                        groupByFunctionPositions,
                        recordFunctions,
                        recordFunctionPositions,
                        groupByMetadata,
                        keyTypes,
<span class="fc" id="L2431">                        valueTypes.getColumnCount(),</span>
                        false,
                        timestampIndex
                );

<span class="fc" id="L2436">                return new SampleByInterpolateRecordCursorFactory(</span>
                        asm,
                        configuration,
                        factory,
                        groupByMetadata,
                        groupByFunctions,
                        recordFunctions,
                        timestampSampler,
                        model,
                        listColumnFilterA,
                        keyTypes,
                        valueTypes,
                        entityColumnFilter,
                        groupByFunctionPositions,
                        timestampIndex
                );
            }

<span class="fc" id="L2454">            final int columnCount = model.getColumns().size();</span>
<span class="fc" id="L2455">            final ObjList&lt;GroupByFunction&gt; groupByFunctions = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L2456">            valueTypes.add(ColumnType.TIMESTAMP); // first value is always timestamp</span>

<span class="fc" id="L2458">            GroupByUtils.prepareGroupByFunctions(</span>
                    model,
                    metadata,
                    functionParser,
                    executionContext,
                    groupByFunctions,
                    groupByFunctionPositions,
                    valueTypes
            );

<span class="fc" id="L2468">            final ObjList&lt;Function&gt; recordFunctions = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L2469">            final GenericRecordMetadata groupByMetadata = new GenericRecordMetadata();</span>

<span class="fc" id="L2471">            GroupByUtils.prepareGroupByRecordFunctions(</span>
                    model,
                    metadata,
                    listColumnFilterA,
                    groupByFunctions,
                    groupByFunctionPositions,
                    recordFunctions,
                    recordFunctionPositions,
                    groupByMetadata,
                    keyTypes,
<span class="fc" id="L2481">                    valueTypes.getColumnCount(),</span>
                    false,
                    timestampIndex
            );


<span class="fc bfc" id="L2487" title="All 6 branches covered.">            boolean isFillNone = fillCount == 0 || fillCount == 1 &amp;&amp; Chars.equalsLowerCaseAscii(sampleByFill.getQuick(0).token, &quot;none&quot;);</span>
<span class="fc bfc" id="L2488" title="All 4 branches covered.">            boolean allGroupsFirstLast = isFillNone &amp;&amp; allGroupsFirstLastWithSingleSymbolFilter(model, metadata);</span>
<span class="fc bfc" id="L2489" title="All 2 branches covered.">            if (allGroupsFirstLast) {</span>
<span class="fc" id="L2490">                SingleSymbolFilter symbolFilter = factory.convertToSampleByIndexDataFrameCursorFactory();</span>
<span class="fc bfc" id="L2491" title="All 2 branches covered.">                if (symbolFilter != null) {</span>
<span class="fc" id="L2492">                    return new SampleByFirstLastRecordCursorFactory(</span>
                            factory,
                            timestampSampler,
                            groupByMetadata,
<span class="fc" id="L2496">                            model.getColumns(),</span>
                            metadata,
                            timezoneNameFunc,
                            timezoneNameFuncPos,
                            offsetFunc,
                            offsetFuncPos,
                            timestampIndex,
                            symbolFilter,
<span class="fc" id="L2504">                            configuration.getSampleByIndexSearchPageSize()</span>
                    );
                }
            }

<span class="fc bfc" id="L2509" title="All 4 branches covered.">            if (fillCount == 1 &amp;&amp; Chars.equalsLowerCaseAscii(sampleByFill.getQuick(0).token, &quot;prev&quot;)) {</span>
<span class="fc bfc" id="L2510" title="All 2 branches covered.">                if (keyTypes.getColumnCount() == 0) {</span>
<span class="fc" id="L2511">                    return new SampleByFillPrevNotKeyedRecordCursorFactory(</span>
                            asm,
                            factory,
                            timestampSampler,
                            groupByMetadata,
                            groupByFunctions,
                            recordFunctions,
                            timestampIndex,
<span class="fc" id="L2519">                            valueTypes.getColumnCount(),</span>
                            timezoneNameFunc,
                            timezoneNameFuncPos,
                            offsetFunc,
                            offsetFuncPos
                    );
                }

<span class="fc" id="L2527">                return new SampleByFillPrevRecordCursorFactory(</span>
                        asm,
                        configuration,
                        factory,
                        timestampSampler,
                        listColumnFilterA,
                        keyTypes,
                        valueTypes,
                        groupByMetadata,
                        groupByFunctions,
                        recordFunctions,
                        timestampIndex,
                        timezoneNameFunc,
                        timezoneNameFuncPos,
                        offsetFunc,
                        offsetFuncPos
                );
            }

<span class="fc bfc" id="L2546" title="All 2 branches covered.">            if (isFillNone) {</span>

<span class="fc bfc" id="L2548" title="All 2 branches covered.">                if (keyTypes.getColumnCount() == 0) {</span>
                    // this sample by is not keyed
<span class="fc" id="L2550">                    return new SampleByFillNoneNotKeyedRecordCursorFactory(</span>
                            asm,
                            factory,
                            timestampSampler,
                            groupByMetadata,
                            groupByFunctions,
                            recordFunctions,
<span class="fc" id="L2557">                            valueTypes.getColumnCount(),</span>
                            timestampIndex,
                            timezoneNameFunc,
                            timezoneNameFuncPos,
                            offsetFunc,
                            offsetFuncPos
                    );
                }

<span class="fc" id="L2566">                return new SampleByFillNoneRecordCursorFactory(</span>
                        asm,
                        configuration,
                        factory,
                        groupByMetadata,
                        groupByFunctions,
                        recordFunctions,
                        timestampSampler,
                        listColumnFilterA,
                        keyTypes,
                        valueTypes,
                        timestampIndex,
                        timezoneNameFunc,
                        timezoneNameFuncPos,
                        offsetFunc,
                        offsetFuncPos
                );
            }

<span class="fc bfc" id="L2585" title="All 4 branches covered.">            if (fillCount == 1 &amp;&amp; isNullKeyword(sampleByFill.getQuick(0).token)) {</span>
<span class="fc bfc" id="L2586" title="All 2 branches covered.">                if (keyTypes.getColumnCount() == 0) {</span>
<span class="fc" id="L2587">                    return new SampleByFillNullNotKeyedRecordCursorFactory(</span>
                            asm,
                            factory,
                            timestampSampler,
                            groupByMetadata,
                            groupByFunctions,
                            recordFunctions,
                            recordFunctionPositions,
<span class="fc" id="L2595">                            valueTypes.getColumnCount(),</span>
                            timestampIndex,
                            timezoneNameFunc,
                            timezoneNameFuncPos,
                            offsetFunc,
                            offsetFuncPos
                    );
                }

<span class="fc" id="L2604">                return new SampleByFillNullRecordCursorFactory(</span>
                        asm,
                        configuration,
                        factory,
                        timestampSampler,
                        listColumnFilterA,
                        keyTypes,
                        valueTypes,
                        groupByMetadata,
                        groupByFunctions,
                        recordFunctions,
                        recordFunctionPositions,
                        timestampIndex,
                        timezoneNameFunc,
                        timezoneNameFuncPos,
                        offsetFunc,
                        offsetFuncPos
                );
            }

<span class="pc bpc" id="L2624" title="1 of 2 branches missed.">            assert fillCount &gt; 0;</span>

<span class="fc bfc" id="L2626" title="All 2 branches covered.">            if (keyTypes.getColumnCount() == 0) {</span>
<span class="fc" id="L2627">                return new SampleByFillValueNotKeyedRecordCursorFactory(</span>
                        asm,
                        factory,
                        timestampSampler,
                        sampleByFill,
                        groupByMetadata,
                        groupByFunctions,
                        recordFunctions,
                        recordFunctionPositions,
<span class="fc" id="L2636">                        valueTypes.getColumnCount(),</span>
                        timestampIndex,
                        timezoneNameFunc,
                        timezoneNameFuncPos,
                        offsetFunc,
                        offsetFuncPos
                );
            }

<span class="fc" id="L2645">            return new SampleByFillValueRecordCursorFactory(</span>
                    asm,
                    configuration,
                    factory,
                    timestampSampler,
                    listColumnFilterA,
                    sampleByFill,
                    keyTypes,
                    valueTypes,
                    groupByMetadata,
                    groupByFunctions,
                    recordFunctions,
                    recordFunctionPositions,
                    timestampIndex,
                    timezoneNameFunc,
                    timezoneNameFuncPos,
                    offsetFunc,
                    offsetFuncPos
            );
<span class="fc" id="L2664">        } catch (Throwable e) {</span>
<span class="fc" id="L2665">            Misc.free(factory);</span>
<span class="fc" id="L2666">            throw e;</span>
        }
    }

    private RecordCursorFactory generateSelect(
            QueryModel model,
            SqlExecutionContext executionContext,
            boolean processJoins
    ) throws SqlException {
<span class="fc bfc" id="L2675" title="All 7 branches covered.">        switch (model.getSelectModelType()) {</span>
            case QueryModel.SELECT_MODEL_CHOOSE:
<span class="fc" id="L2677">                return generateSelectChoose(model, executionContext);</span>
            case QueryModel.SELECT_MODEL_GROUP_BY:
<span class="fc" id="L2679">                return generateSelectGroupBy(model, executionContext);</span>
            case QueryModel.SELECT_MODEL_VIRTUAL:
<span class="fc" id="L2681">                return generateSelectVirtual(model, executionContext);</span>
            case QueryModel.SELECT_MODEL_ANALYTIC:
<span class="fc" id="L2683">                return generateSelectAnalytic(model, executionContext);</span>
            case QueryModel.SELECT_MODEL_DISTINCT:
<span class="fc" id="L2685">                return generateSelectDistinct(model, executionContext);</span>
            case QueryModel.SELECT_MODEL_CURSOR:
<span class="fc" id="L2687">                return generateSelectCursor(model, executionContext);</span>
            default:
<span class="fc bfc" id="L2689" title="All 4 branches covered.">                if (model.getJoinModels().size() &gt; 1 &amp;&amp; processJoins) {</span>
<span class="fc" id="L2690">                    return generateJoins(model, executionContext);</span>
                }
<span class="fc" id="L2692">                return generateNoSelect(model, executionContext);</span>
        }
    }

    private RecordCursorFactory generateSelectAnalytic(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2697">        final RecordCursorFactory base = generateSubQuery(model, executionContext);</span>
<span class="fc" id="L2698">        final RecordMetadata baseMetadata = base.getMetadata();</span>
<span class="fc" id="L2699">        final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</span>
<span class="fc" id="L2700">        final int columnCount = columns.size();</span>
<span class="fc" id="L2701">        groupedAnalytic.clear();</span>
<span class="fc" id="L2702">        ObjList&lt;AnalyticFunction&gt; naturalOrderFunctions = null;</span>

<span class="fc" id="L2704">        valueTypes.clear();</span>
<span class="fc" id="L2705">        ArrayColumnTypes chainTypes = valueTypes;</span>
<span class="fc" id="L2706">        GenericRecordMetadata chainMetadata = new GenericRecordMetadata();</span>
<span class="fc" id="L2707">        GenericRecordMetadata factoryMetadata = new GenericRecordMetadata();</span>

<span class="fc" id="L2709">        listColumnFilterA.clear();</span>
<span class="fc" id="L2710">        listColumnFilterB.clear();</span>

        // we need two passes over columns because partitionBy and orderBy clauses of
        // the analytical function must reference the metadata of &quot;this&quot; factory.

        // pass #1 assembles metadata of non-analytic columns

        // set of column indexes in the base metadata that has already been added to the main
        // metadata instance
<span class="fc" id="L2719">        intHashSet.clear();</span>
<span class="fc" id="L2720">        final IntList columnIndexes = new IntList();</span>
<span class="fc bfc" id="L2721" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2722">            final QueryColumn qc = columns.getQuick(i);</span>
<span class="fc bfc" id="L2723" title="All 2 branches covered.">            if (!(qc instanceof AnalyticColumn)) {</span>
<span class="fc" id="L2724">                final int columnIndex = baseMetadata.getColumnIndexQuiet(qc.getAst().token);</span>
<span class="fc" id="L2725">                final TableColumnMetadata m = AbstractRecordMetadata.copyOf(baseMetadata, columnIndex);</span>
<span class="fc" id="L2726">                chainMetadata.add(i, m);</span>
<span class="fc" id="L2727">                factoryMetadata.add(i, m);</span>
<span class="fc" id="L2728">                chainTypes.add(i, m.getType());</span>
<span class="fc" id="L2729">                listColumnFilterA.extendAndSet(i, i + 1);</span>
<span class="fc" id="L2730">                listColumnFilterB.extendAndSet(i, columnIndex);</span>
<span class="fc" id="L2731">                intHashSet.add(columnIndex);</span>
<span class="fc" id="L2732">                columnIndexes.extendAndSet(i, columnIndex);</span>
            }
        }

        // pass #2 - add remaining base metadata column that are not in intHashSet already
        // we need to pay attention to stepping over analytic column slots
        // Chain metadata is assembled in such way that all columns the factory
        // needs to provide are at the beginning of the metadata so the record the factory cursor
        // returns can be chain record, because the chain record is always longer than record needed out of the
        // cursor and relevant columns are 0..n limited by factory metadata

<span class="fc" id="L2743">        int addAt = columnCount;</span>
<span class="fc bfc" id="L2744" title="All 2 branches covered.">        for (int i = 0, n = baseMetadata.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L2745" title="All 2 branches covered.">            if (intHashSet.excludes(i)) {</span>
<span class="fc" id="L2746">                final TableColumnMetadata m = AbstractRecordMetadata.copyOf(baseMetadata, i);</span>
<span class="fc" id="L2747">                chainMetadata.add(addAt, m);</span>
<span class="fc" id="L2748">                chainTypes.add(addAt, m.getType());</span>
<span class="fc" id="L2749">                listColumnFilterA.extendAndSet(addAt, addAt + 1);</span>
<span class="fc" id="L2750">                listColumnFilterB.extendAndSet(addAt, i);</span>
<span class="fc" id="L2751">                columnIndexes.extendAndSet(addAt, i);</span>
<span class="fc" id="L2752">                addAt++;</span>
            }
        }

        // pass #3 assembles analytic column metadata into a list
        // not main metadata to avoid partitionBy functions accidentally looking up
        // analytic columns recursively

<span class="fc" id="L2760">        deferredAnalyticMetadata.clear();</span>
<span class="fc bfc" id="L2761" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2762">            final QueryColumn qc = columns.getQuick(i);</span>
<span class="fc bfc" id="L2763" title="All 2 branches covered.">            if (qc instanceof AnalyticColumn) {</span>
<span class="fc" id="L2764">                final AnalyticColumn ac = (AnalyticColumn) qc;</span>
<span class="fc" id="L2765">                final ExpressionNode ast = qc.getAst();</span>
<span class="fc bfc" id="L2766" title="All 2 branches covered.">                if (ast.paramCount &gt; 1) {</span>
<span class="fc" id="L2767">                    Misc.free(base);</span>
<span class="fc" id="L2768">                    throw SqlException.$(ast.position, &quot;too many arguments&quot;);</span>
                }

<span class="fc" id="L2771">                ObjList&lt;Function&gt; partitionBy = null;</span>
<span class="fc" id="L2772">                int psz = ac.getPartitionBy().size();</span>
<span class="fc bfc" id="L2773" title="All 2 branches covered.">                if (psz &gt; 0) {</span>
<span class="fc" id="L2774">                    partitionBy = new ObjList&lt;&gt;(psz);</span>
<span class="fc bfc" id="L2775" title="All 2 branches covered.">                    for (int j = 0; j &lt; psz; j++) {</span>
<span class="fc" id="L2776">                        partitionBy.add(</span>
<span class="fc" id="L2777">                                functionParser.parseFunction(ac.getPartitionBy().getQuick(j), chainMetadata, executionContext)</span>
                        );
                    }
                }

                final VirtualRecord partitionByRecord;
                final RecordSink partitionBySink;

<span class="fc bfc" id="L2785" title="All 2 branches covered.">                if (partitionBy != null) {</span>
<span class="fc" id="L2786">                    partitionByRecord = new VirtualRecord(partitionBy);</span>
<span class="fc" id="L2787">                    keyTypes.clear();</span>
<span class="fc" id="L2788">                    final int partitionByCount = partitionBy.size();</span>

<span class="fc bfc" id="L2790" title="All 2 branches covered.">                    for (int j = 0; j &lt; partitionByCount; j++) {</span>
<span class="fc" id="L2791">                        keyTypes.add(partitionBy.getQuick(j).getType());</span>
                    }
<span class="fc" id="L2793">                    entityColumnFilter.of(partitionByCount);</span>
                    // create sink
<span class="fc" id="L2795">                    partitionBySink = RecordSinkFactory.getInstance(</span>
                            asm,
                            keyTypes,
                            entityColumnFilter,
                            false
                    );
<span class="fc" id="L2801">                } else {</span>
<span class="fc" id="L2802">                    partitionByRecord = null;</span>
<span class="fc" id="L2803">                    partitionBySink = null;</span>
                }


<span class="fc" id="L2807">                final int osz = ac.getOrderBy().size();</span>
<span class="fc bfc" id="L2808" title="All 2 branches covered.">                executionContext.configureAnalyticContext(</span>
                        partitionByRecord,
                        partitionBySink,
                        keyTypes,
                        osz &gt; 0,
<span class="fc" id="L2813">                        base.recordCursorSupportsRandomAccess()</span>
                );
                final Function f;
                try {
<span class="fc" id="L2817">                    f = functionParser.parseFunction(ast, baseMetadata, executionContext);</span>
<span class="fc bfc" id="L2818" title="All 2 branches covered.">                    if (!(f instanceof AnalyticFunction)) {</span>
<span class="fc" id="L2819">                        Misc.free(base);</span>
<span class="fc" id="L2820">                        throw SqlException.$(ast.position, &quot;non-analytic function called in analytic context&quot;);</span>
                    }
                } finally {
<span class="fc" id="L2823">                    executionContext.clearAnalyticContext();</span>
                }

<span class="fc" id="L2826">                AnalyticFunction analyticFunction = (AnalyticFunction) f;</span>

                // analyze order by clause on the current model and optimise out
                // order by on analytic function if it matches the one on the model
<span class="fc" id="L2830">                final LowerCaseCharSequenceIntHashMap orderHash = model.getOrderHash();</span>
                boolean dismissOrder;
<span class="fc bfc" id="L2832" title="All 4 branches covered.">                if (osz &gt; 0 &amp;&amp; orderHash.size() &gt; 0) {</span>
<span class="fc" id="L2833">                    dismissOrder = true;</span>
<span class="fc bfc" id="L2834" title="All 2 branches covered.">                    for (int j = 0; j &lt; osz; j++) {</span>
<span class="fc" id="L2835">                        ExpressionNode node = ac.getOrderBy().getQuick(j);</span>
<span class="fc" id="L2836">                        int direction = ac.getOrderByDirection().getQuick(j);</span>
<span class="pc bpc" id="L2837" title="1 of 2 branches missed.">                        if (orderHash.get(node.token) != direction) {</span>
<span class="nc" id="L2838">                            dismissOrder = false;</span>
<span class="nc" id="L2839">                            break;</span>
                        }
                    }
                } else {
<span class="fc" id="L2843">                    dismissOrder = false;</span>
                }

<span class="fc bfc" id="L2846" title="All 4 branches covered.">                if (osz &gt; 0 &amp;&amp; !dismissOrder) {</span>
<span class="fc" id="L2847">                    IntList order = toOrderIndices(chainMetadata, ac.getOrderBy(), ac.getOrderByDirection());</span>
                    // init comparator if we need
<span class="fc" id="L2849">                    analyticFunction.initRecordComparator(recordComparatorCompiler, chainTypes, order);</span>
<span class="fc" id="L2850">                    ObjList&lt;AnalyticFunction&gt; funcs = groupedAnalytic.get(order);</span>
<span class="pc bpc" id="L2851" title="1 of 2 branches missed.">                    if (funcs == null) {</span>
<span class="fc" id="L2852">                        groupedAnalytic.put(order, funcs = new ObjList&lt;&gt;());</span>
                    }
<span class="fc" id="L2854">                    funcs.add(analyticFunction);</span>
<span class="fc" id="L2855">                } else {</span>
<span class="pc bpc" id="L2856" title="1 of 2 branches missed.">                    if (naturalOrderFunctions == null) {</span>
<span class="fc" id="L2857">                        naturalOrderFunctions = new ObjList&lt;&gt;();</span>
                    }
<span class="fc" id="L2859">                    naturalOrderFunctions.add(analyticFunction);</span>
                }

<span class="fc" id="L2862">                analyticFunction.setColumnIndex(i);</span>

<span class="fc" id="L2864">                deferredAnalyticMetadata.extendAndSet(i, new TableColumnMetadata(</span>
<span class="fc" id="L2865">                        Chars.toString(qc.getAlias()),</span>
<span class="fc" id="L2866">                        analyticFunction.getType(),</span>
                        false,
                        0,
                        false,
                        null
                ));

<span class="fc" id="L2873">                listColumnFilterA.extendAndSet(i, -i - 1);</span>
            }
        }

        // after all columns are processed we can re-insert deferred metadata
<span class="fc bfc" id="L2878" title="All 2 branches covered.">        for (int i = 0, n = deferredAnalyticMetadata.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2879">            TableColumnMetadata m = deferredAnalyticMetadata.getQuick(i);</span>
<span class="fc bfc" id="L2880" title="All 2 branches covered.">            if (m != null) {</span>
<span class="fc" id="L2881">                chainTypes.add(i, m.getType());</span>
<span class="fc" id="L2882">                factoryMetadata.add(i, m);</span>
            }
        }

<span class="fc" id="L2886">        final ObjList&lt;RecordComparator&gt; analyticComparators = new ObjList&lt;&gt;(groupedAnalytic.size());</span>
<span class="fc" id="L2887">        final ObjList&lt;ObjList&lt;AnalyticFunction&gt;&gt; functionGroups = new ObjList&lt;&gt;(groupedAnalytic.size());</span>
<span class="fc bfc" id="L2888" title="All 2 branches covered.">        for (ObjObjHashMap.Entry&lt;IntList, ObjList&lt;AnalyticFunction&gt;&gt; e : groupedAnalytic) {</span>
<span class="fc" id="L2889">            analyticComparators.add(recordComparatorCompiler.compile(chainTypes, e.key));</span>
<span class="fc" id="L2890">            functionGroups.add(e.value);</span>
<span class="fc" id="L2891">        }</span>

<span class="fc" id="L2893">        final RecordSink recordSink = RecordSinkFactory.getInstance(</span>
                asm,
                chainTypes,
                listColumnFilterA,
                false,
                listColumnFilterB
        );

<span class="fc" id="L2901">        return new CachedAnalyticRecordCursorFactory(</span>
                configuration,
                base,
                recordSink,
                factoryMetadata,
                chainTypes,
                analyticComparators,
                functionGroups,
                naturalOrderFunctions,
                columnIndexes
        );
    }

    private RecordCursorFactory generateSelectChoose(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2915">        final RecordCursorFactory factory = generateSubQuery(model, executionContext);</span>

<span class="fc" id="L2917">        final RecordMetadata metadata = factory.getMetadata();</span>
<span class="fc" id="L2918">        final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</span>
<span class="fc" id="L2919">        final int selectColumnCount = columns.size();</span>
<span class="fc" id="L2920">        final ExpressionNode timestamp = model.getTimestamp();</span>

        // If this is update query and column types don't match exactly
        // to the column type of table to be updated we have to fall back to
        // select-virtual
<span class="fc bfc" id="L2925" title="All 2 branches covered.">        if (model.isUpdate()) {</span>
<span class="fc" id="L2926">            boolean columnTypeMismatch = false;</span>
<span class="fc" id="L2927">            ObjList&lt;CharSequence&gt; updateColumnNames = model.getUpdateTableColumnNames();</span>
<span class="fc" id="L2928">            IntList updateColumnTypes = model.getUpdateTableColumnTypes();</span>

<span class="fc bfc" id="L2930" title="All 2 branches covered.">            for (int i = 0, n = columns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2931">                QueryColumn queryColumn = columns.getQuick(i);</span>
<span class="fc" id="L2932">                CharSequence columnName = queryColumn.getAlias();</span>
<span class="fc" id="L2933">                int index = metadata.getColumnIndexQuiet(queryColumn.getAst().token);</span>
<span class="pc bpc" id="L2934" title="1 of 2 branches missed.">                assert index &gt; -1 : &quot;wtf? &quot; + queryColumn.getAst().token;</span>

<span class="fc" id="L2936">                int updateColumnIndex = updateColumnNames.indexOf(columnName);</span>
<span class="fc" id="L2937">                int updateColumnType = updateColumnTypes.get(updateColumnIndex);</span>

<span class="fc bfc" id="L2939" title="All 2 branches covered.">                if (updateColumnType != metadata.getColumnType(index)) {</span>
<span class="fc" id="L2940">                    columnTypeMismatch = true;</span>
<span class="fc" id="L2941">                    break;</span>
                }
            }

<span class="fc bfc" id="L2945" title="All 2 branches covered.">            if (columnTypeMismatch) {</span>
<span class="fc" id="L2946">                return generateSelectVirtualWithSubQuery(model, executionContext, factory);</span>
            }
        }

        boolean entity;
        // the model is considered entity when it doesn't add any value to its nested model
        //
<span class="fc bfc" id="L2953" title="All 4 branches covered.">        if (timestamp == null &amp;&amp; metadata.getColumnCount() == selectColumnCount) {</span>
<span class="fc" id="L2954">            entity = true;</span>
<span class="fc bfc" id="L2955" title="All 2 branches covered.">            for (int i = 0; i &lt; selectColumnCount; i++) {</span>
<span class="fc" id="L2956">                QueryColumn qc = columns.getQuick(i);</span>
<span class="fc" id="L2957">                if (</span>
<span class="fc bfc" id="L2958" title="All 2 branches covered.">                        !Chars.equals(metadata.getColumnName(i), qc.getAst().token) ||</span>
<span class="pc bpc" id="L2959" title="1 of 4 branches missed.">                                qc.getAlias() != null &amp;&amp; !(Chars.equals(qc.getAlias(), qc.getAst().token))</span>
                ) {
<span class="fc" id="L2961">                    entity = false;</span>
<span class="fc" id="L2962">                    break;</span>
                }
            }
        } else {
<span class="fc" id="L2966">            entity = false;</span>
        }

<span class="fc bfc" id="L2969" title="All 2 branches covered.">        if (entity) {</span>
<span class="fc" id="L2970">            return factory;</span>
        }

        // We require timestamp with asc order.
        final int timestampIndex;
        try {
<span class="fc" id="L2976">            timestampIndex = getTimestampIndex(model, factory);</span>
<span class="fc bfc" id="L2977" title="All 6 branches covered.">            if (executionContext.isTimestampRequired() &amp;&amp; (timestampIndex == -1 || factory.hasDescendingOrder())) {</span>
<span class="fc" id="L2978">                throw SqlException.$(model.getModelPosition(), &quot;ASC order over TIMESTAMP column is required but not provided&quot;);</span>
            }
<span class="fc" id="L2980">        } catch (Throwable e) {</span>
<span class="fc" id="L2981">            Misc.free(factory);</span>
<span class="fc" id="L2982">            throw e;</span>
<span class="fc" id="L2983">        }</span>

<span class="fc" id="L2985">        final IntList columnCrossIndex = new IntList(selectColumnCount);</span>
<span class="fc" id="L2986">        final GenericRecordMetadata selectMetadata = new GenericRecordMetadata();</span>
<span class="fc" id="L2987">        boolean timestampSet = false;</span>
<span class="fc bfc" id="L2988" title="All 2 branches covered.">        for (int i = 0; i &lt; selectColumnCount; i++) {</span>
<span class="fc" id="L2989">            final QueryColumn queryColumn = columns.getQuick(i);</span>
<span class="fc" id="L2990">            int index = metadata.getColumnIndexQuiet(queryColumn.getAst().token);</span>
<span class="pc bpc" id="L2991" title="1 of 2 branches missed.">            assert index &gt; -1 : &quot;wtf? &quot; + queryColumn.getAst().token;</span>
<span class="fc" id="L2992">            columnCrossIndex.add(index);</span>

<span class="pc bpc" id="L2994" title="1 of 2 branches missed.">            if (queryColumn.getAlias() == null) {</span>
<span class="nc" id="L2995">                selectMetadata.add(AbstractRecordMetadata.copyOf(metadata, index));</span>
            } else {
<span class="fc" id="L2997">                selectMetadata.add(</span>
                        new TableColumnMetadata(
<span class="fc" id="L2999">                                Chars.toString(queryColumn.getAlias()),</span>
<span class="fc" id="L3000">                                metadata.getColumnType(index),</span>
<span class="fc" id="L3001">                                metadata.isColumnIndexed(index),</span>
<span class="fc" id="L3002">                                metadata.getIndexValueBlockCapacity(index),</span>
<span class="fc" id="L3003">                                metadata.isSymbolTableStatic(index),</span>
<span class="fc" id="L3004">                                metadata.getMetadata(index)</span>
                        )
                );
            }

<span class="fc bfc" id="L3009" title="All 2 branches covered.">            if (index == timestampIndex) {</span>
<span class="fc" id="L3010">                selectMetadata.setTimestampIndex(i);</span>
<span class="fc" id="L3011">                timestampSet = true;</span>
            }
        }

<span class="fc bfc" id="L3015" title="All 4 branches covered.">        if (!timestampSet &amp;&amp; executionContext.isTimestampRequired()) {</span>
<span class="fc" id="L3016">            selectMetadata.add(AbstractRecordMetadata.copyOf(metadata, timestampIndex));</span>
<span class="fc" id="L3017">            selectMetadata.setTimestampIndex(selectMetadata.getColumnCount() - 1);</span>
<span class="fc" id="L3018">            columnCrossIndex.add(timestampIndex);</span>
        }

<span class="fc" id="L3021">        return new SelectedRecordCursorFactory(selectMetadata, columnCrossIndex, factory);</span>
    }

    private RecordCursorFactory generateSelectCursor(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
        // sql parser ensures this type of model always has only one column
<span class="fc" id="L3026">        return new RecordAsAFieldRecordCursorFactory(</span>
<span class="fc" id="L3027">                generate(model.getNestedModel(), executionContext),</span>
<span class="fc" id="L3028">                model.getColumns().getQuick(0).getAlias()</span>
        );
    }

    private RecordCursorFactory generateSelectDistinct(QueryModel model, SqlExecutionContext executionContext) throws SqlException {

        QueryModel twoDeepNested;
        ExpressionNode tableNameEn;

<span class="fc" id="L3037">        if (</span>
<span class="fc bfc" id="L3038" title="All 2 branches covered.">                model.getColumns().size() == 1</span>
<span class="pc bpc" id="L3039" title="1 of 2 branches missed.">                        &amp;&amp; model.getNestedModel() != null</span>
<span class="fc bfc" id="L3040" title="All 2 branches covered.">                        &amp;&amp; model.getNestedModel().getSelectModelType() == QueryModel.SELECT_MODEL_CHOOSE</span>
<span class="pc bpc" id="L3041" title="1 of 2 branches missed.">                        &amp;&amp; (twoDeepNested = model.getNestedModel().getNestedModel()) != null</span>
<span class="pc bpc" id="L3042" title="1 of 2 branches missed.">                        &amp;&amp; twoDeepNested.getLatestBy().size() == 0</span>
<span class="fc bfc" id="L3043" title="All 2 branches covered.">                        &amp;&amp; (tableNameEn = twoDeepNested.getTableNameExpr()) != null</span>
<span class="fc bfc" id="L3044" title="All 2 branches covered.">                        &amp;&amp; twoDeepNested.getWhereClause() == null</span>
        ) {
<span class="fc" id="L3046">            CharSequence tableName = tableNameEn.token;</span>
<span class="fc" id="L3047">            TableToken tableToken = executionContext.getTableToken(tableName);</span>
<span class="fc" id="L3048">            try (TableReader reader = executionContext.getReader(tableToken)) {</span>
<span class="fc" id="L3049">                CharSequence columnName = model.getBottomUpColumnNames().get(0);</span>
<span class="fc" id="L3050">                TableReaderMetadata readerMetadata = reader.getMetadata();</span>
<span class="fc" id="L3051">                int columnIndex = readerMetadata.getColumnIndex(columnName);</span>
<span class="fc" id="L3052">                int columnType = readerMetadata.getColumnType(columnIndex);</span>

<span class="fc" id="L3054">                final GenericRecordMetadata distinctColumnMetadata = new GenericRecordMetadata();</span>
<span class="fc" id="L3055">                distinctColumnMetadata.add(AbstractRecordMetadata.copyOf(readerMetadata, columnIndex));</span>
<span class="fc bfc" id="L3056" title="All 4 branches covered.">                if (ColumnType.isSymbol(columnType) || columnType == ColumnType.INT) {</span>

<span class="fc" id="L3058">                    final RecordCursorFactory factory = generateSubQuery(model.getNestedModel(), executionContext);</span>

<span class="pc bpc" id="L3060" title="1 of 2 branches missed.">                    if (factory.supportPageFrameCursor()) {</span>
                        try {
<span class="fc" id="L3062">                            return new DistinctKeyRecordCursorFactory(</span>
<span class="fc" id="L3063">                                    engine.getConfiguration(),</span>
                                    factory,
                                    distinctColumnMetadata,
                                    arrayColumnTypes,
                                    tempVaf,
<span class="fc" id="L3068">                                    executionContext.getSharedWorkerCount(),</span>
                                    tempSymbolSkewIndexes
                            );
<span class="fc" id="L3071">                        } catch (Throwable t) {</span>
<span class="fc" id="L3072">                            Misc.free(factory);</span>
<span class="fc" id="L3073">                            throw t;</span>
                        }
                    } else {
                        // Shouldn't really happen, we cannot recompile below, QueryModel is changed during compilation
<span class="nc" id="L3077">                        Misc.free(factory);</span>
<span class="nc" id="L3078">                        throw CairoException.critical(0).put(&quot;Optimization error, incorrect path chosen, please contact support.&quot;);</span>
                    }
                }
<span class="pc bpc" id="L3081" title="1 of 2 branches missed.">            }</span>
        }

<span class="fc" id="L3084">        final RecordCursorFactory factory = generateSubQuery(model, executionContext);</span>
        try {
<span class="fc bfc" id="L3086" title="All 4 branches covered.">            if (factory.recordCursorSupportsRandomAccess() &amp;&amp; factory.getMetadata().getTimestampIndex() != -1) {</span>
<span class="fc" id="L3087">                return new DistinctTimeSeriesRecordCursorFactory(</span>
                        configuration,
                        factory,
                        entityColumnFilter,
                        asm
                );
            }
<span class="fc" id="L3094">            return new DistinctRecordCursorFactory(</span>
                    configuration,
                    factory,
                    entityColumnFilter,
                    asm
            );
<span class="nc" id="L3100">        } catch (Throwable e) {</span>
<span class="nc" id="L3101">            factory.close();</span>
<span class="nc" id="L3102">            throw e;</span>
        }
    }

    private RecordCursorFactory generateSelectGroupBy(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L3107">        final ExpressionNode sampleByNode = model.getSampleBy();</span>
<span class="fc bfc" id="L3108" title="All 2 branches covered.">        if (sampleByNode != null) {</span>
<span class="fc" id="L3109">            return generateSampleBy(model, executionContext, sampleByNode, model.getSampleByUnit());</span>
        }

<span class="fc" id="L3112">        RecordCursorFactory factory = null;</span>
        try {
            ObjList&lt;QueryColumn&gt; columns;
            ExpressionNode columnExpr;

            // generate special case plan for &quot;select count() from somewhere&quot;
<span class="fc" id="L3118">            columns = model.getColumns();</span>
<span class="fc bfc" id="L3119" title="All 2 branches covered.">            if (columns.size() == 1) {</span>
<span class="fc" id="L3120">                CharSequence columnName = columns.getQuick(0).getName();</span>
<span class="fc" id="L3121">                columnExpr = columns.getQuick(0).getAst();</span>
<span class="pc bpc" id="L3122" title="2 of 6 branches missed.">                if (columnExpr.type == FUNCTION &amp;&amp; columnExpr.paramCount == 0 &amp;&amp; isCountKeyword(columnExpr.token)) {</span>
                    // check if count() was not aliased, if it was, we need to generate new metadata, bummer
<span class="fc bfc" id="L3124" title="All 2 branches covered.">                    final RecordMetadata metadata = isCountKeyword(columnName) ? CountRecordCursorFactory.DEFAULT_COUNT_METADATA :</span>
<span class="fc" id="L3125">                            new GenericRecordMetadata().add(new TableColumnMetadata(Chars.toString(columnName), ColumnType.LONG));</span>
<span class="fc" id="L3126">                    return new CountRecordCursorFactory(metadata, generateSubQuery(model, executionContext));</span>
                }
            }

<span class="fc" id="L3130">            tempKeyIndexesInBase.clear();</span>
<span class="fc" id="L3131">            tempKeyIndex.clear();</span>
<span class="fc" id="L3132">            arrayColumnTypes.clear();</span>
<span class="fc" id="L3133">            tempKeyKinds.clear();</span>

<span class="fc" id="L3135">            boolean pageFramingSupported = false;</span>
<span class="fc" id="L3136">            boolean specialCaseKeys = false;</span>

            // check for special case time function aggregations
<span class="fc" id="L3139">            final QueryModel nested = model.getNestedModel();</span>
<span class="pc bpc" id="L3140" title="1 of 2 branches missed.">            assert nested != null;</span>
            // check if underlying model has reference to hour(column) function
<span class="fc" id="L3142">            if (</span>
<span class="fc bfc" id="L3143" title="All 2 branches covered.">                    nested.getSelectModelType() == QueryModel.SELECT_MODEL_VIRTUAL</span>
<span class="fc bfc" id="L3144" title="All 2 branches covered.">                            &amp;&amp; (columnExpr = nested.getColumns().getQuick(0).getAst()).type == FUNCTION</span>
<span class="pc bpc" id="L3145" title="2 of 6 branches missed.">                            &amp;&amp; isHourKeyword(columnExpr.token)</span>
                            &amp;&amp; columnExpr.paramCount == 1
                            &amp;&amp; columnExpr.rhs.type == LITERAL
            ) {
<span class="fc" id="L3149">                specialCaseKeys = true;</span>
<span class="fc" id="L3150">                QueryModel.backupWhereClause(expressionNodePool, model);</span>
<span class="fc" id="L3151">                factory = generateSubQuery(nested, executionContext);</span>
<span class="fc" id="L3152">                pageFramingSupported = factory.supportPageFrameCursor();</span>
<span class="fc bfc" id="L3153" title="All 2 branches covered.">                if (pageFramingSupported) {</span>

                    // find position of the hour() argument in the factory meta
<span class="fc" id="L3156">                    tempKeyIndexesInBase.add(factory.getMetadata().getColumnIndex(columnExpr.rhs.token));</span>

                    // find position of hour() alias in selected columns
                    // also make sure there are no other literal column than our function reference
<span class="fc" id="L3160">                    final CharSequence functionColumnName = columns.getQuick(0).getName();</span>
<span class="fc bfc" id="L3161" title="All 2 branches covered.">                    for (int i = 0, n = columns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L3162">                        columnExpr = columns.getQuick(i).getAst();</span>
<span class="fc bfc" id="L3163" title="All 2 branches covered.">                        if (columnExpr.type == LITERAL) {</span>
<span class="pc bpc" id="L3164" title="1 of 2 branches missed.">                            if (Chars.equals(columnExpr.token, functionColumnName)) {</span>
<span class="fc" id="L3165">                                tempKeyIndex.add(i);</span>
                                // storage dimension for Rosti is INT when we use hour(). This function produces INT.
<span class="fc" id="L3167">                                tempKeyKinds.add(GKK_HOUR_INT);</span>
<span class="fc" id="L3168">                                arrayColumnTypes.add(ColumnType.INT);</span>
                            } else {
                                // there is something else here, fallback to default implementation
<span class="nc" id="L3171">                                pageFramingSupported = false;</span>
<span class="nc" id="L3172">                                break;</span>
                            }
                        }
                    }
<span class="fc" id="L3176">                } else {</span>
<span class="fc" id="L3177">                    factory = Misc.free(factory);</span>
                }
            }

<span class="fc bfc" id="L3181" title="All 2 branches covered.">            if (factory == null) {</span>
<span class="fc bfc" id="L3182" title="All 2 branches covered.">                if (specialCaseKeys) {</span>
<span class="fc" id="L3183">                    QueryModel.restoreWhereClause(expressionNodePool, model);</span>
                }
<span class="fc" id="L3185">                factory = generateSubQuery(model, executionContext);</span>
<span class="fc" id="L3186">                pageFramingSupported = factory.supportPageFrameCursor();</span>
            }

<span class="fc" id="L3189">            RecordMetadata metadata = factory.getMetadata();</span>

            // Inspect model for possibility of vector aggregate intrinsics.
<span class="fc bfc" id="L3192" title="All 6 branches covered.">            if (pageFramingSupported &amp;&amp; assembleKeysAndFunctionReferences(columns, metadata, !specialCaseKeys)) {</span>
                // Create metadata from everything we've gathered.
<span class="fc" id="L3194">                GenericRecordMetadata meta = new GenericRecordMetadata();</span>

                // Start with keys.
<span class="fc bfc" id="L3197" title="All 2 branches covered.">                for (int i = 0, n = tempKeyIndex.size(); i &lt; n; i++) {</span>
<span class="fc" id="L3198">                    final int indexInThis = tempKeyIndex.getQuick(i);</span>
<span class="fc" id="L3199">                    final int indexInBase = tempKeyIndexesInBase.getQuick(i);</span>
<span class="fc" id="L3200">                    final int type = arrayColumnTypes.getColumnType(i);</span>

<span class="fc bfc" id="L3202" title="All 2 branches covered.">                    if (ColumnType.isSymbol(type)) {</span>
<span class="fc" id="L3203">                        meta.add(</span>
                                indexInThis,
                                new TableColumnMetadata(
<span class="fc" id="L3206">                                        Chars.toString(columns.getQuick(indexInThis).getName()),</span>
                                        type,
                                        false,
                                        0,
<span class="fc" id="L3210">                                        metadata.isSymbolTableStatic(indexInBase),</span>
                                        null
                                )
                        );
                    } else {
<span class="fc" id="L3215">                        meta.add(</span>
                                indexInThis,
                                new TableColumnMetadata(
<span class="fc" id="L3218">                                        Chars.toString(columns.getQuick(indexInThis).getName()),</span>
                                        type,
                                        null
                                )
                        );
                    }
                }

                // Add the aggregate functions.
<span class="fc bfc" id="L3227" title="All 2 branches covered.">                for (int i = 0, n = tempVecConstructors.size(); i &lt; n; i++) {</span>
<span class="fc" id="L3228">                    VectorAggregateFunctionConstructor constructor = tempVecConstructors.getQuick(i);</span>
<span class="fc" id="L3229">                    int indexInBase = tempVecConstructorArgIndexes.getQuick(i);</span>
<span class="fc" id="L3230">                    int indexInThis = tempAggIndex.getQuick(i);</span>
<span class="fc bfc" id="L3231" title="All 2 branches covered.">                    VectorAggregateFunction vaf = constructor.create(tempKeyKinds.size() == 0 ? 0 : tempKeyKinds.getQuick(0), indexInBase, executionContext.getSharedWorkerCount());</span>
<span class="fc" id="L3232">                    tempVaf.add(vaf);</span>
<span class="fc" id="L3233">                    meta.add(indexInThis,</span>
                            new TableColumnMetadata(
<span class="fc" id="L3235">                                    Chars.toString(columns.getQuick(indexInThis).getName()),</span>
<span class="fc" id="L3236">                                    vaf.getType(),</span>
                                    null
                            )
                    );
                }

<span class="fc bfc" id="L3242" title="All 2 branches covered.">                if (tempKeyIndexesInBase.size() == 0) {</span>
<span class="fc" id="L3243">                    return new GroupByNotKeyedVectorRecordCursorFactory(</span>
                            configuration,
                            factory,
                            meta,
                            tempVaf
                    );
                }

<span class="fc bfc" id="L3251" title="All 2 branches covered.">                if (tempKeyIndexesInBase.size() == 1) {</span>
<span class="fc bfc" id="L3252" title="All 2 branches covered.">                    for (int i = 0, n = tempVaf.size(); i &lt; n; i++) {</span>
<span class="fc" id="L3253">                        tempVaf.getQuick(i).pushValueTypes(arrayColumnTypes);</span>
                    }

                    try {
<span class="fc" id="L3257">                        GroupByUtils.validateGroupByColumns(model, 1);</span>
<span class="fc" id="L3258">                    } catch (Throwable e) {</span>
<span class="fc" id="L3259">                        Misc.freeObjList(tempVaf);</span>
<span class="fc" id="L3260">                        throw e;</span>
<span class="fc" id="L3261">                    }</span>

<span class="fc" id="L3263">                    return new GroupByRecordCursorFactory(</span>
                            configuration,
                            factory,
                            meta,
                            arrayColumnTypes,
<span class="fc" id="L3268">                            executionContext.getSharedWorkerCount(),</span>
                            tempVaf,
<span class="fc" id="L3270">                            tempKeyIndexesInBase.getQuick(0),</span>
<span class="fc" id="L3271">                            tempKeyIndex.getQuick(0),</span>
                            tempSymbolSkewIndexes
                    );
                }

                // Free the vector aggregate functions since we didn't use them.
<span class="fc" id="L3277">                Misc.freeObjList(tempVaf);</span>
            }

<span class="fc bfc" id="L3280" title="All 2 branches covered.">            if (specialCaseKeys) {</span>
                // uh-oh, we had special case keys, but could not find implementation for the functions
                // release factory we created unnecessarily
<span class="fc" id="L3283">                factory = Misc.free(factory);</span>
                // create factory on top level model
<span class="fc" id="L3285">                QueryModel.restoreWhereClause(expressionNodePool, model);</span>
<span class="fc" id="L3286">                factory = generateSubQuery(model, executionContext);</span>
                // and reset metadata
<span class="fc" id="L3288">                metadata = factory.getMetadata();</span>
            }

<span class="fc" id="L3291">            final int timestampIndex = getTimestampIndex(model, factory);</span>

<span class="fc" id="L3293">            keyTypes.clear();</span>
<span class="fc" id="L3294">            valueTypes.clear();</span>
<span class="fc" id="L3295">            listColumnFilterA.clear();</span>

<span class="fc" id="L3297">            final int columnCount = model.getColumns().size();</span>
<span class="fc" id="L3298">            ObjList&lt;GroupByFunction&gt; groupByFunctions = new ObjList&lt;&gt;(columnCount);</span>
            try {
<span class="fc" id="L3300">                GroupByUtils.prepareGroupByFunctions(</span>
                        model,
                        metadata,
                        functionParser,
                        executionContext,
                        groupByFunctions,
                        groupByFunctionPositions,
                        valueTypes
                );
<span class="fc" id="L3309">            } catch (Throwable e) {</span>
<span class="fc" id="L3310">                Misc.freeObjList(groupByFunctions);</span>
<span class="fc" id="L3311">                throw e;</span>
<span class="fc" id="L3312">            }</span>

<span class="fc" id="L3314">            final ObjList&lt;Function&gt; recordFunctions = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L3315">            final GenericRecordMetadata groupByMetadata = new GenericRecordMetadata();</span>
            try {
<span class="fc" id="L3317">                GroupByUtils.prepareGroupByRecordFunctions(</span>
                        model,
                        metadata,
                        listColumnFilterA,
                        groupByFunctions,
                        groupByFunctionPositions,
                        recordFunctions,
                        recordFunctionPositions,
                        groupByMetadata,
                        keyTypes,
<span class="fc" id="L3327">                        valueTypes.getColumnCount(),</span>
                        true,
                        timestampIndex
                );
<span class="fc" id="L3331">            } catch (Throwable e) {</span>
<span class="fc" id="L3332">                Misc.freeObjList(recordFunctions);</span>
<span class="fc" id="L3333">                throw e;</span>
<span class="fc" id="L3334">            }</span>

<span class="fc bfc" id="L3336" title="All 2 branches covered.">            if (keyTypes.getColumnCount() == 0) {</span>
<span class="fc" id="L3337">                return new GroupByNotKeyedRecordCursorFactory(</span>
                        asm,
                        factory,
                        groupByMetadata,
                        groupByFunctions,
                        recordFunctions,
<span class="fc" id="L3343">                        valueTypes.getColumnCount()</span>
                );
            }

<span class="fc" id="L3347">            return new io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory(</span>
                    asm,
                    configuration,
                    factory,
                    listColumnFilterA,
                    keyTypes,
                    valueTypes,
                    groupByMetadata,
                    groupByFunctions,
                    recordFunctions
            );
<span class="fc" id="L3358">        } catch (Throwable e) {</span>
<span class="fc" id="L3359">            Misc.free(factory);</span>
<span class="fc" id="L3360">            throw e;</span>
        }
    }

    private RecordCursorFactory generateSelectVirtual(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L3365">        final RecordCursorFactory factory = generateSubQuery(model, executionContext);</span>
<span class="fc" id="L3366">        return generateSelectVirtualWithSubQuery(model, executionContext, factory);</span>
    }

    @NotNull
    private VirtualRecordCursorFactory generateSelectVirtualWithSubQuery(QueryModel model, SqlExecutionContext executionContext, RecordCursorFactory factory) throws SqlException {
        try {
<span class="fc" id="L3372">            final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</span>
<span class="fc" id="L3373">            final int columnCount = columns.size();</span>
<span class="fc" id="L3374">            final RecordMetadata metadata = factory.getMetadata();</span>
<span class="fc" id="L3375">            final ObjList&lt;Function&gt; functions = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L3376">            final GenericRecordMetadata virtualMetadata = new GenericRecordMetadata();</span>

            // attempt to preserve timestamp on new data set
            CharSequence timestampColumn;
<span class="fc" id="L3380">            final int timestampIndex = metadata.getTimestampIndex();</span>
<span class="fc bfc" id="L3381" title="All 2 branches covered.">            if (timestampIndex &gt; -1) {</span>
<span class="fc" id="L3382">                timestampColumn = metadata.getColumnName(timestampIndex);</span>
            } else {
<span class="fc" id="L3384">                timestampColumn = null;</span>
            }

<span class="fc bfc" id="L3387" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L3388">                final QueryColumn column = columns.getQuick(i);</span>
<span class="fc" id="L3389">                final ExpressionNode node = column.getAst();</span>
<span class="fc bfc" id="L3390" title="All 4 branches covered.">                if (node.type == ExpressionNode.LITERAL &amp;&amp; Chars.equalsNc(node.token, timestampColumn)) {</span>
<span class="fc" id="L3391">                    virtualMetadata.setTimestampIndex(i);</span>
                }

<span class="fc" id="L3394">                Function function = functionParser.parseFunction(</span>
<span class="fc" id="L3395">                        column.getAst(),</span>
                        metadata,
                        executionContext
                );
<span class="fc" id="L3399">                int targetColumnType = -1;</span>
<span class="fc bfc" id="L3400" title="All 2 branches covered.">                if (model.isUpdate()) {</span>
                    // Check the type of the column to be updated
<span class="fc" id="L3402">                    int columnIndex = model.getUpdateTableColumnNames().indexOf(column.getAlias());</span>
<span class="fc" id="L3403">                    targetColumnType = model.getUpdateTableColumnTypes().get(columnIndex);</span>
                }

                // define &quot;undefined&quot; functions as string unless it's update. Leave Undefined if update
<span class="fc bfc" id="L3407" title="All 2 branches covered.">                if (function.isUndefined()) {</span>
<span class="fc bfc" id="L3408" title="All 2 branches covered.">                    if (!model.isUpdate()) {</span>
<span class="fc" id="L3409">                        function.assignType(ColumnType.STRING, executionContext.getBindVariableService());</span>
                    } else {
                        // Set bind variable the type of the column
<span class="fc" id="L3412">                        function.assignType(targetColumnType, executionContext.getBindVariableService());</span>
                    }
                }

<span class="fc" id="L3416">                int columnType = function.getType();</span>
<span class="fc bfc" id="L3417" title="All 4 branches covered.">                if (targetColumnType != -1 &amp;&amp; targetColumnType != columnType) {</span>
                    // This is an update and the target column does not match with column the update is trying to perform
<span class="fc bfc" id="L3419" title="All 2 branches covered.">                    if (ColumnType.isBuiltInWideningCast(function.getType(), targetColumnType)) {</span>
                        // All functions will be able to getLong() if they support getInt(), no need to generate cast here
<span class="fc" id="L3421">                        columnType = targetColumnType;</span>
                    } else {
<span class="fc" id="L3423">                        Function castFunction = functionParser.createImplicitCast(column.getAst().position, function, targetColumnType);</span>
<span class="fc bfc" id="L3424" title="All 2 branches covered.">                        if (castFunction != null) {</span>
<span class="fc" id="L3425">                            function = castFunction;</span>
<span class="fc" id="L3426">                            columnType = targetColumnType;</span>
                        }
                        // else - update code will throw incompatibility exception. It will have better chance close resources then
                    }
                }

<span class="fc" id="L3432">                functions.add(function);</span>

<span class="fc bfc" id="L3434" title="All 2 branches covered.">                if (columnType == ColumnType.SYMBOL) {</span>
<span class="fc bfc" id="L3435" title="All 2 branches covered.">                    if (function instanceof SymbolFunction) {</span>
<span class="fc" id="L3436">                        virtualMetadata.add(</span>
                                new TableColumnMetadata(
<span class="fc" id="L3438">                                        Chars.toString(column.getAlias()),</span>
<span class="fc" id="L3439">                                        function.getType(),</span>
                                        false,
                                        0,
<span class="fc" id="L3442">                                        ((SymbolFunction) function).isSymbolTableStatic(),</span>
<span class="fc" id="L3443">                                        function.getMetadata()</span>
                                )
                        );
<span class="pc bpc" id="L3446" title="1 of 2 branches missed.">                    } else if (function instanceof NullConstant) {</span>
<span class="fc" id="L3447">                        virtualMetadata.add(</span>
                                new TableColumnMetadata(
<span class="fc" id="L3449">                                        Chars.toString(column.getAlias()),</span>
                                        ColumnType.SYMBOL,
                                        false,
                                        0,
                                        false,
<span class="fc" id="L3454">                                        function.getMetadata()</span>
                                )
                        );
                        // Replace with symbol null constant
<span class="fc" id="L3458">                        functions.setQuick(functions.size() - 1, SymbolConstant.NULL);</span>
                    }
                } else {
<span class="fc" id="L3461">                    virtualMetadata.add(</span>
                            new TableColumnMetadata(
<span class="fc" id="L3463">                                    Chars.toString(column.getAlias()),</span>
                                    columnType,
<span class="fc" id="L3465">                                    function.getMetadata()</span>
                            )
                    );
                }
            }

            // if timestamp was required and present in the base model but
            // not selected, we will need to add it
<span class="fc" id="L3473">            if (</span>
<span class="fc bfc" id="L3474" title="All 4 branches covered.">                    executionContext.isTimestampRequired()</span>
                            &amp;&amp; timestampColumn != null
<span class="pc bpc" id="L3476" title="1 of 2 branches missed.">                            &amp;&amp; virtualMetadata.getTimestampIndex() == -1</span>
            ) {
<span class="fc" id="L3478">                final Function timestampFunction = FunctionParser.createColumn(</span>
                        0,
                        timestampColumn,
                        metadata
                );
<span class="fc" id="L3483">                functions.add(timestampFunction);</span>

                // here the base timestamp column name can name-clash with one of the
                // functions, so we have to use bottomUpColumns to lookup alias we should
                // be using. Bottom up column should have our timestamp because optimiser puts it there

<span class="fc bfc" id="L3489" title="All 2 branches covered.">                for (int i = 0, n = model.getBottomUpColumns().size(); i &lt; n; i++) {</span>
<span class="fc" id="L3490">                    QueryColumn qc = model.getBottomUpColumns().getQuick(i);</span>
<span class="fc bfc" id="L3491" title="All 4 branches covered.">                    if (qc.getAst().type == LITERAL &amp;&amp; Chars.equals(timestampColumn, qc.getAst().token)) {</span>
<span class="fc" id="L3492">                        virtualMetadata.setTimestampIndex(virtualMetadata.getColumnCount());</span>
<span class="fc" id="L3493">                        virtualMetadata.add(</span>
                                new TableColumnMetadata(
<span class="fc" id="L3495">                                        Chars.toString(qc.getAlias()),</span>
<span class="fc" id="L3496">                                        timestampFunction.getType(),</span>
<span class="fc" id="L3497">                                        timestampFunction.getMetadata()</span>
                                )
                        );
<span class="fc" id="L3500">                        break;</span>
                    }
                }
            }
<span class="fc" id="L3504">            return new VirtualRecordCursorFactory(virtualMetadata, functions, factory);</span>
<span class="fc" id="L3505">        } catch (SqlException | CairoException e) {</span>
<span class="fc" id="L3506">            factory.close();</span>
<span class="fc" id="L3507">            throw e;</span>
        }
    }

    /**
     * Generates chain of parent factories each of which takes only two argument factories.
     * Parent factory will perform one of SET operations on its arguments, such as UNION, UNION ALL,
     * INTERSECT or EXCEPT
     *
     * @param model            incoming model is expected to have a chain of models via its QueryModel.getUnionModel() function
     * @param factoryA         is compiled first argument
     * @param executionContext execution context for authorization and parallel execution purposes
     * @return factory that performs a SET operation
     * @throws SqlException when query contains syntax errors
     */
    private RecordCursorFactory generateSetFactory(
            QueryModel model,
            RecordCursorFactory factoryA,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L3527">        final RecordCursorFactory factoryB = generateQuery0(model.getUnionModel(), executionContext, true);</span>
<span class="fc" id="L3528">        ObjList&lt;Function&gt; castFunctionsA = null;</span>
<span class="fc" id="L3529">        ObjList&lt;Function&gt; castFunctionsB = null;</span>
        try {
<span class="fc" id="L3531">            final RecordMetadata metadataA = factoryA.getMetadata();</span>
<span class="fc" id="L3532">            final RecordMetadata metadataB = factoryB.getMetadata();</span>
<span class="fc" id="L3533">            final int positionA = model.getModelPosition();</span>
<span class="fc" id="L3534">            final int positionB = model.getUnionModel().getModelPosition();</span>

<span class="pc bpc" id="L3536" title="1 of 5 branches missed.">            switch (model.getSetOperationType()) {</span>
                case SET_OPERATION_UNION: {
<span class="fc" id="L3538">                    final boolean castIsRequired = checkIfSetCastIsRequired(metadataA, metadataB, true);</span>
<span class="fc bfc" id="L3539" title="All 2 branches covered.">                    final RecordMetadata setMetadata = castIsRequired ? widenSetMetadata(metadataA, metadataB) : GenericRecordMetadata.removeTimestamp(metadataA);</span>
<span class="fc bfc" id="L3540" title="All 2 branches covered.">                    if (castIsRequired) {</span>
<span class="fc" id="L3541">                        castFunctionsA = generateCastFunctions(setMetadata, metadataA, positionA);</span>
<span class="fc" id="L3542">                        castFunctionsB = generateCastFunctions(setMetadata, metadataB, positionB);</span>
                    }

<span class="fc" id="L3545">                    return generateUnionFactory(</span>
                            model,
                            executionContext,
                            factoryA,
                            factoryB,
                            castFunctionsA,
                            castFunctionsB,
                            setMetadata,
                            SET_UNION_CONSTRUCTOR
                    );
                }
                case SET_OPERATION_UNION_ALL: {
<span class="fc" id="L3557">                    final boolean castIsRequired = checkIfSetCastIsRequired(metadataA, metadataB, true);</span>
<span class="fc bfc" id="L3558" title="All 2 branches covered.">                    final RecordMetadata setMetadata = castIsRequired ? widenSetMetadata(metadataA, metadataB) : GenericRecordMetadata.removeTimestamp(metadataA);</span>
<span class="fc bfc" id="L3559" title="All 2 branches covered.">                    if (castIsRequired) {</span>
<span class="fc" id="L3560">                        castFunctionsA = generateCastFunctions(setMetadata, metadataA, positionA);</span>
<span class="fc" id="L3561">                        castFunctionsB = generateCastFunctions(setMetadata, metadataB, positionB);</span>
                    }

<span class="fc" id="L3564">                    return generateUnionAllFactory(</span>
                            model,
                            executionContext,
                            factoryA,
                            factoryB,
                            castFunctionsA,
                            castFunctionsB,
                            setMetadata
                    );
                }
                case SET_OPERATION_EXCEPT: {
<span class="fc" id="L3575">                    final boolean castIsRequired = checkIfSetCastIsRequired(metadataA, metadataB, false);</span>
<span class="fc bfc" id="L3576" title="All 2 branches covered.">                    final RecordMetadata setMetadata = castIsRequired ? widenSetMetadata(metadataA, metadataB) : metadataA;</span>
<span class="fc bfc" id="L3577" title="All 2 branches covered.">                    if (castIsRequired) {</span>
<span class="fc" id="L3578">                        castFunctionsA = generateCastFunctions(setMetadata, metadataA, positionA);</span>
<span class="fc" id="L3579">                        castFunctionsB = generateCastFunctions(setMetadata, metadataB, positionB);</span>
                    }

<span class="fc" id="L3582">                    return generateUnionFactory(</span>
                            model,
                            executionContext,
                            factoryA,
                            factoryB,
                            castFunctionsA,
                            castFunctionsB,
                            setMetadata,
                            SET_EXCEPT_CONSTRUCTOR
                    );
                }
                case SET_OPERATION_INTERSECT: {
<span class="fc" id="L3594">                    final boolean castIsRequired = checkIfSetCastIsRequired(metadataA, metadataB, false);</span>
<span class="fc bfc" id="L3595" title="All 2 branches covered.">                    final RecordMetadata setMetadata = castIsRequired ? widenSetMetadata(metadataA, metadataB) : metadataA;</span>
<span class="fc bfc" id="L3596" title="All 2 branches covered.">                    if (castIsRequired) {</span>
<span class="fc" id="L3597">                        castFunctionsA = generateCastFunctions(setMetadata, metadataA, positionA);</span>
<span class="fc" id="L3598">                        castFunctionsB = generateCastFunctions(setMetadata, metadataB, positionB);</span>
                    }

<span class="fc" id="L3601">                    return generateUnionFactory(</span>
                            model,
                            executionContext,
                            factoryA,
                            factoryB,
                            castFunctionsA,
                            castFunctionsB,
                            setMetadata,
                            SET_INTERSECT_CONSTRUCTOR
                    );
                }
                default:
<span class="nc" id="L3613">                    assert false;</span>
<span class="nc" id="L3614">                    return null;</span>
            }
<span class="fc" id="L3616">        } catch (Throwable e) {</span>
<span class="fc" id="L3617">            Misc.free(factoryA);</span>
<span class="fc" id="L3618">            Misc.free(factoryB);</span>
<span class="fc" id="L3619">            Misc.freeObjList(castFunctionsA);</span>
<span class="fc" id="L3620">            Misc.freeObjList(castFunctionsB);</span>
<span class="fc" id="L3621">            throw e;</span>
        }
    }

    private RecordCursorFactory generateSubQuery(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="pc bpc" id="L3626" title="1 of 2 branches missed.">        assert model.getNestedModel() != null;</span>
<span class="fc" id="L3627">        return generateQuery(model.getNestedModel(), executionContext, true);</span>
    }

    private RecordCursorFactory generateTableQuery(
            QueryModel model,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L3634">        final ObjList&lt;ExpressionNode&gt; latestBy = model.getLatestBy();</span>

<span class="fc" id="L3636">        final GenericLexer.FloatingSequence tab = (GenericLexer.FloatingSequence) model.getTableName();</span>
        final boolean supportsRandomAccess;
<span class="fc bfc" id="L3638" title="All 2 branches covered.">        if (Chars.startsWith(tab, NO_ROWID_MARKER)) {</span>
<span class="fc" id="L3639">            tab.setLo(tab.getLo() + NO_ROWID_MARKER.length());</span>
<span class="fc" id="L3640">            supportsRandomAccess = false;</span>
        } else {
<span class="fc" id="L3642">            supportsRandomAccess = true;</span>
        }

<span class="fc" id="L3645">        final TableToken tableToken = executionContext.getTableToken(tab);</span>
<span class="fc bfc" id="L3646" title="All 4 branches covered.">        if (model.isUpdate() &amp;&amp; !executionContext.isWalApplication()) {</span>
            try (
<span class="fc" id="L3648">                    TableReader reader = executionContext.getReader(tableToken);</span>
<span class="fc" id="L3649">                    TableRecordMetadata metadata = executionContext.getMetadata(tableToken, model.getTableVersion())</span>
            ) {
<span class="fc" id="L3651">                return generateTableQuery0(model, executionContext, latestBy, supportsRandomAccess, reader, metadata);</span>
            }
        } else {
<span class="fc" id="L3654">            try (TableReader reader = executionContext.getReader(</span>
                    tableToken,
<span class="fc" id="L3656">                    model.getTableVersion())) {</span>
<span class="fc" id="L3657">                return generateTableQuery0(model, executionContext, latestBy, supportsRandomAccess, reader, reader.getMetadata());</span>
            }
        }
    }

    private RecordCursorFactory generateTableQuery0(QueryModel model, SqlExecutionContext executionContext, ObjList&lt;ExpressionNode&gt; latestBy, boolean supportsRandomAccess, TableReader reader, TableRecordMetadata metadata) throws SqlException {
        // create metadata based on top-down columns that are required

<span class="fc" id="L3665">        final ObjList&lt;QueryColumn&gt; topDownColumns = model.getTopDownColumns();</span>
<span class="fc" id="L3666">        final int topDownColumnCount = topDownColumns.size();</span>
<span class="fc" id="L3667">        final IntList columnIndexes = new IntList();</span>
<span class="fc" id="L3668">        final IntList columnSizes = new IntList();</span>

        // topDownColumnCount can be 0 for 'select count()' queries

        int readerTimestampIndex;
<span class="fc" id="L3673">        readerTimestampIndex = getTimestampIndex(model, metadata);</span>

        // Latest by on a table requires the provided timestamp column to be the designated timestamp.
<span class="fc bfc" id="L3676" title="All 4 branches covered.">        if (latestBy.size() &gt; 0 &amp;&amp; readerTimestampIndex != metadata.getTimestampIndex()) {</span>
<span class="fc" id="L3677">            throw SqlException.$(model.getTimestamp().position, &quot;latest by over a table requires designated TIMESTAMP&quot;);</span>
        }

<span class="fc" id="L3680">        boolean requiresTimestamp = joinsRequiringTimestamp[model.getJoinType()];</span>
<span class="fc" id="L3681">        final GenericRecordMetadata myMeta = new GenericRecordMetadata();</span>
        boolean framingSupported;
        try {
<span class="fc bfc" id="L3684" title="All 2 branches covered.">            if (requiresTimestamp) {</span>
<span class="fc" id="L3685">                executionContext.pushTimestampRequiredFlag(true);</span>
            }

<span class="fc" id="L3688">            boolean contextTimestampRequired = executionContext.isTimestampRequired();</span>
            // some &quot;sample by&quot; queries don't select any cols but needs timestamp col selected
            // for example &quot;select count() from x sample by 1h&quot; implicitly needs timestamp column selected
<span class="fc bfc" id="L3691" title="All 6 branches covered.">            if (topDownColumnCount &gt; 0 || contextTimestampRequired || model.isUpdate()) {</span>
<span class="fc" id="L3692">                framingSupported = true;</span>
<span class="fc bfc" id="L3693" title="All 2 branches covered.">                for (int i = 0; i &lt; topDownColumnCount; i++) {</span>
<span class="fc" id="L3694">                    int columnIndex = metadata.getColumnIndexQuiet(topDownColumns.getQuick(i).getName());</span>
<span class="fc" id="L3695">                    int type = metadata.getColumnType(columnIndex);</span>
<span class="fc" id="L3696">                    int typeSize = ColumnType.sizeOf(type);</span>

<span class="fc" id="L3698">                    columnIndexes.add(columnIndex);</span>
<span class="fc" id="L3699">                    columnSizes.add(Numbers.msb(typeSize));</span>

<span class="fc" id="L3701">                    myMeta.add(new TableColumnMetadata(</span>
<span class="fc" id="L3702">                            Chars.toString(topDownColumns.getQuick(i).getName()),</span>
                            type,
<span class="fc" id="L3704">                            metadata.isColumnIndexed(columnIndex),</span>
<span class="fc" id="L3705">                            metadata.getIndexValueBlockCapacity(columnIndex),</span>
<span class="fc" id="L3706">                            metadata.isSymbolTableStatic(columnIndex),</span>
<span class="fc" id="L3707">                            metadata.getMetadata(columnIndex)</span>
                    ));

<span class="fc bfc" id="L3710" title="All 2 branches covered.">                    if (columnIndex == readerTimestampIndex) {</span>
<span class="fc" id="L3711">                        myMeta.setTimestampIndex(myMeta.getColumnCount() - 1);</span>
                    }
                }

                // select timestamp when it is required but not already selected
<span class="fc bfc" id="L3716" title="All 6 branches covered.">                if (readerTimestampIndex != -1 &amp;&amp; myMeta.getTimestampIndex() == -1 &amp;&amp; contextTimestampRequired) {</span>
<span class="fc" id="L3717">                    myMeta.add(new TableColumnMetadata(</span>
<span class="fc" id="L3718">                            metadata.getColumnName(readerTimestampIndex),</span>
<span class="fc" id="L3719">                            metadata.getColumnType(readerTimestampIndex),</span>
<span class="fc" id="L3720">                            metadata.getMetadata(readerTimestampIndex)</span>
                    ));
<span class="fc" id="L3722">                    myMeta.setTimestampIndex(myMeta.getColumnCount() - 1);</span>

<span class="fc" id="L3724">                    columnIndexes.add(readerTimestampIndex);</span>
<span class="fc" id="L3725">                    columnSizes.add((Numbers.msb(ColumnType.TIMESTAMP)));</span>
                }
            } else {
<span class="fc" id="L3728">                framingSupported = false;</span>
            }
        } finally {
<span class="fc bfc" id="L3731" title="All 2 branches covered.">            if (requiresTimestamp) {</span>
<span class="fc" id="L3732">                executionContext.popTimestampRequiredFlag();</span>
            }
        }

<span class="fc" id="L3736">        GenericRecordMetadata dfcFactoryMeta = GenericRecordMetadata.deepCopyOf(reader.getMetadata());</span>
<span class="fc" id="L3737">        final int latestByColumnCount = prepareLatestByColumnIndexes(latestBy, myMeta);</span>
        // Reader TableToken can have out of date table name in getLoggingName().
        // We need to resolve it from the engine to get correct value.
<span class="fc" id="L3740">        final TableToken tableToken = reader.getTableToken();</span>

<span class="fc" id="L3742">        final ExpressionNode withinExtracted = whereClauseParser.extractWithin(</span>
                model,
<span class="fc" id="L3744">                model.getWhereClause(),</span>
                metadata,
                functionParser,
                executionContext,
                prefixes
        );

<span class="fc" id="L3751">        model.setWhereClause(withinExtracted);</span>

<span class="fc bfc" id="L3753" title="All 2 branches covered.">        if (withinExtracted != null) {</span>

<span class="fc" id="L3755">            CharSequence preferredKeyColumn = null;</span>

<span class="fc bfc" id="L3757" title="All 2 branches covered.">            if (latestByColumnCount == 1) {</span>
<span class="fc" id="L3758">                final int latestByIndex = listColumnFilterA.getColumnIndexFactored(0);</span>

<span class="fc bfc" id="L3760" title="All 2 branches covered.">                if (ColumnType.isSymbol(myMeta.getColumnType(latestByIndex))) {</span>
<span class="fc" id="L3761">                    preferredKeyColumn = latestBy.getQuick(0).token;</span>
                }
            }

<span class="fc bfc" id="L3765" title="All 2 branches covered.">            final IntrinsicModel intrinsicModel = whereClauseParser.extract(</span>
                    model,
                    withinExtracted,
                    metadata,
                    preferredKeyColumn,
                    readerTimestampIndex,
                    functionParser,
                    myMeta,
                    executionContext,
                    latestByColumnCount &gt; 1,
                    reader
            );

            // intrinsic parser can collapse where clause when removing parts it can replace
            // need to make sure that filter is updated on the model in case it is processed up the call stack
            //
            // At this juncture filter can use used up by one of the implementations below.
            // We will clear it preemptively. If nothing picks filter up we will set model &quot;where&quot;
            // to the downsized filter
<span class="fc" id="L3784">            model.setWhereClause(null);</span>

<span class="fc bfc" id="L3786" title="All 2 branches covered.">            if (intrinsicModel.intrinsicValue == IntrinsicModel.FALSE) {</span>
<span class="fc" id="L3787">                return new EmptyTableRecordCursorFactory(myMeta);</span>
            }

            DataFrameCursorFactory dfcFactory;

<span class="fc bfc" id="L3792" title="All 2 branches covered.">            if (latestByColumnCount &gt; 0) {</span>
<span class="fc" id="L3793">                Function f = compileFilter(intrinsicModel, myMeta, executionContext);</span>
<span class="fc bfc" id="L3794" title="All 6 branches covered.">                if (f != null &amp;&amp; f.isConstant() &amp;&amp; !f.getBool(null)) {</span>
                    // 'latest by' clause takes over the latest by nodes, so that the later generateLatestBy() is no-op
<span class="fc" id="L3796">                    model.getLatestBy().clear();</span>
<span class="fc" id="L3797">                    Misc.free(f);</span>
<span class="fc" id="L3798">                    return new EmptyTableRecordCursorFactory(myMeta);</span>
                }

                // a sub-query present in the filter may have used the latest by
                // column index lists, so we need to regenerate them
<span class="fc" id="L3803">                prepareLatestByColumnIndexes(latestBy, myMeta);</span>

<span class="fc" id="L3805">                return generateLatestByTableQuery(</span>
                        model,
                        reader,
                        myMeta,
                        tableToken,
                        intrinsicModel,
                        f,
                        executionContext,
                        readerTimestampIndex,
                        columnIndexes,
                        columnSizes,
                        prefixes
                );
            }

            // below code block generates index-based filter
            final boolean intervalHitsOnlyOnePartition;
<span class="fc bfc" id="L3822" title="All 2 branches covered.">            if (intrinsicModel.hasIntervalFilters()) {</span>
<span class="fc" id="L3823">                RuntimeIntrinsicIntervalModel intervalModel = intrinsicModel.buildIntervalModel();</span>
<span class="fc" id="L3824">                dfcFactory = new IntervalFwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), intervalModel, readerTimestampIndex, dfcFactoryMeta);</span>
<span class="fc" id="L3825">                intervalHitsOnlyOnePartition = intervalModel.allIntervalsHitOnePartition(reader.getPartitionedBy());</span>
<span class="fc" id="L3826">            } else {</span>
<span class="fc" id="L3827">                dfcFactory = new FullFwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta);</span>
<span class="fc" id="L3828">                intervalHitsOnlyOnePartition = false;</span>
            }

<span class="fc bfc" id="L3831" title="All 2 branches covered.">            if (intrinsicModel.keyColumn != null) {</span>
                // existence of column would have been already validated
<span class="fc" id="L3833">                final int keyColumnIndex = metadata.getColumnIndexQuiet(intrinsicModel.keyColumn);</span>
<span class="fc" id="L3834">                final int nKeyValues = intrinsicModel.keyValueFuncs.size();</span>
<span class="fc" id="L3835">                final int nKeyExcludedValues = intrinsicModel.keyExcludedValueFuncs.size();</span>

<span class="fc bfc" id="L3837" title="All 2 branches covered.">                if (intrinsicModel.keySubQuery != null) {</span>
<span class="fc" id="L3838">                    final RecordCursorFactory rcf = generate(intrinsicModel.keySubQuery, executionContext);</span>
<span class="fc" id="L3839">                    final Record.CharSequenceFunction func = validateSubQueryColumnAndGetGetter(intrinsicModel, rcf.getMetadata());</span>

<span class="fc" id="L3841">                    Function f = compileFilter(intrinsicModel, myMeta, executionContext);</span>
<span class="pc bpc" id="L3842" title="1 of 6 branches missed.">                    if (f != null &amp;&amp; f.isConstant() &amp;&amp; !f.getBool(null)) {</span>
<span class="fc" id="L3843">                        Misc.free(dfcFactory);</span>
<span class="fc" id="L3844">                        return new EmptyTableRecordCursorFactory(myMeta);</span>
                    }
<span class="fc" id="L3846">                    return new FilterOnSubQueryRecordCursorFactory(</span>
                            myMeta,
                            dfcFactory,
                            rcf,
                            keyColumnIndex,
                            f,
                            func,
                            columnIndexes
                    );
                }
<span class="pc bpc" id="L3856" title="1 of 4 branches missed.">                assert nKeyValues &gt; 0 || nKeyExcludedValues &gt; 0;</span>

<span class="fc" id="L3858">                boolean orderByKeyColumn = false;</span>
<span class="fc" id="L3859">                int indexDirection = BitmapIndexReader.DIR_FORWARD;</span>
<span class="fc bfc" id="L3860" title="All 2 branches covered.">                if (intervalHitsOnlyOnePartition) {</span>
<span class="fc" id="L3861">                    final ObjList&lt;ExpressionNode&gt; orderByAdvice = model.getOrderByAdvice();</span>
<span class="fc" id="L3862">                    final int orderByAdviceSize = orderByAdvice.size();</span>
<span class="pc bpc" id="L3863" title="1 of 4 branches missed.">                    if (orderByAdviceSize &gt; 0 &amp;&amp; orderByAdviceSize &lt; 3) {</span>
                        // todo: when order by coincides with keyColumn and there is index we can incorporate
                        //    ordering in the code that returns rows from index rather than having an
                        //    &quot;overhead&quot; order by implementation, which would be trying to oder already ordered symbols
<span class="pc bpc" id="L3867" title="1 of 2 branches missed.">                        if (Chars.equals(orderByAdvice.getQuick(0).token, intrinsicModel.keyColumn)) {</span>
<span class="fc" id="L3868">                            myMeta.setTimestampIndex(-1);</span>
<span class="fc bfc" id="L3869" title="All 2 branches covered.">                            if (orderByAdviceSize == 1) {</span>
<span class="fc" id="L3870">                                orderByKeyColumn = true;</span>
<span class="pc bpc" id="L3871" title="1 of 2 branches missed.">                            } else if (Chars.equals(orderByAdvice.getQuick(1).token, model.getTimestamp().token)) {</span>
<span class="fc" id="L3872">                                orderByKeyColumn = true;</span>
<span class="fc bfc" id="L3873" title="All 2 branches covered.">                                if (getOrderByDirectionOrDefault(model, 1) == QueryModel.ORDER_DIRECTION_DESCENDING) {</span>
<span class="fc" id="L3874">                                    indexDirection = BitmapIndexReader.DIR_BACKWARD;</span>
                                }
                            }
                        }
                    }
                }

<span class="fc bfc" id="L3881" title="All 2 branches covered.">                if (intrinsicModel.keyExcludedValueFuncs.size() == 0) {</span>
<span class="fc" id="L3882">                    Function f = compileFilter(intrinsicModel, myMeta, executionContext);</span>
<span class="fc bfc" id="L3883" title="All 4 branches covered.">                    if (f != null &amp;&amp; f.isConstant()) {</span>
                        try {
<span class="fc bfc" id="L3885" title="All 2 branches covered.">                            if (!f.getBool(null)) {</span>
<span class="fc" id="L3886">                                Misc.free(dfcFactory);</span>
<span class="fc" id="L3887">                                return new EmptyTableRecordCursorFactory(myMeta);</span>
                            }
                        } finally {
<span class="fc" id="L3890">                            f = Misc.free(f);</span>
                        }
                    }
<span class="fc bfc" id="L3893" title="All 2 branches covered.">                    if (nKeyValues == 1) {</span>
                        final RowCursorFactory rcf;
<span class="fc" id="L3895">                        final Function symbolFunc = intrinsicModel.keyValueFuncs.get(0);</span>
<span class="fc" id="L3896">                        final SymbolMapReader symbolMapReader = reader.getSymbolMapReader(keyColumnIndex);</span>
<span class="fc bfc" id="L3897" title="All 2 branches covered.">                        final int symbolKey = symbolFunc.isRuntimeConstant()</span>
<span class="fc" id="L3898">                                ? SymbolTable.VALUE_NOT_FOUND</span>
<span class="fc" id="L3899">                                : symbolMapReader.keyOf(symbolFunc.getStr(null));</span>

<span class="fc bfc" id="L3901" title="All 2 branches covered.">                        if (symbolKey == SymbolTable.VALUE_NOT_FOUND) {</span>
<span class="fc bfc" id="L3902" title="All 2 branches covered.">                            if (f == null) {</span>
<span class="fc" id="L3903">                                rcf = new DeferredSymbolIndexRowCursorFactory(keyColumnIndex,</span>
                                        symbolFunc,
                                        true,
                                        indexDirection
                                );
                            } else {
<span class="fc" id="L3909">                                rcf = new DeferredSymbolIndexFilteredRowCursorFactory(</span>
                                        keyColumnIndex,
                                        symbolFunc,
                                        f,
                                        true,
                                        indexDirection,
                                        columnIndexes
                                );
                            }
                        } else {
<span class="fc bfc" id="L3919" title="All 2 branches covered.">                            if (f == null) {</span>
<span class="fc" id="L3920">                                rcf = new SymbolIndexRowCursorFactory(keyColumnIndex, symbolKey, true, indexDirection, null);</span>
                            } else {
<span class="fc" id="L3922">                                rcf = new SymbolIndexFilteredRowCursorFactory(keyColumnIndex, symbolKey, f, true, indexDirection, columnIndexes, null);</span>
                            }
                        }

<span class="fc bfc" id="L3926" title="All 2 branches covered.">                        if (f == null) {</span>
                            // This special case factory can later be disassembled to framing and index
                            // cursors in Sample By processing
<span class="fc" id="L3929">                            return new DeferredSingleSymbolFilterDataFrameRecordCursorFactory(</span>
                                    configuration,
                                    keyColumnIndex,
                                    symbolFunc,
                                    rcf,
                                    myMeta,
                                    dfcFactory,
                                    orderByKeyColumn,
                                    columnIndexes,
                                    columnSizes,
                                    supportsRandomAccess
                            );
                        }
<span class="fc" id="L3942">                        return new DataFrameRecordCursorFactory(</span>
                                configuration,
                                myMeta,
                                dfcFactory,
                                rcf,
                                orderByKeyColumn,
                                f,
                                false,
                                columnIndexes,
                                columnSizes,
                                supportsRandomAccess
                        );
                    }

<span class="fc bfc" id="L3956" title="All 2 branches covered.">                    if (orderByKeyColumn) {</span>
<span class="fc" id="L3957">                        myMeta.setTimestampIndex(-1);</span>
                    }

<span class="fc" id="L3960">                    return new FilterOnValuesRecordCursorFactory(</span>
                            myMeta,
                            dfcFactory,
                            intrinsicModel.keyValueFuncs,
                            keyColumnIndex,
                            reader,
                            f,
<span class="fc" id="L3967">                            model.getOrderByAdviceMnemonic(),</span>
                            orderByKeyColumn,
<span class="fc" id="L3969">                            getOrderByDirectionOrDefault(model, 0),</span>
                            indexDirection,
                            columnIndexes
                    );
<span class="fc" id="L3973">                } else if (</span>
<span class="pc bpc" id="L3974" title="1 of 2 branches missed.">                        intrinsicModel.keyExcludedValueFuncs.size() &gt; 0</span>
<span class="fc bfc" id="L3975" title="All 2 branches covered.">                                &amp;&amp; reader.getSymbolMapReader(keyColumnIndex).getSymbolCount() &lt; configuration.getMaxSymbolNotEqualsCount()</span>
                ) {
<span class="fc" id="L3977">                    Function f = compileFilter(intrinsicModel, myMeta, executionContext);</span>
<span class="fc bfc" id="L3978" title="All 4 branches covered.">                    if (f != null &amp;&amp; f.isConstant()) {</span>
                        try {
<span class="pc bpc" id="L3980" title="1 of 2 branches missed.">                            if (!f.getBool(null)) {</span>
<span class="fc" id="L3981">                                Misc.free(dfcFactory);</span>
<span class="fc" id="L3982">                                return new EmptyTableRecordCursorFactory(myMeta);</span>
                            }
                        } finally {
<span class="fc" id="L3985">                            f = Misc.free(f);</span>
                        }
                    }

<span class="fc" id="L3989">                    return new FilterOnExcludedValuesRecordCursorFactory(</span>
                            myMeta,
                            dfcFactory,
                            intrinsicModel.keyExcludedValueFuncs,
                            keyColumnIndex,
                            f,
<span class="fc" id="L3995">                            model.getOrderByAdviceMnemonic(),</span>
                            orderByKeyColumn,
                            indexDirection,
                            columnIndexes,
<span class="fc" id="L3999">                            configuration.getMaxSymbolNotEqualsCount()</span>
                    );
                }
            }

<span class="fc bfc" id="L4004" title="All 4 branches covered.">            if (intervalHitsOnlyOnePartition &amp;&amp; intrinsicModel.filter == null) {</span>
<span class="fc" id="L4005">                final ObjList&lt;ExpressionNode&gt; orderByAdvice = model.getOrderByAdvice();</span>
<span class="fc" id="L4006">                final int orderByAdviceSize = orderByAdvice.size();</span>
<span class="pc bpc" id="L4007" title="2 of 6 branches missed.">                if (orderByAdviceSize &gt; 0 &amp;&amp; orderByAdviceSize &lt; 3 &amp;&amp; intrinsicModel.hasIntervalFilters()) {</span>
                    // we can only deal with 'order by symbol, timestamp' at best
                    // skip this optimisation if order by is more extensive
<span class="fc" id="L4010">                    final int columnIndex = myMeta.getColumnIndexQuiet(model.getOrderByAdvice().getQuick(0).token);</span>
<span class="pc bpc" id="L4011" title="1 of 2 branches missed.">                    assert columnIndex &gt; -1;</span>

                    // this is our kind of column
<span class="fc bfc" id="L4014" title="All 2 branches covered.">                    if (myMeta.isColumnIndexed(columnIndex)) {</span>
<span class="fc" id="L4015">                        boolean orderByKeyColumn = false;</span>
<span class="fc" id="L4016">                        int indexDirection = BitmapIndexReader.DIR_FORWARD;</span>
<span class="fc bfc" id="L4017" title="All 2 branches covered.">                        if (orderByAdviceSize == 1) {</span>
<span class="fc" id="L4018">                            orderByKeyColumn = true;</span>
<span class="pc bpc" id="L4019" title="1 of 2 branches missed.">                        } else if (Chars.equals(orderByAdvice.getQuick(1).token, model.getTimestamp().token)) {</span>
<span class="fc" id="L4020">                            orderByKeyColumn = true;</span>
<span class="pc bpc" id="L4021" title="1 of 2 branches missed.">                            if (getOrderByDirectionOrDefault(model, 1) == QueryModel.ORDER_DIRECTION_DESCENDING) {</span>
<span class="fc" id="L4022">                                indexDirection = BitmapIndexReader.DIR_BACKWARD;</span>
                            }
                        }

<span class="pc bpc" id="L4026" title="1 of 2 branches missed.">                        if (orderByKeyColumn) {</span>
                            // check that intrinsicModel.intervals hit only one partition
<span class="fc" id="L4028">                            myMeta.setTimestampIndex(-1);</span>
<span class="fc" id="L4029">                            return new SortedSymbolIndexRecordCursorFactory(</span>
                                    myMeta,
                                    dfcFactory,
                                    columnIndex,
<span class="fc bfc" id="L4033" title="All 2 branches covered.">                                    getOrderByDirectionOrDefault(model, 0) == QueryModel.ORDER_DIRECTION_ASCENDING,</span>
                                    indexDirection,
                                    columnIndexes
                            );
                        }
                    }
                }
            }

<span class="fc" id="L4042">            boolean isOrderByTimestampDesc = isOrderDescendingByDesignatedTimestampOnly(model);</span>
            RowCursorFactory rowFactory;

<span class="fc bfc" id="L4045" title="All 4 branches covered.">            if (isOrderByTimestampDesc &amp;&amp; !intrinsicModel.hasIntervalFilters()) {</span>
<span class="fc" id="L4046">                Misc.free(dfcFactory);</span>
<span class="fc" id="L4047">                dfcFactory = new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta);</span>
<span class="fc" id="L4048">                rowFactory = new BwdDataFrameRowCursorFactory();</span>
            } else {
<span class="fc" id="L4050">                rowFactory = new DataFrameRowCursorFactory();</span>
            }

<span class="fc" id="L4053">            model.setWhereClause(intrinsicModel.filter);</span>
<span class="fc" id="L4054">            return new DataFrameRecordCursorFactory(</span>
                    configuration,
                    myMeta,
                    dfcFactory,
                    rowFactory,
                    false,
                    null,
                    framingSupported,
                    columnIndexes,
                    columnSizes,
                    supportsRandomAccess
            );
        }

        // no where clause
<span class="fc bfc" id="L4069" title="All 2 branches covered.">        if (latestByColumnCount == 0) {</span>
            // construct new metadata, which is a copy of what we constructed just above, but
            // in the interest of isolating problems we will only affect this factory

            AbstractDataFrameCursorFactory cursorFactory;
            RowCursorFactory rowCursorFactory;

<span class="fc bfc" id="L4076" title="All 2 branches covered.">            if (isOrderDescendingByDesignatedTimestampOnly(model)) {</span>
<span class="fc" id="L4077">                cursorFactory = new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta);</span>
<span class="fc" id="L4078">                rowCursorFactory = new BwdDataFrameRowCursorFactory();</span>
            } else {
<span class="fc" id="L4080">                cursorFactory = new FullFwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta);</span>
<span class="fc" id="L4081">                rowCursorFactory = new DataFrameRowCursorFactory();</span>
            }

<span class="fc" id="L4084">            return new DataFrameRecordCursorFactory(</span>
                    configuration,
                    myMeta,
                    cursorFactory,
                    rowCursorFactory,
                    false,
                    null,
                    framingSupported,
                    columnIndexes,
                    columnSizes,
                    supportsRandomAccess
            );
        }

        // 'latest by' clause takes over the latest by nodes, so that the later generateLatestBy() is no-op
<span class="fc" id="L4099">        model.getLatestBy().clear();</span>

        // listColumnFilterA = latest by column indexes
<span class="fc bfc" id="L4102" title="All 2 branches covered.">        if (latestByColumnCount == 1) {</span>
<span class="fc" id="L4103">            int latestByColumnIndex = listColumnFilterA.getColumnIndexFactored(0);</span>
<span class="fc bfc" id="L4104" title="All 2 branches covered.">            if (myMeta.isColumnIndexed(latestByColumnIndex)) {</span>
<span class="fc" id="L4105">                return new LatestByAllIndexedRecordCursorFactory(</span>
                        myMeta,
                        configuration,
<span class="fc" id="L4108">                        new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta),</span>
<span class="fc" id="L4109">                        listColumnFilterA.getColumnIndexFactored(0),</span>
                        columnIndexes,
                        prefixes
                );
            }

<span class="fc bfc" id="L4115" title="All 2 branches covered.">            if (ColumnType.isSymbol(myMeta.getColumnType(latestByColumnIndex))</span>
<span class="pc bpc" id="L4116" title="1 of 2 branches missed.">                    &amp;&amp; myMeta.isSymbolTableStatic(latestByColumnIndex)) {</span>
                // we have &quot;latest by&quot; symbol column values, but no index
<span class="fc" id="L4118">                return new LatestByDeferredListValuesFilteredRecordCursorFactory(</span>
                        configuration,
                        myMeta,
<span class="fc" id="L4121">                        new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta),</span>
                        latestByColumnIndex,
                        null,
                        columnIndexes
                );
            }
        }

<span class="fc" id="L4129">        boolean symbolKeysOnly = true;</span>
<span class="fc bfc" id="L4130" title="All 2 branches covered.">        for (int i = 0, n = keyTypes.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L4131">            symbolKeysOnly &amp;= ColumnType.isSymbol(keyTypes.getColumnType(i));</span>
        }
<span class="fc bfc" id="L4133" title="All 2 branches covered.">        if (symbolKeysOnly) {</span>
<span class="fc" id="L4134">            IntList partitionByColumnIndexes = new IntList(listColumnFilterA.size());</span>
<span class="fc bfc" id="L4135" title="All 2 branches covered.">            for (int i = 0, n = listColumnFilterA.size(); i &lt; n; i++) {</span>
<span class="fc" id="L4136">                partitionByColumnIndexes.add(listColumnFilterA.getColumnIndexFactored(i));</span>
            }
<span class="fc" id="L4138">            return new LatestByAllSymbolsFilteredRecordCursorFactory(</span>
                    myMeta,
                    configuration,
<span class="fc" id="L4141">                    new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta),</span>
<span class="fc" id="L4142">                    RecordSinkFactory.getInstance(asm, myMeta, listColumnFilterA, false),</span>
                    keyTypes,
                    partitionByColumnIndexes,
                    null,
                    null,
                    columnIndexes
            );
        }

<span class="fc" id="L4151">        return new LatestByAllFilteredRecordCursorFactory(</span>
                myMeta,
                configuration,
<span class="fc" id="L4154">                new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta),</span>
<span class="fc" id="L4155">                RecordSinkFactory.getInstance(asm, myMeta, listColumnFilterA, false),</span>
                keyTypes,
                null,
                columnIndexes
        );
    }

    private RecordCursorFactory generateUnionAllFactory(
            QueryModel model,
            SqlExecutionContext executionContext,
            RecordCursorFactory factoryA,
            RecordCursorFactory factoryB,
            ObjList&lt;Function&gt; castFunctionsA,
            ObjList&lt;Function&gt; castFunctionsB,
            RecordMetadata setMetadata
    ) throws SqlException {
<span class="fc" id="L4171">        final RecordCursorFactory setFactory = new UnionAllRecordCursorFactory(</span>
                setMetadata,
                factoryA,
                factoryB,
                castFunctionsA,
                castFunctionsB
        );

<span class="fc bfc" id="L4179" title="All 2 branches covered.">        if (model.getUnionModel().getUnionModel() != null) {</span>
<span class="fc" id="L4180">            return generateSetFactory(model.getUnionModel(), setFactory, executionContext);</span>
        }
<span class="fc" id="L4182">        return setFactory;</span>
    }

    private RecordCursorFactory generateUnionFactory(
            QueryModel model,
            SqlExecutionContext executionContext,
            RecordCursorFactory factoryA,
            RecordCursorFactory factoryB,
            ObjList&lt;Function&gt; castFunctionsA,
            ObjList&lt;Function&gt; castFunctionsB,
            RecordMetadata setMetadata,
            SetRecordCursorFactoryConstructor constructor
    ) throws SqlException {
<span class="fc" id="L4195">        entityColumnFilter.of(factoryA.getMetadata().getColumnCount());</span>
<span class="fc" id="L4196">        final RecordSink recordSink = RecordSinkFactory.getInstance(</span>
                asm,
                setMetadata,
                entityColumnFilter,
                true
        );
<span class="fc" id="L4202">        valueTypes.clear();</span>
        // Remap symbol columns to string type since that's how recordSink copies them.
<span class="fc" id="L4204">        keyTypes.clear();</span>
<span class="fc bfc" id="L4205" title="All 2 branches covered.">        for (int i = 0, n = setMetadata.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L4206">            final int columnType = setMetadata.getColumnType(i);</span>
<span class="fc bfc" id="L4207" title="All 2 branches covered.">            if (ColumnType.isSymbol(columnType)) {</span>
<span class="fc" id="L4208">                keyTypes.add(ColumnType.STRING);</span>
            } else {
<span class="fc" id="L4210">                keyTypes.add(columnType);</span>
            }
        }
<span class="fc" id="L4213">        RecordCursorFactory unionFactory = constructor.create(</span>
                configuration,
                setMetadata,
                factoryA,
                factoryB,
                castFunctionsA,
                castFunctionsB,
                recordSink,
                keyTypes,
                valueTypes
        );

<span class="fc bfc" id="L4225" title="All 2 branches covered.">        if (model.getUnionModel().getUnionModel() != null) {</span>
<span class="fc" id="L4226">            return generateSetFactory(model.getUnionModel(), unionFactory, executionContext);</span>
        }
<span class="fc" id="L4228">        return unionFactory;</span>
    }

    @Nullable
    private Function getHiFunction(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L4233">        return toLimitFunction(executionContext, model.getLimitHi(), null);</span>
    }

    @Nullable
    private Function getLimitLoFunctionOnly(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="pc bpc" id="L4238" title="1 of 4 branches missed.">        if (model.getLimitAdviceLo() != null &amp;&amp; model.getLimitAdviceHi() == null) {</span>
<span class="fc" id="L4239">            return toLimitFunction(executionContext, model.getLimitAdviceLo(), LongConstant.ZERO);</span>
        }
<span class="fc" id="L4241">        return null;</span>
    }

    @NotNull
    private Function getLoFunction(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="pc bpc" id="L4246" title="1 of 2 branches missed.">        return toLimitFunction(executionContext, model.getLimitLo(), LongConstant.ZERO);</span>
    }

    private int getTimestampIndex(QueryModel model, RecordCursorFactory factory) throws SqlException {
<span class="fc" id="L4250">        return getTimestampIndex(model, factory.getMetadata());</span>
    }

    private int getTimestampIndex(QueryModel model, RecordMetadata metadata) throws SqlException {
<span class="fc" id="L4254">        final ExpressionNode timestamp = model.getTimestamp();</span>
<span class="fc bfc" id="L4255" title="All 2 branches covered.">        if (timestamp != null) {</span>
<span class="fc" id="L4256">            int timestampIndex = metadata.getColumnIndexQuiet(timestamp.token);</span>
<span class="fc bfc" id="L4257" title="All 2 branches covered.">            if (timestampIndex == -1) {</span>
<span class="fc" id="L4258">                throw SqlException.invalidColumn(timestamp.position, timestamp.token);</span>
            }
<span class="fc bfc" id="L4260" title="All 2 branches covered.">            if (!ColumnType.isTimestamp(metadata.getColumnType(timestampIndex))) {</span>
<span class="fc" id="L4261">                throw SqlException.$(timestamp.position, &quot;not a TIMESTAMP&quot;);</span>
            }
<span class="fc" id="L4263">            return timestampIndex;</span>
        }
<span class="fc" id="L4265">        return metadata.getTimestampIndex();</span>
    }

    private boolean isOrderDescendingByDesignatedTimestampOnly(QueryModel model) {
<span class="fc bfc" id="L4269" title="All 4 branches covered.">        return model.getOrderByAdvice().size() == 1 &amp;&amp; model.getTimestamp() != null &amp;&amp;</span>
<span class="fc bfc" id="L4270" title="All 2 branches covered.">                Chars.equalsIgnoreCase(model.getOrderByAdvice().getQuick(0).token, model.getTimestamp().token) &amp;&amp;</span>
<span class="fc bfc" id="L4271" title="All 2 branches covered.">                getOrderByDirectionOrDefault(model, 0) == ORDER_DIRECTION_DESCENDING;</span>
    }

    private boolean isSingleColumnFunction(ExpressionNode ast, CharSequence name) {
<span class="pc bpc" id="L4275" title="1 of 8 branches missed.">        return ast.type == FUNCTION &amp;&amp; ast.paramCount == 1 &amp;&amp; Chars.equalsIgnoreCase(ast.token, name) &amp;&amp; ast.rhs.type == LITERAL;</span>
    }

    private void lookupColumnIndexes(
            ListColumnFilter filter,
            ObjList&lt;ExpressionNode&gt; columnNames,
            RecordMetadata metadata
    ) throws SqlException {
<span class="fc" id="L4283">        filter.clear();</span>
<span class="fc bfc" id="L4284" title="All 2 branches covered.">        for (int i = 0, n = columnNames.size(); i &lt; n; i++) {</span>
<span class="fc" id="L4285">            final CharSequence columnName = columnNames.getQuick(i).token;</span>
<span class="fc" id="L4286">            int columnIndex = metadata.getColumnIndexQuiet(columnName);</span>
<span class="fc bfc" id="L4287" title="All 2 branches covered.">            if (columnIndex &gt; -1) {</span>
<span class="fc" id="L4288">                filter.add(columnIndex + 1);</span>
            } else {
<span class="fc" id="L4290">                int dot = Chars.indexOf(columnName, '.');</span>
<span class="pc bpc" id="L4291" title="1 of 2 branches missed.">                if (dot &gt; -1) {</span>
<span class="fc" id="L4292">                    columnIndex = metadata.getColumnIndexQuiet(columnName, dot + 1, columnName.length());</span>
<span class="pc bpc" id="L4293" title="1 of 2 branches missed.">                    if (columnIndex &gt; -1) {</span>
<span class="fc" id="L4294">                        filter.add(columnIndex + 1);</span>
<span class="fc" id="L4295">                        return;</span>
                    }
                }
<span class="nc" id="L4298">                throw SqlException.invalidColumn(columnNames.getQuick(i).position, columnName);</span>
            }
        }
<span class="fc" id="L4301">    }</span>

    private void lookupColumnIndexesUsingVanillaNames(
            ListColumnFilter filter,
            ObjList&lt;CharSequence&gt; columnNames,
            RecordMetadata metadata
    ) {
<span class="fc" id="L4308">        filter.clear();</span>
<span class="fc bfc" id="L4309" title="All 2 branches covered.">        for (int i = 0, n = columnNames.size(); i &lt; n; i++) {</span>
<span class="fc" id="L4310">            filter.add(metadata.getColumnIndex(columnNames.getQuick(i)) + 1);</span>
        }
<span class="fc" id="L4312">    }</span>

    private int prepareLatestByColumnIndexes(ObjList&lt;ExpressionNode&gt; latestBy, RecordMetadata myMeta) throws SqlException {
<span class="fc" id="L4315">        keyTypes.clear();</span>
<span class="fc" id="L4316">        listColumnFilterA.clear();</span>

<span class="fc" id="L4318">        final int latestByColumnCount = latestBy.size();</span>
<span class="fc bfc" id="L4319" title="All 2 branches covered.">        if (latestByColumnCount &gt; 0) {</span>
            // validate the latest by against the current reader
            // first check if column is valid
<span class="fc bfc" id="L4322" title="All 2 branches covered.">            for (int i = 0; i &lt; latestByColumnCount; i++) {</span>
<span class="fc" id="L4323">                final ExpressionNode latestByNode = latestBy.getQuick(i);</span>
<span class="fc" id="L4324">                final int index = myMeta.getColumnIndexQuiet(latestByNode.token);</span>
<span class="fc bfc" id="L4325" title="All 2 branches covered.">                if (index == -1) {</span>
<span class="fc" id="L4326">                    throw SqlException.invalidColumn(latestByNode.position, latestByNode.token);</span>
                }

                // check the type of the column, not all are supported
<span class="fc" id="L4330">                int columnType = myMeta.getColumnType(index);</span>
<span class="fc bfc" id="L4331" title="All 2 branches covered.">                switch (ColumnType.tagOf(columnType)) {</span>
                    case ColumnType.BOOLEAN:
                    case ColumnType.CHAR:
                    case ColumnType.SHORT:
                    case ColumnType.INT:
                    case ColumnType.LONG:
                    case ColumnType.LONG256:
                    case ColumnType.STRING:
                    case ColumnType.SYMBOL:
                    case ColumnType.UUID:
                    case ColumnType.LONG128:
                        // we are reusing collections which leads to confusing naming for this method
                        // keyTypes are types of columns we collect 'latest by' for
<span class="fc" id="L4344">                        keyTypes.add(columnType);</span>
                        // listColumnFilterA are indexes of columns we collect 'latest by' for
<span class="fc" id="L4346">                        listColumnFilterA.add(index + 1);</span>
<span class="fc" id="L4347">                        break;</span>

                    default:
<span class="fc" id="L4350">                        throw SqlException</span>
<span class="fc" id="L4351">                                .position(latestByNode.position)</span>
<span class="fc" id="L4352">                                .put(latestByNode.token)</span>
<span class="fc" id="L4353">                                .put(&quot; (&quot;)</span>
<span class="fc" id="L4354">                                .put(ColumnType.nameOf(columnType))</span>
<span class="fc" id="L4355">                                .put(&quot;): invalid type, only [BOOLEAN, SHORT, INT, LONG, LONG128, LONG256, CHAR, STRING, SYMBOL, UUID] are supported in LATEST BY&quot;);</span>
                }
            }
        }
<span class="fc" id="L4359">        return latestByColumnCount;</span>
    }

    private void processJoinContext(
            boolean vanillaMaster,
            JoinContext jc,
            RecordMetadata masterMetadata,
            RecordMetadata slaveMetadata
    ) throws SqlException {
<span class="fc" id="L4368">        lookupColumnIndexesUsingVanillaNames(listColumnFilterA, jc.aNames, slaveMetadata);</span>
<span class="fc bfc" id="L4369" title="All 2 branches covered.">        if (vanillaMaster) {</span>
<span class="fc" id="L4370">            lookupColumnIndexesUsingVanillaNames(listColumnFilterB, jc.bNames, masterMetadata);</span>
        } else {
<span class="fc" id="L4372">            lookupColumnIndexes(listColumnFilterB, jc.bNodes, masterMetadata);</span>
        }

        // compare types and populate keyTypes
<span class="fc" id="L4376">        keyTypes.clear();</span>
<span class="fc bfc" id="L4377" title="All 2 branches covered.">        for (int k = 0, m = listColumnFilterA.getColumnCount(); k &lt; m; k++) {</span>
            // Don't use tagOf(columnType) to compare the types.
            // Key types have too much exactly except SYMBOL and STRING special case
<span class="fc" id="L4380">            int columnTypeA = slaveMetadata.getColumnType(listColumnFilterA.getColumnIndexFactored(k));</span>
<span class="fc" id="L4381">            int columnTypeB = masterMetadata.getColumnType(listColumnFilterB.getColumnIndexFactored(k));</span>
<span class="pc bpc" id="L4382" title="1 of 6 branches missed.">            if (columnTypeB != columnTypeA &amp;&amp; !(ColumnType.isSymbolOrString(columnTypeB) &amp;&amp; ColumnType.isSymbolOrString(columnTypeA))) {</span>
                // index in column filter and join context is the same
<span class="fc" id="L4384">                throw SqlException.$(jc.aNodes.getQuick(k).position, &quot;join column type mismatch&quot;);</span>
            }
<span class="fc bfc" id="L4386" title="All 2 branches covered.">            keyTypes.add(columnTypeB == ColumnType.SYMBOL ? ColumnType.STRING : columnTypeB);</span>
        }
<span class="fc" id="L4388">    }</span>

    private void processNodeQueryModels(ExpressionNode node, ModelOperator operator) {
<span class="fc" id="L4391">        sqlNodeStack.clear();</span>
<span class="fc bfc" id="L4392" title="All 2 branches covered.">        while (node != null) {</span>
<span class="fc bfc" id="L4393" title="All 2 branches covered.">            if (node.queryModel != null) {</span>
<span class="fc" id="L4394">                operator.operate(expressionNodePool, node.queryModel);</span>
            }

<span class="fc bfc" id="L4397" title="All 2 branches covered.">            if (node.lhs != null) {</span>
<span class="fc" id="L4398">                sqlNodeStack.push(node.lhs);</span>
            }

<span class="fc bfc" id="L4401" title="All 2 branches covered.">            if (node.rhs != null) {</span>
<span class="fc" id="L4402">                node = node.rhs;</span>
            } else {
<span class="fc bfc" id="L4404" title="All 2 branches covered.">                if (!sqlNodeStack.isEmpty()) {</span>
<span class="fc" id="L4405">                    node = this.sqlNodeStack.poll();</span>
                } else {
<span class="fc" id="L4407">                    node = null;</span>
                }
            }
        }

<span class="fc" id="L4412">    }</span>

    private void restoreWhereClause(ExpressionNode node) {
<span class="fc" id="L4415">        processNodeQueryModels(node, RESTORE_WHERE_CLAUSE);</span>
<span class="fc" id="L4416">    }</span>

    private Function toLimitFunction(
            SqlExecutionContext executionContext,
            ExpressionNode limit,
            ConstantFunction defaultValue
    ) throws SqlException {
<span class="fc bfc" id="L4423" title="All 2 branches covered.">        if (limit == null) {</span>
<span class="fc" id="L4424">            return defaultValue;</span>
        }

<span class="fc" id="L4427">        final Function func = functionParser.parseFunction(limit, EmptyRecordMetadata.INSTANCE, executionContext);</span>
<span class="fc" id="L4428">        final int type = func.getType();</span>
<span class="fc bfc" id="L4429" title="All 2 branches covered.">        if (limitTypes.excludes(type)) {</span>
<span class="fc bfc" id="L4430" title="All 2 branches covered.">            if (type == ColumnType.UNDEFINED) {</span>
<span class="pc bpc" id="L4431" title="1 of 2 branches missed.">                if (func instanceof IndexedParameterLinkFunction) {</span>
<span class="fc" id="L4432">                    executionContext.getBindVariableService().setLong(((IndexedParameterLinkFunction) func).getVariableIndex(), defaultValue.getLong(null));</span>
<span class="fc" id="L4433">                    return func;</span>
                }

<span class="nc bnc" id="L4436" title="All 2 branches missed.">                if (func instanceof NamedParameterLinkFunction) {</span>
<span class="nc" id="L4437">                    executionContext.getBindVariableService().setLong(((NamedParameterLinkFunction) func).getVariableName(), defaultValue.getLong(null));</span>
<span class="nc" id="L4438">                    return func;</span>
                }
            }
<span class="fc" id="L4441">            throw SqlException.$(limit.position, &quot;invalid type: &quot;).put(ColumnType.nameOf(type));</span>
        }
<span class="fc" id="L4443">        return func;</span>
    }

    private IntList toOrderIndices(RecordMetadata m, ObjList&lt;ExpressionNode&gt; orderBy, IntList orderByDirection) throws SqlException {
<span class="fc" id="L4447">        final IntList indices = intListPool.next();</span>
<span class="fc bfc" id="L4448" title="All 2 branches covered.">        for (int i = 0, n = orderBy.size(); i &lt; n; i++) {</span>
<span class="fc" id="L4449">            ExpressionNode tok = orderBy.getQuick(i);</span>
<span class="fc" id="L4450">            int index = m.getColumnIndexQuiet(tok.token);</span>
<span class="pc bpc" id="L4451" title="1 of 2 branches missed.">            if (index == -1) {</span>
<span class="nc" id="L4452">                throw SqlException.invalidColumn(tok.position, tok.token);</span>
            }

            // shift index by 1 to use sign as sort direction
<span class="fc" id="L4456">            index++;</span>

            // negative column index means descending order of sort
<span class="fc bfc" id="L4459" title="All 2 branches covered.">            if (orderByDirection.getQuick(i) == QueryModel.ORDER_DIRECTION_DESCENDING) {</span>
<span class="fc" id="L4460">                index = -index;</span>
            }

<span class="fc" id="L4463">            indices.add(index);</span>
        }
<span class="fc" id="L4465">        return indices;</span>
    }

    private void validateBothTimestampOrders(RecordCursorFactory masterFactory, RecordCursorFactory slaveFactory, int position) throws SqlException {
<span class="fc bfc" id="L4469" title="All 2 branches covered.">        if (masterFactory.hasDescendingOrder()) {</span>
<span class="fc" id="L4470">            throw SqlException.$(position, &quot;left side of time series join has DESC timestamp order&quot;);</span>
        }

<span class="fc bfc" id="L4473" title="All 2 branches covered.">        if (slaveFactory.hasDescendingOrder()) {</span>
<span class="fc" id="L4474">            throw SqlException.$(position, &quot;right side of time series join has DESC timestamp order&quot;);</span>
        }
<span class="fc" id="L4476">    }</span>

    private void validateBothTimestamps(QueryModel slaveModel, RecordMetadata masterMetadata, RecordMetadata slaveMetadata) throws SqlException {
<span class="fc bfc" id="L4479" title="All 2 branches covered.">        if (masterMetadata.getTimestampIndex() == -1) {</span>
<span class="fc" id="L4480">            throw SqlException.$(slaveModel.getJoinKeywordPosition(), &quot;left side of time series join has no timestamp&quot;);</span>
        }

<span class="fc bfc" id="L4483" title="All 2 branches covered.">        if (slaveMetadata.getTimestampIndex() == -1) {</span>
<span class="fc" id="L4484">            throw SqlException.$(slaveModel.getJoinKeywordPosition(), &quot;right side of time series join has no timestamp&quot;);</span>
        }
<span class="fc" id="L4486">    }</span>

    private void validateOuterJoinExpressions(QueryModel model, CharSequence joinType) throws SqlException {
<span class="fc bfc" id="L4489" title="All 2 branches covered.">        if (model.getOuterJoinExpressionClause() != null) {</span>
<span class="fc" id="L4490">            throw SqlException.$(model.getOuterJoinExpressionClause().position, &quot;unsupported &quot;).put(joinType).put(&quot; join expression &quot;)</span>
<span class="fc" id="L4491">                    .put(&quot;[expr='&quot;).put(model.getOuterJoinExpressionClause()).put(&quot;']&quot;);</span>
        }
<span class="fc" id="L4493">    }</span>

    private Record.CharSequenceFunction validateSubQueryColumnAndGetGetter(IntrinsicModel intrinsicModel, RecordMetadata metadata) throws SqlException {
<span class="fc" id="L4496">        int columnType = metadata.getColumnType(0);</span>
<span class="fc bfc" id="L4497" title="All 2 branches covered.">        if (!ColumnType.isSymbolOrString(columnType)) {</span>
<span class="pc bpc" id="L4498" title="1 of 2 branches missed.">            assert intrinsicModel.keySubQuery.getColumns() != null;</span>
<span class="pc bpc" id="L4499" title="1 of 2 branches missed.">            assert intrinsicModel.keySubQuery.getColumns().size() &gt; 0;</span>

<span class="fc" id="L4501">            throw SqlException</span>
<span class="fc" id="L4502">                    .position(intrinsicModel.keySubQuery.getColumns().getQuick(0).getAst().position)</span>
<span class="fc" id="L4503">                    .put(&quot;unsupported column type: &quot;)</span>
<span class="fc" id="L4504">                    .put(metadata.getColumnName(0))</span>
<span class="fc" id="L4505">                    .put(&quot;: &quot;)</span>
<span class="fc" id="L4506">                    .put(ColumnType.nameOf(columnType));</span>
        }

<span class="fc bfc" id="L4509" title="All 2 branches covered.">        return ColumnType.isString(columnType) ? Record.GET_STR : Record.GET_SYM;</span>
    }

    private RecordMetadata widenSetMetadata(RecordMetadata typesA, RecordMetadata typesB) {
<span class="fc" id="L4513">        int columnCount = typesA.getColumnCount();</span>
<span class="pc bpc" id="L4514" title="1 of 2 branches missed.">        assert columnCount == typesB.getColumnCount();</span>

<span class="fc" id="L4516">        GenericRecordMetadata metadata = new GenericRecordMetadata();</span>
<span class="fc bfc" id="L4517" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L4518">            int typeA = typesA.getColumnType(i);</span>
<span class="fc" id="L4519">            int typeB = typesB.getColumnType(i);</span>

<span class="fc bfc" id="L4521" title="All 4 branches covered.">            if (typeA == typeB &amp;&amp; typeA != ColumnType.SYMBOL) {</span>
<span class="fc" id="L4522">                metadata.add(AbstractRecordMetadata.copyOf(typesA, i));</span>
<span class="fc bfc" id="L4523" title="All 6 branches covered.">            } else if (ColumnType.isToSameOrWider(typeB, typeA) &amp;&amp; typeA != ColumnType.SYMBOL &amp;&amp; typeA != ColumnType.CHAR) {</span>
                // CHAR is &quot;specially&quot; assignable from SHORT, but we don't want that
<span class="fc" id="L4525">                metadata.add(AbstractRecordMetadata.copyOf(typesA, i));</span>
<span class="fc bfc" id="L4526" title="All 4 branches covered.">            } else if (ColumnType.isToSameOrWider(typeA, typeB) &amp;&amp; typeB != ColumnType.SYMBOL) {</span>
                // even though A is assignable to B (e.g. A union B)
                // set metadata will use A column names
<span class="fc" id="L4529">                metadata.add(new TableColumnMetadata(</span>
<span class="fc" id="L4530">                        typesA.getColumnName(i),</span>
                        typeB
                ));
            } else {
                // we can cast anything to string
<span class="fc" id="L4535">                metadata.add(new TableColumnMetadata(</span>
<span class="fc" id="L4536">                        typesA.getColumnName(i),</span>
                        ColumnType.STRING
                ));
            }
        }

<span class="fc" id="L4542">        return metadata;</span>
    }

    // used in tests
    void setEnableJitNullChecks(boolean value) {
<span class="nc" id="L4547">        enableJitNullChecks = value;</span>
<span class="nc" id="L4548">    }</span>

    void setFullFatJoins(boolean fullFatJoins) {
<span class="fc" id="L4551">        this.fullFatJoins = fullFatJoins;</span>
<span class="fc" id="L4552">    }</span>

    @FunctionalInterface
    public interface FullFatJoinGenerator {
        RecordCursorFactory create(
                CairoConfiguration configuration,
                RecordMetadata metadata,
                RecordCursorFactory masterFactory,
                RecordCursorFactory slaveFactory,
                @Transient ColumnTypes mapKeyTypes,
                @Transient ColumnTypes mapValueTypes,
                @Transient ColumnTypes slaveColumnTypes,
                RecordSink masterKeySink,
                RecordSink slaveKeySink,
                int columnSplit,
                RecordValueSink slaveValueSink,
                IntList columnIndex,
                JoinContext joinContext
        );
    }

    @FunctionalInterface
    interface ModelOperator {
        void operate(ObjectPool&lt;ExpressionNode&gt; pool, QueryModel model);
    }

    private static class RecordCursorFactoryStub implements RecordCursorFactory {
        final ExecutionModel model;
        RecordCursorFactory factory;

<span class="fc" id="L4582">        protected RecordCursorFactoryStub(ExecutionModel model, RecordCursorFactory factory) {</span>
<span class="fc" id="L4583">            this.model = model;</span>
<span class="fc" id="L4584">            this.factory = factory;</span>
<span class="fc" id="L4585">        }</span>

        @Override
        public void close() {
<span class="fc" id="L4589">            factory = Misc.free(factory);</span>
<span class="fc" id="L4590">        }</span>

        @Override
        public RecordCursor getCursor(SqlExecutionContext executionContext) throws SqlException {
<span class="nc bnc" id="L4594" title="All 2 branches missed.">            if (factory != null) {</span>
<span class="nc" id="L4595">                return factory.getCursor(executionContext);</span>
            } else {
<span class="nc" id="L4597">                return null;</span>
            }
        }

        @Override
        public RecordMetadata getMetadata() {
<span class="nc" id="L4603">            return null;</span>
        }

        @Override
        public boolean recordCursorSupportsRandomAccess() {
<span class="nc" id="L4608">            return false;</span>
        }

        @Override
        public void toPlan(PlanSink sink) {
<span class="fc" id="L4613">            sink.type(model.getTypeName());</span>

<span class="fc" id="L4615">            CharSequence tableName = model.getTableName();</span>
<span class="pc bpc" id="L4616" title="1 of 2 branches missed.">            if (tableName != null) {</span>
<span class="fc" id="L4617">                sink.meta(&quot;table&quot;).val(tableName);</span>
            }
<span class="fc bfc" id="L4619" title="All 2 branches covered.">            if (factory != null) {</span>
<span class="fc" id="L4620">                sink.child(factory);</span>
            }
<span class="fc" id="L4622">        }</span>
    }

    static {
<span class="fc" id="L4626">        joinsRequiringTimestamp[JOIN_INNER] = false;</span>
<span class="fc" id="L4627">        joinsRequiringTimestamp[JOIN_OUTER] = false;</span>
<span class="fc" id="L4628">        joinsRequiringTimestamp[JOIN_CROSS] = false;</span>
<span class="fc" id="L4629">        joinsRequiringTimestamp[JOIN_ASOF] = true;</span>
<span class="fc" id="L4630">        joinsRequiringTimestamp[JOIN_SPLICE] = true;</span>
<span class="fc" id="L4631">        joinsRequiringTimestamp[JOIN_LT] = true;</span>
<span class="fc" id="L4632">        joinsRequiringTimestamp[JOIN_ONE] = false;</span>
    }

    static {
<span class="fc" id="L4636">        limitTypes.add(ColumnType.LONG);</span>
<span class="fc" id="L4637">        limitTypes.add(ColumnType.BYTE);</span>
<span class="fc" id="L4638">        limitTypes.add(ColumnType.SHORT);</span>
<span class="fc" id="L4639">        limitTypes.add(ColumnType.INT);</span>
    }

    static {
<span class="fc" id="L4643">        limitTypes.add(ColumnType.LONG);</span>
<span class="fc" id="L4644">        limitTypes.add(ColumnType.BYTE);</span>
<span class="fc" id="L4645">        limitTypes.add(ColumnType.SHORT);</span>
<span class="fc" id="L4646">        limitTypes.add(ColumnType.INT);</span>
    }

    static {
<span class="fc" id="L4650">        countConstructors.put(ColumnType.DOUBLE, CountDoubleVectorAggregateFunction::new);</span>
<span class="fc" id="L4651">        countConstructors.put(ColumnType.INT, CountIntVectorAggregateFunction::new);</span>
<span class="fc" id="L4652">        countConstructors.put(ColumnType.LONG, CountLongVectorAggregateFunction::new);</span>
<span class="fc" id="L4653">        countConstructors.put(ColumnType.DATE, CountLongVectorAggregateFunction::new);</span>
<span class="fc" id="L4654">        countConstructors.put(ColumnType.TIMESTAMP, CountLongVectorAggregateFunction::new);</span>

<span class="fc" id="L4656">        sumConstructors.put(ColumnType.DOUBLE, SumDoubleVectorAggregateFunction::new);</span>
<span class="fc" id="L4657">        sumConstructors.put(ColumnType.INT, SumIntVectorAggregateFunction::new);</span>
<span class="fc" id="L4658">        sumConstructors.put(ColumnType.LONG, SumLongVectorAggregateFunction::new);</span>
<span class="fc" id="L4659">        sumConstructors.put(ColumnType.LONG256, SumLong256VectorAggregateFunction::new);</span>
<span class="fc" id="L4660">        sumConstructors.put(ColumnType.DATE, SumDateVectorAggregateFunction::new);</span>
<span class="fc" id="L4661">        sumConstructors.put(ColumnType.TIMESTAMP, SumTimestampVectorAggregateFunction::new);</span>

<span class="fc" id="L4663">        ksumConstructors.put(ColumnType.DOUBLE, KSumDoubleVectorAggregateFunction::new);</span>
<span class="fc" id="L4664">        nsumConstructors.put(ColumnType.DOUBLE, NSumDoubleVectorAggregateFunction::new);</span>

<span class="fc" id="L4666">        avgConstructors.put(ColumnType.DOUBLE, AvgDoubleVectorAggregateFunction::new);</span>
<span class="fc" id="L4667">        avgConstructors.put(ColumnType.LONG, AvgLongVectorAggregateFunction::new);</span>
<span class="fc" id="L4668">        avgConstructors.put(ColumnType.TIMESTAMP, AvgLongVectorAggregateFunction::new);</span>
<span class="fc" id="L4669">        avgConstructors.put(ColumnType.DATE, AvgLongVectorAggregateFunction::new);</span>
<span class="fc" id="L4670">        avgConstructors.put(ColumnType.INT, AvgIntVectorAggregateFunction::new);</span>

<span class="fc" id="L4672">        minConstructors.put(ColumnType.DOUBLE, MinDoubleVectorAggregateFunction::new);</span>
<span class="fc" id="L4673">        minConstructors.put(ColumnType.LONG, MinLongVectorAggregateFunction::new);</span>
<span class="fc" id="L4674">        minConstructors.put(ColumnType.DATE, MinDateVectorAggregateFunction::new);</span>
<span class="fc" id="L4675">        minConstructors.put(ColumnType.TIMESTAMP, MinTimestampVectorAggregateFunction::new);</span>
<span class="fc" id="L4676">        minConstructors.put(ColumnType.INT, MinIntVectorAggregateFunction::new);</span>

<span class="fc" id="L4678">        maxConstructors.put(ColumnType.DOUBLE, MaxDoubleVectorAggregateFunction::new);</span>
<span class="fc" id="L4679">        maxConstructors.put(ColumnType.LONG, MaxLongVectorAggregateFunction::new);</span>
<span class="fc" id="L4680">        maxConstructors.put(ColumnType.DATE, MaxDateVectorAggregateFunction::new);</span>
<span class="fc" id="L4681">        maxConstructors.put(ColumnType.TIMESTAMP, MaxTimestampVectorAggregateFunction::new);</span>
<span class="fc" id="L4682">        maxConstructors.put(ColumnType.INT, MaxIntVectorAggregateFunction::new);</span>
<span class="fc" id="L4683">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>