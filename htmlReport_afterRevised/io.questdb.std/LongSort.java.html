<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LongSort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.std</a> &gt; <span class="el_source">LongSort.java</span></div><h1>LongSort.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.std;

<span class="nc" id="L27">public class LongSort {</span>
    /**
     * The maximum number of runs in merge sort.
     */
    public static final int MAX_RUN_COUNT = 67;
    /**
     * If the length of an array to be sorted is less than this
     * constant, Quicksort is used in preference to merge sort.
     */
    public static final int QUICKSORT_THRESHOLD = 286;
    /**
     * If the length of an array to be sorted is less than this
     * constant, insertion sort is used in preference to Quicksort.
     */
    private static final int INSERTION_SORT_THRESHOLD = 47;
    /**
     * The maximum length of run in merge sort.
     */
    private static final int MAX_RUN_LENGTH = 33;

    /**
     * Sorts the specified range of the array.
     *
     * @param vec   vector of long values
     * @param left  the index of the first element, inclusive, to be sorted
     * @param right the index of the last element, inclusive, to be sorted
     */
    public static void sort(LongVec vec, int left, int right) {
        // Use Quicksort on small arrays
<span class="fc bfc" id="L56" title="All 2 branches covered.">        if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="fc" id="L57">            sort(vec, left, right, true);</span>
<span class="fc" id="L58">            return;</span>
        }

        /*
         * Index run[i] is the start of i-th run
         * (ascending or descending sequence).
         */
<span class="fc" id="L65">        int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="fc" id="L66">        int count = 0;</span>
<span class="fc" id="L67">        run[0] = left;</span>

        // Check if the array is nearly sorted
<span class="fc bfc" id="L70" title="All 2 branches covered.">        for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">            if (vec.getQuick(k) &lt; vec.getQuick(k + 1)) { // ascending</span>
                //noinspection StatementWithEmptyBody
<span class="fc bfc" id="L73" title="All 4 branches covered.">                while (++k &lt;= right &amp;&amp; vec.getQuick(k - 1) &lt;= vec.getQuick(k)) ;</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">            } else if (vec.getQuick(k) &gt; vec.getQuick(k + 1)) { // descending</span>
                //noinspection StatementWithEmptyBody
<span class="pc bpc" id="L76" title="1 of 4 branches missed.">                while (++k &lt;= right &amp;&amp; vec.getQuick(k - 1) &gt;= vec.getQuick(k)) ;</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">                for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="fc" id="L78">                    swap(vec, lo, hi);</span>
                }
            } else { // equal
<span class="nc bnc" id="L81" title="All 4 branches missed.">                for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; vec.getQuick(k - 1) == vec.getQuick(k); ) {</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">                    if (--m == 0) {</span>
<span class="nc" id="L83">                        sort(vec, left, right, true);</span>
<span class="nc" id="L84">                        return;</span>
                    }
                }
            }

            /*
             * The array is not highly structured,
             * use Quicksort instead of merge sort.
             */
<span class="fc bfc" id="L93" title="All 2 branches covered.">            if (++count == MAX_RUN_COUNT) {</span>
<span class="fc" id="L94">                sort(vec, left, right, true);</span>
<span class="fc" id="L95">                return;</span>
            }
        }

        // Check special cases
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (run[count] == right++) { // The last run contains one element</span>
<span class="nc" id="L101">            run[++count] = right;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        } else if (count == 1) { // The array is already sorted</span>
<span class="fc" id="L103">            return;</span>
        }

        /*
         * Create temporary array, which is used for merging.
         * Implementation note: variable &quot;right&quot; is increased by 1.
         */

        LongVec a;
        LongVec b;

<span class="fc" id="L114">        byte odd = 0;</span>
        //noinspection StatementWithEmptyBody
<span class="fc bfc" id="L116" title="All 2 branches covered.">        for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1) ;</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (odd == 0) {</span>
<span class="fc" id="L119">            b = vec;</span>
<span class="fc" id="L120">            a = vec.newInstance();</span>

            //noinspection StatementWithEmptyBody
<span class="fc bfc" id="L123" title="All 2 branches covered.">            for (int i = left - 1; ++i &lt; right; a.setQuick(i, b.getQuick(i))) ;</span>
        } else {
<span class="fc" id="L125">            a = vec;</span>
<span class="fc" id="L126">            b = vec.newInstance();</span>
        }

        // Merging
<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (int last; count &gt; 1; count = last) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="fc" id="L132">                int hi = run[k], mi = run[k - 1];</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">                for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="fc bfc" id="L134" title="All 6 branches covered.">                    if (q &gt;= hi || p &lt; mi &amp;&amp; a.getQuick(p) &lt;= a.getQuick(q)) {</span>
<span class="fc" id="L135">                        b.setQuick(i, a.getQuick(p++));</span>
                    } else {
<span class="fc" id="L137">                        b.setQuick(i, a.getQuick(q++));</span>
                    }
                }
<span class="fc" id="L140">                run[++last] = hi;</span>
            }
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if ((count &amp; 1) != 0) {</span>
                //noinspection StatementWithEmptyBody
<span class="fc bfc" id="L144" title="All 2 branches covered.">                for (int i = right, lo = run[count - 1]; --i &gt;= lo; b.setQuick(i, a.getQuick(i))) ;</span>
<span class="fc" id="L145">                run[++last] = right;</span>
            }
<span class="fc" id="L147">            LongVec t = a;</span>
<span class="fc" id="L148">            a = b;</span>
<span class="fc" id="L149">            b = t;</span>
        }
<span class="fc" id="L151">    }</span>

    private static void let(LongVec vec, int a, int b) {
<span class="fc" id="L154">        vec.setQuick(a, vec.getQuick(b));</span>
<span class="fc" id="L155">    }</span>

    /**
     * Sorts the specified range of the array by Dual-Pivot Quicksort.
     *
     * @param left     the index of the first element, inclusive, to be sorted
     * @param right    the index of the last element, inclusive, to be sorted
     * @param leftmost indicates if this part is the leftmost in the range
     */
    private static void sort(LongVec vec, int left, int right, boolean leftmost) {
<span class="fc" id="L165">        int length = right - left + 1;</span>

        // Use insertion sort on tiny arrays
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (leftmost) {</span>
                /*
                 * Traditional (without sentinel) insertion sort,
                 * optimized for server VM, is used in case of
                 * the leftmost part.
                 */
<span class="fc bfc" id="L175" title="All 2 branches covered.">                for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="fc" id="L176">                    long ai = vec.getQuick(i + 1);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">                    while (ai &lt; vec.getQuick(j)) {</span>
<span class="fc" id="L178">                        let(vec, j + 1, j);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                        if (j-- == left) {</span>
<span class="fc" id="L180">                            break;</span>
                        }
                    }
<span class="fc" id="L183">                    vec.setQuick(j + 1, ai);</span>
                }
            } else {
                /*
                 * Skip the longest ascending sequence.
                 */
                do {
<span class="fc bfc" id="L190" title="All 2 branches covered.">                    if (left &gt;= right) {</span>
<span class="fc" id="L191">                        return;</span>
                    }
<span class="fc bfc" id="L193" title="All 2 branches covered.">                } while (vec.getQuick(++left) &gt;= vec.getQuick(left - 1));</span>

                /*
                 * Every element from adjoining part plays the role
                 * of sentinel, therefore this allows us to avoid the
                 * left range check on each iteration. Moreover, we use
                 * the more optimized algorithm, so called pair insertion
                 * sort, which is faster (in the context of Quicksort)
                 * than traditional implementation of insertion sort.
                 */
<span class="fc bfc" id="L203" title="All 2 branches covered.">                for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="fc" id="L204">                    long a1 = vec.getQuick(k), a2 = vec.getQuick(left);</span>

<span class="fc bfc" id="L206" title="All 2 branches covered.">                    if (a1 &lt; a2) {</span>
<span class="fc" id="L207">                        a2 = a1;</span>
<span class="fc" id="L208">                        a1 = vec.getQuick(left);</span>
                    }
<span class="fc bfc" id="L210" title="All 2 branches covered.">                    while (a1 &lt; vec.getQuick(--k)) {</span>
<span class="fc" id="L211">                        let(vec, k + 2, k);</span>
                    }
<span class="fc" id="L213">                    vec.setQuick(++k + 1, a1);</span>

<span class="fc bfc" id="L215" title="All 2 branches covered.">                    while (a2 &lt; vec.getQuick(--k)) {</span>
<span class="fc" id="L216">                        let(vec, k + 1, k);</span>
                    }
<span class="fc" id="L218">                    vec.setQuick(k + 1, a2);</span>
                }
<span class="fc" id="L220">                long last = vec.getQuick(right);</span>

<span class="fc bfc" id="L222" title="All 2 branches covered.">                while (last &lt; vec.getQuick(--right)) {</span>
<span class="fc" id="L223">                    let(vec, right + 1, right);</span>
                }
<span class="fc" id="L225">                vec.setQuick(right + 1, last);</span>
            }
<span class="fc" id="L227">            return;</span>
        }

        // Inexpensive approximation of length / 7
<span class="fc" id="L231">        int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>

        /*
         * Sort five evenly spaced elements around (and including) the
         * center element in the range. These elements will be used for
         * pivot selection as described below. The choice for spacing
         * these elements was empirically determined to work well on
         * a wide variety of inputs.
         */
<span class="fc" id="L240">        int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="fc" id="L241">        int e2 = e3 - seventh;</span>
<span class="fc" id="L242">        int e1 = e2 - seventh;</span>
<span class="fc" id="L243">        int e4 = e3 + seventh;</span>
<span class="fc" id="L244">        int e5 = e4 + seventh;</span>

        // Sort these elements using insertion sort
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (vec.getQuick(e2) &lt; vec.getQuick(e1)) {</span>
<span class="fc" id="L248">            swap(vec, e2, e1);</span>
        }

<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (vec.getQuick(e3) &lt; vec.getQuick(e2)) {</span>
<span class="fc" id="L252">            long t = vec.getQuick(e3);</span>
<span class="fc" id="L253">            let(vec, e3, e2);</span>
<span class="fc" id="L254">            vec.setQuick(e2, t);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (t &lt; vec.getQuick(e1)) {</span>
<span class="fc" id="L256">                let(vec, e2, e1);</span>
<span class="fc" id="L257">                vec.setQuick(e1, t);</span>
            }
        }
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (vec.getQuick(e4) &lt; vec.getQuick(e3)) {</span>
<span class="fc" id="L261">            long t = vec.getQuick(e4);</span>
<span class="fc" id="L262">            let(vec, e4, e3);</span>
<span class="fc" id="L263">            vec.setQuick(e3, t);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            if (t &lt; vec.getQuick(e2)) {</span>
<span class="fc" id="L265">                let(vec, e3, e2);</span>
<span class="fc" id="L266">                vec.setQuick(e2, t);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (t &lt; vec.getQuick(e1)) {</span>
<span class="fc" id="L268">                    let(vec, e2, e1);</span>
<span class="fc" id="L269">                    vec.setQuick(e1, t);</span>
                }
            }
        }
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (vec.getQuick(e5) &lt; vec.getQuick(e4)) {</span>
<span class="fc" id="L274">            long t = vec.getQuick(e5);</span>
<span class="fc" id="L275">            let(vec, e5, e4);</span>
<span class="fc" id="L276">            vec.setQuick(e4, t);</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (t &lt; vec.getQuick(e3)) {</span>
<span class="fc" id="L278">                let(vec, e4, e3);</span>
<span class="fc" id="L279">                vec.setQuick(e3, t);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                if (t &lt; vec.getQuick(e2)) {</span>
<span class="fc" id="L281">                    let(vec, e3, e2);</span>
<span class="fc" id="L282">                    vec.setQuick(e2, t);</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                    if (t &lt; vec.getQuick(e1)) {</span>
<span class="fc" id="L284">                        let(vec, e2, e1);</span>
<span class="fc" id="L285">                        vec.setQuick(e1, t);</span>
                    }
                }
            }
        }

        // Pointers
<span class="fc" id="L292">        int less = left;  // The index of the first element of center part</span>
<span class="fc" id="L293">        int great = right; // The index before the first element of right part</span>

<span class="pc bpc" id="L295" title="4 of 8 branches missed.">        if (vec.getQuick(e1) != vec.getQuick(e2) &amp;&amp; vec.getQuick(e2) != vec.getQuick(e3) &amp;&amp; vec.getQuick(e3) != vec.getQuick(e4) &amp;&amp; vec.getQuick(e4) != vec.getQuick(e5)) {</span>
            /*
             * Use the second and fourth of the five sorted elements as pivots.
             * These values are inexpensive approximations of the first and
             * second terciles of the array. Note that pivot1 &lt;= pivot2.
             */
<span class="fc" id="L301">            long pivot1 = vec.getQuick(e2);</span>
<span class="fc" id="L302">            long pivot2 = vec.getQuick(e4);</span>

            /*
             * The first and the last elements to be sorted are moved to the
             * locations formerly occupied by the pivots. When partitioning
             * is complete, the pivots are swapped back into their final
             * positions, and excluded from subsequent sorting.
             */
<span class="fc" id="L310">            let(vec, e2, left);</span>
<span class="fc" id="L311">            let(vec, e4, right);</span>

            /*
             * Skip elements, which are less or greater than pivot values.
             */
            //noinspection StatementWithEmptyBody
<span class="fc bfc" id="L317" title="All 2 branches covered.">            while (vec.getQuick(++less) &lt; pivot1) ;</span>
            //noinspection StatementWithEmptyBody
<span class="fc bfc" id="L319" title="All 2 branches covered.">            while (vec.getQuick(--great) &gt; pivot2) ;</span>

            /*
             * Partitioning:
             *
             *   left part           center part                   right part
             * +--------------------------------------------------------------+
             * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              less                        k     great
             *
             * Invariants:
             *
             *              all in (left, less)   &lt; pivot1
             *    pivot1 &lt;= all in [less, k)     &lt;= pivot2
             *              all in (great, right) &gt; pivot2
             *
             * Pointer k is the first index of ?-part.
             */
            outer:
<span class="fc bfc" id="L341" title="All 2 branches covered.">            for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="fc" id="L342">                long ak = vec.getQuick(k);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">                if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="fc" id="L344">                    let(vec, k, less);</span>
                    /*
                     * Here and below we use &quot;a[i] = b; i++;&quot; instead
                     * of &quot;a[i++] = b;&quot; due to performance issue.
                     */
<span class="fc" id="L349">                    vec.setQuick(less, ak);</span>
<span class="fc" id="L350">                    ++less;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                    while (vec.getQuick(great) &gt; pivot2) {</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">                        if (great-- == k) {</span>
<span class="fc" id="L354">                            break outer;</span>
                        }
                    }
<span class="fc bfc" id="L357" title="All 2 branches covered.">                    if (vec.getQuick(great) &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="fc" id="L358">                        let(vec, k, less);</span>
<span class="fc" id="L359">                        let(vec, less, great);</span>
<span class="fc" id="L360">                        ++less;</span>
                    } else { // pivot1 &lt;= a[great] &lt;= pivot2
<span class="fc" id="L362">                        let(vec, k, great);</span>
                    }
                    /*
                     * Here and below we use &quot;a[i] = b; i--;&quot; instead
                     * of &quot;a[i--] = b;&quot; due to performance issue.
                     */
<span class="fc" id="L368">                    vec.setQuick(great, ak);</span>
<span class="fc" id="L369">                    --great;</span>
                }
<span class="fc" id="L371">            }</span>

            // Swap pivots into their final positions
<span class="fc" id="L374">            let(vec, left, less - 1);</span>
<span class="fc" id="L375">            vec.setQuick(less - 1, pivot1);</span>
<span class="fc" id="L376">            let(vec, right, great + 1);</span>
<span class="fc" id="L377">            vec.setQuick(great + 1, pivot2);</span>

            // Sort left and right parts recursively, excluding known pivots
<span class="fc" id="L380">            sort(vec, left, less - 2, leftmost);</span>
<span class="fc" id="L381">            sort(vec, great + 2, right, false);</span>

            /*
             * If center part is too large (comprises &gt; 4/7 of the array),
             * swap internal pivot values to ends.
             */
<span class="fc bfc" id="L387" title="All 4 branches covered.">            if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
                /*
                 * Skip elements, which are equal to pivot values.
                 */
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                while (vec.getQuick(less) == pivot1) {</span>
<span class="nc" id="L392">                    ++less;</span>
                }

<span class="pc bpc" id="L395" title="1 of 2 branches missed.">                while (vec.getQuick(great) == pivot2) {</span>
<span class="nc" id="L396">                    --great;</span>
                }

                /*
                 * Partitioning:
                 *
                 *   left part         center part                  right part
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             less                      k     great
                 *
                 * Invariants:
                 *
                 *              all in (*,  less) == pivot1
                 *     pivot1 &lt; all in [less,  k)  &lt; pivot2
                 *              all in (great, *) == pivot2
                 *
                 * Pointer k is the first index of ?-part.
                 */
                outer:
<span class="fc bfc" id="L419" title="All 2 branches covered.">                for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="fc" id="L420">                    long ak = vec.getQuick(k);</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">                    if (ak == pivot1) { // Move a[k] to left part</span>
<span class="nc" id="L422">                        let(vec, k, less);</span>
<span class="nc" id="L423">                        vec.setQuick(less, ak);</span>
<span class="nc" id="L424">                        ++less;</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">                    } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">                        while (vec.getQuick(great) == pivot2) {</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                            if (great-- == k) {</span>
<span class="nc" id="L428">                                break outer;</span>
                            }
                        }
<span class="nc bnc" id="L431" title="All 2 branches missed.">                        if (vec.getQuick(great) == pivot1) { // a[great] &lt; pivot2</span>
<span class="nc" id="L432">                            let(vec, k, less);</span>
                            /*
                             * Even though a[great] equals to pivot1, the
                             * assignment a[less] = pivot1 may be incorrect,
                             * if a[great] and pivot1 are floating-point zeros
                             * of different signs. Therefore in float and
                             * double sorting methods we have to use more
                             * accurate assignment a[less] = a[great].
                             */
<span class="nc" id="L441">                            vec.setQuick(less, pivot1);</span>
<span class="nc" id="L442">                            ++less;</span>
                        } else { // pivot1 &lt; a[great] &lt; pivot2
<span class="nc" id="L444">                            let(vec, k, great);</span>
                        }
<span class="nc" id="L446">                        vec.setQuick(great, ak);</span>
<span class="nc" id="L447">                        --great;</span>
                    }
<span class="fc" id="L449">                }</span>
            }

            // Sort center part recursively
<span class="fc" id="L453">            sort(vec, less, great, false);</span>

<span class="fc" id="L455">        } else { // Partitioning with one pivot</span>
            /*
             * Use the third of the five sorted elements as pivot.
             * This value is inexpensive approximation of the median.
             */
<span class="nc" id="L460">            long pivot = vec.getQuick(e3);</span>

            /*
             * Partitioning degenerates to the traditional 3-way
             * (or &quot;Dutch National Flag&quot;) schema:
             *
             *   left part    center part              right part
             * +-------------------------------------------------+
             * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             less            k      great
             *
             * Invariants:
             *
             *   all in (left, less)   &lt; pivot
             *   all in [less, k)     == pivot
             *   all in (great, right) &gt; pivot
             *
             * Pointer k is the first index of ?-part.
             */
<span class="nc bnc" id="L482" title="All 2 branches missed.">            for (int k = less; k &lt;= great; ++k) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                if (vec.getQuick(k) == pivot) {</span>
<span class="nc" id="L484">                    continue;</span>
                }
<span class="nc" id="L486">                long ak = vec.getQuick(k);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="nc" id="L488">                    let(vec, k, less);</span>
<span class="nc" id="L489">                    vec.setQuick(less, ak);</span>
<span class="nc" id="L490">                    ++less;</span>
                } else { // a[k] &gt; pivot - Move a[k] to right part
<span class="nc bnc" id="L492" title="All 2 branches missed.">                    while (vec.getQuick(great) &gt; pivot) {</span>
<span class="nc" id="L493">                        --great;</span>
                    }
<span class="nc bnc" id="L495" title="All 2 branches missed.">                    if (vec.getQuick(great) &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="nc" id="L496">                        let(vec, k, less);</span>
<span class="nc" id="L497">                        let(vec, less, great);</span>
<span class="nc" id="L498">                        ++less;</span>
                    } else { // a[great] == pivot
                        /*
                         * Even though a[great] equals to pivot, the
                         * assignment a[k] = pivot may be incorrect,
                         * if a[great] and pivot are floating-point
                         * zeros of different signs. Therefore in float
                         * and double sorting methods we have to use
                         * more accurate assignment a[k] = a[great].
                         */
<span class="nc" id="L508">                        vec.setQuick(k, pivot);</span>
                    }
<span class="nc" id="L510">                    vec.setQuick(great, ak);</span>
<span class="nc" id="L511">                    --great;</span>
                }
            }

            /*
             * Sort left and right parts recursively.
             * All elements from center part are equal
             * and, therefore, already sorted.
             */
<span class="nc" id="L520">            sort(vec, left, less - 1, leftmost);</span>
<span class="nc" id="L521">            sort(vec, great + 1, right, false);</span>
        }
<span class="fc" id="L523">    }</span>

    private static void swap(LongVec vec, int a, int b) {
<span class="fc" id="L526">        long tmp = vec.getQuick(a);</span>
<span class="fc" id="L527">        vec.setQuick(a, vec.getQuick(b));</span>
<span class="fc" id="L528">        vec.setQuick(b, tmp);</span>
<span class="fc" id="L529">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>