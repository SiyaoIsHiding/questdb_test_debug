<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AsyncFilteredNegativeLimitRecordCursor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.engine.table</a> &gt; <span class="el_source">AsyncFilteredNegativeLimitRecordCursor.java</span></div><h1>AsyncFilteredNegativeLimitRecordCursor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.engine.table;

import io.questdb.cairo.sql.PageAddressCacheRecord;
import io.questdb.cairo.sql.Record;
import io.questdb.cairo.sql.RecordCursor;
import io.questdb.cairo.sql.SymbolTable;
import io.questdb.cairo.sql.async.PageFrameReduceTask;
import io.questdb.cairo.sql.async.PageFrameSequence;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.DirectLongList;
import io.questdb.std.Misc;
import io.questdb.std.Os;
import io.questdb.std.Rows;

/**
 * Used to handle the LIMIT -N clause with the descending timestamp order case. To do so, this cursor
 * accumulates the row ids in a buffer and only then starts the iteration. That's necessary to preserve
 * the timestamp-based order in the result set. The buffer is filled in from bottom to top.
 * &lt;p&gt;
 * Here is an illustration of the described problem:
 * &lt;pre&gt;
 * row iteration order    frames                      frame iteration order
 *         |            [ row 0   &lt;- frame 0 start           /\
 *         |              row 1                              |
 *         |              row 2 ] &lt;- frame 0 end             |
 *         |            [ row 3   &lt;- frame 1 start           |
 *        \/              row 4 ] &lt;- frame 1 end             |
 * &lt;/pre&gt;
 */
class AsyncFilteredNegativeLimitRecordCursor implements RecordCursor {

<span class="fc" id="L57">    private static final Log LOG = LogFactory.getLog(AsyncFilteredNegativeLimitRecordCursor.class);</span>

    private final PageAddressCacheRecord record;
    private int frameIndex;
    private int frameLimit;
    private PageFrameSequence&lt;?&gt; frameSequence;
    private PageAddressCacheRecord recordB;
    private long rowCount;
    private long rowIndex;
    // Artificial limit on remaining rows to be returned from this cursor.
    // It is typically copied from LIMIT clause on SQL statement.
    private long rowLimit;
    // Buffer used to accumulate all filtered row ids.
    private DirectLongList rows;

<span class="fc" id="L72">    public AsyncFilteredNegativeLimitRecordCursor() {</span>
<span class="fc" id="L73">        this.record = new PageAddressCacheRecord();</span>
<span class="fc" id="L74">    }</span>

    @Override
    public void close() {
<span class="fc" id="L78">        LOG.debug()</span>
<span class="fc" id="L79">                .$(&quot;closing [shard=&quot;).$(frameSequence.getShard())</span>
<span class="fc" id="L80">                .$(&quot;, frameCount=&quot;).$(frameLimit)</span>
<span class="fc" id="L81">                .I$();</span>

<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (frameLimit &gt; -1) {</span>
<span class="fc" id="L84">            frameSequence.await();</span>
        }
<span class="fc" id="L86">        frameSequence.clear();</span>
<span class="fc" id="L87">    }</span>

    public void freeRecords() {
<span class="fc" id="L90">        Misc.free(record);</span>
<span class="fc" id="L91">        Misc.free(recordB);</span>
<span class="fc" id="L92">    }</span>

    @Override
    public Record getRecord() {
<span class="fc" id="L96">        return record;</span>
    }

    @Override
    public Record getRecordB() {
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (recordB != null) {</span>
<span class="fc" id="L102">            return recordB;</span>
        }
<span class="fc" id="L104">        recordB = new PageAddressCacheRecord(record);</span>
<span class="fc" id="L105">        return recordB;</span>
    }

    @Override
    public SymbolTable getSymbolTable(int columnIndex) {
<span class="fc" id="L110">        return frameSequence.getSymbolTableSource().getSymbolTable(columnIndex);</span>
    }

    @Override
    public boolean hasNext() {
        // check for the first hasNext call
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (frameIndex == -1) {</span>
<span class="fc" id="L117">            fetchAllFrames();</span>
        }
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (rowIndex &lt; rows.getCapacity()) {</span>
<span class="fc" id="L120">            long rowId = rows.get(rowIndex);</span>
<span class="fc" id="L121">            record.setRowIndex(Rows.toLocalRowID(rowId));</span>
<span class="fc" id="L122">            record.setFrameIndex(Rows.toPartitionIndex(rowId));</span>
<span class="fc" id="L123">            rowIndex++;</span>
<span class="fc" id="L124">            return true;</span>
        }
<span class="fc" id="L126">        return false;</span>
    }

    @Override
    public SymbolTable newSymbolTable(int columnIndex) {
<span class="fc" id="L131">        return frameSequence.getSymbolTableSource().newSymbolTable(columnIndex);</span>
    }

    @Override
    public void recordAt(Record record, long atRowId) {
<span class="fc" id="L136">        ((PageAddressCacheRecord) record).setFrameIndex(Rows.toPartitionIndex(atRowId));</span>
<span class="fc" id="L137">        ((PageAddressCacheRecord) record).setRowIndex(Rows.toLocalRowID(atRowId));</span>
<span class="fc" id="L138">    }</span>

    @Override
    public long size() {
<span class="fc" id="L142">        return rowCount;</span>
    }

    @Override
    public void toTop() {
<span class="fc" id="L147">        rowIndex = rows.getCapacity() - rowCount;</span>
<span class="fc" id="L148">    }</span>

    private void fetchAllFrames() {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (frameLimit == -1) {</span>
<span class="fc" id="L152">            frameSequence.prepareForDispatch();</span>
<span class="fc" id="L153">            frameLimit = frameSequence.getFrameCount() - 1;</span>
        }

        do {
<span class="fc" id="L157">            final long cursor = frameSequence.next();</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">            if (cursor &gt; -1) {</span>
<span class="fc" id="L159">                PageFrameReduceTask task = frameSequence.getTask(cursor);</span>
<span class="fc" id="L160">                LOG.debug()</span>
<span class="fc" id="L161">                        .$(&quot;collected [shard=&quot;).$(frameSequence.getShard())</span>
<span class="fc" id="L162">                        .$(&quot;, frameIndex=&quot;).$(task.getFrameIndex())</span>
<span class="fc" id="L163">                        .$(&quot;, frameCount=&quot;).$(frameSequence.getFrameCount())</span>
<span class="fc" id="L164">                        .$(&quot;, active=&quot;).$(frameSequence.isActive())</span>
<span class="fc" id="L165">                        .$(&quot;, cursor=&quot;).$(cursor)</span>
<span class="fc" id="L166">                        .I$();</span>

<span class="fc" id="L168">                final DirectLongList frameRows = task.getRows();</span>
<span class="fc" id="L169">                final long frameRowCount = frameRows.size();</span>
<span class="fc" id="L170">                frameIndex = task.getFrameIndex();</span>

<span class="pc bpc" id="L172" title="1 of 6 branches missed.">                if (frameRowCount &gt; 0 &amp;&amp; rowCount &lt; rowLimit + 1 &amp;&amp; frameSequence.isActive()) {</span>
                    // Copy rows into the buffer.
<span class="fc bfc" id="L174" title="All 4 branches covered.">                    for (long i = frameRowCount - 1; i &gt; -1 &amp;&amp; rowCount &lt; rowLimit; i--, rowCount++) {</span>
<span class="fc" id="L175">                        rows.set(--rowIndex, Rows.toRowID(frameIndex, frameRows.get(i)));</span>
                    }

<span class="fc bfc" id="L178" title="All 2 branches covered.">                    if (rowCount &gt;= rowLimit) {</span>
<span class="fc" id="L179">                        frameSequence.cancel();</span>
                    }
                }

<span class="fc" id="L183">                frameSequence.collect(cursor, false);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            } else if (cursor == -2) {</span>
<span class="fc" id="L185">                break; // No frames to filter.</span>
            } else {
<span class="fc" id="L187">                Os.pause();</span>
            }
<span class="fc bfc" id="L189" title="All 2 branches covered.">        } while (frameIndex &lt; frameLimit);</span>
<span class="fc" id="L190">    }</span>

    void of(PageFrameSequence&lt;?&gt; frameSequence, long rowLimit, DirectLongList negativeLimitRows) {
<span class="fc" id="L193">        this.frameSequence = frameSequence;</span>
<span class="fc" id="L194">        frameIndex = -1;</span>
<span class="fc" id="L195">        frameLimit = -1;</span>
<span class="fc" id="L196">        this.rowLimit = rowLimit;</span>
<span class="fc" id="L197">        rows = negativeLimitRows;</span>
<span class="fc" id="L198">        rowIndex = negativeLimitRows.getCapacity();</span>
<span class="fc" id="L199">        rowCount = 0;</span>
<span class="fc" id="L200">        record.of(frameSequence.getSymbolTableSource(), frameSequence.getPageAddressCache());</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (recordB != null) {</span>
<span class="fc" id="L202">            recordB.of(frameSequence.getSymbolTableSource(), frameSequence.getPageAddressCache());</span>
        }
<span class="fc" id="L204">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>