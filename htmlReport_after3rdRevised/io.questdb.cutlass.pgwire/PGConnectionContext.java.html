<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PGConnectionContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.pgwire</a> &gt; <span class="el_source">PGConnectionContext.java</span></div><h1>PGConnectionContext.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.pgwire;

import io.questdb.TelemetryOrigin;
import io.questdb.cairo.*;
import io.questdb.cairo.pool.WriterSource;
import io.questdb.cairo.security.AllowAllCairoSecurityContext;
import io.questdb.cairo.sql.Record;
import io.questdb.cairo.sql.*;
import io.questdb.cutlass.text.TextLoader;
import io.questdb.cutlass.text.types.TypeManager;
import io.questdb.griffin.*;
import io.questdb.griffin.engine.functions.bind.BindVariableServiceImpl;
import io.questdb.griffin.engine.ops.UpdateOperation;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.mp.SCSequence;
import io.questdb.network.*;
import io.questdb.std.*;
import io.questdb.std.datetime.microtime.TimestampFormatUtils;
import io.questdb.std.str.*;
import org.jetbrains.annotations.Nullable;

import java.util.Iterator;

import static io.questdb.cairo.sql.OperationFuture.QUERY_COMPLETE;
import static io.questdb.cutlass.pgwire.PGOids.*;
import static io.questdb.std.datetime.millitime.DateFormatUtils.PG_DATE_MILLI_TIME_Z_PRINT_FORMAT;

/**
 * Useful PostgreSQL documentation links:&lt;br&gt;
 * &lt;a href=&quot;https://www.postgresql.org/docs/current/protocol-flow.html&quot;&gt;Wire protocol&lt;/a&gt;&lt;br&gt;
 * &lt;a href=&quot;https://www.postgresql.org/docs/current/protocol-message-formats.html&quot;&gt;Message formats&lt;/a&gt;
 */
public class PGConnectionContext extends AbstractMutableIOContext&lt;PGConnectionContext&gt; implements WriterSource {

    public static final char STATUS_IDLE = 'I';
    public static final char STATUS_IN_ERROR = 'E';
    public static final char STATUS_IN_TRANSACTION = 'T';
    public static final String TAG_BEGIN = &quot;BEGIN&quot;;
    public static final String TAG_COMMIT = &quot;COMMIT&quot;;
    public static final String TAG_COPY = &quot;COPY&quot;;
    // create as select tag
    public static final String TAG_CTAS = &quot;CTAS&quot;;
    public static final String TAG_DEALLOCATE = &quot;DEALLOCATE&quot;;
    public static final String TAG_EXPLAIN = &quot;EXPLAIN&quot;;
    public static final String TAG_INSERT = &quot;INSERT&quot;;
    public static final String TAG_OK = &quot;OK&quot;;
    public static final String TAG_ROLLBACK = &quot;ROLLBACK&quot;;
    public static final String TAG_SELECT = &quot;SELECT&quot;;
    public static final String TAG_SET = &quot;SET&quot;;
    public static final String TAG_UPDATE = &quot;UPDATE&quot;;
    private static final int COMMIT_TRANSACTION = 2;
    private static final int ERROR_TRANSACTION = 3;
    private static final int INIT_CANCEL_REQUEST = 80877102;
    private static final int INIT_GSS_REQUEST = 80877104;
    private static final int INIT_SSL_REQUEST = 80877103;
    private static final int INIT_STARTUP_MESSAGE = 196608;
<span class="fc" id="L82">    private static final int INT_BYTES_X = Numbers.bswap(Integer.BYTES);</span>
<span class="fc" id="L83">    private static final int INT_NULL_X = Numbers.bswap(-1);</span>
    private static final int IN_TRANSACTION = 1;
<span class="fc" id="L85">    private final static Log LOG = LogFactory.getLog(PGConnectionContext.class);</span>
    private static final byte MESSAGE_TYPE_BIND_COMPLETE = '2';
    private static final byte MESSAGE_TYPE_CLOSE_COMPLETE = '3';
    private static final byte MESSAGE_TYPE_COMMAND_COMPLETE = 'C';
    private static final byte MESSAGE_TYPE_COPY_IN_RESPONSE = 'G';
    private static final byte MESSAGE_TYPE_DATA_ROW = 'D';
    private static final byte MESSAGE_TYPE_EMPTY_QUERY = 'I';
    private static final byte MESSAGE_TYPE_ERROR_RESPONSE = 'E';
    private static final byte MESSAGE_TYPE_LOGIN_RESPONSE = 'R';
    private static final byte MESSAGE_TYPE_NO_DATA = 'n';
    private static final byte MESSAGE_TYPE_PARAMETER_DESCRIPTION = 't';
    private static final byte MESSAGE_TYPE_PARAMETER_STATUS = 'S';
    private static final byte MESSAGE_TYPE_PARSE_COMPLETE = '1';
    private static final byte MESSAGE_TYPE_PORTAL_SUSPENDED = 's';
    private static final byte MESSAGE_TYPE_READY_FOR_QUERY = 'Z';
    private static final byte MESSAGE_TYPE_ROW_DESCRIPTION = 'T';
    private static final int NO_TRANSACTION = 0;
    private static final int PREFIXED_MESSAGE_HEADER_LEN = 5;
    private static final int PROTOCOL_TAIL_COMMAND_LENGTH = 64;
    private static final int ROLLING_BACK_TRANSACTION = 4;
    private static final int SYNC_BIND = 3;
    private static final int SYNC_DESCRIBE = 2;
    private static final int SYNC_DESCRIBE_PORTAL = 4;
    private static final int SYNC_PARSE = 1;
    private static final String WRITER_LOCK_REASON = &quot;pgConnection&quot;;
    private final PGAuthenticator authenticator;
    private final BatchCallback batchCallback;
    private final ObjectPool&lt;DirectBinarySequence&gt; binarySequenceParamsPool;
    //stores result format codes (0=Text,1=Binary) from the latest bind message
    //we need it in case cursor gets invalidated and bind used non-default binary format for some column(s)
    //pg clients (like asyncpg) fail when format sent by server is not the same as requested in bind message
    private final IntList bindSelectColumnFormats;
<span class="fc" id="L117">    private final IntList bindVariableTypes = new IntList();</span>
    private final CharacterStore characterStore;
    private final NetworkSqlExecutionCircuitBreaker circuitBreaker;
<span class="fc" id="L120">    private final DirectByteCharSequence dbcs = new DirectByteCharSequence();</span>
    private final boolean dumpNetworkTraffic;
    private final CairoEngine engine;
    private final int maxBlobSizeOnQuery;
    private final CharSequenceObjHashMap&lt;Portal&gt; namedPortalMap;
    private final WeakMutableObjectPool&lt;Portal&gt; namedPortalPool;
    private final CharSequenceObjHashMap&lt;NamedStatementWrapper&gt; namedStatementMap;
    private final WeakMutableObjectPool&lt;NamedStatementWrapper&gt; namedStatementWrapperPool;
    private final NetworkFacade nf;
<span class="fc" id="L129">    private final Path path = new Path();</span>
    private final ObjObjHashMap&lt;TableToken, TableWriterAPI&gt; pendingWriters;
    private final int recvBufferSize;
<span class="fc" id="L132">    private final ResponseAsciiSink responseAsciiSink = new ResponseAsciiSink();</span>
    @Nullable
    private final PGAuthenticator roUserAuthenticator;
<span class="fc" id="L135">    private final IntList selectColumnTypes = new IntList();</span>
    private final int sendBufferSize;
    private final String serverVersion;
<span class="fc" id="L138">    private final IntList syncActions = new IntList(4);</span>
<span class="fc" id="L139">    private final SCSequence tempSequence = new SCSequence();</span>
    private final TypeManager typeManager;
    private final AssociativeCache&lt;TypesAndInsert&gt; typesAndInsertCache;
    private final WeakSelfReturningObjectPool&lt;TypesAndInsert&gt; typesAndInsertPool;
    private final DirectCharSink utf8Sink;
    // this is a reference to types either from the context or named statement, where it is provided
    private IntList activeBindVariableTypes;
    //list of pair: column types (with format flag stored in first bit) AND additional type flag
    private IntList activeSelectColumnTypes;
<span class="fc" id="L148">    private boolean authenticationRequired = true;</span>
    private BindVariableService bindVariableService;
<span class="fc" id="L150">    private int bufferRemainingOffset = 0;</span>
<span class="fc" id="L151">    private int bufferRemainingSize = 0;</span>
<span class="fc" id="L152">    private boolean completed = true;</span>
<span class="fc" id="L153">    private RecordCursor currentCursor = null;</span>
<span class="fc" id="L154">    private RecordCursorFactory currentFactory = null;</span>
<span class="fc" id="L155">    private boolean isEmptyQuery = false;</span>
<span class="fc" id="L156">    private boolean isPausedQuery = false;</span>
    private long maxRows;
    private int parsePhaseBindVariableCount;
    //command tag used when returning row count to client,
    //see CommandComplete (B) at https://www.postgresql.org/docs/current/protocol-message-formats.html
    private CharSequence queryTag;
    private CharSequence queryText;
    private long recvBuffer;
<span class="fc" id="L164">    private long recvBufferReadOffset = 0;</span>
<span class="fc" id="L165">    private long recvBufferWriteOffset = 0;</span>
<span class="fc" id="L166">    private boolean requireInitialMessage = true;</span>
    private PGResumeProcessor resumeProcessor;
    private Rnd rnd;
    private long rowCount;
    private long sendBuffer;
    private long sendBufferLimit;
    private long sendBufferPtr;
<span class="fc" id="L173">    private final PGResumeProcessor resumeCommandCompleteRef = this::resumeCommandComplete;</span>
    private boolean sendParameterDescription;
<span class="fc" id="L175">    private boolean sendRNQ = true;</span>
    private SqlExecutionContextImpl sqlExecutionContext;
<span class="fc" id="L177">    private long statementTimeout = -1L;</span>
    private SuspendEvent suspendEvent;
<span class="fc" id="L179">    private long totalReceived = 0;</span>
<span class="fc" id="L180">    private int transactionState = NO_TRANSACTION;</span>
<span class="fc" id="L181">    private final PGResumeProcessor resumeQueryCompleteRef = this::resumeQueryComplete;</span>
<span class="fc" id="L182">    private final PGResumeProcessor resumeCursorQueryRef = this::resumeCursorQuery;</span>
<span class="fc" id="L183">    private TypesAndInsert typesAndInsert = null;</span>
    // these references are held by context only for a period of processing single request
    // in PF world this request can span multiple messages, but still, only for one request
    // the rationale is to be able to return &quot;selectAndTypes&quot; instance to thread-local
    // cache, which is &quot;typesAndSelectCache&quot;. We typically do this after query results are
    // served to client or query errored out due to network issues
<span class="fc" id="L189">    private TypesAndSelect typesAndSelect = null;</span>
    private AssociativeCache&lt;TypesAndSelect&gt; typesAndSelectCache;
<span class="fc" id="L191">    private boolean typesAndSelectIsCached = true;</span>
    private WeakSelfReturningObjectPool&lt;TypesAndSelect&gt; typesAndSelectPool;
<span class="fc" id="L193">    private TypesAndUpdate typesAndUpdate = null;</span>
    private AssociativeCache&lt;TypesAndUpdate&gt; typesAndUpdateCache;
<span class="fc" id="L195">    private boolean typesAndUpdateIsCached = false;</span>
<span class="fc" id="L196">    private final PGResumeProcessor resumeCursorExecuteRef = this::resumeCursorExecute;</span>
    private WeakSelfReturningObjectPool&lt;TypesAndUpdate&gt; typesAndUpdatePool;
    private CharSequence username;
    private NamedStatementWrapper wrapper;

<span class="fc" id="L201">    public PGConnectionContext(CairoEngine engine, PGWireConfiguration configuration, SqlExecutionContextImpl sqlExecutionContext) {</span>
<span class="fc" id="L202">        this.engine = engine;</span>
<span class="fc" id="L203">        this.utf8Sink = new DirectCharSink(engine.getConfiguration().getTextConfiguration().getUtf8SinkSize());</span>
<span class="fc" id="L204">        this.typeManager = new TypeManager(engine.getConfiguration().getTextConfiguration(), utf8Sink);</span>
<span class="fc" id="L205">        this.nf = configuration.getNetworkFacade();</span>
<span class="fc" id="L206">        this.bindVariableService = new BindVariableServiceImpl(engine.getConfiguration());</span>
<span class="fc" id="L207">        this.recvBufferSize = Numbers.ceilPow2(configuration.getRecvBufferSize());</span>
<span class="fc" id="L208">        this.sendBufferSize = Numbers.ceilPow2(configuration.getSendBufferSize());</span>
<span class="fc" id="L209">        this.characterStore = new CharacterStore(</span>
<span class="fc" id="L210">                configuration.getCharacterStoreCapacity(),</span>
<span class="fc" id="L211">                configuration.getCharacterStorePoolCapacity()</span>
        );
<span class="fc" id="L213">        this.maxBlobSizeOnQuery = configuration.getMaxBlobSizeOnQuery();</span>
<span class="fc" id="L214">        this.dumpNetworkTraffic = configuration.getDumpNetworkTraffic();</span>
<span class="fc" id="L215">        this.serverVersion = configuration.getServerVersion();</span>
<span class="fc" id="L216">        this.authenticator = new PGBasicAuthenticator(configuration.getDefaultUsername(), configuration.getDefaultPassword(), configuration.readOnlySecurityContext());</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        this.roUserAuthenticator = configuration.isReadOnlyUserEnabled()</span>
<span class="fc" id="L218">                ? new PGBasicAuthenticator(configuration.getReadOnlyUsername(), configuration.getReadOnlyPassword(), true)</span>
<span class="fc" id="L219">                : null;</span>
<span class="fc" id="L220">        this.sqlExecutionContext = sqlExecutionContext;</span>
<span class="fc" id="L221">        this.sqlExecutionContext.setRandom(this.rnd = configuration.getRandom());</span>
<span class="fc" id="L222">        this.namedStatementWrapperPool = new WeakMutableObjectPool&lt;&gt;(NamedStatementWrapper::new, configuration.getNamesStatementPoolCapacity()); // 32</span>
<span class="fc" id="L223">        this.namedPortalPool = new WeakMutableObjectPool&lt;&gt;(Portal::new, configuration.getNamesStatementPoolCapacity()); // 32</span>
<span class="fc" id="L224">        this.namedStatementMap = new CharSequenceObjHashMap&lt;&gt;(configuration.getNamedStatementCacheCapacity());</span>
<span class="fc" id="L225">        this.pendingWriters = new ObjObjHashMap&lt;&gt;(configuration.getPendingWritersCacheSize());</span>
<span class="fc" id="L226">        this.namedPortalMap = new CharSequenceObjHashMap&lt;&gt;(configuration.getNamedStatementCacheCapacity());</span>
<span class="fc" id="L227">        this.binarySequenceParamsPool = new ObjectPool&lt;&gt;(DirectBinarySequence::new, configuration.getBinParamCountCapacity());</span>
<span class="fc" id="L228">        this.circuitBreaker = new NetworkSqlExecutionCircuitBreaker(configuration.getCircuitBreakerConfiguration(), MemoryTag.NATIVE_CB5);</span>
<span class="fc" id="L229">        this.typesAndInsertPool = new WeakSelfReturningObjectPool&lt;&gt;(TypesAndInsert::new, configuration.getInsertPoolCapacity()); // 64</span>
<span class="fc" id="L230">        final boolean enableInsertCache = configuration.isInsertCacheEnabled();</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        final int insertBlockCount = enableInsertCache ? configuration.getInsertCacheBlockCount() : 1; // 8</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        final int insertRowCount = enableInsertCache ? configuration.getInsertCacheRowCount() : 1; // 8</span>
<span class="fc" id="L233">        this.typesAndInsertCache = new AssociativeCache&lt;&gt;(insertBlockCount, insertRowCount);</span>
<span class="fc" id="L234">        this.batchCallback = new PGConnectionBatchCallback();</span>
<span class="fc" id="L235">        this.bindSelectColumnFormats = new IntList();</span>
<span class="fc" id="L236">        this.queryTag = TAG_OK;</span>
<span class="fc" id="L237">    }</span>

    public static int getInt(long address, long msgLimit, CharSequence errorMessage) throws BadProtocolException {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (address + Integer.BYTES &lt;= msgLimit) {</span>
<span class="fc" id="L241">            return getIntUnsafe(address);</span>
        }
<span class="nc" id="L243">        LOG.error().$(errorMessage).$();</span>
<span class="nc" id="L244">        throw BadProtocolException.INSTANCE;</span>
    }

    public static long getLongUnsafe(long address) {
<span class="fc" id="L248">        return Numbers.bswap(Unsafe.getUnsafe().getLong(address));</span>
    }

    public static short getShort(long address, long msgLimit, CharSequence errorMessage) throws BadProtocolException {
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (address + Short.BYTES &lt;= msgLimit) {</span>
<span class="fc" id="L253">            return getShortUnsafe(address);</span>
        }
<span class="fc" id="L255">        LOG.error().$(errorMessage).$();</span>
<span class="fc" id="L256">        throw BadProtocolException.INSTANCE;</span>
    }

    public static long getStringLength(
            long x,
            long limit,
            CharSequence errorMessage
    ) throws BadProtocolException {
<span class="fc bfc" id="L264" title="All 2 branches covered.">        long len = Unsafe.getUnsafe().getByte(x) == 0 ? x : getStringLengthTedious(x, limit);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (len &gt; -1) {</span>
<span class="fc" id="L266">            return len;</span>
        }
        // we did not find 0 within message limit
<span class="fc" id="L269">        LOG.error().$(errorMessage).$();</span>
<span class="fc" id="L270">        throw BadProtocolException.INSTANCE;</span>
    }

    public static long getStringLengthTedious(long x, long limit) {
        // calculate length
<span class="fc bfc" id="L275" title="All 2 branches covered.">        for (long i = x; i &lt; limit; i++) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            if (Unsafe.getUnsafe().getByte(i) == 0) {</span>
<span class="fc" id="L277">                return i;</span>
            }
        }
<span class="fc" id="L280">        return -1;</span>
    }

    public static void putInt(long address, int value) {
<span class="fc" id="L284">        Unsafe.getUnsafe().putInt(address, Numbers.bswap(value));</span>
<span class="fc" id="L285">    }</span>

    public static void putLong(long address, long value) {
<span class="fc" id="L288">        Unsafe.getUnsafe().putLong(address, Numbers.bswap(value));</span>
<span class="fc" id="L289">    }</span>

    public static void putShort(long address, short value) {
<span class="fc" id="L292">        Unsafe.getUnsafe().putShort(address, Numbers.bswap(value));</span>
<span class="fc" id="L293">    }</span>

    @Override
    public void clear() {
<span class="fc" id="L297">        sendBufferPtr = sendBuffer;</span>
<span class="fc" id="L298">        requireInitialMessage = true;</span>
<span class="fc" id="L299">        bufferRemainingOffset = 0;</span>
<span class="fc" id="L300">        bufferRemainingSize = 0;</span>
<span class="fc" id="L301">        responseAsciiSink.reset();</span>
<span class="fc" id="L302">        prepareForNewQuery();</span>
<span class="fc" id="L303">        authenticationRequired = true;</span>
<span class="fc" id="L304">        username = null;</span>
<span class="fc" id="L305">        typeManager.clear();</span>
<span class="fc" id="L306">        clearWriters();</span>
<span class="fc" id="L307">        clearRecvBuffer();</span>
<span class="fc" id="L308">        typesAndInsertCache.clear();</span>
<span class="fc" id="L309">        evictNamedStatementWrappersAndClear();</span>
<span class="fc" id="L310">        namedPortalMap.clear();</span>
<span class="fc" id="L311">        bindVariableService.clear();</span>
<span class="fc" id="L312">        bindVariableTypes.clear();</span>
<span class="fc" id="L313">        binarySequenceParamsPool.clear();</span>
<span class="fc" id="L314">        resumeProcessor = null;</span>
<span class="fc" id="L315">        completed = true;</span>
<span class="fc" id="L316">        clearCursorAndFactory();</span>
<span class="fc" id="L317">        totalReceived = 0;</span>
<span class="fc" id="L318">        typesAndSelectIsCached = true;</span>
<span class="fc" id="L319">        typesAndUpdateIsCached = false;</span>
<span class="fc" id="L320">        statementTimeout = -1L;</span>
<span class="fc" id="L321">        circuitBreaker.resetMaxTimeToDefault();</span>
<span class="fc" id="L322">        circuitBreaker.unsetTimer();</span>
<span class="fc" id="L323">        isPausedQuery = false;</span>
<span class="fc" id="L324">        isEmptyQuery = false;</span>
<span class="fc" id="L325">        clearSuspendEvent();</span>
<span class="fc" id="L326">    }</span>

    @Override
    public void clearSuspendEvent() {
<span class="fc" id="L330">        suspendEvent = Misc.free(suspendEvent);</span>
<span class="fc" id="L331">    }</span>

    public void clearWriters() {
<span class="fc" id="L334">        closePendingWriters(false);</span>
<span class="fc" id="L335">        pendingWriters.clear();</span>
<span class="fc" id="L336">    }</span>

    @Override
    public void close() {
        // We're about to close the context, so no need to return pending factory to cache.
<span class="fc" id="L341">        typesAndSelectIsCached = false;</span>
<span class="fc" id="L342">        typesAndUpdateIsCached = false;</span>
<span class="fc" id="L343">        clear();</span>
<span class="fc" id="L344">        this.fd = -1;</span>
<span class="fc" id="L345">        sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null, -1, null);</span>
<span class="fc" id="L346">        Misc.free(path);</span>
<span class="fc" id="L347">        Misc.free(utf8Sink);</span>
<span class="fc" id="L348">        Misc.free(circuitBreaker);</span>
<span class="fc" id="L349">        freeBuffers();</span>
<span class="fc" id="L350">    }</span>

    @Override
    public SuspendEvent getSuspendEvent() {
<span class="fc" id="L354">        return suspendEvent;</span>
    }

    @Override
    public TableWriterAPI getTableWriterAPI(CairoSecurityContext context, TableToken tableToken, String lockReason) {
<span class="fc" id="L359">        final int index = pendingWriters.keyIndex(tableToken);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L361">            return pendingWriters.valueAt(index);</span>
        }
<span class="fc" id="L363">        return engine.getTableWriterAPI(context, tableToken, lockReason);</span>
    }

    public void handleClientOperation(
            @Transient SqlCompiler compiler,
            @Transient AssociativeCache&lt;TypesAndSelect&gt; selectAndTypesCache,
            @Transient WeakSelfReturningObjectPool&lt;TypesAndSelect&gt; selectAndTypesPool,
            @Transient AssociativeCache&lt;TypesAndUpdate&gt; typesAndUpdateCache,
            @Transient WeakSelfReturningObjectPool&lt;TypesAndUpdate&gt; typesAndUpdatePool,
            int operation
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, PeerIsSlowToWriteException, QueryPausedException, BadProtocolException {

<span class="fc" id="L375">        this.typesAndSelectCache = selectAndTypesCache;</span>
<span class="fc" id="L376">        this.typesAndSelectPool = selectAndTypesPool;</span>
<span class="fc" id="L377">        this.typesAndUpdateCache = typesAndUpdateCache;</span>
<span class="fc" id="L378">        this.typesAndUpdatePool = typesAndUpdatePool;</span>

        try {
<span class="fc bfc" id="L381" title="All 2 branches covered.">            if (isPausedQuery) {</span>
<span class="fc" id="L382">                isPausedQuery = false;</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">                if (resumeProcessor != null) {</span>
<span class="fc" id="L384">                    resumeProcessor.resume(true);</span>
                }
<span class="fc bfc" id="L386" title="All 2 branches covered.">            } else if (bufferRemainingSize &gt; 0) {</span>
<span class="fc" id="L387">                doSend(bufferRemainingOffset, bufferRemainingSize);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">                if (resumeProcessor != null) {</span>
<span class="fc" id="L389">                    resumeProcessor.resume(false);</span>
                }
            }

<span class="fc" id="L393">            boolean keepReceiving = true;</span>
            OUTER:
            do {
<span class="fc bfc" id="L396" title="All 2 branches covered.">                if (operation == IOOperation.READ) {</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">                    if (recv() == 0) {</span>
<span class="nc" id="L398">                        keepReceiving = false;</span>
                    }
                }

                // we do not pre-compute length because 'parse' will mutate 'recvBufferReadOffset'
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">                if (keepReceiving) {</span>
                    do {
                        // Parse will update the value of recvBufferOffset upon completion of
                        // logical block. We cannot count on return value because 'parse' may try to
                        // respond to client and fail with exception. When it does fail we would have
                        // to retry 'send' but not parse the same input again

<span class="fc" id="L410">                        long readOffsetBeforeParse = recvBufferReadOffset;</span>
<span class="fc" id="L411">                        totalReceived += (recvBufferWriteOffset - recvBufferReadOffset);</span>
<span class="fc" id="L412">                        parse(</span>
                                recvBuffer + recvBufferReadOffset,
                                (int) (recvBufferWriteOffset - recvBufferReadOffset),
                                compiler
                        );

                        // nothing changed?
<span class="fc bfc" id="L419" title="All 2 branches covered.">                        if (readOffsetBeforeParse == recvBufferReadOffset) {</span>
                            // shift to start
<span class="fc bfc" id="L421" title="All 2 branches covered.">                            if (readOffsetBeforeParse &gt; 0) {</span>
<span class="fc" id="L422">                                shiftReceiveBuffer(readOffsetBeforeParse);</span>
                            }
                            continue OUTER;
                        }
<span class="fc bfc" id="L426" title="All 2 branches covered.">                    } while (recvBufferReadOffset &lt; recvBufferWriteOffset);</span>
<span class="fc" id="L427">                    clearRecvBuffer();</span>
                }
<span class="pc bpc" id="L429" title="1 of 4 branches missed.">            } while (keepReceiving &amp;&amp; operation == IOOperation.READ);</span>
<span class="fc" id="L430">        } catch (SqlException e) {</span>
<span class="fc" id="L431">            reportNonCriticalError(e.getPosition(), e.getFlyweightMessage());</span>
<span class="fc" id="L432">        } catch (ImplicitCastException e) {</span>
<span class="fc" id="L433">            reportNonCriticalError(-1, e.getFlyweightMessage());</span>
<span class="fc" id="L434">        } catch (CairoException e) {</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">            if (e.isInterruption()) {</span>
<span class="fc" id="L436">                reportQueryCancelled(e.getFlyweightMessage());</span>
            } else {
<span class="fc" id="L438">                reportError(e);</span>
            }
<span class="fc" id="L440">        } catch (AuthenticationException e) {</span>
<span class="fc" id="L441">            prepareNonCriticalError(-1, e.getMessage());</span>
<span class="fc" id="L442">            sendAndReset();</span>
<span class="fc" id="L443">            clearRecvBuffer();</span>
<span class="fc" id="L444">        }</span>
<span class="fc" id="L445">    }</span>

    @Override
    public PGConnectionContext of(int fd, IODispatcher&lt;PGConnectionContext&gt; dispatcher) {
<span class="fc" id="L449">        PGConnectionContext r = super.of(fd, dispatcher);</span>
<span class="fc" id="L450">        sqlExecutionContext.with(fd);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (fd == -1) {</span>
            // The context is about to be returned to the pool, so we should release the memory.
<span class="fc" id="L453">            freeBuffers();</span>
        } else {
            // The context is obtained from the pool, so we should initialize the memory.
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">            if (recvBuffer == 0) {</span>
<span class="fc" id="L457">                this.recvBuffer = Unsafe.malloc(this.recvBufferSize, MemoryTag.NATIVE_PGW_CONN);</span>
            }
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">            if (sendBuffer == 0) {</span>
<span class="fc" id="L460">                this.sendBuffer = Unsafe.malloc(this.sendBufferSize, MemoryTag.NATIVE_PGW_CONN);</span>
<span class="fc" id="L461">                this.sendBufferPtr = sendBuffer;</span>
<span class="fc" id="L462">                this.sendBufferLimit = sendBuffer + sendBufferSize;</span>
            }
        }
<span class="fc" id="L465">        return r;</span>
    }

    public void setBinBindVariable(int index, long address, int valueLen) throws SqlException {
<span class="fc" id="L469">        bindVariableService.setBin(index, this.binarySequenceParamsPool.next().of(address, valueLen));</span>
<span class="fc" id="L470">    }</span>

    public void setBooleanBindVariable(int index, int valueLen) throws SqlException {
<span class="nc bnc" id="L473" title="All 4 branches missed.">        if (valueLen != 4 &amp;&amp; valueLen != 5) {</span>
<span class="nc" id="L474">            throw SqlException.$(0, &quot;bad value for BOOLEAN parameter [index=&quot;).put(index).put(&quot;, valueLen=&quot;).put(valueLen).put(']');</span>
        }
<span class="nc bnc" id="L476" title="All 2 branches missed.">        bindVariableService.setBoolean(index, valueLen == 4);</span>
<span class="nc" id="L477">    }</span>

    public void setCharBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="nc" id="L480">        CharacterStoreEntry e = characterStore.newEntry();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (Chars.utf8Decode(address, address + valueLen, e)) {</span>
<span class="nc" id="L482">            bindVariableService.setChar(index, characterStore.toImmutable().charAt(0));</span>
        } else {
<span class="nc" id="L484">            LOG.error().$(&quot;invalid char UTF8 bytes [index=&quot;).$(index).$(']').$();</span>
<span class="nc" id="L485">            throw BadProtocolException.INSTANCE;</span>
        }
<span class="nc" id="L487">    }</span>

    public void setDateBindVariable(int index, long address, int valueLen) throws SqlException {
<span class="nc" id="L490">        dbcs.of(address, address + valueLen);</span>
<span class="nc" id="L491">        bindVariableService.define(index, ColumnType.DATE, 0);</span>
<span class="nc" id="L492">        bindVariableService.setStr(index, dbcs);</span>
<span class="nc" id="L493">    }</span>

    public void setDoubleBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="fc" id="L496">        ensureValueLength(index, Double.BYTES, valueLen);</span>
<span class="fc" id="L497">        bindVariableService.setDouble(index, Double.longBitsToDouble(getLongUnsafe(address)));</span>
<span class="fc" id="L498">    }</span>

    public void setFloatBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="fc" id="L501">        ensureValueLength(index, Float.BYTES, valueLen);</span>
<span class="fc" id="L502">        bindVariableService.setFloat(index, Float.intBitsToFloat(getIntUnsafe(address)));</span>
<span class="fc" id="L503">    }</span>

    public void setIntBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="fc" id="L506">        ensureValueLength(index, Integer.BYTES, valueLen);</span>
<span class="fc" id="L507">        bindVariableService.setInt(index, getIntUnsafe(address));</span>
<span class="fc" id="L508">    }</span>

    public void setLongBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="fc" id="L511">        ensureValueLength(index, Long.BYTES, valueLen);</span>
<span class="fc" id="L512">        bindVariableService.setLong(index, getLongUnsafe(address));</span>
<span class="fc" id="L513">    }</span>

    public void setShortBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="fc" id="L516">        ensureValueLength(index, Short.BYTES, valueLen);</span>
<span class="fc" id="L517">        bindVariableService.setShort(index, getShortUnsafe(address));</span>
<span class="fc" id="L518">    }</span>

    public void setStrBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="fc" id="L521">        CharacterStoreEntry e = characterStore.newEntry();</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        if (Chars.utf8Decode(address, address + valueLen, e)) {</span>
<span class="fc" id="L523">            bindVariableService.setStr(index, characterStore.toImmutable());</span>
        } else {
<span class="fc" id="L525">            LOG.error().$(&quot;invalid str UTF8 bytes [index=&quot;).$(index).$(']').$();</span>
<span class="fc" id="L526">            throw BadProtocolException.INSTANCE;</span>
        }
<span class="fc" id="L528">    }</span>

    public void setSuspendEvent(SuspendEvent suspendEvent) {
<span class="fc" id="L531">        this.suspendEvent = suspendEvent;</span>
<span class="fc" id="L532">    }</span>

    public void setTimestampBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="fc" id="L535">        ensureValueLength(index, Long.BYTES, valueLen);</span>
<span class="fc" id="L536">        bindVariableService.setTimestamp(index, getLongUnsafe(address) + Numbers.JULIAN_EPOCH_OFFSET_USEC);</span>
<span class="fc" id="L537">    }</span>

    private static void bindParameterFormats(
            long lo,
            long msgLimit,
            short parameterFormatCount,
            IntList bindVariableTypes
    ) throws BadProtocolException {
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">        if (lo + Short.BYTES * parameterFormatCount &lt;= msgLimit) {</span>
<span class="fc" id="L546">            LOG.debug().$(&quot;processing bind formats [count=&quot;).$(parameterFormatCount).$(']').$();</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">            for (int i = 0; i &lt; parameterFormatCount; i++) {</span>
<span class="fc" id="L548">                final short code = getShortUnsafe(lo + i * Short.BYTES);</span>
<span class="fc" id="L549">                bindVariableTypes.setQuick(i, toParamBinaryType(code, bindVariableTypes.getQuick(i)));</span>
            }
        } else {
<span class="nc" id="L552">            LOG.error().$(&quot;invalid format code count [value=&quot;).$(parameterFormatCount).$(']').$();</span>
<span class="nc" id="L553">            throw BadProtocolException.INSTANCE;</span>
        }
<span class="fc" id="L555">    }</span>

    private static void bindSingleFormatForAll(long lo, long msgLimit, IntList activeBindVariableTypes) throws BadProtocolException {
<span class="fc" id="L558">        short code = getShort(lo, msgLimit, &quot;could not read parameter formats&quot;);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">        for (int i = 0, n = activeBindVariableTypes.size(); i &lt; n; i++) {</span>
<span class="fc" id="L560">            activeBindVariableTypes.setQuick(i, toParamBinaryType(code, activeBindVariableTypes.getQuick(i)));</span>
        }
<span class="fc" id="L562">    }</span>

    private static void ensureValueLength(int index, int required, int actual) throws BadProtocolException {
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">        if (required == actual) {</span>
<span class="fc" id="L566">            return;</span>
        }
<span class="nc" id="L568">        LOG.error()</span>
<span class="nc" id="L569">                .$(&quot;bad parameter value length [required=&quot;).$(required)</span>
<span class="nc" id="L570">                .$(&quot;, actual=&quot;).$(actual)</span>
<span class="nc" id="L571">                .$(&quot;, index=&quot;).$(index)</span>
<span class="nc" id="L572">                .I$();</span>
<span class="nc" id="L573">        throw BadProtocolException.INSTANCE;</span>
    }

    private static int getIntUnsafe(long address) {
<span class="fc" id="L577">        return Numbers.bswap(Unsafe.getUnsafe().getInt(address));</span>
    }

    private static short getShortUnsafe(long address) {
<span class="fc" id="L581">        return Numbers.bswap(Unsafe.getUnsafe().getShort(address));</span>
    }

    private static void prepareParams(PGConnectionContext.ResponseAsciiSink sink, String name, String value) {
<span class="fc" id="L585">        sink.put(MESSAGE_TYPE_PARAMETER_STATUS);</span>
<span class="fc" id="L586">        final long addr = sink.skip();</span>
<span class="fc" id="L587">        sink.encodeUtf8Z(name);</span>
<span class="fc" id="L588">        sink.encodeUtf8Z(value);</span>
<span class="fc" id="L589">        sink.putLen(addr);</span>
<span class="fc" id="L590">    }</span>

    private static void setupBindVariables(long lo, IntList bindVariableTypes, int count) {
<span class="fc" id="L593">        bindVariableTypes.setPos(count);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L595">            bindVariableTypes.setQuick(i, Unsafe.getUnsafe().getInt(lo + i * 4L));</span>
        }
<span class="fc" id="L597">    }</span>

    private void appendBinColumn(Record record, int i) throws SqlException {
<span class="fc" id="L600">        BinarySequence sequence = record.getBin(i);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (sequence == null) {</span>
<span class="fc" id="L602">            responseAsciiSink.setNullValue();</span>
        } else {
            // if length is above max we will error out the result set
<span class="fc" id="L605">            long blobSize = sequence.length();</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">            if (blobSize &lt; maxBlobSizeOnQuery) {</span>
<span class="fc" id="L607">                responseAsciiSink.put(sequence);</span>
            } else {
<span class="fc" id="L609">                throw SqlException.position(0)</span>
<span class="fc" id="L610">                        .put(&quot;blob is too large [blobSize=&quot;).put(blobSize)</span>
<span class="fc" id="L611">                        .put(&quot;, max=&quot;).put(maxBlobSizeOnQuery)</span>
<span class="fc" id="L612">                        .put(&quot;, columnIndex=&quot;).put(i)</span>
<span class="fc" id="L613">                        .put(']');</span>
            }
        }
<span class="fc" id="L616">    }</span>

    private void appendBooleanColumn(Record record, int columnIndex) {
<span class="fc" id="L619">        responseAsciiSink.putNetworkInt(Byte.BYTES);</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">        responseAsciiSink.put(record.getBool(columnIndex) ? 't' : 'f');</span>
<span class="fc" id="L621">    }</span>

    private void appendBooleanColumnBin(Record record, int columnIndex) {
<span class="fc" id="L624">        responseAsciiSink.putNetworkInt(Byte.BYTES);</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">        responseAsciiSink.put(record.getBool(columnIndex) ? (byte) 1 : (byte) 0);</span>
<span class="fc" id="L626">    }</span>

    private void appendByteColumn(Record record, int columnIndex) {
<span class="fc" id="L629">        long a = responseAsciiSink.skip();</span>
<span class="fc" id="L630">        responseAsciiSink.put((int) record.getByte(columnIndex));</span>
<span class="fc" id="L631">        responseAsciiSink.putLenEx(a);</span>
<span class="fc" id="L632">    }</span>

    private void appendByteColumnBin(Record record, int columnIndex) {
<span class="fc" id="L635">        final byte value = record.getByte(columnIndex);</span>
<span class="fc" id="L636">        responseAsciiSink.putNetworkInt(Short.BYTES);</span>
<span class="fc" id="L637">        responseAsciiSink.putNetworkShort(value);</span>
<span class="fc" id="L638">    }</span>

    private void appendCharColumn(Record record, int columnIndex) {
<span class="fc" id="L641">        final char charValue = record.getChar(columnIndex);</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (charValue == 0) {</span>
<span class="fc" id="L643">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L645">            long a = responseAsciiSink.skip();</span>
<span class="fc" id="L646">            responseAsciiSink.putUtf8(charValue);</span>
<span class="fc" id="L647">            responseAsciiSink.putLenEx(a);</span>
        }
<span class="fc" id="L649">    }</span>

    private void appendDateColumn(Record record, int columnIndex) {
<span class="fc" id="L652">        final long longValue = record.getDate(columnIndex);</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">        if (longValue != Numbers.LONG_NaN) {</span>
<span class="fc" id="L654">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L655">            PG_DATE_MILLI_TIME_Z_PRINT_FORMAT.format(longValue, null, null, responseAsciiSink);</span>
<span class="fc" id="L656">            responseAsciiSink.putLenEx(a);</span>
<span class="fc" id="L657">        } else {</span>
<span class="fc" id="L658">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L660">    }</span>

    private void appendDateColumnBin(Record record, int columnIndex) {
<span class="fc" id="L663">        final long longValue = record.getLong(columnIndex);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        if (longValue != Numbers.LONG_NaN) {</span>
<span class="fc" id="L665">            responseAsciiSink.putNetworkInt(Long.BYTES);</span>
            // PG epoch starts at 2000 rather than 1970
<span class="fc" id="L667">            responseAsciiSink.putNetworkLong(longValue * 1000 - Numbers.JULIAN_EPOCH_OFFSET_USEC);</span>
        } else {
<span class="fc" id="L669">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L671">    }</span>

    private void appendDoubleColumn(Record record, int columnIndex) {
<span class="fc" id="L674">        final double doubleValue = record.getDouble(columnIndex);</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (doubleValue == doubleValue) {</span>
<span class="fc" id="L676">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L677">            responseAsciiSink.put(doubleValue);</span>
<span class="fc" id="L678">            responseAsciiSink.putLenEx(a);</span>
<span class="fc" id="L679">        } else {</span>
<span class="fc" id="L680">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L682">    }</span>

    private void appendDoubleColumnBin(Record record, int columnIndex) {
<span class="fc" id="L685">        final double value = record.getDouble(columnIndex);</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (value == value) {</span>
<span class="fc" id="L687">            responseAsciiSink.putNetworkInt(Double.BYTES);</span>
<span class="fc" id="L688">            responseAsciiSink.putNetworkDouble(value);</span>
        } else {
<span class="fc" id="L690">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L692">    }</span>

    private void appendFloatColumn(Record record, int columnIndex) {
<span class="fc" id="L695">        final float floatValue = record.getFloat(columnIndex);</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (floatValue == floatValue) {</span>
<span class="fc" id="L697">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L698">            responseAsciiSink.put(floatValue, 3);</span>
<span class="fc" id="L699">            responseAsciiSink.putLenEx(a);</span>
<span class="fc" id="L700">        } else {</span>
<span class="fc" id="L701">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L703">    }</span>

    private void appendFloatColumnBin(Record record, int columnIndex) {
<span class="fc" id="L706">        final float value = record.getFloat(columnIndex);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        if (value == value) {</span>
<span class="fc" id="L708">            responseAsciiSink.putNetworkInt(Float.BYTES);</span>
<span class="fc" id="L709">            responseAsciiSink.putNetworkFloat(value);</span>
        } else {
<span class="fc" id="L711">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L713">    }</span>

    private void appendIntCol(Record record, int i) {
<span class="fc" id="L716">        final int intValue = record.getInt(i);</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">        if (intValue != Numbers.INT_NaN) {</span>
<span class="fc" id="L718">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L719">            responseAsciiSink.put(intValue);</span>
<span class="fc" id="L720">            responseAsciiSink.putLenEx(a);</span>
<span class="fc" id="L721">        } else {</span>
<span class="fc" id="L722">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L724">    }</span>

    private void appendIntColumnBin(Record record, int columnIndex) {
<span class="fc" id="L727">        final int value = record.getInt(columnIndex);</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">        if (value != Numbers.INT_NaN) {</span>
<span class="fc" id="L729">            responseAsciiSink.ensureCapacity(8);</span>
<span class="fc" id="L730">            responseAsciiSink.putIntUnsafe(0, INT_BYTES_X);</span>
<span class="fc" id="L731">            responseAsciiSink.putIntUnsafe(4, Numbers.bswap(value));</span>
<span class="fc" id="L732">            responseAsciiSink.bump(8);</span>
        } else {
<span class="fc" id="L734">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L736">    }</span>

    private void appendLong256Column(Record record, int columnIndex) {
<span class="fc" id="L739">        final Long256 long256Value = record.getLong256A(columnIndex);</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if (long256Value.getLong0() == Numbers.LONG_NaN &amp;&amp;</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">                long256Value.getLong1() == Numbers.LONG_NaN &amp;&amp;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">                long256Value.getLong2() == Numbers.LONG_NaN &amp;&amp;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                long256Value.getLong3() == Numbers.LONG_NaN) {</span>
<span class="nc" id="L744">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L746">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L747">            Numbers.appendLong256(</span>
<span class="fc" id="L748">                    long256Value.getLong0(),</span>
<span class="fc" id="L749">                    long256Value.getLong1(),</span>
<span class="fc" id="L750">                    long256Value.getLong2(),</span>
<span class="fc" id="L751">                    long256Value.getLong3(),</span>
                    responseAsciiSink);
<span class="fc" id="L753">            responseAsciiSink.putLenEx(a);</span>
        }
<span class="fc" id="L755">    }</span>

    private void appendLongColumn(Record record, int columnIndex) {
<span class="fc" id="L758">        final long longValue = record.getLong(columnIndex);</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">        if (longValue != Numbers.LONG_NaN) {</span>
<span class="fc" id="L760">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L761">            responseAsciiSink.put(longValue);</span>
<span class="fc" id="L762">            responseAsciiSink.putLenEx(a);</span>
<span class="fc" id="L763">        } else {</span>
<span class="fc" id="L764">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L766">    }</span>

    private void appendLongColumnBin(Record record, int columnIndex) {
<span class="fc" id="L769">        final long longValue = record.getLong(columnIndex);</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">        if (longValue != Numbers.LONG_NaN) {</span>
<span class="fc" id="L771">            responseAsciiSink.putNetworkInt(Long.BYTES);</span>
<span class="fc" id="L772">            responseAsciiSink.putNetworkLong(longValue);</span>
        } else {
<span class="fc" id="L774">            responseAsciiSink.setNullValue();</span>
        }
<span class="fc" id="L776">    }</span>

    private void appendRecord(Record record, int columnCount) throws SqlException {
<span class="fc" id="L779">        responseAsciiSink.put(MESSAGE_TYPE_DATA_ROW); // data</span>
<span class="fc" id="L780">        final long offset = responseAsciiSink.skip();</span>
<span class="fc" id="L781">        responseAsciiSink.putNetworkShort((short) columnCount);</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L783">            final int type = activeSelectColumnTypes.getQuick(2 * i);</span>
<span class="fc" id="L784">            final short columnBinaryFlag = getColumnBinaryFlag(type);</span>
<span class="fc" id="L785">            final int typeTag = ColumnType.tagOf(type);</span>

<span class="fc" id="L787">            final int tagWithFlag = toColumnBinaryType(columnBinaryFlag, typeTag);</span>
<span class="pc bpc" id="L788" title="1 of 31 branches missed.">            switch (tagWithFlag) {</span>
                case BINARY_TYPE_INT:
<span class="fc" id="L790">                    appendIntColumnBin(record, i);</span>
<span class="fc" id="L791">                    break;</span>
                case ColumnType.INT:
<span class="fc" id="L793">                    appendIntCol(record, i);</span>
<span class="fc" id="L794">                    break;</span>
                case ColumnType.STRING:
                case BINARY_TYPE_STRING:
<span class="fc" id="L797">                    appendStrColumn(record, i);</span>
<span class="fc" id="L798">                    break;</span>
                case ColumnType.SYMBOL:
                case BINARY_TYPE_SYMBOL:
<span class="fc" id="L801">                    appendSymbolColumn(record, i);</span>
<span class="fc" id="L802">                    break;</span>
                case BINARY_TYPE_LONG:
<span class="fc" id="L804">                    appendLongColumnBin(record, i);</span>
<span class="fc" id="L805">                    break;</span>
                case ColumnType.LONG:
<span class="fc" id="L807">                    appendLongColumn(record, i);</span>
<span class="fc" id="L808">                    break;</span>
                case ColumnType.SHORT:
<span class="fc" id="L810">                    appendShortColumn(record, i);</span>
<span class="fc" id="L811">                    break;</span>
                case BINARY_TYPE_DOUBLE:
<span class="fc" id="L813">                    appendDoubleColumnBin(record, i);</span>
<span class="fc" id="L814">                    break;</span>
                case ColumnType.DOUBLE:
<span class="fc" id="L816">                    appendDoubleColumn(record, i);</span>
<span class="fc" id="L817">                    break;</span>
                case BINARY_TYPE_FLOAT:
<span class="fc" id="L819">                    appendFloatColumnBin(record, i);</span>
<span class="fc" id="L820">                    break;</span>
                case BINARY_TYPE_SHORT:
<span class="fc" id="L822">                    appendShortColumnBin(record, i);</span>
<span class="fc" id="L823">                    break;</span>
                case BINARY_TYPE_DATE:
<span class="fc" id="L825">                    appendDateColumnBin(record, i);</span>
<span class="fc" id="L826">                    break;</span>
                case BINARY_TYPE_TIMESTAMP:
<span class="fc" id="L828">                    appendTimestampColumnBin(record, i);</span>
<span class="fc" id="L829">                    break;</span>
                case BINARY_TYPE_BYTE:
<span class="fc" id="L831">                    appendByteColumnBin(record, i);</span>
<span class="fc" id="L832">                    break;</span>
                case BINARY_TYPE_UUID:
<span class="fc" id="L834">                    appendUuidColumnBin(record, i);</span>
<span class="fc" id="L835">                    break;</span>
                case ColumnType.FLOAT:
<span class="fc" id="L837">                    appendFloatColumn(record, i);</span>
<span class="fc" id="L838">                    break;</span>
                case ColumnType.TIMESTAMP:
<span class="fc" id="L840">                    appendTimestampColumn(record, i);</span>
<span class="fc" id="L841">                    break;</span>
                case ColumnType.DATE:
<span class="fc" id="L843">                    appendDateColumn(record, i);</span>
<span class="fc" id="L844">                    break;</span>
                case ColumnType.BOOLEAN:
<span class="fc" id="L846">                    appendBooleanColumn(record, i);</span>
<span class="fc" id="L847">                    break;</span>
                case BINARY_TYPE_BOOLEAN:
<span class="fc" id="L849">                    appendBooleanColumnBin(record, i);</span>
<span class="fc" id="L850">                    break;</span>
                case ColumnType.BYTE:
<span class="fc" id="L852">                    appendByteColumn(record, i);</span>
<span class="fc" id="L853">                    break;</span>
                case ColumnType.BINARY:
                case BINARY_TYPE_BINARY:
<span class="fc" id="L856">                    appendBinColumn(record, i);</span>
<span class="fc" id="L857">                    break;</span>
                case ColumnType.CHAR:
                case BINARY_TYPE_CHAR:
<span class="fc" id="L860">                    appendCharColumn(record, i);</span>
<span class="fc" id="L861">                    break;</span>
                case ColumnType.LONG256:
                case BINARY_TYPE_LONG256:
<span class="fc" id="L864">                    appendLong256Column(record, i);</span>
<span class="fc" id="L865">                    break;</span>
                case ColumnType.GEOBYTE:
<span class="fc" id="L867">                    putGeoHashStringByteValue(record, i, activeSelectColumnTypes.getQuick(2 * i + 1));</span>
<span class="fc" id="L868">                    break;</span>
                case ColumnType.GEOSHORT:
<span class="fc" id="L870">                    putGeoHashStringShortValue(record, i, activeSelectColumnTypes.getQuick(2 * i + 1));</span>
<span class="fc" id="L871">                    break;</span>
                case ColumnType.GEOINT:
<span class="fc" id="L873">                    putGeoHashStringIntValue(record, i, activeSelectColumnTypes.getQuick(2 * i + 1));</span>
<span class="fc" id="L874">                    break;</span>
                case ColumnType.GEOLONG:
<span class="fc" id="L876">                    putGeoHashStringLongValue(record, i, activeSelectColumnTypes.getQuick(2 * i + 1));</span>
<span class="fc" id="L877">                    break;</span>
                case ColumnType.NULL:
<span class="fc" id="L879">                    responseAsciiSink.setNullValue();</span>
<span class="fc" id="L880">                    break;</span>
                case ColumnType.UUID:
<span class="fc" id="L882">                    appendUuidColumn(record, i);</span>
<span class="fc" id="L883">                    break;</span>
                default:
<span class="nc" id="L885">                    assert false;</span>
            }
        }
<span class="fc" id="L888">        responseAsciiSink.putLen(offset);</span>
<span class="fc" id="L889">        rowCount++;</span>
<span class="fc" id="L890">    }</span>

    private void appendShortColumn(Record record, int columnIndex) {
<span class="fc" id="L893">        final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L894">        responseAsciiSink.put(record.getShort(columnIndex));</span>
<span class="fc" id="L895">        responseAsciiSink.putLenEx(a);</span>
<span class="fc" id="L896">    }</span>

    private void appendShortColumnBin(Record record, int columnIndex) {
<span class="fc" id="L899">        final short value = record.getShort(columnIndex);</span>
<span class="fc" id="L900">        responseAsciiSink.putNetworkInt(Short.BYTES);</span>
<span class="fc" id="L901">        responseAsciiSink.putNetworkShort(value);</span>
<span class="fc" id="L902">    }</span>

    private void appendSingleRecord(Record record, int columnCount) throws SqlException {
        try {
<span class="fc" id="L906">            appendRecord(record, columnCount);</span>
<span class="fc" id="L907">        } catch (NoSpaceLeftInResponseBufferException e1) {</span>
            // oopsie, buffer is too small for single record
<span class="fc" id="L909">            LOG.error().$(&quot;not enough space in buffer for row data [buffer=&quot;).$(sendBufferSize).I$();</span>
<span class="fc" id="L910">            responseAsciiSink.reset();</span>
<span class="fc" id="L911">            freeFactory();</span>
<span class="fc" id="L912">            throw CairoException.critical(0).put(&quot;server configuration error: not enough space in send buffer for row data&quot;);</span>
<span class="fc" id="L913">        }</span>
<span class="fc" id="L914">    }</span>

    private void appendStrColumn(Record record, int columnIndex) {
<span class="fc" id="L917">        final CharSequence strValue = record.getStr(columnIndex);</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">        if (strValue == null) {</span>
<span class="fc" id="L919">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L921">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L922">            responseAsciiSink.encodeUtf8(strValue);</span>
<span class="fc" id="L923">            responseAsciiSink.putLenEx(a);</span>
        }
<span class="fc" id="L925">    }</span>

    private void appendSymbolColumn(Record record, int columnIndex) {
<span class="fc" id="L928">        final CharSequence strValue = record.getSym(columnIndex);</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">        if (strValue == null) {</span>
<span class="fc" id="L930">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L932">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L933">            responseAsciiSink.encodeUtf8(strValue);</span>
<span class="fc" id="L934">            responseAsciiSink.putLenEx(a);</span>
        }
<span class="fc" id="L936">    }</span>

    private void appendTimestampColumn(Record record, int i) {
        long a;
<span class="fc" id="L940">        long longValue = record.getTimestamp(i);</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">        if (longValue == Numbers.LONG_NaN) {</span>
<span class="fc" id="L942">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L944">            a = responseAsciiSink.skip();</span>
<span class="fc" id="L945">            TimestampFormatUtils.PG_TIMESTAMP_FORMAT.format(longValue, null, null, responseAsciiSink);</span>
<span class="fc" id="L946">            responseAsciiSink.putLenEx(a);</span>
        }
<span class="fc" id="L948">    }</span>

    private void appendTimestampColumnBin(Record record, int columnIndex) {
<span class="fc" id="L951">        final long longValue = record.getLong(columnIndex);</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">        if (longValue == Numbers.LONG_NaN) {</span>
<span class="fc" id="L953">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L955">            responseAsciiSink.putNetworkInt(Long.BYTES);</span>
            // PG epoch starts at 2000 rather than 1970
<span class="fc" id="L957">            responseAsciiSink.putNetworkLong(longValue - Numbers.JULIAN_EPOCH_OFFSET_USEC);</span>
        }
<span class="fc" id="L959">    }</span>

    private void appendUuidColumn(Record record, int columnIndex) {
<span class="fc" id="L962">        final long lo = record.getLong128Lo(columnIndex);</span>
<span class="fc" id="L963">        final long hi = record.getLong128Hi(columnIndex);</span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">        if (Uuid.isNull(lo, hi)) {</span>
<span class="nc" id="L965">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L967">            final long a = responseAsciiSink.skip();</span>
<span class="fc" id="L968">            Numbers.appendUuid(lo, hi, responseAsciiSink);</span>
<span class="fc" id="L969">            responseAsciiSink.putLenEx(a);</span>
        }
<span class="fc" id="L971">    }</span>

    private void appendUuidColumnBin(Record record, int columnIndex) {
<span class="fc" id="L974">        final long lo = record.getLong128Lo(columnIndex);</span>
<span class="fc" id="L975">        final long hi = record.getLong128Hi(columnIndex);</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">        if (Uuid.isNull(lo, hi)) {</span>
<span class="nc" id="L977">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L979">            responseAsciiSink.putNetworkInt(Long.BYTES * 2);</span>
<span class="fc" id="L980">            responseAsciiSink.putNetworkLong(hi);</span>
<span class="fc" id="L981">            responseAsciiSink.putNetworkLong(lo);</span>
        }
<span class="fc" id="L983">    }</span>

    //replace column formats in activeSelectColumnTypes with those from latest bind call
    private void applyLatestBindColumnFormats() {
<span class="fc bfc" id="L987" title="All 2 branches covered.">        for (int i = 0; i &lt; bindSelectColumnFormats.size(); i++) {</span>
<span class="fc" id="L988">            int newValue = toColumnBinaryType((short) bindSelectColumnFormats.get(i),</span>
<span class="fc" id="L989">                    toColumnType(activeSelectColumnTypes.getQuick(2 * i)));</span>
<span class="fc" id="L990">            activeSelectColumnTypes.setQuick(2 * i, newValue);</span>
        }
<span class="fc" id="L992">    }</span>

    private void assertTrue(boolean check, String message) throws BadProtocolException {
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">        if (check) {</span>
<span class="fc" id="L996">            return;</span>
        }
        // we did not find 0 within message limit
<span class="nc" id="L999">        LOG.error().$(message).$();</span>
<span class="nc" id="L1000">        throw BadProtocolException.INSTANCE;</span>
    }

    private long bindValuesAsStrings(long lo, long msgLimit, short parameterValueCount) throws BadProtocolException, SqlException {
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        for (int j = 0; j &lt; parameterValueCount; j++) {</span>
<span class="fc" id="L1005">            final int valueLen = getInt(lo, msgLimit, &quot;malformed bind variable&quot;);</span>
<span class="fc" id="L1006">            lo += Integer.BYTES;</span>

<span class="pc bpc" id="L1008" title="2 of 4 branches missed.">            if (valueLen != -1 &amp;&amp; lo + valueLen &lt;= msgLimit) {</span>
<span class="fc" id="L1009">                setStrBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1010">                lo += valueLen;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">            } else if (valueLen != -1) {</span>
<span class="nc" id="L1012">                LOG.error()</span>
<span class="nc" id="L1013">                        .$(&quot;value length is outside of buffer [parameterIndex=&quot;).$(j)</span>
<span class="nc" id="L1014">                        .$(&quot;, valueLen=&quot;).$(valueLen)</span>
<span class="nc" id="L1015">                        .$(&quot;, messageRemaining=&quot;).$(msgLimit - lo)</span>
<span class="nc" id="L1016">                        .$(']').$();</span>
<span class="nc" id="L1017">                throw BadProtocolException.INSTANCE;</span>
            }
        }
<span class="fc" id="L1020">        return lo;</span>
    }

    private long bindValuesUsingSetters(
            long lo,
            long msgLimit,
            short parameterValueCount
    ) throws BadProtocolException, SqlException {
<span class="fc bfc" id="L1028" title="All 2 branches covered.">        for (int j = 0; j &lt; parameterValueCount; j++) {</span>
<span class="fc" id="L1029">            final int valueLen = getInt(lo, msgLimit, &quot;malformed bind variable&quot;);</span>
<span class="fc" id="L1030">            lo += Integer.BYTES;</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">            if (valueLen == -1) {</span>
                // this is null we have already defaulted parameters to
<span class="fc" id="L1033">                continue;</span>
            }

<span class="fc bfc" id="L1036" title="All 2 branches covered.">            if (lo + valueLen &lt;= msgLimit) {</span>
<span class="pc bpc" id="L1037" title="3 of 12 branches missed.">                switch (activeBindVariableTypes.getQuick(j)) {</span>
                    case X_B_PG_INT4:
<span class="fc" id="L1039">                        setIntBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1040">                        break;</span>
                    case X_B_PG_INT8:
<span class="fc" id="L1042">                        setLongBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1043">                        break;</span>
                    case X_B_PG_TIMESTAMP:
<span class="fc" id="L1045">                        setTimestampBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1046">                        break;</span>
                    case X_B_PG_INT2:
<span class="fc" id="L1048">                        setShortBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1049">                        break;</span>
                    case X_B_PG_FLOAT8:
<span class="fc" id="L1051">                        setDoubleBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1052">                        break;</span>
                    case X_B_PG_FLOAT4:
<span class="fc" id="L1054">                        setFloatBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1055">                        break;</span>
                    case X_B_PG_CHAR:
<span class="nc" id="L1057">                        setCharBindVariable(j, lo, valueLen);</span>
<span class="nc" id="L1058">                        break;</span>
                    case X_B_PG_DATE:
<span class="nc" id="L1060">                        setDateBindVariable(j, lo, valueLen);</span>
<span class="nc" id="L1061">                        break;</span>
                    case X_B_PG_BOOL:
<span class="nc" id="L1063">                        setBooleanBindVariable(j, valueLen);</span>
<span class="nc" id="L1064">                        break;</span>
                    case X_B_PG_BYTEA:
<span class="fc" id="L1066">                        setBinBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1067">                        break;</span>
                    case X_B_PG_UUID:
<span class="fc" id="L1069">                        setUuidBindVariable(j, lo, valueLen);</span>
<span class="fc" id="L1070">                        break;</span>
                    default:
<span class="fc" id="L1072">                        setStrBindVariable(j, lo, valueLen);</span>
                        break;
                }
<span class="fc" id="L1075">                typesAndUpdateIsCached = true;</span>
<span class="fc" id="L1076">                typesAndSelectIsCached = true;</span>
<span class="fc" id="L1077">                lo += valueLen;</span>
            } else {
<span class="fc" id="L1079">                LOG.error()</span>
<span class="fc" id="L1080">                        .$(&quot;value length is outside of buffer [parameterIndex=&quot;).$(j)</span>
<span class="fc" id="L1081">                        .$(&quot;, valueLen=&quot;).$(valueLen)</span>
<span class="fc" id="L1082">                        .$(&quot;, messageRemaining=&quot;).$(msgLimit - lo)</span>
<span class="fc" id="L1083">                        .$(']').$();</span>
<span class="fc" id="L1084">                throw BadProtocolException.INSTANCE;</span>
            }
        }
<span class="fc" id="L1087">        return lo;</span>
    }

    private void buildSelectColumnTypes() {
<span class="fc" id="L1091">        final RecordMetadata m = typesAndSelect.getFactory().getMetadata();</span>
<span class="fc" id="L1092">        final int columnCount = m.getColumnCount();</span>
<span class="fc" id="L1093">        activeSelectColumnTypes.setPos(2 * columnCount);</span>

<span class="fc bfc" id="L1095" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1096">            int columnType = m.getColumnType(i);</span>
<span class="fc" id="L1097">            int flags = GeoHashes.getBitFlags(columnType);</span>
<span class="fc" id="L1098">            activeSelectColumnTypes.setQuick(2 * i, columnType);</span>
<span class="fc" id="L1099">            activeSelectColumnTypes.setQuick(2 * i + 1, flags);</span>
        }
<span class="fc" id="L1101">    }</span>

    private void clearCursorAndFactory() {
<span class="fc" id="L1104">        resumeProcessor = null;</span>
<span class="fc" id="L1105">        currentCursor = Misc.free(currentCursor);</span>
        // do not free factory, we may cache it
<span class="fc" id="L1107">        currentFactory = null;</span>
        // we resumed the cursor send the typeAndSelect will be null
        // we do not want to overwrite cache entries and potentially
        // leak memory
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if (typesAndSelect != null) {</span>
<span class="fc bfc" id="L1112" title="All 2 branches covered.">            if (typesAndSelectIsCached) {</span>
<span class="fc" id="L1113">                typesAndSelectCache.put(queryText, typesAndSelect);</span>
                // clear selectAndTypes so that context doesn't accidentally
                // free the factory when context finishes abnormally
<span class="fc" id="L1116">                this.typesAndSelect = null;</span>
            } else {
<span class="fc" id="L1118">                this.typesAndSelect = Misc.free(this.typesAndSelect);</span>
            }
        }

<span class="fc bfc" id="L1122" title="All 2 branches covered.">        if (typesAndUpdate != null) {</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">            if (typesAndUpdateIsCached) {</span>
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">                assert queryText != null;</span>
<span class="fc" id="L1125">                typesAndUpdateCache.put(queryText, typesAndUpdate);</span>
<span class="fc" id="L1126">                this.typesAndUpdate = null;</span>
            } else {
<span class="fc" id="L1128">                typesAndUpdate = Misc.free(typesAndUpdate);</span>
            }
        }
<span class="fc" id="L1131">    }</span>

    private void closePendingWriters(boolean commit) {
<span class="fc" id="L1134">        Iterator&lt;ObjObjHashMap.Entry&lt;TableToken, TableWriterAPI&gt;&gt; iterator = pendingWriters.iterator();</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L1136">            final TableWriterAPI m = iterator.next().value;</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">            if (commit) {</span>
<span class="fc" id="L1138">                m.commit();</span>
            } else {
<span class="fc" id="L1140">                m.rollback();</span>
            }
<span class="fc" id="L1142">            Misc.free(m);</span>
<span class="fc" id="L1143">        }</span>
<span class="fc" id="L1144">    }</span>

    private boolean compileQuery(@Transient SqlCompiler compiler) throws SqlException {
<span class="pc bpc" id="L1147" title="1 of 4 branches missed.">        if (queryText != null &amp;&amp; queryText.length() &gt; 0) {</span>

            // try insert, peek because this is our private cache
            // and we do not want to remove statement from it
<span class="fc" id="L1151">            typesAndInsert = typesAndInsertCache.peek(queryText);</span>

            // not found or not insert, try select
            // poll this cache because it is shared and we do not want
            // select factory to be used by another thread concurrently
<span class="fc bfc" id="L1156" title="All 2 branches covered.">            if (typesAndInsert != null) {</span>
<span class="fc" id="L1157">                typesAndInsert.defineBindVariables(bindVariableService);</span>
<span class="fc" id="L1158">                queryTag = TAG_INSERT;</span>
<span class="fc" id="L1159">                return false;</span>
            }

<span class="fc" id="L1162">            typesAndUpdate = typesAndUpdateCache.poll(queryText);</span>

<span class="fc bfc" id="L1164" title="All 2 branches covered.">            if (typesAndUpdate != null) {</span>
<span class="fc" id="L1165">                typesAndUpdate.defineBindVariables(bindVariableService);</span>
<span class="fc" id="L1166">                queryTag = TAG_UPDATE;</span>
<span class="fc" id="L1167">                typesAndUpdateIsCached = true;</span>
<span class="fc" id="L1168">                return false;</span>
            }

<span class="fc" id="L1171">            typesAndSelect = typesAndSelectCache.poll(queryText);</span>

<span class="fc bfc" id="L1173" title="All 2 branches covered.">            if (typesAndSelect != null) {</span>
<span class="fc" id="L1174">                LOG.info().$(&quot;query cache used [fd=&quot;).$(fd).I$();</span>
                // cache hit, define bind variables
<span class="fc" id="L1176">                bindVariableService.clear();</span>
<span class="fc" id="L1177">                typesAndSelect.defineBindVariables(bindVariableService);</span>
<span class="fc" id="L1178">                queryTag = TAG_SELECT;</span>
<span class="fc" id="L1179">                return false;</span>
            }

            // not cached - compile to see what it is
<span class="fc" id="L1183">            final CompiledQuery cc = compiler.compile(queryText, sqlExecutionContext);</span>
<span class="fc" id="L1184">            processCompiledQuery(cc);</span>
<span class="fc" id="L1185">        } else {</span>
<span class="fc" id="L1186">            isEmptyQuery = true;</span>
        }

<span class="fc" id="L1189">        return true;</span>
    }

    private void configureContextFromNamedStatement(CharSequence statementName, @Nullable @Transient SqlCompiler compiler)
            throws BadProtocolException, SqlException {

<span class="fc bfc" id="L1195" title="All 2 branches covered.">        this.sendParameterDescription = statementName != null;</span>

<span class="fc bfc" id="L1197" title="All 2 branches covered.">        if (wrapper != null) {</span>
<span class="fc" id="L1198">            LOG.debug().$(&quot;reusing existing wrapper&quot;).$();</span>
<span class="fc" id="L1199">            return;</span>
        }

        // make sure there is no current wrapper is set, so that we don't assign values
        // from the wrapper back to context on the first pass where named statement is setup
<span class="fc bfc" id="L1204" title="All 2 branches covered.">        if (statementName != null) {</span>
<span class="fc" id="L1205">            LOG.debug().$(&quot;named statement [name=&quot;).$(statementName).$(']').$();</span>
<span class="fc" id="L1206">            wrapper = namedStatementMap.get(statementName);</span>
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">            if (wrapper != null) {</span>
<span class="fc" id="L1208">                setupVariableSettersFromWrapper(wrapper, compiler);</span>
            } else {
                // todo: when we have nothing for prepared statement name we need to produce an error
<span class="nc" id="L1211">                LOG.error().$(&quot;statement does not exist [name=&quot;).$(statementName).$(']').$();</span>
<span class="nc" id="L1212">                throw BadProtocolException.INSTANCE;</span>
            }
        }
<span class="fc" id="L1215">    }</span>

    private void configurePortal(CharSequence portalName, CharSequence statementName) throws BadProtocolException {
<span class="fc" id="L1218">        int index = namedPortalMap.keyIndex(portalName);</span>
<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">        if (index &gt; -1) {</span>
<span class="fc" id="L1220">            Portal portal = namedPortalPool.pop();</span>
<span class="fc" id="L1221">            portal.statementName = statementName;</span>
<span class="fc" id="L1222">            namedPortalMap.putAt(index, Chars.toString(portalName), portal);</span>
<span class="fc" id="L1223">        } else {</span>
<span class="nc" id="L1224">            LOG.error().$(&quot;duplicate portal [name=&quot;).$(portalName).$(']').$();</span>
<span class="nc" id="L1225">            throw BadProtocolException.INSTANCE;</span>
        }
<span class="fc" id="L1227">    }</span>

    private void configurePreparedStatement(CharSequence statementName) throws BadProtocolException {
        // this is a PARSE message asking us to setup named SQL
        // we need to keep SQL text in case our SQL cache expires
        // as well as PG types of the bind variables, which we will need to configure setters

<span class="fc" id="L1234">        int index = namedStatementMap.keyIndex(statementName);</span>
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">        if (index &gt; -1) {</span>
<span class="fc" id="L1236">            wrapper = namedStatementWrapperPool.pop();</span>
<span class="fc" id="L1237">            wrapper.queryText = Chars.toString(queryText);</span>
            // COPY 'id' CANCEL; queries shouldn't be compiled multiple times, but it's fine to compile
            // COPY 'x' FROM ...; queries multiple times since the import is executed lazily
<span class="fc bfc" id="L1240" title="All 8 branches covered.">            wrapper.alreadyExecuted = (queryTag == TAG_OK || queryTag == TAG_CTAS || (queryTag == TAG_COPY &amp;&amp; typesAndSelect == null));</span>
<span class="fc" id="L1241">            namedStatementMap.putAt(index, Chars.toString(statementName), wrapper);</span>
<span class="fc" id="L1242">            this.activeBindVariableTypes = wrapper.bindVariableTypes;</span>
<span class="fc" id="L1243">            this.activeSelectColumnTypes = wrapper.selectColumnTypes;</span>
        } else {
<span class="nc" id="L1245">            LOG.error().$(&quot;duplicate statement [name=&quot;).$(statementName).$(']').$();</span>
<span class="nc" id="L1246">            throw BadProtocolException.INSTANCE;</span>
        }
<span class="fc" id="L1248">    }</span>

    private void doAuthentication(
            long msgLo,
            long msgLimit
    ) throws BadProtocolException, PeerDisconnectedException, PeerIsSlowToReadException, AuthenticationException {

<span class="fc" id="L1255">        CairoSecurityContext cairoSecurityContext = null;</span>
        // First, try to authenticate as the read-only user if it's configured.
<span class="fc bfc" id="L1257" title="All 2 branches covered.">        if (roUserAuthenticator != null) {</span>
            try {
<span class="fc" id="L1259">                cairoSecurityContext = roUserAuthenticator.authenticate(username, msgLo, msgLimit);</span>
<span class="fc" id="L1260">            } catch (AuthenticationException ignore) {</span>
                // Wrong user, never mind.
<span class="fc" id="L1262">            }</span>
        }
        // Next, authenticate as the primary user if we failed to recognize the read-only user.
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        if (cairoSecurityContext == null) {</span>
<span class="fc" id="L1266">            cairoSecurityContext = authenticator.authenticate(username, msgLo, msgLimit);</span>
        }
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">        if (cairoSecurityContext != null) {</span>
<span class="fc" id="L1269">            sqlExecutionContext.with(cairoSecurityContext, bindVariableService, rnd, this.fd, circuitBreaker.of(this.fd));</span>
<span class="fc" id="L1270">            authenticationRequired = false;</span>
<span class="fc" id="L1271">            prepareLoginOk();</span>
<span class="fc" id="L1272">            sendAndReset();</span>
        }
<span class="fc" id="L1274">    }</span>

    private void doSendWithRetries(int bufferOffset, int bufferSize) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L1277">        int offset = bufferOffset;</span>
<span class="fc" id="L1278">        int remaining = bufferSize;</span>

<span class="fc bfc" id="L1280" title="All 2 branches covered.">        while (remaining &gt; 0) {</span>
<span class="fc" id="L1281">            int m = nf.send(</span>
<span class="fc" id="L1282">                    getFd(),</span>
                    sendBuffer + offset,
                    remaining
            );
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">            if (m &lt; 0) {</span>
<span class="nc" id="L1287">                LOG.info().$(&quot;disconnected on write [code=&quot;).$(m).$(']').$();</span>
<span class="nc" id="L1288">                throw PeerDisconnectedException.INSTANCE;</span>
            }
<span class="fc bfc" id="L1290" title="All 2 branches covered.">            if (m == 0) {</span>
                // The socket is not ready for write.
<span class="fc" id="L1292">                break;</span>
            }

<span class="fc" id="L1295">            dumpBuffer('&lt;', sendBuffer + offset, m);</span>

<span class="fc" id="L1297">            remaining -= m;</span>
<span class="fc" id="L1298">            offset += m;</span>
<span class="fc" id="L1299">        }</span>

<span class="fc bfc" id="L1301" title="All 2 branches covered.">        if (remaining &gt; 0) {</span>
<span class="fc" id="L1302">            bufferRemainingOffset = offset;</span>
<span class="fc" id="L1303">            bufferRemainingSize = remaining;</span>
<span class="fc" id="L1304">            throw PeerIsSlowToReadException.INSTANCE;</span>
        }
<span class="fc" id="L1306">    }</span>

    private void dumpBuffer(char direction, long buffer, int len) {
<span class="pc bpc" id="L1309" title="3 of 4 branches missed.">        if (dumpNetworkTraffic &amp;&amp; len &gt; 0) {</span>
<span class="nc" id="L1310">            StdoutSink.INSTANCE.put(direction);</span>
<span class="nc" id="L1311">            Net.dump(buffer, len);</span>
        }
<span class="fc" id="L1313">    }</span>

    private void evictNamedStatementWrappersAndClear() {
<span class="fc bfc" id="L1316" title="All 2 branches covered.">        if (namedStatementMap.size() &gt; 0) {</span>
<span class="fc" id="L1317">            ObjList&lt;CharSequence&gt; names = namedStatementMap.keys();</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">            for (int i = 0, n = names.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1319">                CharSequence name = names.getQuick(i);</span>
<span class="fc" id="L1320">                namedStatementWrapperPool.push(namedStatementMap.get(name));</span>
            }
<span class="fc" id="L1322">            namedStatementMap.clear();</span>
        }
<span class="fc" id="L1324">    }</span>

    private void executeInsert(SqlCompiler compiler) throws SqlException {
        TableWriterAPI writer;
<span class="fc" id="L1328">        boolean recompileStale = true;</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">        for (int retries = 0; recompileStale; retries++) {</span>
            try {
<span class="fc bfc" id="L1331" title="All 3 branches covered.">                switch (transactionState) {</span>
                    case IN_TRANSACTION:
<span class="fc" id="L1333">                        final InsertMethod m = typesAndInsert.getInsert().createMethod(sqlExecutionContext, this);</span>
<span class="fc" id="L1334">                        recompileStale = false;</span>
                        try {
<span class="fc" id="L1336">                            rowCount = m.execute();</span>
<span class="fc" id="L1337">                            writer = m.popWriter();</span>
<span class="fc" id="L1338">                            pendingWriters.put(writer.getTableToken(), writer);</span>
<span class="fc" id="L1339">                        } catch (Throwable e) {</span>
<span class="fc" id="L1340">                            Misc.free(m);</span>
<span class="fc" id="L1341">                            throw e;</span>
<span class="fc" id="L1342">                        }</span>
                        break;
                    case ERROR_TRANSACTION:
                        // when transaction is in error state, skip execution
<span class="fc" id="L1346">                        break;</span>
                    default:
                        // in any other case we will commit in place
<span class="fc" id="L1349">                        try (final InsertMethod m2 = typesAndInsert.getInsert().createMethod(sqlExecutionContext, this)) {</span>
<span class="fc" id="L1350">                            recompileStale = false;</span>
<span class="fc" id="L1351">                            rowCount = m2.execute();</span>
<span class="fc" id="L1352">                            m2.commit();</span>
                        }
                        break;
                }
<span class="fc" id="L1356">                prepareCommandComplete(true);</span>
<span class="fc" id="L1357">                return;</span>
<span class="fc" id="L1358">            } catch (TableReferenceOutOfDateException ex) {</span>
<span class="pc bpc" id="L1359" title="2 of 4 branches missed.">                if (!recompileStale || retries == TableReferenceOutOfDateException.MAX_RETRY_ATTEMPS) {</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">                    if (transactionState == IN_TRANSACTION) {</span>
<span class="nc" id="L1361">                        transactionState = ERROR_TRANSACTION;</span>
                    }
<span class="nc" id="L1363">                    throw ex;</span>
                }
<span class="fc" id="L1365">                LOG.info().$(ex.getFlyweightMessage()).$();</span>
<span class="fc" id="L1366">                Misc.free(typesAndInsert);</span>
<span class="fc" id="L1367">                CompiledQuery cc = compiler.compile(queryText, sqlExecutionContext); //here</span>
<span class="fc" id="L1368">                processCompiledQuery(cc);</span>
<span class="fc" id="L1369">            } catch (Throwable e) {</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">                if (transactionState == IN_TRANSACTION) {</span>
<span class="fc" id="L1371">                    transactionState = ERROR_TRANSACTION;</span>
                }
<span class="fc" id="L1373">                throw e;</span>
<span class="fc" id="L1374">            }</span>
        }
<span class="nc" id="L1376">    }</span>

    private void executeTag() {
<span class="fc" id="L1379">        LOG.debug().$(&quot;executing [tag=&quot;).$(queryTag).$(']').$();</span>
<span class="pc bpc" id="L1380" title="1 of 4 branches missed.">        if (queryTag != null &amp;&amp; TAG_OK != queryTag) {  //do not run this for OK tag (i.e.: create table)</span>
<span class="fc" id="L1381">            executeTag0();</span>
        }
<span class="fc" id="L1383">    }</span>

    private void executeTag0() {
<span class="fc bfc" id="L1386" title="All 3 branches covered.">        switch (transactionState) {</span>
            case COMMIT_TRANSACTION:
                try {
<span class="fc" id="L1389">                    closePendingWriters(true);</span>
                } finally {
<span class="fc" id="L1391">                    pendingWriters.clear();</span>
<span class="fc" id="L1392">                    transactionState = NO_TRANSACTION;</span>
                }
<span class="fc" id="L1394">                break;</span>
            case ROLLING_BACK_TRANSACTION:
                try {
<span class="fc" id="L1397">                    closePendingWriters(false);</span>
                } finally {
<span class="fc" id="L1399">                    pendingWriters.clear();</span>
<span class="fc" id="L1400">                    transactionState = NO_TRANSACTION;</span>
                }
<span class="fc" id="L1402">                break;</span>
            default:
                break;
        }
<span class="fc" id="L1406">    }</span>

    private void executeUpdate(SqlCompiler compiler) throws SqlException {
<span class="fc" id="L1409">        boolean recompileStale = true;</span>
<span class="fc bfc" id="L1410" title="All 2 branches covered.">        for (int retries = 0; recompileStale; retries++) {</span>
            try {
<span class="pc bpc" id="L1412" title="1 of 2 branches missed.">                if (transactionState != ERROR_TRANSACTION) {</span>
                    // when transaction is in error state, skip execution
<span class="fc" id="L1414">                    executeUpdate0();</span>
<span class="fc" id="L1415">                    recompileStale = false;</span>
                }
<span class="fc" id="L1417">                prepareCommandComplete(true);</span>
<span class="fc" id="L1418">            } catch (TableReferenceOutOfDateException e) {</span>
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">                if (retries == TableReferenceOutOfDateException.MAX_RETRY_ATTEMPS) {</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">                    if (transactionState == IN_TRANSACTION) {</span>
<span class="nc" id="L1421">                        transactionState = ERROR_TRANSACTION;</span>
                    }
<span class="nc" id="L1423">                    throw e;</span>
                }
<span class="fc" id="L1425">                LOG.info().$(e.getFlyweightMessage()).$();</span>
<span class="fc" id="L1426">                typesAndUpdate = Misc.free(typesAndUpdate);</span>
<span class="fc" id="L1427">                CompiledQuery cc = compiler.compile(queryText, sqlExecutionContext);</span>
<span class="fc" id="L1428">                processCompiledQuery(cc);</span>
<span class="fc" id="L1429">            } catch (Throwable e) {</span>
<span class="fc" id="L1430">                typesAndUpdate = Misc.free(typesAndUpdate);</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">                if (transactionState == IN_TRANSACTION) {</span>
<span class="fc" id="L1432">                    transactionState = ERROR_TRANSACTION;</span>
                }
<span class="fc" id="L1434">                throw e;</span>
<span class="fc" id="L1435">            }</span>
        }
<span class="fc" id="L1437">    }</span>

    private void executeUpdate0() throws SqlException {
<span class="fc" id="L1440">        final CompiledQuery cq = typesAndUpdate.getCompiledQuery();</span>
<span class="fc" id="L1441">        final UpdateOperation op = cq.getUpdateOperation();</span>
<span class="fc" id="L1442">        op.start();</span>

        // check if there is pending writer, which would be pending if there is active transaction
        // when we have writer, execution is synchronous
<span class="fc" id="L1446">        TableToken tableToken = op.getTableToken();</span>
<span class="pc bpc" id="L1447" title="1 of 2 branches missed.">        if (tableToken == null) {</span>
<span class="nc" id="L1448">            throw CairoException.critical(0).put(&quot;invalid update operation plan cached, table token is null&quot;);</span>
        }
<span class="fc" id="L1450">        final int index = pendingWriters.keyIndex(tableToken);</span>
<span class="fc bfc" id="L1451" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L1452">            op.withContext(sqlExecutionContext);</span>
<span class="fc" id="L1453">            TableWriterAPI tableWriterAPI = pendingWriters.valueAt(index);</span>
            // Update implicitly commits. WAL table cannot do 2 commits in 1 call and require commits to be made upfront.
<span class="fc" id="L1455">            tableWriterAPI.commit();</span>
<span class="fc" id="L1456">            tableWriterAPI.apply(op);</span>
<span class="fc" id="L1457">        } else {</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">            if (statementTimeout &gt; 0) {</span>
<span class="fc" id="L1459">                circuitBreaker.setTimeout(statementTimeout);</span>
            }

            // execute against writer from the engine, or async
<span class="fc" id="L1463">            try (OperationFuture fut = cq.execute(sqlExecutionContext, tempSequence, false)) {</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">                if (statementTimeout &gt; 0) {</span>
<span class="pc bpc" id="L1465" title="1 of 2 branches missed.">                    if (fut.await(statementTimeout) != QUERY_COMPLETE) {</span>
                        // Timeout
<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">                        if (op.isWriterClosePending()) {</span>
                            // Writer has not tried to execute the command
<span class="fc" id="L1469">                            freeUpdateCommand(op);</span>
                        }
<span class="fc" id="L1471">                        throw SqlException.$(0, &quot;UPDATE query timeout &quot;).put(statementTimeout).put(&quot; ms&quot;);</span>
                    }
                } else {
                    // Default timeouts, can be different for select and update part
<span class="fc" id="L1475">                    fut.await();</span>
                }
<span class="fc" id="L1477">                rowCount = fut.getAffectedRowsCount();</span>
<span class="fc" id="L1478">            } catch (SqlTimeoutException ex) {</span>
                // After timeout, TableWriter can still use the UpdateCommand and Execution Context
<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">                if (op.isWriterClosePending()) {</span>
<span class="fc" id="L1481">                    freeUpdateCommand(op);</span>
                }
<span class="fc" id="L1483">                throw ex;</span>
<span class="fc" id="L1484">            } catch (SqlException | CairoException ex) {</span>
                // These exceptions mean the UpdateOperation cannot be used by writer anymore, and it's safe to re-use it.
<span class="fc" id="L1486">                throw ex;</span>
<span class="fc" id="L1487">            } catch (Throwable ex) {</span>
                // Unknown exception, assume TableWriter can still use the UpdateCommand and Execution Context
<span class="pc bpc" id="L1489" title="1 of 2 branches missed.">                if (op.isWriterClosePending()) {</span>
<span class="nc" id="L1490">                    freeUpdateCommand(op);</span>
                }
<span class="fc" id="L1492">                throw ex;</span>
<span class="fc" id="L1493">            }</span>
        }
<span class="fc" id="L1495">    }</span>

    private void freeBuffers() {
<span class="fc" id="L1498">        this.recvBuffer = Unsafe.free(recvBuffer, recvBufferSize, MemoryTag.NATIVE_PGW_CONN);</span>
<span class="fc" id="L1499">        this.sendBuffer = this.sendBufferPtr = this.sendBufferLimit = Unsafe.free(sendBuffer, sendBufferSize, MemoryTag.NATIVE_PGW_CONN);</span>
<span class="fc" id="L1500">    }</span>

    private void freeFactory() {
<span class="fc" id="L1503">        currentFactory = null;</span>
<span class="fc" id="L1504">        typesAndSelect = Misc.free(typesAndSelect);</span>
<span class="fc" id="L1505">    }</span>

    private void freeUpdateCommand(UpdateOperation op) {
        // Create a copy of sqlExecutionContext here
<span class="fc" id="L1509">        bindVariableService = new BindVariableServiceImpl(engine.getConfiguration());</span>
<span class="fc" id="L1510">        SqlExecutionContextImpl newSqlExecutionContext = new SqlExecutionContextImpl(</span>
                engine,
<span class="fc" id="L1512">                sqlExecutionContext.getWorkerCount(),</span>
<span class="fc" id="L1513">                sqlExecutionContext.getSharedWorkerCount()</span>
        );
<span class="fc" id="L1515">        newSqlExecutionContext.with(</span>
<span class="fc" id="L1516">                sqlExecutionContext.getCairoSecurityContext(),</span>
                bindVariableService,
<span class="fc" id="L1518">                sqlExecutionContext.getRandom(),</span>
<span class="fc" id="L1519">                sqlExecutionContext.getRequestFd(),</span>
                circuitBreaker
        );
<span class="fc" id="L1522">        sqlExecutionContext = newSqlExecutionContext;</span>

        // Do not cache, let last closing party free the resources
<span class="fc" id="L1525">        op.close();</span>
<span class="fc" id="L1526">        typesAndUpdate = null;</span>
<span class="fc" id="L1527">    }</span>

    @Nullable
    private CharSequence getPortalName(long lo, long hi) throws BadProtocolException {
<span class="fc bfc" id="L1531" title="All 2 branches covered.">        if (hi - lo &gt; 0) {</span>
<span class="fc" id="L1532">            return getString(lo, hi, &quot;invalid UTF8 bytes in portal name&quot;);</span>
        }
<span class="fc" id="L1534">        return null;</span>
    }

    @Nullable
    private CharSequence getStatementName(long lo, long hi) throws BadProtocolException {
<span class="fc bfc" id="L1539" title="All 2 branches covered.">        if (hi - lo &gt; 0) {</span>
<span class="fc" id="L1540">            return getString(lo, hi, &quot;invalid UTF8 bytes in statement name&quot;);</span>
        }
<span class="fc" id="L1542">        return null;</span>
    }

    private CharSequence getString(long lo, long hi, CharSequence errorMessage) throws BadProtocolException {
<span class="fc" id="L1546">        CharacterStoreEntry e = characterStore.newEntry();</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">        if (Chars.utf8Decode(lo, hi, e)) {</span>
<span class="fc" id="L1548">            return characterStore.toImmutable();</span>
        } else {
<span class="fc" id="L1550">            LOG.error().$(errorMessage).$();</span>
<span class="fc" id="L1551">            throw BadProtocolException.INSTANCE;</span>
        }
    }

    /**
     * Returns address of where parsing stopped. If there are remaining bytes left
     * in the buffer they need to be passed again in parse function along with
     * any additional bytes received
     */
    private void parse(
            long address,
            int len,
            @Transient SqlCompiler compiler
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, BadProtocolException, QueryPausedException, AuthenticationException, SqlException {

<span class="fc bfc" id="L1566" title="All 2 branches covered.">        if (requireInitialMessage) {</span>
<span class="fc" id="L1567">            sendRNQ = true;</span>
<span class="fc" id="L1568">            processInitialMessage(address, len);</span>
<span class="fc" id="L1569">            return;</span>
        }

        // this is a type-prefixed message
        // we will wait until we receive the entire header

<span class="fc bfc" id="L1575" title="All 2 branches covered.">        if (len &lt; PREFIXED_MESSAGE_HEADER_LEN) {</span>
            // we need to be able to read header and length
<span class="fc" id="L1577">            return;</span>
        }

<span class="fc" id="L1580">        final byte type = Unsafe.getUnsafe().getByte(address);</span>
<span class="fc" id="L1581">        final int msgLen = getIntUnsafe(address + 1);</span>
<span class="fc" id="L1582">        LOG.debug()</span>
<span class="fc" id="L1583">                .$(&quot;received msg [type=&quot;).$((char) type)</span>
<span class="fc" id="L1584">                .$(&quot;, len=&quot;).$(msgLen)</span>
<span class="fc" id="L1585">                .$(']').$();</span>
<span class="fc bfc" id="L1586" title="All 2 branches covered.">        if (msgLen &lt; 1) {</span>
<span class="fc" id="L1587">            LOG.error()</span>
<span class="fc" id="L1588">                    .$(&quot;invalid message length [type=&quot;).$(type)</span>
<span class="fc" id="L1589">                    .$(&quot;, msgLen=&quot;).$(msgLen)</span>
<span class="fc" id="L1590">                    .$(&quot;, recvBufferReadOffset=&quot;).$(recvBufferReadOffset)</span>
<span class="fc" id="L1591">                    .$(&quot;, recvBufferWriteOffset=&quot;).$(recvBufferWriteOffset)</span>
<span class="fc" id="L1592">                    .$(&quot;, totalReceived=&quot;).$(totalReceived)</span>
<span class="fc" id="L1593">                    .$(']').$();</span>
<span class="fc" id="L1594">            throw BadProtocolException.INSTANCE;</span>
        }

        // msgLen does not take into account type byte
<span class="fc bfc" id="L1598" title="All 2 branches covered.">        if (msgLen &gt; len - 1) {</span>
            // When this happens we need to shift our receive buffer left
            // to fit this message. Outer function will do that if we
            // just exit.
<span class="fc" id="L1602">            LOG.debug()</span>
<span class="fc" id="L1603">                    .$(&quot;not enough data in buffer [expected=&quot;).$(msgLen)</span>
<span class="fc" id="L1604">                    .$(&quot;, have=&quot;).$(len)</span>
<span class="fc" id="L1605">                    .$(&quot;, recvBufferWriteOffset=&quot;).$(recvBufferWriteOffset)</span>
<span class="fc" id="L1606">                    .$(&quot;, recvBufferReadOffset=&quot;).$(recvBufferReadOffset)</span>
<span class="fc" id="L1607">                    .$(']').$();</span>
<span class="fc" id="L1608">            return;</span>
        }
        // we have enough to read entire message
<span class="fc" id="L1611">        recvBufferReadOffset += msgLen + 1;</span>
<span class="fc" id="L1612">        final long msgLimit = address + msgLen + 1;</span>
<span class="fc" id="L1613">        final long msgLo = address + PREFIXED_MESSAGE_HEADER_LEN; // 8 is offset where name value pairs begin</span>

<span class="fc bfc" id="L1615" title="All 2 branches covered.">        if (authenticationRequired) {</span>
<span class="fc" id="L1616">            sendRNQ = true;</span>
<span class="fc" id="L1617">            doAuthentication(msgLo, msgLimit);</span>
<span class="fc" id="L1618">            return;</span>
        }
<span class="pc bpc" id="L1620" title="2 of 11 branches missed.">        switch (type) {</span>
            case 'P': // parse
<span class="fc" id="L1622">                sendRNQ = true;</span>
<span class="fc" id="L1623">                processParse(</span>
                        address,
                        msgLo,
                        msgLimit,
                        compiler
                );
<span class="fc" id="L1629">                break;</span>
            case 'X': // 'Terminate'
<span class="fc" id="L1631">                throw PeerDisconnectedException.INSTANCE;</span>
            case 'C':
                // close
<span class="fc" id="L1634">                processClose(msgLo, msgLimit);</span>
<span class="fc" id="L1635">                sendRNQ = true;</span>
<span class="fc" id="L1636">                break;</span>
            case 'B': // bind
<span class="fc" id="L1638">                sendRNQ = true;</span>
<span class="fc" id="L1639">                processBind(msgLo, msgLimit, compiler);</span>
<span class="fc" id="L1640">                break;</span>
            case 'E': // execute
<span class="fc" id="L1642">                sendRNQ = true;</span>
<span class="fc" id="L1643">                processExec(msgLo, msgLimit, compiler);</span>
<span class="fc" id="L1644">                break;</span>
            case 'S': // sync
<span class="fc" id="L1646">                processSyncActions();</span>
<span class="fc" id="L1647">                prepareReadyForQuery();</span>
<span class="fc" id="L1648">                prepareForNewQuery();</span>
<span class="fc" id="L1649">                sendRNQ = true;</span>
                // fall thru
            case 'H': // flush
                // some clients (asyncpg) chose not to send 'S' (sync) message
                // but instead fire 'H'. Can't wrap my head around as to why
                // query execution is so ambiguous
<span class="fc bfc" id="L1655" title="All 2 branches covered.">                if (syncActions.size() &gt; 0) {</span>
<span class="fc" id="L1656">                    processSyncActions();</span>
<span class="fc" id="L1657">                    prepareForNewQuery();</span>
                }
<span class="fc" id="L1659">                sendAndReset();</span>
<span class="fc" id="L1660">                break;</span>
            case 'D': // describe
<span class="fc" id="L1662">                sendRNQ = true;</span>
<span class="fc" id="L1663">                processDescribe(msgLo, msgLimit, compiler);</span>
<span class="fc" id="L1664">                break;</span>
            case 'Q': // simple query
<span class="fc" id="L1666">                sendRNQ = true;</span>
<span class="fc" id="L1667">                processQuery(msgLo, msgLimit, compiler);</span>
<span class="fc" id="L1668">                break;</span>
            case 'd': // COPY data 
<span class="nc" id="L1670">                break;</span>
            default:
<span class="nc" id="L1672">                LOG.error().$(&quot;unknown message [type=&quot;).$(type).$(']').$();</span>
<span class="nc" id="L1673">                throw BadProtocolException.INSTANCE;</span>
        }
<span class="fc" id="L1675">    }</span>

    private void parseQueryText(long lo, long hi, @Transient SqlCompiler compiler) throws BadProtocolException, SqlException {
<span class="fc" id="L1678">        CharacterStoreEntry e = characterStore.newEntry();</span>
<span class="fc bfc" id="L1679" title="All 2 branches covered.">        if (Chars.utf8Decode(lo, hi, e)) {</span>
<span class="fc" id="L1680">            queryText = characterStore.toImmutable();</span>

<span class="fc" id="L1682">            LOG.info().$(&quot;parse [fd=&quot;).$(fd).$(&quot;, q=&quot;).utf8(queryText).I$();</span>
<span class="fc" id="L1683">            compileQuery(compiler);</span>
<span class="fc" id="L1684">            return;</span>
        }
<span class="fc" id="L1686">        LOG.error().$(&quot;invalid UTF8 bytes in parse query&quot;).$();</span>
<span class="fc" id="L1687">        throw BadProtocolException.INSTANCE;</span>
    }

    private void prepareBindComplete() {
<span class="fc" id="L1691">        responseAsciiSink.put(MESSAGE_TYPE_BIND_COMPLETE);</span>
<span class="fc" id="L1692">        responseAsciiSink.putIntDirect(INT_BYTES_X);</span>
<span class="fc" id="L1693">    }</span>

    private void prepareCloseComplete() {
<span class="fc" id="L1696">        responseAsciiSink.put(MESSAGE_TYPE_CLOSE_COMPLETE);</span>
<span class="fc" id="L1697">        responseAsciiSink.putIntDirect(INT_BYTES_X);</span>
<span class="fc" id="L1698">    }</span>

    private void prepareDescribePortalResponse() {
<span class="fc bfc" id="L1701" title="All 2 branches covered.">        if (typesAndSelect != null) {</span>
            try {
<span class="fc" id="L1703">                prepareRowDescription();</span>
<span class="fc" id="L1704">            } catch (NoSpaceLeftInResponseBufferException ignored) {</span>
<span class="fc" id="L1705">                LOG.error().$(&quot;not enough space in buffer for row description [buffer=&quot;).$(sendBufferSize).I$();</span>
<span class="fc" id="L1706">                responseAsciiSink.reset();</span>
<span class="fc" id="L1707">                freeFactory();</span>
<span class="fc" id="L1708">                throw CairoException.critical(0).put(&quot;server configuration error: not enough space in send buffer for row description&quot;);</span>
<span class="fc" id="L1709">            }</span>
        } else {
<span class="fc" id="L1711">            prepareNoDataMessage();</span>
        }
<span class="fc" id="L1713">    }</span>

    private void prepareDescribeResponse() {
        // only send parameter description when we have named statement
<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">        if (sendParameterDescription) {</span>
<span class="fc" id="L1718">            prepareParameterDescription();</span>
        }
<span class="fc" id="L1720">        prepareDescribePortalResponse();</span>
<span class="fc" id="L1721">    }</span>

    private void prepareError(CairoException ex) {
<span class="fc" id="L1724">        int errno = ex.getErrno();</span>
<span class="fc" id="L1725">        CharSequence message = ex.getFlyweightMessage();</span>
<span class="fc" id="L1726">        prepareErrorResponse(ex.getPosition(), ex.getFlyweightMessage());</span>
<span class="fc bfc" id="L1727" title="All 2 branches covered.">        if (ex.isCritical()) {</span>
<span class="fc" id="L1728">            LOG.critical()</span>
<span class="fc" id="L1729">                    .$(&quot;error [msg=`&quot;).utf8(message)</span>
<span class="fc" id="L1730">                    .$(&quot;`, errno=&quot;).$(errno)</span>
<span class="fc" id="L1731">                    .I$();</span>
        } else {
<span class="fc" id="L1733">            LOG.error()</span>
<span class="fc" id="L1734">                    .$(&quot;error [msg=`&quot;).utf8(message)</span>
<span class="fc" id="L1735">                    .$(&quot;`, errno=&quot;).$(errno)</span>
<span class="fc" id="L1736">                    .I$();</span>
        }
<span class="fc" id="L1738">    }</span>

    private void prepareErrorResponse(int position, CharSequence message) {
<span class="fc" id="L1741">        responseAsciiSink.put(MESSAGE_TYPE_ERROR_RESPONSE);</span>
<span class="fc" id="L1742">        long addr = responseAsciiSink.skip();</span>
<span class="fc" id="L1743">        responseAsciiSink.put('C');</span>
<span class="fc" id="L1744">        responseAsciiSink.encodeUtf8Z(&quot;00000&quot;);</span>
<span class="fc" id="L1745">        responseAsciiSink.put('M');</span>
<span class="fc" id="L1746">        responseAsciiSink.encodeUtf8Z(message);</span>
<span class="fc" id="L1747">        responseAsciiSink.put('S');</span>
<span class="fc" id="L1748">        responseAsciiSink.encodeUtf8Z(&quot;ERROR&quot;);</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">        if (position &gt; -1) {</span>
<span class="fc" id="L1750">            responseAsciiSink.put('P').put(position + 1).put((char) 0);</span>
        }
<span class="fc" id="L1752">        responseAsciiSink.put((char) 0);</span>
<span class="fc" id="L1753">        responseAsciiSink.putLen(addr);</span>
<span class="fc" id="L1754">    }</span>

    //clears whole state except for characterStore because top-level batch text is using it
    private void prepareForNewBatchQuery() {
<span class="fc bfc" id="L1758" title="All 2 branches covered.">        if (completed) {</span>
<span class="fc" id="L1759">            LOG.debug().$(&quot;prepare for new query&quot;).$();</span>
<span class="fc" id="L1760">            isEmptyQuery = false;</span>
<span class="fc" id="L1761">            bindVariableService.clear();</span>
<span class="fc" id="L1762">            currentCursor = Misc.free(currentCursor);</span>
<span class="fc" id="L1763">            typesAndInsert = null;</span>
<span class="fc" id="L1764">            clearCursorAndFactory();</span>
<span class="fc" id="L1765">            rowCount = 0;</span>
<span class="fc" id="L1766">            queryTag = TAG_OK;</span>
<span class="fc" id="L1767">            queryText = null;</span>
<span class="fc" id="L1768">            wrapper = null;</span>
<span class="fc" id="L1769">            syncActions.clear();</span>
<span class="fc" id="L1770">            sendParameterDescription = false;</span>
        }
<span class="fc" id="L1772">    }</span>

    private void prepareForNewQuery() {
<span class="fc" id="L1775">        prepareForNewBatchQuery();</span>
<span class="fc" id="L1776">        characterStore.clear();</span>
<span class="fc" id="L1777">    }</span>

    private void prepareGssResponse() {
<span class="fc" id="L1780">        responseAsciiSink.put('N');</span>
<span class="fc" id="L1781">    }</span>

    private void prepareLoginOk() {
<span class="fc" id="L1784">        responseAsciiSink.put(MESSAGE_TYPE_LOGIN_RESPONSE);</span>
<span class="fc" id="L1785">        responseAsciiSink.putNetworkInt(Integer.BYTES * 2); // length of this message</span>
<span class="fc" id="L1786">        responseAsciiSink.putIntDirect(0); // response code</span>
<span class="fc" id="L1787">        prepareParams(responseAsciiSink, &quot;TimeZone&quot;, &quot;GMT&quot;);</span>
<span class="fc" id="L1788">        prepareParams(responseAsciiSink, &quot;application_name&quot;, &quot;QuestDB&quot;);</span>
<span class="fc" id="L1789">        prepareParams(responseAsciiSink, &quot;server_version&quot;, serverVersion);</span>
<span class="fc" id="L1790">        prepareParams(responseAsciiSink, &quot;integer_datetimes&quot;, &quot;on&quot;);</span>
<span class="fc" id="L1791">        prepareParams(responseAsciiSink, &quot;client_encoding&quot;, &quot;UTF8&quot;);</span>
<span class="fc" id="L1792">        prepareReadyForQuery();</span>
<span class="fc" id="L1793">    }</span>

    private void prepareLoginResponse() {
<span class="fc" id="L1796">        responseAsciiSink.put(MESSAGE_TYPE_LOGIN_RESPONSE);</span>
<span class="fc" id="L1797">        responseAsciiSink.putNetworkInt(Integer.BYTES * 2);</span>
<span class="fc" id="L1798">        responseAsciiSink.putNetworkInt(3);</span>
<span class="fc" id="L1799">    }</span>

    private void prepareNoDataMessage() {
<span class="fc" id="L1802">        responseAsciiSink.put(MESSAGE_TYPE_NO_DATA);</span>
<span class="fc" id="L1803">        responseAsciiSink.putIntDirect(INT_BYTES_X);</span>
<span class="fc" id="L1804">    }</span>

    private void prepareNonCriticalError(int position, CharSequence message) {
<span class="fc" id="L1807">        prepareErrorResponse(position, message);</span>
<span class="fc" id="L1808">        LOG.error()</span>
<span class="fc" id="L1809">                .$(&quot;error [pos=&quot;).$(position)</span>
<span class="fc" id="L1810">                .$(&quot;, msg=`&quot;).utf8(message).$('`')</span>
<span class="fc" id="L1811">                .I$();</span>
<span class="fc" id="L1812">    }</span>

    private void prepareParameterDescription() {
<span class="fc" id="L1815">        responseAsciiSink.put(MESSAGE_TYPE_PARAMETER_DESCRIPTION);</span>
<span class="fc" id="L1816">        final long l = responseAsciiSink.skip();</span>
<span class="fc" id="L1817">        final int n = bindVariableService.getIndexedVariableCount();</span>
<span class="fc" id="L1818">        responseAsciiSink.putNetworkShort((short) n);</span>
<span class="fc bfc" id="L1819" title="All 2 branches covered.">        if (n &gt; 0) {</span>
<span class="fc bfc" id="L1820" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1821">                responseAsciiSink.putIntDirect(toParamType(activeBindVariableTypes.getQuick(i)));</span>
            }
        }
<span class="fc" id="L1824">        responseAsciiSink.putLen(l);</span>
<span class="fc" id="L1825">    }</span>

    private void prepareParseComplete() {
<span class="fc" id="L1828">        responseAsciiSink.put(MESSAGE_TYPE_PARSE_COMPLETE);</span>
<span class="fc" id="L1829">        responseAsciiSink.putIntDirect(INT_BYTES_X);</span>
<span class="fc" id="L1830">    }</span>

    private void prepareQueryCanceled(CharSequence message) {
<span class="fc" id="L1833">        prepareErrorResponse(-1, message);</span>
<span class="fc" id="L1834">        LOG.info()</span>
<span class="fc" id="L1835">                .$(&quot;query cancelled [msg=`&quot;).$(message).$('`')</span>
<span class="fc" id="L1836">                .I$();</span>
<span class="fc" id="L1837">    }</span>

    private void prepareRowDescription() {
<span class="fc" id="L1840">        final RecordMetadata metadata = typesAndSelect.getFactory().getMetadata();</span>
<span class="fc" id="L1841">        ResponseAsciiSink sink = responseAsciiSink;</span>
<span class="fc" id="L1842">        sink.put(MESSAGE_TYPE_ROW_DESCRIPTION);</span>
<span class="fc" id="L1843">        final long addr = sink.skip();</span>
<span class="fc" id="L1844">        final int n = activeSelectColumnTypes.size() / 2;</span>
<span class="fc" id="L1845">        sink.putNetworkShort((short) n);</span>
<span class="fc bfc" id="L1846" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1847">            final int typeFlag = activeSelectColumnTypes.getQuick(2 * i);</span>
<span class="fc bfc" id="L1848" title="All 2 branches covered.">            final int columnType = toColumnType(ColumnType.isNull(typeFlag) ? ColumnType.STRING : typeFlag);</span>
<span class="fc" id="L1849">            sink.encodeUtf8Z(metadata.getColumnName(i));</span>
<span class="fc" id="L1850">            sink.putIntDirect(0); //tableOid ?</span>
<span class="fc" id="L1851">            sink.putNetworkShort((short) (i + 1)); //column number, starting from 1</span>
<span class="fc" id="L1852">            sink.putNetworkInt(PGOids.getTypeOid(columnType)); // type</span>
<span class="fc bfc" id="L1853" title="All 2 branches covered.">            if (ColumnType.tagOf(columnType) &lt; ColumnType.STRING) {</span>
                // type size
                // todo: cache small endian type sizes and do not check if type is valid - its coming from metadata, must be always valid
<span class="fc" id="L1856">                sink.putNetworkShort((short) ColumnType.sizeOf(columnType));</span>
            } else {
                // type size
<span class="fc" id="L1859">                sink.putNetworkShort((short) -1);</span>
            }

            //type modifier
<span class="fc" id="L1863">            sink.putIntDirect(INT_NULL_X);</span>
            // this is special behaviour for binary fields to prevent binary data being hex encoded on the wire
            // format code
<span class="fc bfc" id="L1866" title="All 2 branches covered.">            sink.putNetworkShort(ColumnType.isBinary(columnType) ? 1 : getColumnBinaryFlag(typeFlag)); // format code</span>
        }
<span class="fc" id="L1868">        sink.putLen(addr);</span>
<span class="fc" id="L1869">    }</span>

    private void prepareSslResponse() {
<span class="fc" id="L1872">        responseAsciiSink.put('N');</span>
<span class="fc" id="L1873">    }</span>

    private void processBind(long lo, long msgLimit, @Transient SqlCompiler compiler)
            throws BadProtocolException, SqlException {
<span class="fc" id="L1877">        sqlExecutionContext.getCircuitBreaker().resetTimer();</span>

        short parameterFormatCount;
        short parameterValueCount;

<span class="fc" id="L1882">        LOG.debug().$(&quot;bind&quot;).$();</span>
        // portal name
<span class="fc" id="L1884">        long hi = getStringLength(lo, msgLimit, &quot;bad portal name length [msgType='B']&quot;);</span>
<span class="fc" id="L1885">        CharSequence portalName = getPortalName(lo, hi);</span>
        // named statement
<span class="fc" id="L1887">        lo = hi + 1;</span>
<span class="fc" id="L1888">        hi = getStringLength(lo, msgLimit, &quot;bad prepared statement name length [msgType='B']&quot;);</span>
<span class="fc" id="L1889">        final CharSequence statementName = getStatementName(lo, hi);</span>

<span class="fc" id="L1891">        configureContextFromNamedStatement(statementName, compiler);</span>
<span class="fc bfc" id="L1892" title="All 2 branches covered.">        if (portalName != null) {</span>
<span class="fc" id="L1893">            configurePortal(portalName, statementName);</span>
        }

        //parameter format count
<span class="fc" id="L1897">        lo = hi + 1;</span>
<span class="fc" id="L1898">        parameterFormatCount = getShort(lo, msgLimit, &quot;could not read parameter format code count&quot;);</span>
<span class="fc" id="L1899">        lo += Short.BYTES;</span>
<span class="fc bfc" id="L1900" title="All 2 branches covered.">        if (parameterFormatCount &gt; 0) {</span>
<span class="fc bfc" id="L1901" title="All 2 branches covered.">            if (parameterFormatCount == 1) {</span>
                // same format applies to all parameters
<span class="fc" id="L1903">                bindSingleFormatForAll(lo, msgLimit, activeBindVariableTypes);</span>
<span class="fc bfc" id="L1904" title="All 2 branches covered.">            } else if (parameterFormatCount == parsePhaseBindVariableCount) {</span>
<span class="fc" id="L1905">                bindParameterFormats(lo, msgLimit, parameterFormatCount, activeBindVariableTypes);</span>
            }
        }

        // parameter value count
<span class="fc" id="L1910">        lo += parameterFormatCount * Short.BYTES;</span>
<span class="fc" id="L1911">        parameterValueCount = getShort(lo, msgLimit, &quot;could not read parameter value count&quot;);</span>

<span class="fc" id="L1913">        LOG.debug().$(&quot;binding [parameterValueCount=&quot;).$(parameterValueCount).$(&quot;, thread=&quot;).$(Thread.currentThread().getId()).$(']').$();</span>

        //we now have all parameter counts, validate them
<span class="fc" id="L1916">        validateParameterCounts(parameterFormatCount, parameterValueCount, parsePhaseBindVariableCount);</span>

<span class="fc" id="L1918">        lo += Short.BYTES;</span>

        try {
<span class="fc bfc" id="L1921" title="All 2 branches covered.">            if (parameterValueCount &gt; 0) {</span>
<span class="fc bfc" id="L1922" title="All 2 branches covered.">                if (this.parsePhaseBindVariableCount == parameterValueCount) {</span>
<span class="fc" id="L1923">                    lo = bindValuesUsingSetters(lo, msgLimit, parameterValueCount);</span>
                } else {
<span class="fc" id="L1925">                    lo = bindValuesAsStrings(lo, msgLimit, parameterValueCount);</span>
                }
            }
<span class="fc" id="L1928">        } catch (SqlException | ImplicitCastException e) {</span>
<span class="fc" id="L1929">            freeFactory();</span>
<span class="fc" id="L1930">            typesAndUpdate = Misc.free(typesAndUpdate);</span>
<span class="fc" id="L1931">            throw e;</span>
<span class="fc" id="L1932">        }</span>

<span class="fc bfc" id="L1934" title="All 2 branches covered.">        if (typesAndSelect != null) {</span>
<span class="fc" id="L1935">            bindSelectColumnFormats.clear();</span>

<span class="fc" id="L1937">            short columnFormatCodeCount = getShort(lo, msgLimit, &quot;could not read result set column format codes&quot;);</span>
<span class="fc bfc" id="L1938" title="All 2 branches covered.">            if (columnFormatCodeCount &gt; 0) {</span>

<span class="fc" id="L1940">                final RecordMetadata m = typesAndSelect.getFactory().getMetadata();</span>
<span class="fc" id="L1941">                final int columnCount = m.getColumnCount();</span>
                // apply format codes to the cursor column types
                // but check if there is message is consistent

<span class="fc" id="L1945">                final long spaceNeeded = lo + (columnFormatCodeCount + 1) * Short.BYTES;</span>
<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">                if (spaceNeeded &lt;= msgLimit) {</span>
<span class="fc" id="L1947">                    bindSelectColumnFormats.setPos(columnCount);</span>

<span class="fc bfc" id="L1949" title="All 2 branches covered.">                    if (columnFormatCodeCount == columnCount) {</span>
                        // good to go
<span class="fc bfc" id="L1951" title="All 2 branches covered.">                        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1952">                            lo += Short.BYTES;</span>
<span class="fc" id="L1953">                            final short code = getShortUnsafe(lo);</span>
<span class="fc" id="L1954">                            activeSelectColumnTypes.setQuick(2 * i, toColumnBinaryType(code, m.getColumnType(i)));</span>
<span class="fc" id="L1955">                            bindSelectColumnFormats.setQuick(i, code);</span>
<span class="fc" id="L1956">                            activeSelectColumnTypes.setQuick(2 * i + 1, 0);</span>
                        }
<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">                    } else if (columnFormatCodeCount == 1) {</span>
<span class="fc" id="L1959">                        lo += Short.BYTES;</span>
<span class="fc" id="L1960">                        final short code = getShortUnsafe(lo);</span>
<span class="fc bfc" id="L1961" title="All 2 branches covered.">                        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1962">                            activeSelectColumnTypes.setQuick(2 * i, toColumnBinaryType(code, m.getColumnType(i)));</span>
<span class="fc" id="L1963">                            bindSelectColumnFormats.setQuick(i, code);</span>
<span class="fc" id="L1964">                            activeSelectColumnTypes.setQuick(2 * i + 1, 0);</span>
                        }
<span class="fc" id="L1966">                    } else {</span>
<span class="nc" id="L1967">                        LOG.error()</span>
<span class="nc" id="L1968">                                .$(&quot;could not process column format codes [fmtCount=&quot;).$(columnFormatCodeCount)</span>
<span class="nc" id="L1969">                                .$(&quot;, columnCount=&quot;).$(columnCount)</span>
<span class="nc" id="L1970">                                .$(']').$();</span>
<span class="nc" id="L1971">                        throw BadProtocolException.INSTANCE;</span>
                    }
                } else {
<span class="nc" id="L1974">                    LOG.error()</span>
<span class="nc" id="L1975">                            .$(&quot;could not process column format codes [bufSpaceNeeded=&quot;).$(spaceNeeded)</span>
<span class="nc" id="L1976">                            .$(&quot;, bufSpaceAvail=&quot;).$(msgLimit)</span>
<span class="nc" id="L1977">                            .$(']').$();</span>
<span class="nc" id="L1978">                    throw BadProtocolException.INSTANCE;</span>
                }
<span class="pc bpc" id="L1980" title="1 of 2 branches missed.">            } else if (columnFormatCodeCount == 0) {</span>
                //if count == 0 then we've to use default and clear binary flags that might come from cached statements
<span class="fc" id="L1982">                final RecordMetadata m = typesAndSelect.getFactory().getMetadata();</span>
<span class="fc" id="L1983">                final int columnCount = m.getColumnCount();</span>
<span class="fc" id="L1984">                bindSelectColumnFormats.setPos(columnCount);</span>

<span class="fc bfc" id="L1986" title="All 2 branches covered.">                for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1987">                    activeSelectColumnTypes.setQuick(2 * i, toColumnBinaryType((short) 0, m.getColumnType(i)));</span>
<span class="fc" id="L1988">                    bindSelectColumnFormats.setQuick(i, 0);</span>
                }
            }

        }

<span class="fc" id="L1994">        syncActions.add(SYNC_BIND);</span>
<span class="fc" id="L1995">    }</span>

    private void processClose(long lo, long msgLimit) throws BadProtocolException {
<span class="fc" id="L1998">        final byte type = Unsafe.getUnsafe().getByte(lo);</span>
<span class="fc bfc" id="L1999" title="All 3 branches covered.">        switch (type) {</span>
            case 'S':
<span class="fc" id="L2001">                lo = lo + 1;</span>
<span class="fc" id="L2002">                final long hi = getStringLength(lo, msgLimit, &quot;bad prepared statement name length&quot;);</span>
<span class="fc" id="L2003">                removeNamedStatement(getStatementName(lo, hi));</span>
<span class="fc" id="L2004">                break;</span>
            case 'P':
<span class="fc" id="L2006">                lo = lo + 1;</span>
<span class="fc" id="L2007">                final long high = getStringLength(lo, msgLimit, &quot;bad prepared statement name length&quot;);</span>
<span class="fc" id="L2008">                final CharSequence portalName = getPortalName(lo, high);</span>
<span class="pc bpc" id="L2009" title="1 of 2 branches missed.">                if (portalName != null) {</span>
<span class="fc" id="L2010">                    final int index = namedPortalMap.keyIndex(portalName);</span>
<span class="pc bpc" id="L2011" title="1 of 2 branches missed.">                    if (index &lt; 0) {</span>
<span class="fc" id="L2012">                        namedPortalPool.push(namedPortalMap.valueAt(index));</span>
<span class="fc" id="L2013">                        namedPortalMap.removeAt(index);</span>
                    } else {
<span class="nc" id="L2015">                        LOG.error().$(&quot;invalid portal name [value=&quot;).$(portalName).$(']').$();</span>
<span class="nc" id="L2016">                        throw BadProtocolException.INSTANCE;</span>
                    }
<span class="fc" id="L2018">                }</span>
                break;
            default:
<span class="fc" id="L2021">                LOG.error().$(&quot;invalid type for close message [type=&quot;).$(type).$(']').$();</span>
<span class="fc" id="L2022">                throw BadProtocolException.INSTANCE;</span>
        }
<span class="fc" id="L2024">        prepareCloseComplete();</span>
<span class="fc" id="L2025">    }</span>

    private void processCompiledQuery(CompiledQuery cq) throws SqlException {
<span class="fc" id="L2028">        sqlExecutionContext.storeTelemetry(cq.getType(), TelemetryOrigin.POSTGRES);</span>

<span class="fc bfc" id="L2030" title="All 14 branches covered.">        switch (cq.getType()) {</span>
            case CompiledQuery.CREATE_TABLE_AS_SELECT:
<span class="fc" id="L2032">                queryTag = TAG_CTAS;</span>
<span class="fc" id="L2033">                rowCount = cq.getAffectedRowsCount();</span>
<span class="fc" id="L2034">                break;</span>
            case CompiledQuery.EXPLAIN:
                //explain results should not be cached 
<span class="fc" id="L2037">                typesAndSelectIsCached = false;</span>
<span class="fc" id="L2038">                typesAndSelect = typesAndSelectPool.pop();</span>
<span class="fc" id="L2039">                typesAndSelect.of(cq.getRecordCursorFactory(), bindVariableService);</span>
<span class="fc" id="L2040">                queryTag = TAG_EXPLAIN;</span>
            case CompiledQuery.SELECT:
<span class="fc" id="L2042">                typesAndSelect = typesAndSelectPool.pop();</span>
<span class="fc" id="L2043">                typesAndSelect.of(cq.getRecordCursorFactory(), bindVariableService);</span>
<span class="fc" id="L2044">                queryTag = TAG_SELECT;</span>
<span class="fc" id="L2045">                LOG.debug().$(&quot;cache select [sql=&quot;).$(queryText).$(&quot;, thread=&quot;).$(Thread.currentThread().getId()).$(']').$();</span>
<span class="fc" id="L2046">                break;</span>
            case CompiledQuery.INSERT:
<span class="fc" id="L2048">                queryTag = TAG_INSERT;</span>
<span class="fc" id="L2049">                typesAndInsert = typesAndInsertPool.pop();</span>
<span class="fc" id="L2050">                typesAndInsert.of(cq.getInsertOperation(), bindVariableService);</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">                if (bindVariableService.getIndexedVariableCount() &gt; 0) {</span>
<span class="fc" id="L2052">                    LOG.debug().$(&quot;cache insert [sql=&quot;).$(queryText).$(&quot;, thread=&quot;).$(Thread.currentThread().getId()).$(']').$();</span>
                    // we can add insert to cache right away because it is local to the connection
<span class="fc" id="L2054">                    typesAndInsertCache.put(queryText, typesAndInsert);</span>
                }
                break;
            case CompiledQuery.UPDATE:
<span class="fc" id="L2058">                queryTag = TAG_UPDATE;</span>
<span class="fc" id="L2059">                typesAndUpdate = typesAndUpdatePool.pop();</span>
<span class="fc" id="L2060">                typesAndUpdate.of(cq, bindVariableService);</span>
<span class="fc bfc" id="L2061" title="All 2 branches covered.">                typesAndUpdateIsCached = bindVariableService.getIndexedVariableCount() &gt; 0;</span>
<span class="fc" id="L2062">                break;</span>
            case CompiledQuery.INSERT_AS_SELECT:
<span class="fc" id="L2064">                queryTag = TAG_INSERT;</span>
<span class="fc" id="L2065">                rowCount = cq.getAffectedRowsCount();</span>
<span class="fc" id="L2066">                break;</span>
            case CompiledQuery.COPY_LOCAL:
<span class="fc" id="L2068">                final RecordCursorFactory factory = cq.getRecordCursorFactory();</span>
                // factory is null in the COPY 'id' CANCEL; case
<span class="fc bfc" id="L2070" title="All 2 branches covered.">                if (factory != null) {</span>
                    // this query is non-cacheable
<span class="fc" id="L2072">                    typesAndSelectIsCached = false;</span>
<span class="fc" id="L2073">                    typesAndSelect = typesAndSelectPool.pop();</span>
<span class="fc" id="L2074">                    typesAndSelect.of(cq.getRecordCursorFactory(), bindVariableService);</span>
                }
<span class="fc" id="L2076">                queryTag = TAG_COPY;</span>
<span class="fc" id="L2077">                break;</span>
            case CompiledQuery.SET:
<span class="fc" id="L2079">                queryTag = TAG_SET;</span>
<span class="fc" id="L2080">                break;</span>
            case CompiledQuery.DEALLOCATE:
<span class="fc" id="L2082">                queryTag = TAG_DEALLOCATE;</span>
<span class="fc" id="L2083">                removeNamedStatement(cq.getStatementName());</span>
<span class="fc" id="L2084">                break;</span>
            case CompiledQuery.BEGIN:
<span class="fc" id="L2086">                queryTag = TAG_BEGIN;</span>
<span class="fc" id="L2087">                transactionState = IN_TRANSACTION;</span>
<span class="fc" id="L2088">                break;</span>
            case CompiledQuery.COMMIT:
<span class="fc" id="L2090">                queryTag = TAG_COMMIT;</span>
<span class="fc bfc" id="L2091" title="All 2 branches covered.">                if (transactionState != ERROR_TRANSACTION) {</span>
<span class="fc" id="L2092">                    transactionState = COMMIT_TRANSACTION;</span>
                }
                break;
            case CompiledQuery.ROLLBACK:
<span class="fc" id="L2096">                queryTag = TAG_ROLLBACK;</span>
<span class="fc" id="L2097">                transactionState = ROLLING_BACK_TRANSACTION;</span>
<span class="fc" id="L2098">                break;</span>
            case CompiledQuery.ALTER:
                // future-proofing ALTER execution
<span class="fc" id="L2101">                try (OperationFuture fut = cq.execute(sqlExecutionContext, tempSequence, true)) {</span>
<span class="fc" id="L2102">                    fut.await();</span>
                }
                // fall thru
            default:
                // DDL
<span class="fc" id="L2107">                queryTag = TAG_OK;</span>
                break;
        }
<span class="fc" id="L2110">    }</span>

    private void processDescribe(long lo, long msgLimit, @Transient SqlCompiler compiler)
            throws SqlException, BadProtocolException {
<span class="fc" id="L2114">        sqlExecutionContext.getCircuitBreaker().resetTimer();</span>

<span class="fc bfc" id="L2116" title="All 2 branches covered.">        boolean isPortal = Unsafe.getUnsafe().getByte(lo) == 'P';</span>
<span class="fc" id="L2117">        long hi = getStringLength(lo + 1, msgLimit, &quot;bad prepared statement name length&quot;);</span>

<span class="fc" id="L2119">        CharSequence target = getPortalName(lo + 1, hi);</span>
<span class="fc" id="L2120">        LOG.debug().$(&quot;describe [name=&quot;).$(target).$(']').$();</span>
<span class="fc bfc" id="L2121" title="All 4 branches covered.">        if (isPortal &amp;&amp; target != null) {</span>
<span class="fc" id="L2122">            Portal p = namedPortalMap.get(target);</span>
<span class="pc bpc" id="L2123" title="1 of 2 branches missed.">            if (p != null) {</span>
<span class="fc" id="L2124">                target = p.statementName;</span>
            } else {
<span class="nc" id="L2126">                LOG.error().$(&quot;invalid portal [name=&quot;).$(target).$(']').$();</span>
<span class="nc" id="L2127">                throw BadProtocolException.INSTANCE;</span>
            }
        }

<span class="fc" id="L2131">        configureContextFromNamedStatement(target, compiler);</span>

        // initialize activeBindVariableTypes from bind variable service
<span class="fc" id="L2134">        final int n = bindVariableService.getIndexedVariableCount();</span>
<span class="fc bfc" id="L2135" title="All 6 branches covered.">        if (sendParameterDescription &amp;&amp; n &gt; 0 &amp;&amp; activeBindVariableTypes.size() == 0) {</span>
<span class="fc" id="L2136">            activeBindVariableTypes.setPos(n);</span>
<span class="fc bfc" id="L2137" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2138">                activeBindVariableTypes.setQuick(i, Numbers.bswap(PGOids.getTypeOid(bindVariableService.getFunction(i).getType())));</span>
            }
        }
<span class="fc bfc" id="L2141" title="All 2 branches covered.">        if (isPortal) {</span>
<span class="fc" id="L2142">            syncActions.add(SYNC_DESCRIBE_PORTAL);</span>
        } else {
<span class="fc" id="L2144">            syncActions.add(SYNC_DESCRIBE);</span>
        }
<span class="fc" id="L2146">    }</span>

    private void processExec(
            long lo,
            long msgLimit,
            SqlCompiler compiler
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, QueryPausedException, BadProtocolException, SqlException {
<span class="fc" id="L2153">        sqlExecutionContext.getCircuitBreaker().resetTimer();</span>

<span class="fc" id="L2155">        final long hi = getStringLength(lo, msgLimit, &quot;bad portal name length&quot;);</span>
<span class="fc" id="L2156">        final CharSequence portalName = getPortalName(lo, hi);</span>
<span class="fc bfc" id="L2157" title="All 2 branches covered.">        if (portalName != null) {</span>
<span class="fc" id="L2158">            LOG.info().$(&quot;execute portal [name=&quot;).$(portalName).$(']').$();</span>
        }

<span class="fc" id="L2161">        lo = hi + 1;</span>
<span class="fc" id="L2162">        final int maxRows = getInt(lo, msgLimit, &quot;could not read max rows value&quot;);</span>

<span class="fc" id="L2164">        processSyncActions();</span>
<span class="fc" id="L2165">        processExecute(maxRows, compiler);</span>
<span class="fc" id="L2166">        wrapper = null;</span>
<span class="fc" id="L2167">    }</span>

    private void processExecute(
            int maxRows,
            SqlCompiler compiler
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, QueryPausedException, SqlException {
<span class="fc bfc" id="L2173" title="All 2 branches covered.">        if (typesAndSelect != null) {</span>
<span class="fc" id="L2174">            LOG.debug().$(&quot;executing query&quot;).$();</span>
<span class="fc" id="L2175">            setupFactoryAndCursor(compiler);</span>
<span class="fc" id="L2176">            sendCursor(maxRows, resumeCursorExecuteRef, resumeCommandCompleteRef);</span>
<span class="fc bfc" id="L2177" title="All 2 branches covered.">        } else if (typesAndInsert != null) {</span>
<span class="fc" id="L2178">            LOG.debug().$(&quot;executing insert&quot;).$();</span>
<span class="fc" id="L2179">            executeInsert(compiler);</span>
<span class="fc bfc" id="L2180" title="All 2 branches covered.">        } else if (typesAndUpdate != null) {</span>
<span class="fc" id="L2181">            LOG.debug().$(&quot;executing update&quot;).$();</span>
<span class="fc" id="L2182">            executeUpdate(compiler);</span>
        } else { // this must be an OK/SET/COMMIT/ROLLBACK or empty query
<span class="fc" id="L2184">            executeTag();</span>
<span class="fc" id="L2185">            prepareCommandComplete(false);</span>
        }
<span class="fc" id="L2187">    }</span>

    private void processInitialMessage(long address, int len) throws PeerDisconnectedException, PeerIsSlowToReadException, BadProtocolException {
        int msgLen;
        long msgLimit;// expect startup request
<span class="fc bfc" id="L2192" title="All 2 branches covered.">        if (len &lt; Long.BYTES) {</span>
<span class="fc" id="L2193">            return;</span>
        }

        // there is data for length
        // this is quite specific to message type :(
<span class="fc" id="L2198">        msgLen = getIntUnsafe(address); // postgresql includes length bytes in length of message</span>

        // do we have the rest of the message?
<span class="fc bfc" id="L2201" title="All 2 branches covered.">        if (msgLen &gt; len) {</span>
            // we have length - get the rest when ready
<span class="fc" id="L2203">            return;</span>
        }

        // enough to read login request
<span class="fc" id="L2207">        recvBufferReadOffset += msgLen;</span>

        // consume message
        // process protocol
<span class="fc" id="L2211">        int protocol = getIntUnsafe(address + Integer.BYTES);</span>
<span class="pc bpc" id="L2212" title="2 of 5 branches missed.">        switch (protocol) {</span>
            case INIT_SSL_REQUEST:
                // SSLRequest
<span class="fc" id="L2215">                prepareSslResponse();</span>
<span class="fc" id="L2216">                sendAndReset();</span>
<span class="fc" id="L2217">                return;</span>
            case INIT_GSS_REQUEST:
                // GSSENCRequest
<span class="fc" id="L2220">                prepareGssResponse();</span>
<span class="fc" id="L2221">                sendAndReset();</span>
<span class="fc" id="L2222">                return;</span>
            case INIT_STARTUP_MESSAGE:
                // StartupMessage
                // extract properties
<span class="fc" id="L2226">                requireInitialMessage = false;</span>
<span class="fc" id="L2227">                msgLimit = address + msgLen;</span>
<span class="fc" id="L2228">                long lo = address + Long.BYTES;</span>
                // there is an extra byte at the end and it has to be 0
<span class="fc" id="L2230">                LOG.info()</span>
<span class="fc" id="L2231">                        .$(&quot;protocol [major=&quot;).$(protocol &gt;&gt; 16)</span>
<span class="fc" id="L2232">                        .$(&quot;, minor=&quot;).$((short) protocol)</span>
<span class="fc" id="L2233">                        .$(']').$();</span>

<span class="fc bfc" id="L2235" title="All 2 branches covered.">                while (lo &lt; msgLimit - 1) {</span>

<span class="fc" id="L2237">                    final long nameLo = lo;</span>
<span class="fc" id="L2238">                    final long nameHi = getStringLength(lo, msgLimit, &quot;malformed property name&quot;);</span>
<span class="fc" id="L2239">                    final long valueLo = nameHi + 1;</span>
<span class="fc" id="L2240">                    final long valueHi = getStringLength(valueLo, msgLimit, &quot;malformed property value&quot;);</span>
<span class="fc" id="L2241">                    lo = valueHi + 1;</span>

                    // store user
<span class="fc" id="L2244">                    dbcs.of(nameLo, nameHi);</span>
<span class="fc" id="L2245">                    boolean parsed = true;</span>
<span class="fc bfc" id="L2246" title="All 2 branches covered.">                    if (Chars.equals(dbcs, &quot;user&quot;)) {</span>
<span class="fc" id="L2247">                        CharacterStoreEntry e = characterStore.newEntry();</span>
<span class="fc" id="L2248">                        e.put(dbcs.of(valueLo, valueHi));</span>
<span class="fc" id="L2249">                        this.username = e.toImmutable();</span>
                    }

                    // store statement_timeout
<span class="fc bfc" id="L2253" title="All 2 branches covered.">                    if (Chars.equals(dbcs, &quot;options&quot;)) {</span>
<span class="fc" id="L2254">                        dbcs.of(valueLo, valueHi);</span>
<span class="fc bfc" id="L2255" title="All 2 branches covered.">                        if (Chars.startsWith(dbcs, &quot;-c statement_timeout=&quot;)) {</span>
                            try {
<span class="fc" id="L2257">                                this.statementTimeout = Numbers.parseLong(dbcs.of(valueLo + &quot;-c statement_timeout=&quot;.length(), valueHi));</span>
<span class="pc bpc" id="L2258" title="1 of 2 branches missed.">                                if (this.statementTimeout &gt; 0) {</span>
<span class="fc" id="L2259">                                    circuitBreaker.setTimeout(statementTimeout);</span>
                                }
<span class="nc" id="L2261">                            } catch (NumericException ex) {</span>
<span class="nc" id="L2262">                                parsed = false;</span>
<span class="pc" id="L2263">                            }</span>
                        } else {
<span class="fc" id="L2265">                            parsed = false;</span>
                        }
                    }

<span class="fc bfc" id="L2269" title="All 2 branches covered.">                    if (parsed) {</span>
<span class="fc" id="L2270">                        LOG.debug().$(&quot;property [name=&quot;).$(dbcs.of(nameLo, nameHi)).$(&quot;, value=&quot;).$(dbcs.of(valueLo, valueHi)).$(']').$();</span>
                    } else {
<span class="fc" id="L2272">                        LOG.info().$(&quot;invalid property [name=&quot;).$(dbcs.of(nameLo, nameHi)).$(&quot;, value=&quot;).$(dbcs.of(valueLo, valueHi)).$(']').$();</span>
                    }
<span class="fc" id="L2274">                }</span>

<span class="fc" id="L2276">                characterStore.clear();</span>

<span class="pc bpc" id="L2278" title="1 of 2 branches missed.">                assertTrue(this.username != null, &quot;user is not specified&quot;);</span>
<span class="fc" id="L2279">                prepareLoginResponse();</span>
<span class="fc" id="L2280">                sendAndReset();</span>
<span class="fc" id="L2281">                break;</span>
            case INIT_CANCEL_REQUEST:
                //todo - 1. do not disconnect
                //       2. should cancel running query only if PID and secret provided are the same as the ones provided upon logon
                //       3. send back error message (e) for the cancelled running query
<span class="nc" id="L2286">                LOG.info().$(&quot;cancel request&quot;).$();</span>
<span class="nc" id="L2287">                throw PeerDisconnectedException.INSTANCE;</span>
            default:
<span class="nc" id="L2289">                LOG.error().$(&quot;unknown init message [protocol=&quot;).$(protocol).$(']').$();</span>
<span class="nc" id="L2290">                throw BadProtocolException.INSTANCE;</span>
        }
<span class="fc" id="L2292">    }</span>

    private void processParse(long address, long lo, long msgLimit, @Transient SqlCompiler compiler) throws BadProtocolException, SqlException {
<span class="fc" id="L2295">        sqlExecutionContext.getCircuitBreaker().resetTimer();</span>

        // make sure there are no left-over sync actions
        // we are starting a new iteration of the parse
<span class="fc" id="L2299">        syncActions.clear();</span>

        // 'Parse'
        //message length
<span class="fc" id="L2303">        long hi = getStringLength(lo, msgLimit, &quot;bad prepared statement name length&quot;);</span>

        // When we encounter statement name in the &quot;parse&quot; message
        // we need to ensure the wrapper is properly setup to deal with
        // &quot;describe&quot;, &quot;bind&quot; message sequence that will follow next.
        // In that all parameter types that we need to infer will have to be added to the
        // &quot;bindVariableTypes&quot; list.
        // Perhaps this is a good idea to make named statement writer a part of the context
<span class="fc" id="L2311">        final CharSequence statementName = getStatementName(lo, hi);</span>

        //query text
<span class="fc" id="L2314">        lo = hi + 1;</span>
<span class="fc" id="L2315">        hi = getStringLength(lo, msgLimit, &quot;bad query text length&quot;);</span>
        //TODO: parsePhaseBindVariableCount have to be checked before parseQueryText and fed into it to serve as type hints !
<span class="fc" id="L2317">        parseQueryText(lo, hi, compiler);</span>

        //parameter type count
<span class="fc" id="L2320">        lo = hi + 1;</span>
<span class="fc" id="L2321">        this.parsePhaseBindVariableCount = getShort(lo, msgLimit, &quot;could not read parameter type count&quot;);</span>

<span class="fc bfc" id="L2323" title="All 2 branches covered.">        if (statementName != null) {</span>
<span class="fc" id="L2324">            LOG.info().$(&quot;prepare [name=&quot;).$(statementName).$(']').$();</span>
<span class="fc" id="L2325">            configurePreparedStatement(statementName);</span>
        } else {
<span class="fc" id="L2327">            this.activeBindVariableTypes = bindVariableTypes;</span>
<span class="fc" id="L2328">            this.activeSelectColumnTypes = selectColumnTypes;</span>
        }

        //process parameter types
<span class="fc bfc" id="L2332" title="All 2 branches covered.">        if (this.parsePhaseBindVariableCount &gt; 0) {</span>
<span class="fc bfc" id="L2333" title="All 2 branches covered.">            if (lo + Short.BYTES + this.parsePhaseBindVariableCount * 4L &gt; msgLimit) {</span>
<span class="fc" id="L2334">                LOG.error()</span>
<span class="fc" id="L2335">                        .$(&quot;could not read parameters [parameterCount=&quot;).$(this.parsePhaseBindVariableCount)</span>
<span class="fc" id="L2336">                        .$(&quot;, offset=&quot;).$(lo - address)</span>
<span class="fc" id="L2337">                        .$(&quot;, remaining=&quot;).$(msgLimit - lo)</span>
<span class="fc" id="L2338">                        .$(']').$();</span>
<span class="fc" id="L2339">                throw BadProtocolException.INSTANCE;</span>
            }

<span class="fc" id="L2342">            LOG.debug().$(&quot;params [count=&quot;).$(this.parsePhaseBindVariableCount).$(']').$();</span>
<span class="fc" id="L2343">            setupBindVariables(lo + Short.BYTES, activeBindVariableTypes, this.parsePhaseBindVariableCount);</span>
<span class="fc bfc" id="L2344" title="All 2 branches covered.">        } else if (this.parsePhaseBindVariableCount &lt; 0) {</span>
<span class="fc" id="L2345">            LOG.error()</span>
<span class="fc" id="L2346">                    .$(&quot;invalid parameter count [parameterCount=&quot;).$(this.parsePhaseBindVariableCount)</span>
<span class="fc" id="L2347">                    .$(&quot;, offset=&quot;).$(lo - address)</span>
<span class="fc" id="L2348">                    .$(']').$();</span>
<span class="fc" id="L2349">            throw BadProtocolException.INSTANCE;</span>
        }

<span class="fc bfc" id="L2352" title="All 2 branches covered.">        if (typesAndSelect != null) {</span>
<span class="fc" id="L2353">            buildSelectColumnTypes();</span>
        }

<span class="fc" id="L2356">        syncActions.add(SYNC_PARSE);</span>
<span class="fc" id="L2357">    }</span>

    // processes one or more queries (batch/script). &quot;Simple Query&quot; in PostgreSQL docs.
    private void processQuery(
            long lo,
            long limit,
            @Transient SqlCompiler compiler
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, QueryPausedException, BadProtocolException {
<span class="fc" id="L2365">        prepareForNewQuery();</span>
<span class="fc" id="L2366">        CharacterStoreEntry e = characterStore.newEntry();</span>

<span class="pc bpc" id="L2368" title="1 of 2 branches missed.">        if (Chars.utf8Decode(lo, limit - 1, e)) {</span>
<span class="fc" id="L2369">            queryText = characterStore.toImmutable();</span>
            try {
<span class="fc" id="L2371">                compiler.compileBatch(queryText, sqlExecutionContext, batchCallback);</span>
                // we need to continue parsing receive buffer even if we errored out
                // this is because PG client might expect separate responses to everything it sent
<span class="fc" id="L2374">            } catch (SqlException ex) {</span>
<span class="fc" id="L2375">                prepareNonCriticalError(ex.getPosition(), ex.getFlyweightMessage());</span>
<span class="fc" id="L2376">            } catch (CairoException ex) {</span>
<span class="fc bfc" id="L2377" title="All 2 branches covered.">                if (ex.isInterruption()) {</span>
<span class="fc" id="L2378">                    prepareQueryCanceled(ex.getFlyweightMessage());</span>
                } else {
<span class="fc" id="L2380">                    prepareError(ex);</span>
                }
<span class="fc" id="L2382">            }</span>
        } else {
<span class="nc" id="L2384">            LOG.error().$(&quot;invalid UTF8 bytes in parse query&quot;).$();</span>
<span class="nc" id="L2385">            throw BadProtocolException.INSTANCE;</span>
        }
<span class="fc" id="L2387">        sendReadyForNewQuery();</span>
<span class="fc" id="L2388">    }</span>

    private void processSyncActions() {
        try {
<span class="fc bfc" id="L2392" title="All 2 branches covered.">            for (int i = 0, n = syncActions.size(); i &lt; n; i++) {</span>
<span class="pc bpc" id="L2393" title="1 of 5 branches missed.">                switch (syncActions.getQuick(i)) {</span>
                    case SYNC_PARSE:
<span class="fc" id="L2395">                        prepareParseComplete();</span>
<span class="fc" id="L2396">                        break;</span>
                    case SYNC_DESCRIBE:
<span class="fc" id="L2398">                        prepareDescribeResponse();</span>
<span class="fc" id="L2399">                        break;</span>
                    case SYNC_BIND:
<span class="fc" id="L2401">                        prepareBindComplete();</span>
<span class="fc" id="L2402">                        break;</span>
                    case SYNC_DESCRIBE_PORTAL:
<span class="fc" id="L2404">                        prepareDescribePortalResponse();</span>
                        break;
                }
            }
        } finally {
<span class="fc" id="L2409">            syncActions.clear();</span>
        }
<span class="fc" id="L2411">    }</span>

    private void putGeoHashStringByteValue(Record rec, int col, int bitFlags) {
<span class="fc" id="L2414">        byte l = rec.getGeoByte(col);</span>
<span class="fc" id="L2415">        putGeoHashStringValue(l, bitFlags);</span>
<span class="fc" id="L2416">    }</span>

    private void putGeoHashStringIntValue(Record rec, int col, int bitFlags) {
<span class="fc" id="L2419">        int l = rec.getGeoInt(col);</span>
<span class="fc" id="L2420">        putGeoHashStringValue(l, bitFlags);</span>
<span class="fc" id="L2421">    }</span>

    private void putGeoHashStringLongValue(Record rec, int col, int bitFlags) {
<span class="fc" id="L2424">        long l = rec.getGeoLong(col);</span>
<span class="fc" id="L2425">        putGeoHashStringValue(l, bitFlags);</span>
<span class="fc" id="L2426">    }</span>

    private void putGeoHashStringShortValue(Record rec, int col, int bitFlags) {
<span class="fc" id="L2429">        short l = rec.getGeoShort(col);</span>
<span class="fc" id="L2430">        putGeoHashStringValue(l, bitFlags);</span>
<span class="fc" id="L2431">    }</span>

    private void putGeoHashStringValue(long value, int bitFlags) {
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">        if (value == GeoHashes.NULL) {</span>
<span class="nc" id="L2435">            responseAsciiSink.setNullValue();</span>
        } else {
<span class="fc" id="L2437">            final long a = responseAsciiSink.skip();</span>
<span class="fc bfc" id="L2438" title="All 2 branches covered.">            if (bitFlags &lt; 0) {</span>
<span class="fc" id="L2439">                GeoHashes.appendCharsUnsafe(value, -bitFlags, responseAsciiSink);</span>
            } else {
<span class="fc" id="L2441">                GeoHashes.appendBinaryStringUnsafe(value, bitFlags, responseAsciiSink);</span>
            }
<span class="fc" id="L2443">            responseAsciiSink.putLenEx(a);</span>
        }
<span class="fc" id="L2445">    }</span>

    private void removeNamedStatement(CharSequence statementName) {
<span class="pc bpc" id="L2448" title="1 of 2 branches missed.">        if (statementName != null) {</span>
<span class="fc" id="L2449">            final int index = namedStatementMap.keyIndex(statementName);</span>
            // do not freak out if client is closing statement we don't have
            // we could have reported error to client before statement was created
<span class="fc bfc" id="L2452" title="All 2 branches covered.">            if (index &lt; 0) {</span>
<span class="fc" id="L2453">                namedStatementWrapperPool.push(namedStatementMap.valueAt(index));</span>
<span class="fc" id="L2454">                namedStatementMap.removeAt(index);</span>
            }
        }
<span class="fc" id="L2457">    }</span>

    private void reportError(CairoException ex) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L2460">        prepareError(ex);</span>
<span class="fc" id="L2461">        sendReadyForNewQuery();</span>
<span class="fc" id="L2462">        clearRecvBuffer();</span>
<span class="fc" id="L2463">    }</span>

    private void reportNonCriticalError(int position, CharSequence flyweightMessage)
            throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L2467">        prepareNonCriticalError(position, flyweightMessage);</span>
<span class="fc" id="L2468">        sendReadyForNewQuery();</span>
<span class="fc" id="L2469">        clearRecvBuffer();</span>
<span class="fc" id="L2470">    }</span>

    private void reportQueryCancelled(CharSequence flyweightMessage)
            throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L2474">        prepareQueryCanceled(flyweightMessage);</span>
<span class="fc" id="L2475">        sendReadyForNewQuery();</span>
<span class="fc" id="L2476">        clearRecvBuffer();</span>
<span class="fc" id="L2477">    }</span>

    private void resumeCommandComplete(boolean queryWasPaused) {
<span class="nc" id="L2480">        prepareCommandComplete(true);</span>
<span class="nc" id="L2481">    }</span>

    private void resumeCursorExecute(boolean queryWasPaused) throws PeerDisconnectedException, PeerIsSlowToReadException, QueryPausedException, SqlException {
<span class="fc" id="L2484">        final Record record = currentCursor.getRecord();</span>
<span class="fc" id="L2485">        final int columnCount = currentFactory.getMetadata().getColumnCount();</span>
<span class="fc bfc" id="L2486" title="All 2 branches covered.">        if (!queryWasPaused) {</span>
            // We resume after no space left in buffer,
            // so we have to write the last record to the buffer once again.
<span class="fc" id="L2489">            appendSingleRecord(record, columnCount);</span>
        }
<span class="fc" id="L2491">        responseAsciiSink.bookmark();</span>
<span class="fc" id="L2492">        sendCursor0(record, columnCount, resumeCommandCompleteRef);</span>
<span class="fc" id="L2493">    }</span>

    private void resumeCursorQuery(boolean queryWasPaused) throws PeerDisconnectedException, PeerIsSlowToReadException, QueryPausedException, SqlException {
<span class="fc" id="L2496">        resumeCursorQuery0(queryWasPaused);</span>
<span class="fc" id="L2497">        sendReadyForNewQuery();</span>
<span class="fc" id="L2498">    }</span>

    private void resumeCursorQuery0(boolean queryWasPaused) throws PeerDisconnectedException, PeerIsSlowToReadException, QueryPausedException, SqlException {
<span class="fc" id="L2501">        final Record record = currentCursor.getRecord();</span>
<span class="fc" id="L2502">        final int columnCount = currentFactory.getMetadata().getColumnCount();</span>
<span class="pc bpc" id="L2503" title="1 of 2 branches missed.">        if (!queryWasPaused) {</span>
            // We resume after no space left in buffer,
            // so we have to write the last record to the buffer once again.
<span class="nc" id="L2506">            appendSingleRecord(record, columnCount);</span>
        }
<span class="fc" id="L2508">        responseAsciiSink.bookmark();</span>
<span class="fc" id="L2509">        sendCursor0(record, columnCount, resumeQueryCompleteRef);</span>
<span class="fc" id="L2510">    }</span>

    private void resumeQueryComplete(boolean queryWasPaused) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="nc" id="L2513">        prepareCommandComplete(true);</span>
<span class="nc" id="L2514">        sendReadyForNewQuery();</span>
<span class="nc" id="L2515">    }</span>

    private void sendAndReset() throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L2518">        doSend(0, (int) (sendBufferPtr - sendBuffer));</span>
<span class="fc" id="L2519">        responseAsciiSink.reset();</span>
<span class="fc" id="L2520">    }</span>

    // This method is currently unused. it's used for the COPY sub-protocol, which is currently not implemented.
    // It's left here so when we add the sub-protocol later we won't need to reimplemented it.
    // We could keep it just in git history, but chances are nobody would recall to search for it there
    private void sendCopyInResponse(CairoEngine engine, TextLoader textLoader) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="nc" id="L2526">        TableToken tableToken = engine.getTableTokenIfExists(textLoader.getTableName());</span>
<span class="nc" id="L2527">        if (</span>
<span class="nc bnc" id="L2528" title="All 2 branches missed.">                TableUtils.TABLE_EXISTS == engine.getStatus(</span>
<span class="nc" id="L2529">                        sqlExecutionContext.getCairoSecurityContext(),</span>
                        path,
                        tableToken
                )
        ) {
<span class="nc" id="L2534">            responseAsciiSink.put(MESSAGE_TYPE_COPY_IN_RESPONSE);</span>
<span class="nc" id="L2535">            long addr = responseAsciiSink.skip();</span>
<span class="nc" id="L2536">            responseAsciiSink.put((byte) 0); // TEXT (1=BINARY, which we do not support yet)</span>

<span class="nc" id="L2538">            try (TableWriter writer = engine.getWriter(sqlExecutionContext.getCairoSecurityContext(), tableToken, WRITER_LOCK_REASON)) {</span>
<span class="nc" id="L2539">                RecordMetadata metadata = writer.getMetadata();</span>
<span class="nc" id="L2540">                responseAsciiSink.putNetworkShort((short) metadata.getColumnCount());</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">                for (int i = 0, n = metadata.getColumnCount(); i &lt; n; i++) {</span>
<span class="nc" id="L2542">                    responseAsciiSink.putNetworkShort((short) PGOids.getTypeOid(metadata.getColumnType(i)));</span>
                }
            }
<span class="nc" id="L2545">            responseAsciiSink.putLen(addr);</span>
<span class="nc" id="L2546">        } else {</span>
<span class="nc" id="L2547">            final SqlException e = SqlException.$(0, &quot;table does not exist [table=&quot;).put(textLoader.getTableName()).put(']');</span>
<span class="nc" id="L2548">            prepareNonCriticalError(e.getPosition(), e.getFlyweightMessage());</span>
<span class="nc" id="L2549">            prepareReadyForQuery();</span>
        }
<span class="nc" id="L2551">        sendAndReset();</span>
<span class="nc" id="L2552">    }</span>

    private void sendCursor(
            int maxRows,
            PGResumeProcessor cursorResumeProcessor,
            PGResumeProcessor commandCompleteResumeProcessor
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, QueryPausedException, SqlException {
        // the assumption for now is that any record will fit into response buffer. This of course precludes us from
        // streaming large BLOBs, but, and it's a big one, PostgreSQL protocol for DataRow does not allow for
        // streaming anyway. On top of that Java PostgreSQL driver downloads data row fully. This simplifies our
        // approach for general queries. For streaming protocol we will code something else. PostgreSQL Java driver is
        // slow anyway.

<span class="fc" id="L2565">        rowCount = 0;</span>
<span class="fc" id="L2566">        final Record record = currentCursor.getRecord();</span>
<span class="fc" id="L2567">        final RecordMetadata metadata = currentFactory.getMetadata();</span>
<span class="fc" id="L2568">        final int columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L2569">        final long cursorRowCount = currentCursor.size();</span>
<span class="fc bfc" id="L2570" title="All 2 branches covered.">        if (maxRows &gt; 0) {</span>
<span class="fc bfc" id="L2571" title="All 2 branches covered.">            this.maxRows = cursorRowCount &gt; 0 ? Long.min(maxRows, cursorRowCount) : maxRows;</span>
        } else {
<span class="fc" id="L2573">            this.maxRows = Long.MAX_VALUE;</span>
        }
<span class="fc" id="L2575">        resumeProcessor = cursorResumeProcessor;</span>
<span class="fc" id="L2576">        responseAsciiSink.bookmark();</span>
<span class="fc" id="L2577">        sendCursor0(record, columnCount, commandCompleteResumeProcessor);</span>
<span class="fc" id="L2578">    }</span>

    private void sendCursor0(
            Record record,
            int columnCount,
            PGResumeProcessor commandCompleteResumeProcessor
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, QueryPausedException, SqlException {
<span class="fc bfc" id="L2585" title="All 2 branches covered.">        if (!circuitBreaker.isTimerSet()) {</span>
<span class="fc" id="L2586">            circuitBreaker.resetTimer();</span>
        }

        try {
<span class="fc bfc" id="L2590" title="All 2 branches covered.">            while (currentCursor.hasNext()) {</span>
                try {
                    try {
<span class="fc" id="L2593">                        appendRecord(record, columnCount);</span>
<span class="fc" id="L2594">                        responseAsciiSink.bookmark();</span>
<span class="fc" id="L2595">                    } catch (NoSpaceLeftInResponseBufferException e) {</span>
<span class="fc" id="L2596">                        responseAsciiSink.resetToBookmark();</span>
<span class="fc" id="L2597">                        sendAndReset();</span>
<span class="fc" id="L2598">                        appendSingleRecord(record, columnCount);</span>
<span class="fc" id="L2599">                        responseAsciiSink.bookmark();</span>
<span class="fc" id="L2600">                    }</span>
<span class="fc bfc" id="L2601" title="All 2 branches covered.">                    if (rowCount &gt;= maxRows) {</span>
<span class="fc" id="L2602">                        break;</span>
                    }
<span class="fc" id="L2604">                } catch (SqlException e) {</span>
<span class="fc" id="L2605">                    clearCursorAndFactory();</span>
<span class="fc" id="L2606">                    responseAsciiSink.resetToBookmark();</span>
<span class="fc" id="L2607">                    throw e;</span>
<span class="fc" id="L2608">                }</span>
            }
<span class="fc" id="L2610">        } catch (DataUnavailableException e) {</span>
<span class="fc" id="L2611">            isPausedQuery = true;</span>
<span class="fc" id="L2612">            responseAsciiSink.resetToBookmark();</span>
<span class="fc" id="L2613">            throw QueryPausedException.instance(e.getEvent(), sqlExecutionContext.getCircuitBreaker());</span>
<span class="fc" id="L2614">        }</span>

<span class="pc bpc" id="L2616" title="1 of 4 branches missed.">        completed = maxRows &lt;= 0 || rowCount &lt; maxRows;</span>
<span class="fc bfc" id="L2617" title="All 2 branches covered.">        if (completed) {</span>
<span class="fc" id="L2618">            clearCursorAndFactory();</span>
            // at this point buffer can contain unsent data,
            // and it may not have enough space for the command
<span class="fc bfc" id="L2621" title="All 2 branches covered.">            if (sendBufferLimit - sendBufferPtr &lt; PROTOCOL_TAIL_COMMAND_LENGTH) {</span>
<span class="fc" id="L2622">                resumeProcessor = commandCompleteResumeProcessor;</span>
<span class="fc" id="L2623">                sendAndReset();</span>
            }
<span class="fc" id="L2625">            prepareCommandComplete(true);</span>
        } else {
<span class="fc" id="L2627">            prepareSuspended();</span>
            // Prevents re-sending current record row when buffer is sent fully.
<span class="fc" id="L2629">            resumeProcessor = null;</span>
        }
<span class="fc" id="L2631">    }</span>

    private void sendReadyForNewQuery() throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L2634">        prepareReadyForQuery();</span>
<span class="fc" id="L2635">        sendAndReset();</span>
<span class="fc" id="L2636">    }</span>

    private void setUuidBindVariable(int index, long address, int valueLen) throws BadProtocolException, SqlException {
<span class="fc" id="L2639">        ensureValueLength(index, Long128.BYTES, valueLen);</span>
<span class="fc" id="L2640">        long hi = getLongUnsafe(address);</span>
<span class="fc" id="L2641">        long lo = getLongUnsafe(address + Long.BYTES);</span>
<span class="fc" id="L2642">        bindVariableService.setUuid(index, lo, hi);</span>
<span class="fc" id="L2643">    }</span>

    private void setupFactoryAndCursor(SqlCompiler compiler) throws SqlException {
<span class="fc bfc" id="L2646" title="All 2 branches covered.">        if (currentCursor == null) {</span>
<span class="fc" id="L2647">            boolean recompileStale = true;</span>
<span class="fc" id="L2648">            SqlExecutionCircuitBreaker circuitBreaker = sqlExecutionContext.getCircuitBreaker();</span>

            try {
<span class="pc bpc" id="L2651" title="1 of 2 branches missed.">                if (!circuitBreaker.isTimerSet()) {</span>
<span class="nc" id="L2652">                    circuitBreaker.resetTimer();</span>
                }

<span class="fc bfc" id="L2655" title="All 2 branches covered.">                for (int retries = 0; recompileStale; retries++) {</span>
<span class="fc" id="L2656">                    currentFactory = typesAndSelect.getFactory();</span>
                    try {
<span class="fc" id="L2658">                        currentCursor = currentFactory.getCursor(sqlExecutionContext);</span>
<span class="fc" id="L2659">                        recompileStale = false;</span>
                        // cache random if it was replaced
<span class="fc" id="L2661">                        this.rnd = sqlExecutionContext.getRandom();</span>
<span class="fc" id="L2662">                    } catch (TableReferenceOutOfDateException e) {</span>
<span class="pc bpc" id="L2663" title="1 of 2 branches missed.">                        if (retries == TableReferenceOutOfDateException.MAX_RETRY_ATTEMPS) {</span>
<span class="nc" id="L2664">                            throw e;</span>
                        }
<span class="fc" id="L2666">                        LOG.info().$(e.getFlyweightMessage()).$();</span>
<span class="fc" id="L2667">                        freeFactory();</span>
<span class="fc" id="L2668">                        compileQuery(compiler);</span>
<span class="fc" id="L2669">                        buildSelectColumnTypes();</span>
<span class="fc" id="L2670">                        applyLatestBindColumnFormats();</span>
<span class="nc" id="L2671">                    } catch (Throwable e) {</span>
<span class="nc" id="L2672">                        freeFactory();</span>
<span class="nc" id="L2673">                        throw e;</span>
<span class="fc" id="L2674">                    }</span>
                }
            } finally {
<span class="fc" id="L2677">                circuitBreaker.unsetTimer();</span>
            }
        }
<span class="fc" id="L2680">    }</span>

    private void setupVariableSettersFromWrapper(
            @Transient NamedStatementWrapper wrapper,
            @Nullable @Transient SqlCompiler compiler
    ) throws SqlException {
<span class="fc" id="L2686">        queryText = wrapper.queryText;</span>
<span class="fc" id="L2687">        LOG.debug().$(&quot;wrapper query [q=`&quot;).$(wrapper.queryText).$(&quot;`]&quot;).$();</span>
<span class="fc" id="L2688">        this.activeBindVariableTypes = wrapper.bindVariableTypes;</span>
<span class="fc" id="L2689">        this.parsePhaseBindVariableCount = wrapper.bindVariableTypes.size();</span>
<span class="fc" id="L2690">        this.activeSelectColumnTypes = wrapper.selectColumnTypes;</span>
<span class="fc bfc" id="L2691" title="All 6 branches covered.">        if (!wrapper.alreadyExecuted &amp;&amp; compileQuery(compiler) &amp;&amp; typesAndSelect != null) {</span>
<span class="fc" id="L2692">            buildSelectColumnTypes();</span>
        }
        // We'll have to compile/execute the statement next time.
<span class="fc" id="L2695">        wrapper.alreadyExecuted = false;</span>
<span class="fc" id="L2696">    }</span>

    private void shiftReceiveBuffer(long readOffsetBeforeParse) {
<span class="fc" id="L2699">        final long len = recvBufferWriteOffset - readOffsetBeforeParse;</span>
<span class="fc" id="L2700">        LOG.debug()</span>
<span class="fc" id="L2701">                .$(&quot;shift [offset=&quot;).$(readOffsetBeforeParse)</span>
<span class="fc" id="L2702">                .$(&quot;, len=&quot;).$(len)</span>
<span class="fc" id="L2703">                .$(']').$();</span>

<span class="fc" id="L2705">        Vect.memcpy(</span>
                recvBuffer, recvBuffer + readOffsetBeforeParse,
                len
        );
<span class="fc" id="L2709">        recvBufferWriteOffset = len;</span>
<span class="fc" id="L2710">        recvBufferReadOffset = 0;</span>
<span class="fc" id="L2711">    }</span>

    private void validateParameterCounts(short parameterFormatCount, short parameterValueCount, int parameterTypeCount) throws BadProtocolException {
<span class="fc bfc" id="L2714" title="All 2 branches covered.">        if (parameterValueCount &gt; 0) {</span>
<span class="fc bfc" id="L2715" title="All 2 branches covered.">            if (parameterValueCount &lt; parameterTypeCount) {</span>
<span class="fc" id="L2716">                LOG.error().$(&quot;parameter type count must be less or equals to number of parameters values&quot;).$();</span>
<span class="fc" id="L2717">                throw BadProtocolException.INSTANCE;</span>
            }
<span class="fc bfc" id="L2719" title="All 4 branches covered.">            if (parameterFormatCount &gt; 1 &amp;&amp; parameterFormatCount != parameterValueCount) {</span>
<span class="fc" id="L2720">                LOG.error().$(&quot;parameter format count and parameter value count must match&quot;).$();</span>
<span class="fc" id="L2721">                throw BadProtocolException.INSTANCE;</span>
            }
        }
<span class="fc" id="L2724">    }</span>

    void clearRecvBuffer() {
<span class="fc" id="L2727">        recvBufferWriteOffset = 0;</span>
<span class="fc" id="L2728">        recvBufferReadOffset = 0;</span>
<span class="fc" id="L2729">    }</span>

    int doReceive(int remaining) {
<span class="fc" id="L2732">        final long data = recvBuffer + recvBufferWriteOffset;</span>
<span class="fc" id="L2733">        final int n = nf.recv(getFd(), data, remaining);</span>
<span class="fc" id="L2734">        dumpBuffer('&gt;', data, n);</span>
<span class="fc" id="L2735">        return n;</span>
    }

    void doSend(int offset, int size) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L2739">        final int n = nf.send(getFd(), sendBuffer + offset, size);</span>
<span class="fc" id="L2740">        dumpBuffer('&lt;', sendBuffer + offset, n);</span>
<span class="pc bpc" id="L2741" title="1 of 2 branches missed.">        if (n &lt; 0) {</span>
<span class="nc" id="L2742">            throw PeerDisconnectedException.INSTANCE;</span>
        }

<span class="fc bfc" id="L2745" title="All 2 branches covered.">        if (n &lt; size) {</span>
<span class="fc" id="L2746">            doSendWithRetries(offset + n, size - n);</span>
        }
<span class="fc" id="L2748">        sendBufferPtr = sendBuffer;</span>
<span class="fc" id="L2749">        bufferRemainingSize = 0;</span>
<span class="fc" id="L2750">        bufferRemainingOffset = 0;</span>
<span class="fc" id="L2751">    }</span>

    void prepareCommandComplete(boolean addRowCount) {
<span class="fc bfc" id="L2754" title="All 2 branches covered.">        if (isEmptyQuery) {</span>
<span class="fc" id="L2755">            LOG.debug().$(&quot;empty&quot;).$();</span>
<span class="fc" id="L2756">            responseAsciiSink.put(MESSAGE_TYPE_EMPTY_QUERY);</span>
<span class="fc" id="L2757">            responseAsciiSink.putIntDirect(INT_BYTES_X);</span>
        } else {
<span class="fc" id="L2759">            responseAsciiSink.put(MESSAGE_TYPE_COMMAND_COMPLETE);</span>
<span class="fc" id="L2760">            long addr = responseAsciiSink.skip();</span>
<span class="fc bfc" id="L2761" title="All 2 branches covered.">            if (addRowCount) {</span>
<span class="fc bfc" id="L2762" title="All 2 branches covered.">                if (queryTag == TAG_INSERT) {</span>
<span class="fc" id="L2763">                    LOG.debug().$(&quot;insert [rowCount=&quot;).$(rowCount).$(']').$();</span>
<span class="fc" id="L2764">                    responseAsciiSink.encodeUtf8(queryTag).put(&quot; 0 &quot;).put(rowCount).put((char) 0);</span>
                } else {
<span class="fc" id="L2766">                    LOG.debug().$(&quot;other [rowCount=&quot;).$(rowCount).$(']').$();</span>
<span class="fc" id="L2767">                    responseAsciiSink.encodeUtf8(queryTag).put(' ').put(rowCount).put((char) 0);</span>
                }
            } else {
<span class="fc" id="L2770">                LOG.debug().$(&quot;no row count&quot;).$();</span>
<span class="fc" id="L2771">                responseAsciiSink.encodeUtf8(queryTag).put((char) 0);</span>
            }
<span class="fc" id="L2773">            responseAsciiSink.putLen(addr);</span>
        }
<span class="fc" id="L2775">    }</span>

    void prepareReadyForQuery() {
<span class="fc bfc" id="L2778" title="All 2 branches covered.">        if (sendRNQ) {</span>
<span class="fc" id="L2779">            LOG.debug().$(&quot;RNQ sent&quot;).$();</span>
<span class="fc" id="L2780">            responseAsciiSink.put(MESSAGE_TYPE_READY_FOR_QUERY);</span>
<span class="fc" id="L2781">            responseAsciiSink.putNetworkInt(Integer.BYTES + Byte.BYTES);</span>
<span class="fc bfc" id="L2782" title="All 3 branches covered.">            switch (transactionState) {</span>
                case IN_TRANSACTION:
<span class="fc" id="L2784">                    responseAsciiSink.put(STATUS_IN_TRANSACTION);</span>
<span class="fc" id="L2785">                    break;</span>
                case ERROR_TRANSACTION:
<span class="fc" id="L2787">                    responseAsciiSink.put(STATUS_IN_ERROR);</span>
<span class="fc" id="L2788">                    break;</span>
                default:
<span class="fc" id="L2790">                    responseAsciiSink.put(STATUS_IDLE);</span>
                    break;
            }
<span class="fc" id="L2793">            sendRNQ = false;</span>
        }
<span class="fc" id="L2795">    }</span>

    void prepareSuspended() {
<span class="fc" id="L2798">        LOG.debug().$(&quot;suspended&quot;).$();</span>
<span class="fc" id="L2799">        responseAsciiSink.put(MESSAGE_TYPE_PORTAL_SUSPENDED);</span>
<span class="fc" id="L2800">        responseAsciiSink.putIntDirect(INT_BYTES_X);</span>
<span class="fc" id="L2801">    }</span>

    int recv() throws PeerDisconnectedException, PeerIsSlowToWriteException, BadProtocolException {
<span class="fc" id="L2804">        final int remaining = (int) (recvBufferSize - recvBufferWriteOffset);</span>

<span class="pc bpc" id="L2806" title="1 of 2 branches missed.">        assertTrue(remaining &gt; 0, &quot;undersized receive buffer or someone is abusing protocol&quot;);</span>

<span class="fc" id="L2808">        int n = doReceive(remaining);</span>
<span class="fc" id="L2809">        LOG.debug().$(&quot;recv [n=&quot;).$(n).$(']').$();</span>
<span class="fc bfc" id="L2810" title="All 2 branches covered.">        if (n &lt; 0) {</span>
<span class="fc" id="L2811">            LOG.info().$(&quot;disconnected on read [code=&quot;).$(n).$(']').$();</span>
<span class="fc" id="L2812">            throw PeerDisconnectedException.INSTANCE;</span>
        }
<span class="fc bfc" id="L2814" title="All 2 branches covered.">        if (n == 0) {</span>
            // The socket is not ready for read.
<span class="fc" id="L2816">            throw PeerIsSlowToWriteException.INSTANCE;</span>
        }

<span class="fc" id="L2819">        recvBufferWriteOffset += n;</span>
<span class="fc" id="L2820">        return n;</span>
    }

    @FunctionalInterface
    private interface PGResumeProcessor {
        void resume(boolean queryWasPaused) throws PeerIsSlowToReadException, PeerDisconnectedException, QueryPausedException, SqlException;
    }

<span class="fc" id="L2828">    public static class NamedStatementWrapper implements Mutable {</span>

<span class="fc" id="L2830">        public final IntList bindVariableTypes = new IntList();</span>
<span class="fc" id="L2831">        public final IntList selectColumnTypes = new IntList();</span>
        // Used for statements that are executed as a part of compilation (PREPARE), such as DDLs.
<span class="fc" id="L2833">        public boolean alreadyExecuted = false;</span>
<span class="fc" id="L2834">        public CharSequence queryText = null;</span>

        @Override
        public void clear() {
<span class="fc" id="L2838">            queryText = null;</span>
<span class="fc" id="L2839">            bindVariableTypes.clear();</span>
<span class="fc" id="L2840">            selectColumnTypes.clear();</span>
<span class="fc" id="L2841">        }</span>
    }

<span class="fc" id="L2844">    public static class Portal implements Mutable {</span>

<span class="fc" id="L2846">        public CharSequence statementName = null;</span>

        @Override
        public void clear() {
<span class="fc" id="L2850">            statementName = null;</span>
<span class="fc" id="L2851">        }</span>
    }

<span class="fc" id="L2854">    class PGConnectionBatchCallback implements BatchCallback {</span>

        @Override
        public void postCompile(
                SqlCompiler compiler,
                CompiledQuery cq,
                CharSequence text
        ) throws PeerIsSlowToReadException, PeerDisconnectedException, QueryPausedException, SqlException {
            try {
<span class="fc" id="L2863">                PGConnectionContext.this.queryText = text;</span>
<span class="fc" id="L2864">                LOG.info().$(&quot;parse [fd=&quot;).$(fd).$(&quot;, q=&quot;).utf8(text).I$();</span>
<span class="fc" id="L2865">                processCompiledQuery(cq);</span>

<span class="fc bfc" id="L2867" title="All 2 branches covered.">                if (typesAndSelect != null) {</span>
<span class="fc" id="L2868">                    activeSelectColumnTypes = selectColumnTypes;</span>
<span class="fc" id="L2869">                    buildSelectColumnTypes();</span>
<span class="pc bpc" id="L2870" title="1 of 2 branches missed.">                    assert queryText != null;</span>
<span class="fc" id="L2871">                    queryTag = TAG_SELECT;</span>
<span class="fc" id="L2872">                    setupFactoryAndCursor(compiler);</span>
<span class="fc" id="L2873">                    prepareRowDescription();</span>
<span class="fc" id="L2874">                    sendCursor(0, resumeCursorQueryRef, resumeQueryCompleteRef);</span>
<span class="fc bfc" id="L2875" title="All 2 branches covered.">                } else if (typesAndInsert != null) {</span>
<span class="fc" id="L2876">                    executeInsert(compiler);</span>
<span class="fc bfc" id="L2877" title="All 2 branches covered.">                } else if (typesAndUpdate != null) {</span>
<span class="fc" id="L2878">                    executeUpdate(compiler);</span>
<span class="fc bfc" id="L2879" title="All 2 branches covered.">                } else if (cq.getType() == CompiledQuery.INSERT_AS_SELECT ||</span>
<span class="fc bfc" id="L2880" title="All 2 branches covered.">                        cq.getType() == CompiledQuery.CREATE_TABLE_AS_SELECT) {</span>
<span class="fc" id="L2881">                    prepareCommandComplete(true);</span>
                } else {
<span class="fc" id="L2883">                    executeTag();</span>
<span class="fc" id="L2884">                    prepareCommandComplete(false);</span>
                }

<span class="fc" id="L2887">                sqlExecutionContext.getCircuitBreaker().unsetTimer();</span>
<span class="fc" id="L2888">            } catch (QueryPausedException e) {</span>
                // keep circuit breaker's timer as is
<span class="fc" id="L2890">                throw e;</span>
<span class="fc" id="L2891">            } catch (Exception e) {</span>
<span class="fc" id="L2892">                sqlExecutionContext.getCircuitBreaker().unsetTimer();</span>
<span class="fc" id="L2893">                throw e;</span>
<span class="fc" id="L2894">            }</span>
<span class="fc" id="L2895">        }</span>

        @Override
        public void preCompile(SqlCompiler compiler) {
<span class="fc" id="L2899">            sendRNQ = true;</span>
<span class="fc" id="L2900">            prepareForNewBatchQuery();</span>
<span class="fc" id="L2901">            PGConnectionContext.this.typesAndInsert = null;</span>
<span class="fc" id="L2902">            PGConnectionContext.this.typesAndUpdate = null;</span>
<span class="fc" id="L2903">            PGConnectionContext.this.typesAndSelect = null;</span>
<span class="fc" id="L2904">            circuitBreaker.resetTimer();</span>
<span class="fc" id="L2905">        }</span>
    }

<span class="fc" id="L2908">    class ResponseAsciiSink extends AbstractCharSink {</span>

<span class="fc" id="L2910">        private long bookmarkPtr = -1;</span>

        public void bookmark() {
<span class="fc" id="L2913">            this.bookmarkPtr = sendBufferPtr;</span>
<span class="fc" id="L2914">        }</span>

        public void bump(int size) {
<span class="fc" id="L2917">            sendBufferPtr += size;</span>
<span class="fc" id="L2918">        }</span>

        @Override
        public CharSink put(CharSequence cs) {
            // this method is only called by date format utility to print timezone name
            final int len;
<span class="pc bpc" id="L2924" title="1 of 4 branches missed.">            if (cs != null &amp;&amp; (len = cs.length()) &gt; 0) {</span>
<span class="fc" id="L2925">                ensureCapacity(len);</span>
<span class="fc bfc" id="L2926" title="All 2 branches covered.">                for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L2927">                    Unsafe.getUnsafe().putByte(sendBufferPtr + i, (byte) cs.charAt(i));</span>
                }
<span class="fc" id="L2929">                sendBufferPtr += len;</span>
            }
<span class="fc" id="L2931">            return this;</span>
        }

        @Override
        public CharSink put(char c) {
<span class="fc" id="L2936">            ensureCapacity(Byte.BYTES);</span>
<span class="fc" id="L2937">            Unsafe.getUnsafe().putByte(sendBufferPtr++, (byte) c);</span>
<span class="fc" id="L2938">            return this;</span>
        }

        @Override
        public CharSink put(char[] chars, int start, int len) {
<span class="fc" id="L2943">            ensureCapacity(len);</span>
<span class="fc" id="L2944">            Chars.asciiCopyTo(chars, start, len, sendBufferPtr);</span>
<span class="fc" id="L2945">            sendBufferPtr += len;</span>
<span class="fc" id="L2946">            return this;</span>
        }

        public CharSink put(byte b) {
<span class="fc" id="L2950">            ensureCapacity(Byte.BYTES);</span>
<span class="fc" id="L2951">            Unsafe.getUnsafe().putByte(sendBufferPtr++, b);</span>
<span class="fc" id="L2952">            return this;</span>
        }

        public void put(BinarySequence sequence) {
<span class="fc" id="L2956">            final long len = sequence.length();</span>
<span class="pc bpc" id="L2957" title="1 of 2 branches missed.">            if (len &gt; maxBlobSizeOnQuery) {</span>
<span class="nc" id="L2958">                setNullValue();</span>
            } else {
<span class="fc" id="L2960">                ensureCapacity((int) (len + Integer.BYTES));</span>
                // when we reach here the &quot;long&quot; length would have to fit in response buffer
                // if it was larger than integers it would never fit into integer-bound response buffer
<span class="fc" id="L2963">                putInt(sendBufferPtr, (int) len);</span>
<span class="fc" id="L2964">                sendBufferPtr += Integer.BYTES;</span>
<span class="fc bfc" id="L2965" title="All 2 branches covered.">                for (long x = 0; x &lt; len; x++) {</span>
<span class="fc" id="L2966">                    Unsafe.getUnsafe().putByte(sendBufferPtr + x, sequence.byteAt(x));</span>
                }
<span class="fc" id="L2968">                sendBufferPtr += len;</span>
            }
<span class="fc" id="L2970">        }</span>

        public void putIntDirect(int value) {
<span class="fc" id="L2973">            ensureCapacity(Integer.BYTES);</span>
<span class="fc" id="L2974">            putIntUnsafe(0, value);</span>
<span class="fc" id="L2975">            sendBufferPtr += Integer.BYTES;</span>
<span class="fc" id="L2976">        }</span>

        public void putIntUnsafe(long offset, int value) {
<span class="fc" id="L2979">            Unsafe.getUnsafe().putInt(sendBufferPtr + offset, value);</span>
<span class="fc" id="L2980">        }</span>

        public void putLen(long start) {
<span class="fc" id="L2983">            putInt(start, (int) (sendBufferPtr - start));</span>
<span class="fc" id="L2984">        }</span>

        public void putLenEx(long start) {
<span class="fc" id="L2987">            putInt(start, (int) (sendBufferPtr - start - Integer.BYTES));</span>
<span class="fc" id="L2988">        }</span>

        public void putNetworkDouble(double value) {
<span class="fc" id="L2991">            ensureCapacity(Double.BYTES);</span>
<span class="fc" id="L2992">            Unsafe.getUnsafe().putDouble(sendBufferPtr, Double.longBitsToDouble(Numbers.bswap(Double.doubleToLongBits(value))));</span>
<span class="fc" id="L2993">            sendBufferPtr += Double.BYTES;</span>
<span class="fc" id="L2994">        }</span>

        public void putNetworkFloat(float value) {
<span class="fc" id="L2997">            ensureCapacity(Float.BYTES);</span>
<span class="fc" id="L2998">            Unsafe.getUnsafe().putFloat(sendBufferPtr, Float.intBitsToFloat(Numbers.bswap(Float.floatToIntBits(value))));</span>
<span class="fc" id="L2999">            sendBufferPtr += Float.BYTES;</span>
<span class="fc" id="L3000">        }</span>

        public void putNetworkInt(int value) {
<span class="fc" id="L3003">            ensureCapacity(Integer.BYTES);</span>
<span class="fc" id="L3004">            putInt(sendBufferPtr, value);</span>
<span class="fc" id="L3005">            sendBufferPtr += Integer.BYTES;</span>
<span class="fc" id="L3006">        }</span>

        public void putNetworkLong(long value) {
<span class="fc" id="L3009">            ensureCapacity(Long.BYTES);</span>
<span class="fc" id="L3010">            putLong(sendBufferPtr, value);</span>
<span class="fc" id="L3011">            sendBufferPtr += Long.BYTES;</span>
<span class="fc" id="L3012">        }</span>

        public void putNetworkShort(short value) {
<span class="fc" id="L3015">            ensureCapacity(Short.BYTES);</span>
<span class="fc" id="L3016">            putShort(sendBufferPtr, value);</span>
<span class="fc" id="L3017">            sendBufferPtr += Short.BYTES;</span>
<span class="fc" id="L3018">        }</span>

        public void resetToBookmark() {
<span class="pc bpc" id="L3021" title="1 of 2 branches missed.">            assert bookmarkPtr != -1;</span>
<span class="fc" id="L3022">            sendBufferPtr = bookmarkPtr;</span>
<span class="fc" id="L3023">            bookmarkPtr = -1;</span>
<span class="fc" id="L3024">        }</span>

        private void ensureCapacity(int size) {
<span class="fc bfc" id="L3027" title="All 2 branches covered.">            if (sendBufferPtr + size &lt; sendBufferLimit) {</span>
<span class="fc" id="L3028">                return;</span>
            }
<span class="fc" id="L3030">            throw NoSpaceLeftInResponseBufferException.INSTANCE;</span>
        }

        void encodeUtf8Z(CharSequence value) {
<span class="fc" id="L3034">            encodeUtf8(value);</span>
<span class="fc" id="L3035">            ensureCapacity(Byte.BYTES);</span>
<span class="fc" id="L3036">            Unsafe.getUnsafe().putByte(sendBufferPtr++, (byte) 0);</span>
<span class="fc" id="L3037">        }</span>

        void reset() {
<span class="fc" id="L3040">            sendBufferPtr = sendBuffer;</span>
<span class="fc" id="L3041">        }</span>

        void setNullValue() {
<span class="fc" id="L3044">            putIntDirect(INT_NULL_X);</span>
<span class="fc" id="L3045">        }</span>

        long skip() {
<span class="fc" id="L3048">            ensureCapacity(Integer.BYTES);</span>
<span class="fc" id="L3049">            long checkpoint = sendBufferPtr;</span>
<span class="fc" id="L3050">            sendBufferPtr += Integer.BYTES;</span>
<span class="fc" id="L3051">            return checkpoint;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>