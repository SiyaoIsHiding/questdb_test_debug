<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CreateTableModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.model</a> &gt; <span class="el_source">CreateTableModel.java</span></div><h1>CreateTableModel.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.model;

import io.questdb.cairo.ColumnType;
import io.questdb.cairo.PartitionBy;
import io.questdb.cairo.TableStructure;
import io.questdb.griffin.SqlException;
import io.questdb.std.*;
import io.questdb.std.str.CharSink;

public class CreateTableModel implements Mutable, ExecutionModel, Sinkable, TableStructure {
<span class="fc" id="L35">    public static final ObjectFactory&lt;CreateTableModel&gt; FACTORY = CreateTableModel::new;</span>
    private static final int COLUMN_FLAG_CACHED = 1;
    private static final int COLUMN_FLAG_INDEXED = 2;
<span class="fc" id="L38">    private final LongList columnBits = new LongList();</span>
<span class="fc" id="L39">    private final CharSequenceObjHashMap&lt;ColumnCastModel&gt; columnCastModels = new CharSequenceObjHashMap&lt;&gt;();</span>
<span class="fc" id="L40">    private final LowerCaseCharSequenceIntHashMap columnNameIndexMap = new LowerCaseCharSequenceIntHashMap();</span>
<span class="fc" id="L41">    private final ObjList&lt;CharSequence&gt; columnNames = new ObjList&lt;&gt;();</span>
<span class="fc" id="L42">    private boolean ignoreIfExists = false;</span>
    private ExpressionNode likeTableName;
    private int maxUncommittedRows;
    private ExpressionNode name;
    private long o3MaxLag;
    private ExpressionNode partitionBy;
    private QueryModel queryModel;
    private ExpressionNode timestamp;
    private boolean walEnabled;

<span class="fc" id="L52">    private CreateTableModel() {</span>
<span class="fc" id="L53">    }</span>

    public void addColumn(CharSequence name, int type, int symbolCapacity) throws SqlException {
<span class="fc" id="L56">        addColumn(0, name, type, symbolCapacity);</span>
<span class="fc" id="L57">    }</span>

    public void addColumn(int position, CharSequence name, int type, int symbolCapacity) throws SqlException {
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (!columnNameIndexMap.put(name, columnNames.size())) {</span>
<span class="fc" id="L61">            throw SqlException.duplicateColumn(position, name);</span>
        }
<span class="fc" id="L63">        columnNames.add(Chars.toString(name));</span>
<span class="fc" id="L64">        columnBits.add(</span>
<span class="fc" id="L65">                Numbers.encodeLowHighInts(type, symbolCapacity),</span>
<span class="fc" id="L66">                Numbers.encodeLowHighInts(COLUMN_FLAG_CACHED, 0)</span>
        );
<span class="fc" id="L68">    }</span>

    public boolean addColumnCastModel(ColumnCastModel model) {
<span class="fc" id="L71">        return columnCastModels.put(model.getName().token, model);</span>
    }

    public CreateTableModel cached(boolean cached) {
<span class="fc" id="L75">        int last = columnBits.size() - 1;</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        assert last &gt; 0;</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        assert ColumnType.isSymbol(getLowAt(last - 1));</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (cached) {</span>
<span class="fc" id="L79">            columnBits.setQuick(last, Numbers.encodeLowHighInts(getLowAt(last) | COLUMN_FLAG_CACHED, getHighAt(last)));</span>
        } else {
<span class="fc" id="L81">            columnBits.setQuick(last, Numbers.encodeLowHighInts(getLowAt(last) &amp; ~COLUMN_FLAG_CACHED, getHighAt(last)));</span>
        }
<span class="fc" id="L83">        return this;</span>
    }

    @Override
    public void clear() {
<span class="fc" id="L88">        columnCastModels.clear();</span>
<span class="fc" id="L89">        queryModel = null;</span>
<span class="fc" id="L90">        timestamp = null;</span>
<span class="fc" id="L91">        partitionBy = null;</span>
<span class="fc" id="L92">        likeTableName = null;</span>
<span class="fc" id="L93">        name = null;</span>
<span class="fc" id="L94">        columnBits.clear();</span>
<span class="fc" id="L95">        columnNames.clear();</span>
<span class="fc" id="L96">        columnNameIndexMap.clear();</span>
<span class="fc" id="L97">        ignoreIfExists = false;</span>
<span class="fc" id="L98">    }</span>

    public CharSequenceObjHashMap&lt;ColumnCastModel&gt; getColumnCastModels() {
<span class="fc" id="L101">        return columnCastModels;</span>
    }

    @Override
    public int getColumnCount() {
<span class="fc" id="L106">        return columnNames.size();</span>
    }

    public int getColumnIndex(CharSequence columnName) {
<span class="fc" id="L110">        return columnNameIndexMap.get(columnName);</span>
    }

    @Override
    public CharSequence getColumnName(int index) {
<span class="fc" id="L115">        return columnNames.getQuick(index);</span>
    }

    @Override
    public int getColumnType(int index) {
<span class="fc" id="L120">        return getLowAt(index * 2);</span>
    }

    @Override
    public int getIndexBlockCapacity(int index) {
<span class="fc" id="L125">        return getHighAt(index * 2 + 1);</span>
    }

    public ExpressionNode getLikeTableName() {
<span class="fc" id="L129">        return likeTableName;</span>
    }

    @Override
    public int getMaxUncommittedRows() {
<span class="fc" id="L134">        return maxUncommittedRows;</span>
    }

    @Override
    public int getModelType() {
<span class="fc" id="L139">        return CREATE_TABLE;</span>
    }

    public ExpressionNode getName() {
<span class="fc" id="L143">        return name;</span>
    }

    @Override
    public long getO3MaxLag() {
<span class="fc" id="L148">        return o3MaxLag;</span>
    }

    @Override
    public int getPartitionBy() {
<span class="fc bfc" id="L153" title="All 2 branches covered.">        return partitionBy == null ? PartitionBy.NONE : PartitionBy.fromString(partitionBy.token);</span>
    }

    public QueryModel getQueryModel() {
<span class="fc" id="L157">        return queryModel;</span>
    }

    @Override
    public boolean getSymbolCacheFlag(int index) {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        return (getLowAt(index * 2 + 1) &amp; COLUMN_FLAG_CACHED) != 0;</span>
    }

    @Override
    public int getSymbolCapacity(int index) {
<span class="fc" id="L167">        int capacity = getHighAt(index * 2);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        assert capacity != -1;</span>
<span class="fc" id="L169">        return capacity;</span>
    }

    @Override
    public CharSequence getTableName() {
<span class="fc" id="L174">        return name.token;</span>
    }

    public ExpressionNode getTimestamp() {
<span class="fc" id="L178">        return timestamp;</span>
    }

    @Override
    public int getTimestampIndex() {
<span class="fc bfc" id="L183" title="All 2 branches covered.">        return timestamp == null ? -1 : getColumnIndex(timestamp.token);</span>
    }

    public boolean isIgnoreIfExists() {
<span class="fc" id="L187">        return ignoreIfExists;</span>
    }

    @Override
    public boolean isIndexed(int index) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">        return (getLowAt(index * 2 + 1) &amp; COLUMN_FLAG_INDEXED) != 0;</span>
    }

    @Override
    public boolean isSequential(int columnIndex) {
        // todo: expose this flag on CREATE TABLE statement
<span class="fc" id="L198">        return false;</span>
    }

    @Override
    public boolean isWalEnabled() {
<span class="fc" id="L203">        return walEnabled;</span>
    }

    public void setIgnoreIfExists(boolean flag) {
<span class="fc" id="L207">        this.ignoreIfExists = flag;</span>
<span class="fc" id="L208">    }</span>

    public void setIndexFlags(boolean indexFlag, int indexValueBlockSize) {
<span class="fc" id="L211">        setIndexFlags0(columnBits.size() - 1, indexFlag, indexValueBlockSize);</span>
<span class="fc" id="L212">    }</span>

    public void setIndexFlags(int columnIndex, boolean indexFlag, int indexValueBlockSize) {
<span class="fc" id="L215">        setIndexFlags0(columnIndex * 2 + 1, indexFlag, indexValueBlockSize);</span>
<span class="fc" id="L216">    }</span>

    public void setLikeTableName(ExpressionNode tableName) {
<span class="fc" id="L219">        this.likeTableName = tableName;</span>
<span class="fc" id="L220">    }</span>

    public void setMaxUncommittedRows(int maxUncommittedRows) {
<span class="fc" id="L223">        this.maxUncommittedRows = maxUncommittedRows;</span>
<span class="fc" id="L224">    }</span>

    public void setName(ExpressionNode name) {
<span class="fc" id="L227">        this.name = name;</span>
<span class="fc" id="L228">    }</span>

    public void setO3MaxLag(long o3MaxLag) {
<span class="fc" id="L231">        this.o3MaxLag = o3MaxLag;</span>
<span class="fc" id="L232">    }</span>

    public void setPartitionBy(ExpressionNode partitionBy) {
<span class="fc" id="L235">        this.partitionBy = partitionBy;</span>
<span class="fc" id="L236">    }</span>

    public void setQueryModel(QueryModel queryModel) {
<span class="fc" id="L239">        this.queryModel = queryModel;</span>
<span class="fc" id="L240">    }</span>

    public void setTimestamp(ExpressionNode timestamp) {
<span class="fc" id="L243">        this.timestamp = timestamp;</span>
<span class="fc" id="L244">    }</span>

    public void setWalEnabled(boolean walEnabled) {
<span class="fc" id="L247">        this.walEnabled = walEnabled;</span>
<span class="fc" id="L248">    }</span>

    public void symbolCapacity(int capacity) {
<span class="fc" id="L251">        final int pos = columnBits.size() - 2;</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        assert pos &gt; -1;</span>
<span class="fc" id="L253">        final int type = getLowAt(pos);</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        assert ColumnType.isSymbol(type);</span>
<span class="fc" id="L255">        columnBits.setQuick(pos, Numbers.encodeLowHighInts(type, capacity));</span>
<span class="fc" id="L256">    }</span>

    @Override
    public void toSink(CharSink sink) {
<span class="fc" id="L260">        sink.put(&quot;create table &quot;);</span>
<span class="fc" id="L261">        sink.put(getName().token);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (getQueryModel() != null) {</span>
<span class="fc" id="L263">            sink.put(&quot; as (&quot;);</span>
<span class="fc" id="L264">            getQueryModel().toSink(sink);</span>
<span class="fc" id="L265">            sink.put(')');</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">            for (int i = 0, n = getColumnCount(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (isIndexed(i)) {</span>
<span class="fc" id="L268">                    sink.put(&quot;, index(&quot;);</span>
<span class="fc" id="L269">                    sink.put(getColumnName(i));</span>
<span class="fc" id="L270">                    sink.put(&quot; capacity &quot;);</span>
<span class="fc" id="L271">                    sink.put(getIndexBlockCapacity(i));</span>
<span class="fc" id="L272">                    sink.put(')');</span>
                }
            }
<span class="fc" id="L275">            final ObjList&lt;CharSequence&gt; castColumns = getColumnCastModels().keys();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            for (int i = 0, n = castColumns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L277">                final CharSequence column = castColumns.getQuick(i);</span>
<span class="fc" id="L278">                final ColumnCastModel m = getColumnCastModels().get(column);</span>
<span class="fc" id="L279">                final int type = m.getColumnType();</span>
<span class="fc" id="L280">                sink.put(&quot;, cast(&quot;);</span>
<span class="fc" id="L281">                sink.put(column);</span>
<span class="fc" id="L282">                sink.put(&quot; as &quot;);</span>
<span class="fc" id="L283">                sink.put(ColumnType.nameOf(type));</span>
<span class="fc" id="L284">                sink.put(':');</span>
<span class="fc" id="L285">                sink.put(m.getColumnTypePos());</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">                if (ColumnType.isSymbol(type)) {</span>
<span class="fc" id="L287">                    sink.put(&quot; capacity &quot;);</span>
<span class="fc" id="L288">                    sink.put(m.getSymbolCapacity());</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                    if (m.getSymbolCacheFlag()) {</span>
<span class="fc" id="L290">                        sink.put(&quot; cache&quot;);</span>
                    } else {
<span class="fc" id="L292">                        sink.put(&quot; nocache&quot;);</span>
                    }

<span class="pc bpc" id="L295" title="1 of 2 branches missed.">                    if (m.isIndexed()) {</span>
<span class="nc" id="L296">                        sink.put(&quot; index capacity &quot;);</span>
<span class="nc" id="L297">                        sink.put(m.getIndexValueBlockSize());</span>
                    }
                }
<span class="fc" id="L300">                sink.put(')');</span>
            }
<span class="fc" id="L302">        } else {</span>
<span class="fc" id="L303">            sink.put(&quot; (&quot;);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            if (getLikeTableName() != null) {</span>
<span class="fc" id="L305">                sink.put(&quot;like &quot;);</span>
<span class="fc" id="L306">                sink.put(getLikeTableName().token);</span>
            } else {
<span class="fc" id="L308">                int count = getColumnCount();</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                for (int i = 0; i &lt; count; i++) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">                    if (i &gt; 0) {</span>
<span class="fc" id="L311">                        sink.put(&quot;, &quot;);</span>
                    }
<span class="fc" id="L313">                    sink.put(getColumnName(i));</span>
<span class="fc" id="L314">                    sink.put(' ');</span>
<span class="fc" id="L315">                    sink.put(ColumnType.nameOf(getColumnType(i)));</span>

<span class="fc bfc" id="L317" title="All 2 branches covered.">                    if (ColumnType.isSymbol(getColumnType(i))) {</span>
<span class="fc" id="L318">                        sink.put(&quot; capacity &quot;);</span>
<span class="fc" id="L319">                        sink.put(getSymbolCapacity(i));</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">                        if (getSymbolCacheFlag(i)) {</span>
<span class="fc" id="L321">                            sink.put(&quot; cache&quot;);</span>
                        } else {
<span class="fc" id="L323">                            sink.put(&quot; nocache&quot;);</span>
                        }
                    }

<span class="fc bfc" id="L327" title="All 2 branches covered.">                    if (isIndexed(i)) {</span>
<span class="fc" id="L328">                        sink.put(&quot; index capacity &quot;);</span>
<span class="fc" id="L329">                        sink.put(getIndexBlockCapacity(i));</span>
                    }
                }
            }
<span class="fc" id="L333">            sink.put(')');</span>
        }

<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (getTimestamp() != null) {</span>
<span class="fc" id="L337">            sink.put(&quot; timestamp(&quot;);</span>
<span class="fc" id="L338">            sink.put(getTimestamp().token);</span>
<span class="fc" id="L339">            sink.put(')');</span>
        }

<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (partitionBy != null) {</span>
<span class="fc" id="L343">            sink.put(&quot; partition by &quot;).put(partitionBy.token);</span>
        }
<span class="fc" id="L345">    }</span>

    private int getHighAt(int index) {
<span class="fc" id="L348">        return Numbers.decodeHighInt(columnBits.getQuick(index));</span>
    }

    private int getLowAt(int index) {
<span class="fc" id="L352">        return Numbers.decodeLowInt(columnBits.getQuick(index));</span>
    }

    private void setIndexFlags0(int index, boolean indexFlag, int indexValueBlockSize) {
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        assert index &gt; 0;</span>
<span class="fc" id="L357">        final int flags = getLowAt(index);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (indexFlag) {</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            assert indexValueBlockSize &gt; 1;</span>
<span class="fc" id="L360">            columnBits.setQuick(index, Numbers.encodeLowHighInts(flags | COLUMN_FLAG_INDEXED, Numbers.ceilPow2(indexValueBlockSize)));</span>
        } else {
<span class="fc" id="L362">            columnBits.setQuick(index, Numbers.encodeLowHighInts(flags &amp; ~COLUMN_FLAG_INDEXED, Numbers.ceilPow2(indexValueBlockSize)));</span>
        }
<span class="fc" id="L364">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>