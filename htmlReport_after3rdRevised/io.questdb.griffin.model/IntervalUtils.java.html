<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntervalUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.model</a> &gt; <span class="el_source">IntervalUtils.java</span></div><h1>IntervalUtils.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.model;

import io.questdb.cairo.CairoException;
import io.questdb.griffin.SqlException;
import io.questdb.std.LongList;
import io.questdb.std.Numbers;
import io.questdb.std.NumericException;
import io.questdb.std.datetime.microtime.TimestampFormatUtils;
import io.questdb.std.datetime.microtime.Timestamps;

<span class="pc" id="L35">public final class IntervalUtils {</span>
    public static final int HI_INDEX = 1;
    public static final int LO_INDEX = 0;
    public static final int OPERATION_PERIOD_TYPE_ADJUSTMENT_INDEX = 2;
    public static final int PERIOD_COUNT_INDEX = 3;
    public static final int STATIC_LONGS_PER_DYNAMIC_INTERVAL = 4;

    public static void addHiLoInterval(
            long lo,
            long hi,
            int period,
            char periodType,
            int periodCount,
            short operation,
            LongList out) {
<span class="fc" id="L50">        addHiLoInterval(lo, hi, period, periodType, periodCount, IntervalDynamicIndicator.NONE, IntervalOperation.NONE, operation, out);</span>
<span class="fc" id="L51">    }</span>

    public static void addHiLoInterval(
            long lo,
            long hi,
            int period,
            char periodType,
            int periodCount,
            short adjustment,
            short dynamicIndicator,
            short operation,
            LongList out
    ) {
<span class="fc" id="L64">        out.add(</span>
                lo,
                hi,
<span class="fc" id="L67">                Numbers.encodeLowHighInts(</span>
<span class="fc" id="L68">                        Numbers.encodeLowHighShorts(operation, (short) ((int) periodType + Short.MIN_VALUE)),</span>
<span class="fc" id="L69">                        Numbers.encodeLowHighShorts(adjustment, dynamicIndicator)</span>
                ),
<span class="fc" id="L71">                Numbers.encodeLowHighInts(period, periodCount)</span>
        );
<span class="fc" id="L73">    }</span>

    public static void addHiLoInterval(long lo,
                                       long hi,
                                       short adjustment,
                                       short dynamicIndicator,
                                       short operation,
                                       LongList out) {
<span class="fc" id="L81">        addHiLoInterval(lo, hi, 0, PeriodType.NONE, 1, adjustment, dynamicIndicator, operation, out);</span>
<span class="fc" id="L82">    }</span>

    public static void addHiLoInterval(long lo, long hi, short operation, LongList out) {
<span class="fc" id="L85">        addHiLoInterval(lo, hi, 0, PeriodType.NONE, 1, operation, out);</span>
<span class="fc" id="L86">    }</span>

    public static void apply(LongList temp, long lo, long hi, int period, char periodType, int count) {
<span class="fc" id="L89">        temp.add(lo, hi);</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (count &gt; 1) {</span>
<span class="pc bpc" id="L91" title="1 of 7 branches missed.">            switch (periodType) {</span>
                case PeriodType.YEAR:
<span class="fc" id="L93">                    addYearIntervals(period, count, temp);</span>
<span class="fc" id="L94">                    break;</span>
                case PeriodType.MONTH:
<span class="fc" id="L96">                    addMonthInterval(period, count, temp);</span>
<span class="fc" id="L97">                    break;</span>
                case PeriodType.HOUR:
<span class="fc" id="L99">                    addMillisInterval(period * Timestamps.HOUR_MICROS, count, temp);</span>
<span class="fc" id="L100">                    break;</span>
                case PeriodType.MINUTE:
<span class="fc" id="L102">                    addMillisInterval(period * Timestamps.MINUTE_MICROS, count, temp);</span>
<span class="fc" id="L103">                    break;</span>
                case PeriodType.SECOND:
<span class="fc" id="L105">                    addMillisInterval(period * Timestamps.SECOND_MICROS, count, temp);</span>
<span class="fc" id="L106">                    break;</span>
                case PeriodType.DAY:
<span class="fc" id="L108">                    addMillisInterval(period * Timestamps.DAY_MICROS, count, temp);</span>
                    break;
            }
        }
<span class="fc" id="L112">    }</span>

    public static void applyLastEncodedIntervalEx(LongList intervals) {
<span class="fc" id="L115">        int index = intervals.size() - 4;</span>
<span class="fc" id="L116">        long lo = getEncodedPeriodLo(intervals, index);</span>
<span class="fc" id="L117">        long hi = getEncodedPeriodHi(intervals, index);</span>
<span class="fc" id="L118">        int period = getEncodedPeriod(intervals, index);</span>
<span class="fc" id="L119">        char periodType = getEncodedPeriodType(intervals, index);</span>
<span class="fc" id="L120">        int count = getEncodedPeriodCount(intervals, index);</span>

<span class="fc" id="L122">        intervals.setPos(index);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (periodType == PeriodType.NONE) {</span>
<span class="fc" id="L124">            intervals.extendAndSet(index + 1, hi);</span>
<span class="fc" id="L125">            intervals.setQuick(index, lo);</span>
<span class="fc" id="L126">            return;</span>
        }
<span class="fc" id="L128">        apply(intervals, lo, hi, period, periodType, count);</span>
<span class="fc" id="L129">    }</span>

    public static short getEncodedAdjustment(LongList intervals, int index) {
<span class="fc" id="L132">        return Numbers.decodeLowShort(Numbers.decodeHighInt(</span>
<span class="fc" id="L133">                intervals.getQuick(index + OPERATION_PERIOD_TYPE_ADJUSTMENT_INDEX)));</span>
    }

    public static short getEncodedDynamicIndicator(LongList intervals, int index) {
<span class="fc" id="L137">        return Numbers.decodeHighShort(Numbers.decodeHighInt(</span>
<span class="fc" id="L138">                intervals.getQuick(index + OPERATION_PERIOD_TYPE_ADJUSTMENT_INDEX)));</span>
    }

    public static short getEncodedOperation(LongList intervals, int index) {
<span class="fc" id="L142">        return Numbers.decodeLowShort(</span>
<span class="fc" id="L143">                Numbers.decodeLowInt(</span>
<span class="fc" id="L144">                        intervals.getQuick(index + OPERATION_PERIOD_TYPE_ADJUSTMENT_INDEX)</span>
                )
        );
    }

    public static int getEncodedPeriod(LongList intervals, int index) {
<span class="fc" id="L150">        return Numbers.decodeLowInt(</span>
<span class="fc" id="L151">                intervals.getQuick(index + PERIOD_COUNT_INDEX)</span>
        );
    }

    public static int getEncodedPeriodCount(LongList intervals, int index) {
<span class="fc" id="L156">        return Numbers.decodeHighInt(</span>
<span class="fc" id="L157">                intervals.getQuick(index + PERIOD_COUNT_INDEX));</span>
    }

    public static long getEncodedPeriodHi(LongList out, int index) {
<span class="fc" id="L161">        return out.getQuick(index + HI_INDEX);</span>
    }

    public static long getEncodedPeriodLo(LongList out, int index) {
<span class="fc" id="L165">        return out.getQuick(index + LO_INDEX);</span>
    }

    public static char getEncodedPeriodType(LongList intervals, int index) {
<span class="fc" id="L169">        int pts = Numbers.decodeHighShort(</span>
<span class="fc" id="L170">                Numbers.decodeLowInt(</span>
<span class="fc" id="L171">                        intervals.getQuick(index + OPERATION_PERIOD_TYPE_ADJUSTMENT_INDEX)</span>
                )
        );
<span class="fc" id="L174">        return (char) (pts - (int) Short.MIN_VALUE);</span>
    }

    public static boolean isInIntervals(LongList intervals, long timestamp) {
<span class="fc" id="L178">        int left = 0;</span>
<span class="fc" id="L179">        int right = intervals.size() / 2 - 1;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        while (left &lt;= right) {</span>
<span class="fc" id="L181">            int mid = (left + right) / 2;</span>
<span class="fc" id="L182">            long lo = getEncodedPeriodLo(intervals, mid * 2);</span>
<span class="fc" id="L183">            long hi = getEncodedPeriodHi(intervals, mid * 2);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (lo &gt; timestamp) {</span>
<span class="fc" id="L185">                right = mid - 1;</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">            } else if (hi &lt; timestamp) {</span>
<span class="fc" id="L187">                left = mid + 1;</span>
            } else {
<span class="fc" id="L189">                return true;</span>
            }
<span class="fc" id="L191">        }</span>
<span class="fc" id="L192">        return false;</span>
    }

    public static long parseCCPartialDate(CharSequence seq, final int pos, int lim) throws NumericException {
        long ts;
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (lim - pos &lt; 4) {</span>
<span class="nc" id="L198">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L200">        int p = pos;</span>
<span class="fc" id="L201">        int year = Numbers.parseInt(seq, p, p += 4);</span>
<span class="fc" id="L202">        boolean l = Timestamps.isLeapYear(year);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (checkLen(p, lim)) {</span>
<span class="fc" id="L204">            checkChar(seq, p++, lim, '-');</span>
<span class="fc" id="L205">            int month = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L206">            checkRange(month, 1, 12);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (checkLen(p, lim)) {</span>
<span class="fc" id="L208">                checkChar(seq, p++, lim, '-');</span>
<span class="fc" id="L209">                int day = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L210">                checkRange(day, 1, Timestamps.getDaysPerMonth(month, l));</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                if (checkLen(p, lim)) {</span>
<span class="fc" id="L212">                    checkChar(seq, p++, lim, 'T', ' ');</span>
<span class="fc" id="L213">                    int hour = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L214">                    checkRange(hour, 0, 23);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">                    if (checkLen(p, lim)) {</span>
<span class="fc" id="L216">                        checkChar(seq, p++, lim, ':');</span>
<span class="fc" id="L217">                        int min = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L218">                        checkRange(min, 0, 59);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                        if (checkLen(p, lim)) {</span>
<span class="fc" id="L220">                            checkChar(seq, p++, lim, ':');</span>
<span class="fc" id="L221">                            int sec = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L222">                            checkRange(sec, 0, 59);</span>
<span class="fc bfc" id="L223" title="All 4 branches covered.">                            if (lim - p &gt; 3 &amp;&amp; seq.charAt(p) == '.') {</span>
<span class="fc" id="L224">                                p++;</span>
<span class="fc" id="L225">                                int ms = Numbers.parseInt(seq, p, p += 3);</span>
<span class="fc bfc" id="L226" title="All 4 branches covered.">                                if (lim - p &gt; 2 &amp;&amp; Character.isDigit(seq.charAt(p))) {</span>
                                    // micros
<span class="fc" id="L228">                                    int micr = Numbers.parseInt(seq, p, p += 3);</span>
<span class="fc" id="L229">                                    ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L230">                                            + Timestamps.monthOfYearMicros(month, l)</span>
                                            + (day - 1) * Timestamps.DAY_MICROS
                                            + hour * Timestamps.HOUR_MICROS
                                            + min * Timestamps.MINUTE_MICROS
                                            + sec * Timestamps.SECOND_MICROS
                                            + ms * Timestamps.MILLI_MICROS
                                            + micr
<span class="fc" id="L237">                                            + checkTimezoneTail(seq, p, lim)</span>
                                            + 1;
<span class="fc" id="L239">                                } else {</span>
                                    // millis
<span class="fc" id="L241">                                    ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L242">                                            + Timestamps.monthOfYearMicros(month, l)</span>
                                            + (day - 1) * Timestamps.DAY_MICROS
                                            + hour * Timestamps.HOUR_MICROS
                                            + min * Timestamps.MINUTE_MICROS
                                            + sec * Timestamps.SECOND_MICROS
                                            + (ms + 1) * Timestamps.MILLI_MICROS
<span class="fc" id="L248">                                            + checkTimezoneTail(seq, p, lim);</span>
                                }
<span class="fc" id="L250">                            } else {</span>
                                // seconds
<span class="fc" id="L252">                                ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L253">                                        + Timestamps.monthOfYearMicros(month, l)</span>
                                        + (day - 1) * Timestamps.DAY_MICROS
                                        + hour * Timestamps.HOUR_MICROS
                                        + min * Timestamps.MINUTE_MICROS
                                        + (sec + 1) * Timestamps.SECOND_MICROS
<span class="fc" id="L258">                                        + checkTimezoneTail(seq, p, lim);</span>
                            }
<span class="fc" id="L260">                        } else {</span>
                            // minute
<span class="fc" id="L262">                            ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L263">                                    + Timestamps.monthOfYearMicros(month, l)</span>
                                    + (day - 1) * Timestamps.DAY_MICROS
                                    + hour * Timestamps.HOUR_MICROS
                                    + (min + 1) * Timestamps.MINUTE_MICROS;

                        }
<span class="fc" id="L269">                    } else {</span>
                        // year + month + day + hour
<span class="fc" id="L271">                        ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L272">                                + Timestamps.monthOfYearMicros(month, l)</span>
                                + (day - 1) * Timestamps.DAY_MICROS
                                + (hour + 1) * Timestamps.HOUR_MICROS;

                    }
<span class="fc" id="L277">                } else {</span>
                    // year + month + day
<span class="fc" id="L279">                    ts = Timestamps.addDays(Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L280">                            + Timestamps.monthOfYearMicros(month, l)</span>
                            + (day - 1) * Timestamps.DAY_MICROS, 1);
                }
<span class="fc" id="L283">            } else {</span>
                // year + month
<span class="fc" id="L285">                ts = Timestamps.addMonths(Timestamps.yearMicros(year, l) + Timestamps.monthOfYearMicros(month, l), 1);</span>
            }
<span class="fc" id="L287">        } else {</span>
            // year
<span class="fc" id="L289">            ts = Timestamps.yearMicros(year + 1, Timestamps.isLeapYear(year + 1));</span>
        }
<span class="fc" id="L291">        return ts;</span>
    }

    public static long parseCCPartialDate(CharSequence seq) throws NumericException {
<span class="fc" id="L295">        return parseCCPartialDate(seq, 0, seq.length());</span>
    }

    public static long parseFloorPartialTimestamp(CharSequence seq, final int pos, int lim) throws NumericException {
        long ts;
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (lim - pos &lt; 4) {</span>
<span class="fc" id="L301">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L303">        int p = pos;</span>
<span class="fc" id="L304">        int year = Numbers.parseInt(seq, p, p += 4);</span>
<span class="fc" id="L305">        boolean l = Timestamps.isLeapYear(year);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (checkLen(p, lim)) {</span>
<span class="fc" id="L307">            checkChar(seq, p++, lim, '-');</span>
<span class="fc" id="L308">            int month = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L309">            checkRange(month, 1, 12);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">            if (checkLen(p, lim)) {</span>
<span class="fc" id="L311">                checkChar(seq, p++, lim, '-');</span>
<span class="fc" id="L312">                int day = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L313">                checkRange(day, 1, Timestamps.getDaysPerMonth(month, l));</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">                if (checkLen(p, lim)) {</span>
<span class="fc" id="L315">                    checkChar(seq, p++, lim, 'T', ' ');</span>
<span class="fc" id="L316">                    int hour = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L317">                    checkRange(hour, 0, 23);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                    if (checkLen(p, lim)) {</span>
<span class="fc" id="L319">                        checkChar(seq, p++, lim, ':');</span>
<span class="fc" id="L320">                        int min = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L321">                        checkRange(min, 0, 59);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">                        if (checkLen(p, lim)) {</span>
<span class="fc" id="L323">                            checkChar(seq, p++, lim, ':');</span>
<span class="fc" id="L324">                            int sec = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L325">                            checkRange(sec, 0, 59);</span>
<span class="fc bfc" id="L326" title="All 4 branches covered.">                            if (p &lt; lim &amp;&amp; seq.charAt(p) == '.') {</span>

<span class="fc" id="L328">                                p++;</span>
                                // varlen milli and micros
<span class="fc" id="L330">                                int micrLim = p + 6;</span>
<span class="fc" id="L331">                                int mlim = Math.min(lim, micrLim);</span>
<span class="fc" id="L332">                                int micr = 0;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                                for (; p &lt; mlim; p++) {</span>
<span class="fc" id="L334">                                    char c = seq.charAt(p);</span>
<span class="fc bfc" id="L335" title="All 4 branches covered.">                                    if (c &lt; '0' || c &gt; '9') {</span>
                                        // Timezone
<span class="fc" id="L337">                                        break;</span>
                                    }
<span class="fc" id="L339">                                    micr *= 10;</span>
<span class="fc" id="L340">                                    micr += c - '0';</span>
                                }
<span class="fc" id="L342">                                micr *= tenPow(micrLim - p);</span>

                                // micros
<span class="fc" id="L345">                                ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L346">                                        + Timestamps.monthOfYearMicros(month, l)</span>
                                        + (day - 1) * Timestamps.DAY_MICROS
                                        + hour * Timestamps.HOUR_MICROS
                                        + min * Timestamps.MINUTE_MICROS
                                        + sec * Timestamps.SECOND_MICROS
                                        + micr
<span class="fc" id="L352">                                        + checkTimezoneTail(seq, p, lim);</span>
<span class="fc" id="L353">                            } else {</span>
                                // seconds
<span class="fc" id="L355">                                ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L356">                                        + Timestamps.monthOfYearMicros(month, l)</span>
                                        + (day - 1) * Timestamps.DAY_MICROS
                                        + hour * Timestamps.HOUR_MICROS
                                        + min * Timestamps.MINUTE_MICROS
                                        + sec * Timestamps.SECOND_MICROS
<span class="fc" id="L361">                                        + checkTimezoneTail(seq, p, lim);</span>
                            }
<span class="fc" id="L363">                        } else {</span>
                            // minute
<span class="fc" id="L365">                            ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L366">                                    + Timestamps.monthOfYearMicros(month, l)</span>
                                    + (day - 1) * Timestamps.DAY_MICROS
                                    + hour * Timestamps.HOUR_MICROS
                                    + min * Timestamps.MINUTE_MICROS;

                        }
<span class="fc" id="L372">                    } else {</span>
                        // year + month + day + hour
<span class="fc" id="L374">                        ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L375">                                + Timestamps.monthOfYearMicros(month, l)</span>
                                + (day - 1) * Timestamps.DAY_MICROS
                                + hour * Timestamps.HOUR_MICROS;

                    }
<span class="fc" id="L380">                } else {</span>
                    // year + month + day
<span class="fc" id="L382">                    ts = Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L383">                            + Timestamps.monthOfYearMicros(month, l)</span>
                            + (day - 1) * Timestamps.DAY_MICROS;
                }
<span class="fc" id="L386">            } else {</span>
                // year + month
<span class="fc" id="L388">                ts = (Timestamps.yearMicros(year, l) + Timestamps.monthOfYearMicros(month, l));</span>
            }
<span class="fc" id="L390">        } else {</span>
            // year
<span class="fc" id="L392">            ts = (Timestamps.yearMicros(year, l) + Timestamps.monthOfYearMicros(1, l));</span>
        }
<span class="fc" id="L394">        return ts;</span>
    }

    public static long parseFloorPartialTimestamp(CharSequence seq) throws NumericException {
<span class="fc" id="L398">        return parseFloorPartialTimestamp(seq, 0, seq.length());</span>
    }

    public static void parseInterval(CharSequence seq, int pos, int lim, short operation, LongList out) throws NumericException {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (lim - pos &lt; 4) {</span>
<span class="fc" id="L403">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L405">        int p = pos;</span>
<span class="fc" id="L406">        int year = Numbers.parseInt(seq, p, p += 4);</span>
<span class="fc" id="L407">        boolean l = Timestamps.isLeapYear(year);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (checkLen(p, lim)) {</span>
<span class="fc" id="L409">            checkChar(seq, p++, lim, '-');</span>
<span class="fc" id="L410">            int month = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L411">            checkRange(month, 1, 12);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            if (checkLen(p, lim)) {</span>
<span class="fc" id="L413">                checkChar(seq, p++, lim, '-');</span>
<span class="fc" id="L414">                int day = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L415">                checkRange(day, 1, Timestamps.getDaysPerMonth(month, l));</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">                if (checkLen(p, lim)) {</span>
<span class="fc" id="L417">                    checkChar(seq, p++, lim, 'T');</span>
<span class="fc" id="L418">                    int hour = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L419">                    checkRange(hour, 0, 23);</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">                    if (checkLen(p, lim)) {</span>
<span class="fc" id="L421">                        checkChar(seq, p++, lim, ':');</span>
<span class="fc" id="L422">                        int min = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L423">                        checkRange(min, 0, 59);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">                        if (checkLen(p, lim)) {</span>
<span class="fc" id="L425">                            checkChar(seq, p++, lim, ':');</span>
<span class="fc" id="L426">                            int sec = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L427">                            checkRange(sec, 0, 59);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                            if (p &lt; lim) {</span>
<span class="fc" id="L429">                                throw NumericException.INSTANCE;</span>
                            } else {
                                // seconds
<span class="fc" id="L432">                                addHiLoInterval(Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L433">                                                + Timestamps.monthOfYearMicros(month, l)</span>
                                                + (day - 1) * Timestamps.DAY_MICROS
                                                + hour * Timestamps.HOUR_MICROS
                                                + min * Timestamps.MINUTE_MICROS
                                                + sec * Timestamps.SECOND_MICROS,
<span class="fc" id="L438">                                        Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L439">                                                + Timestamps.monthOfYearMicros(month, l)</span>
                                                + (day - 1) * Timestamps.DAY_MICROS
                                                + hour * Timestamps.HOUR_MICROS
                                                + min * Timestamps.MINUTE_MICROS
                                                + sec * Timestamps.SECOND_MICROS
                                                + 999999,
                                        operation,
                                        out);
                            }
<span class="fc" id="L448">                        } else {</span>
                            // minute
<span class="fc" id="L450">                            addHiLoInterval(Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L451">                                            + Timestamps.monthOfYearMicros(month, l)</span>
                                            + (day - 1) * Timestamps.DAY_MICROS
                                            + hour * Timestamps.HOUR_MICROS
                                            + min * Timestamps.MINUTE_MICROS,
<span class="fc" id="L455">                                    Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L456">                                            + Timestamps.monthOfYearMicros(month, l)</span>
                                            + (day - 1) * Timestamps.DAY_MICROS
                                            + hour * Timestamps.HOUR_MICROS
                                            + min * Timestamps.MINUTE_MICROS
                                            + 59 * Timestamps.SECOND_MICROS
                                            + 999999,
                                    operation,
                                    out);
                        }
<span class="fc" id="L465">                    } else {</span>
                        // year + month + day + hour
<span class="fc" id="L467">                        addHiLoInterval(Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L468">                                        + Timestamps.monthOfYearMicros(month, l)</span>
                                        + (day - 1) * Timestamps.DAY_MICROS
                                        + hour * Timestamps.HOUR_MICROS,
<span class="fc" id="L471">                                Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L472">                                        + Timestamps.monthOfYearMicros(month, l)</span>
                                        + (day - 1) * Timestamps.DAY_MICROS
                                        + hour * Timestamps.HOUR_MICROS
                                        + 59 * Timestamps.MINUTE_MICROS
                                        + 59 * Timestamps.SECOND_MICROS
                                        + 999999,
                                operation,
                                out);
                    }
<span class="fc" id="L481">                } else {</span>
                    // year + month + day
<span class="fc" id="L483">                    addHiLoInterval(Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L484">                                    + Timestamps.monthOfYearMicros(month, l)</span>
                                    + (day - 1) * Timestamps.DAY_MICROS,
<span class="fc" id="L486">                            Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L487">                                    + Timestamps.monthOfYearMicros(month, l)</span>
                                    + (day - 1) * Timestamps.DAY_MICROS
                                    + 23 * Timestamps.HOUR_MICROS
                                    + 59 * Timestamps.MINUTE_MICROS
                                    + 59 * Timestamps.SECOND_MICROS
                                    + 999999,
                            operation,
                            out);
                }
<span class="fc" id="L496">            } else {</span>
                // year + month
<span class="fc" id="L498">                addHiLoInterval(Timestamps.yearMicros(year, l) + Timestamps.monthOfYearMicros(month, l),</span>
<span class="fc" id="L499">                        Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L500">                                + Timestamps.monthOfYearMicros(month, l)</span>
<span class="fc" id="L501">                                + (Timestamps.getDaysPerMonth(month, l) - 1) * Timestamps.DAY_MICROS</span>
                                + 23 * Timestamps.HOUR_MICROS
                                + 59 * Timestamps.MINUTE_MICROS
                                + 59 * Timestamps.SECOND_MICROS
                                + 999999,
                        operation,
                        out);
            }
<span class="fc" id="L509">        } else {</span>
            // year
<span class="fc" id="L511">            addHiLoInterval(Timestamps.yearMicros(year, l) + Timestamps.monthOfYearMicros(1, l),</span>
<span class="fc" id="L512">                    Timestamps.yearMicros(year, l)</span>
<span class="fc" id="L513">                            + Timestamps.monthOfYearMicros(12, l)</span>
<span class="fc" id="L514">                            + (Timestamps.getDaysPerMonth(12, l) - 1) * Timestamps.DAY_MICROS</span>
                            + 23 * Timestamps.HOUR_MICROS
                            + 59 * Timestamps.MINUTE_MICROS
                            + 59 * Timestamps.SECOND_MICROS
                            + 999999,
                    operation,
                    out);
        }
<span class="fc" id="L522">    }</span>

    public static void parseIntervalEx(CharSequence seq, int lo, int lim, int position, LongList out, short operation) throws SqlException {
<span class="fc" id="L525">        int writeIndex = out.size();</span>
<span class="fc" id="L526">        int[] pos = new int[3];</span>
<span class="fc" id="L527">        int p = -1;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (int i = lo; i &lt; lim; i++) {</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            if (seq.charAt(i) == ';') {</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">                if (p &gt; 1) {</span>
<span class="nc" id="L531">                    throw SqlException.$(position, &quot;Invalid interval format&quot;);</span>
                }
<span class="fc" id="L533">                pos[++p] = i;</span>
            }
        }

<span class="pc bpc" id="L537" title="1 of 4 branches missed.">        switch (p) {</span>
            case -1:
                // no semicolons, just date part, which can be interval in itself
                try {
<span class="fc" id="L541">                    parseInterval(seq, lo, lim, operation, out);</span>
<span class="fc" id="L542">                    break;</span>
<span class="fc" id="L543">                } catch (NumericException ignore) {</span>
                    // this must be a date then?
                }

                try {
<span class="fc" id="L548">                    long millis = parseFloorPartialTimestamp(seq, lo, lim);</span>
<span class="fc" id="L549">                    addHiLoInterval(millis, millis, operation, out);</span>
<span class="fc" id="L550">                    break;</span>
<span class="fc" id="L551">                } catch (NumericException e) {</span>
                    try {
<span class="fc" id="L553">                        long millis = Numbers.parseLong(seq);</span>
<span class="fc" id="L554">                        addHiLoInterval(millis, millis, operation, out);</span>
<span class="fc" id="L555">                        break;</span>
<span class="fc" id="L556">                    } catch (NumericException e2) {</span>
<span class="fc" id="L557">                        throw SqlException.$(position, &quot;Invalid date&quot;);</span>
                    }
                }
            case 0:
                // single semicolon, expect period format after date
<span class="fc" id="L562">                parseRange(seq, lo, pos[0], lim, position, operation, out);</span>
<span class="fc" id="L563">                break;</span>
            case 2:
                // 2018-01-10T10:30:00.000Z;30m;2d;2
                // means 10:30-11:00 every second day starting 2018-01-10
                int period;
                try {
<span class="fc" id="L569">                    period = Numbers.parseInt(seq, pos[1] + 1, pos[2] - 1);</span>
<span class="nc" id="L570">                } catch (NumericException e) {</span>
<span class="nc" id="L571">                    throw SqlException.$(position, &quot;Period not a number&quot;);</span>
<span class="fc" id="L572">                }</span>
                int count;
                try {
<span class="fc" id="L575">                    count = Numbers.parseInt(seq, pos[2] + 1, lim);</span>
<span class="nc" id="L576">                } catch (NumericException e) {</span>
<span class="nc" id="L577">                    throw SqlException.$(position, &quot;Count not a number&quot;);</span>
<span class="fc" id="L578">                }</span>

<span class="fc" id="L580">                parseRange(seq, lo, pos[0], pos[1], position, operation, out);</span>
<span class="fc" id="L581">                char type = seq.charAt(pos[2] - 1);</span>
<span class="fc" id="L582">                long low = getEncodedPeriodLo(out, writeIndex);</span>
<span class="fc" id="L583">                long hi = getEncodedPeriodHi(out, writeIndex);</span>

<span class="fc" id="L585">                replaceHiLoInterval(low, hi, period, type, count, operation, out);</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">                switch (type) {</span>
                    case PeriodType.YEAR:
                    case PeriodType.MONTH:
                    case PeriodType.HOUR:
                    case PeriodType.MINUTE:
                    case PeriodType.SECOND:
                    case PeriodType.DAY:
<span class="fc" id="L593">                        break;</span>
                    default:
<span class="nc" id="L595">                        throw SqlException.$(position, &quot;Unknown period: &quot; + type + &quot; at &quot; + (p - 1));</span>
                }
                break;
            default:
<span class="nc" id="L599">                throw SqlException.$(position, &quot;Invalid interval format&quot;);</span>
        }
<span class="fc" id="L601">    }</span>

    public static void parseSingleTimestamp(CharSequence seq, int lo, int lim, int position, LongList out, short operation) throws SqlException {
        try {
<span class="fc" id="L605">            long millis = parseFloorPartialTimestamp(seq, lo, lim);</span>
<span class="fc" id="L606">            addHiLoInterval(millis, millis, operation, out);</span>
<span class="fc" id="L607">        } catch (NumericException e) {</span>
            try {
<span class="fc" id="L609">                long millis = Numbers.parseLong(seq);</span>
<span class="fc" id="L610">                addHiLoInterval(millis, millis, operation, out);</span>
<span class="fc" id="L611">            } catch (NumericException e2) {</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">                for (int i = lo; i &lt; lim; i++) {</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">                    if (seq.charAt(i) == ';') {</span>
<span class="fc" id="L614">                        throw SqlException.$(position, &quot;Not a date, use IN keyword with intervals&quot;);</span>
                    }
                }
<span class="fc" id="L617">                throw SqlException.$(position, &quot;Invalid date&quot;);</span>
<span class="fc" id="L618">            }</span>
<span class="fc" id="L619">        }</span>
<span class="fc" id="L620">    }</span>

    public static void subtract(LongList intervals, int divider) {
<span class="fc" id="L623">        IntervalUtils.invert(intervals, divider);</span>
<span class="fc" id="L624">        IntervalUtils.intersectInplace(intervals, divider);</span>
<span class="fc" id="L625">    }</span>

    public static long tryParseTimestamp(CharSequence seq) throws CairoException {
        try {
<span class="fc" id="L629">            return parseFloorPartialTimestamp(seq, 0, seq.length());</span>
<span class="nc" id="L630">        } catch (NumericException e) {</span>
<span class="nc" id="L631">            throw CairoException.nonCritical().put(&quot;Invalid timestamp: &quot;).put(seq);</span>
        }
    }

    private static void addMillisInterval(long period, int count, LongList out) {
<span class="fc" id="L636">        int k = out.size();</span>
<span class="fc" id="L637">        long lo = out.getQuick(k - 2);</span>
<span class="fc" id="L638">        long hi = out.getQuick(k - 1);</span>
<span class="fc" id="L639">        int n = count - 1;</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">        if (period &lt; 0) {</span>
<span class="fc" id="L641">            lo += period * n;</span>
<span class="fc" id="L642">            hi += period * n;</span>
<span class="fc" id="L643">            out.setQuick(k - 2, lo);</span>
<span class="fc" id="L644">            out.setQuick(k - 1, hi);</span>
<span class="fc" id="L645">            period = -period;</span>
        }
<span class="fc" id="L647">        int writePoint = k / 2;</span>

<span class="fc bfc" id="L649" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L650">            lo += period;</span>
<span class="fc" id="L651">            hi += period;</span>
<span class="fc" id="L652">            writePoint = append(out, writePoint, lo, hi);</span>
        }
<span class="fc" id="L654">    }</span>

    private static void addMonthInterval(int period, int count, LongList out) {
<span class="fc" id="L657">        int k = out.size();</span>
<span class="fc" id="L658">        long lo = out.getQuick(k - 2);</span>
<span class="fc" id="L659">        long hi = out.getQuick(k - 1);</span>
<span class="fc" id="L660">        int writePoint = k / 2;</span>
<span class="fc" id="L661">        int n = count - 1;</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (period &lt; 0) {</span>
<span class="fc" id="L663">            lo = Timestamps.addMonths(lo, period * n);</span>
<span class="fc" id="L664">            hi = Timestamps.addMonths(hi, period * n);</span>
<span class="fc" id="L665">            out.setQuick(k - 2, lo);</span>
<span class="fc" id="L666">            out.setQuick(k - 1, hi);</span>
<span class="fc" id="L667">            period = -period;</span>
        }

<span class="fc bfc" id="L670" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L671">            lo = Timestamps.addMonths(lo, period);</span>
<span class="fc" id="L672">            hi = Timestamps.addMonths(hi, period);</span>
<span class="fc" id="L673">            writePoint = append(out, writePoint, lo, hi);</span>
        }
<span class="fc" id="L675">    }</span>

    private static void addYearIntervals(int period, int count, LongList out) {
<span class="fc" id="L678">        int k = out.size();</span>
<span class="fc" id="L679">        long lo = out.getQuick(k - 2);</span>
<span class="fc" id="L680">        long hi = out.getQuick(k - 1);</span>
<span class="fc" id="L681">        int writePoint = k / 2;</span>
<span class="fc" id="L682">        int n = count - 1;</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">        if (period &lt; 0) {</span>
<span class="fc" id="L684">            lo = Timestamps.addYear(lo, period * n);</span>
<span class="fc" id="L685">            hi = Timestamps.addYear(hi, period * n);</span>
<span class="fc" id="L686">            out.setQuick(k - 2, lo);</span>
<span class="fc" id="L687">            out.setQuick(k - 1, hi);</span>
<span class="fc" id="L688">            period = -period;</span>
        }

<span class="fc bfc" id="L691" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L692">            lo = Timestamps.addYear(lo, period);</span>
<span class="fc" id="L693">            hi = Timestamps.addYear(hi, period);</span>
<span class="fc" id="L694">            writePoint = append(out, writePoint, lo, hi);</span>
        }
<span class="fc" id="L696">    }</span>

    private static void checkChar(CharSequence s, int p, int lim, char c) throws NumericException {
<span class="pc bpc" id="L699" title="1 of 4 branches missed.">        if (p &gt;= lim || s.charAt(p) != c) {</span>
<span class="fc" id="L700">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L702">    }</span>

    private static void checkChar(CharSequence s, int p, int lim, char c1, char c2) throws NumericException {
<span class="pc bpc" id="L705" title="1 of 6 branches missed.">        if (p &gt;= lim || (s.charAt(p) != c1 &amp;&amp; s.charAt(p) != c2)) {</span>
<span class="fc" id="L706">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L708">    }</span>

    private static boolean checkLen(int p, int lim) throws NumericException {
<span class="fc bfc" id="L711" title="All 2 branches covered.">        if (lim - p &gt; 2) {</span>
<span class="fc" id="L712">            return true;</span>
        }
<span class="fc bfc" id="L714" title="All 2 branches covered.">        if (lim &lt;= p) {</span>
<span class="fc" id="L715">            return false;</span>
        }

<span class="fc" id="L718">        throw NumericException.INSTANCE;</span>
    }

    private static boolean checkLenStrict(int p, int lim) throws NumericException {
<span class="fc bfc" id="L722" title="All 2 branches covered.">        if (lim - p == 2) {</span>
<span class="fc" id="L723">            return true;</span>
        }
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        if (lim &lt;= p) {</span>
<span class="fc" id="L726">            return false;</span>
        }

<span class="nc" id="L729">        throw NumericException.INSTANCE;</span>
    }

    private static void checkRange(int x, int min, int max) throws NumericException {
<span class="pc bpc" id="L733" title="1 of 4 branches missed.">        if (x &lt; min || x &gt; max) {</span>
<span class="fc" id="L734">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L736">    }</span>

    private static long checkTimezoneTail(CharSequence seq, int p, int lim) throws NumericException {
<span class="fc bfc" id="L739" title="All 2 branches covered.">        if (lim == p) {</span>
<span class="fc" id="L740">            return 0;</span>
        }

<span class="fc bfc" id="L743" title="All 2 branches covered.">        if (lim - p &lt; 2) {</span>
<span class="fc" id="L744">            checkChar(seq, p, lim, 'Z');</span>
<span class="fc" id="L745">            return 0;</span>
        }

<span class="fc bfc" id="L748" title="All 2 branches covered.">        if (lim - p &gt; 2) {</span>
<span class="fc" id="L749">            int tzSign = parseSign(seq, p++);</span>
<span class="fc" id="L750">            int hour = Numbers.parseInt(seq, p, p += 2);</span>
<span class="fc" id="L751">            checkRange(hour, 0, 23);</span>

<span class="fc bfc" id="L753" title="All 2 branches covered.">            if (lim - p == 3) {</span>
                // Optional : separator between hours and mins in timezone
<span class="fc" id="L755">                checkChar(seq, p++, lim, ':');</span>
            }

<span class="fc bfc" id="L758" title="All 2 branches covered.">            if (checkLenStrict(p, lim)) {</span>
<span class="fc" id="L759">                int min = Numbers.parseInt(seq, p, p + 2);</span>
<span class="fc" id="L760">                checkRange(min, 0, 59);</span>
<span class="fc" id="L761">                return tzSign * (hour * Timestamps.HOUR_MICROS + min * Timestamps.MINUTE_MICROS);</span>
            } else {
<span class="fc" id="L763">                return tzSign * (hour * Timestamps.HOUR_MICROS);</span>
            }
        }
<span class="fc" id="L766">        throw NumericException.INSTANCE;</span>
    }

    private static void parseRange(CharSequence seq, int lo, int p, int lim, int position, short operation, LongList out) throws SqlException {
<span class="fc" id="L770">        char type = seq.charAt(lim - 1);</span>
        int period;
        try {
<span class="fc" id="L773">            period = Numbers.parseInt(seq, p + 1, lim - 1);</span>
<span class="nc" id="L774">        } catch (NumericException e) {</span>
<span class="nc" id="L775">            throw SqlException.$(position, &quot;Range not a number&quot;);</span>
<span class="fc" id="L776">        }</span>
        try {
<span class="fc" id="L778">            int index = out.size();</span>
<span class="fc" id="L779">            parseInterval(seq, lo, p, operation, out);</span>
<span class="fc" id="L780">            long low = getEncodedPeriodLo(out, index);</span>
<span class="fc" id="L781">            long hi = getEncodedPeriodHi(out, index);</span>
<span class="fc" id="L782">            hi = Timestamps.addPeriod(hi, type, period);</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">            if (hi &lt; low) {</span>
<span class="nc" id="L784">                throw SqlException.invalidDate(position);</span>
            }
<span class="fc" id="L786">            replaceHiLoInterval(low, hi, operation, out);</span>
<span class="fc" id="L787">            return;</span>
<span class="fc" id="L788">        } catch (NumericException ignore) {</span>
            // try date instead
        }
        try {
<span class="fc" id="L792">            long loMillis = TimestampFormatUtils.tryParse(seq, lo, p);</span>
<span class="fc" id="L793">            long hiMillis = Timestamps.addPeriod(loMillis, type, period);</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">            if (hiMillis &lt; loMillis) {</span>
<span class="fc" id="L795">                throw SqlException.invalidDate(position);</span>
            }
<span class="fc" id="L797">            addHiLoInterval(loMillis, hiMillis, operation, out);</span>
<span class="nc" id="L798">        } catch (NumericException e) {</span>
<span class="nc" id="L799">            throw SqlException.invalidDate(position);</span>
<span class="fc" id="L800">        }</span>
<span class="fc" id="L801">    }</span>

    private static int parseSign(CharSequence seq, int p) throws NumericException {
        int tzSign;
<span class="fc bfc" id="L805" title="All 3 branches covered.">        switch (seq.charAt(p)) {</span>
            case '+':
<span class="fc" id="L807">                tzSign = -1;</span>
<span class="fc" id="L808">                break;</span>
            case '-':
<span class="fc" id="L810">                tzSign = 1;</span>
<span class="fc" id="L811">                break;</span>
            default:
<span class="fc" id="L813">                throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L815">        return tzSign;</span>
    }

    private static void replaceHiLoInterval(long lo, long hi, int period, char periodType, int periodCount, short operation, LongList out) {
<span class="fc" id="L819">        int lastIndex = out.size() - 4;</span>
<span class="fc" id="L820">        out.setQuick(lastIndex, lo);</span>
<span class="fc" id="L821">        out.setQuick(lastIndex + HI_INDEX, hi);</span>
<span class="fc" id="L822">        out.setQuick(lastIndex + OPERATION_PERIOD_TYPE_ADJUSTMENT_INDEX, Numbers.encodeLowHighInts(</span>
<span class="fc" id="L823">                Numbers.encodeLowHighShorts(operation, (short) ((int) periodType + Short.MIN_VALUE)),</span>
                0));
<span class="fc" id="L825">        out.setQuick(lastIndex + PERIOD_COUNT_INDEX, Numbers.encodeLowHighInts(period, periodCount));</span>
<span class="fc" id="L826">    }</span>

    private static void replaceHiLoInterval(long lo, long hi, short operation, LongList out) {
<span class="fc" id="L829">        replaceHiLoInterval(lo, hi, 0, (char) 0, 1, operation, out);</span>
<span class="fc" id="L830">    }</span>

    private static int tenPow(int i) throws NumericException {
<span class="pc bpc" id="L833" title="1 of 7 branches missed.">        switch (i) {</span>
            case 0:
<span class="fc" id="L835">                return 1;</span>
            case 1:
<span class="fc" id="L837">                return 10;</span>
            case 2:
<span class="fc" id="L839">                return 100;</span>
            case 3:
<span class="fc" id="L841">                return 1000;</span>
            case 4:
<span class="fc" id="L843">                return 10000;</span>
            case 5:
<span class="fc" id="L845">                return 100000;</span>
            default:
<span class="nc" id="L847">                throw NumericException.INSTANCE;</span>
        }
    }

    static int append(LongList list, int writePoint, long lo, long hi) {
<span class="fc bfc" id="L852" title="All 2 branches covered.">        if (writePoint &gt; 0) {</span>
<span class="fc" id="L853">            long prevHi = list.getQuick(2 * writePoint - 1) + 1;</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">            if (prevHi &gt;= lo) {</span>
<span class="fc" id="L855">                list.setQuick(2 * writePoint - 1, hi);</span>
<span class="fc" id="L856">                return writePoint;</span>
            }
        }

<span class="fc" id="L860">        list.extendAndSet(2 * writePoint + 1, hi);</span>
<span class="fc" id="L861">        list.setQuick(2 * writePoint, lo);</span>
<span class="fc" id="L862">        return writePoint + 1;</span>
    }

    /**
     * Intersects two lists of intervals compacted in one list in place.
     * Intervals to be chronologically ordered and result list will be ordered as well.
     * &lt;p&gt;
     * Treat a as 2 lists,
     * a: first from 0 to divider
     * b: from divider to the end of list
     *
     * @param concatenatedIntervals 2 lists of intervals concatenated in 1
     */
    static void intersectInplace(LongList concatenatedIntervals, int dividerIndex) {
<span class="fc" id="L876">        final int sizeA = dividerIndex / 2;</span>
<span class="fc" id="L877">        final int sizeB = sizeA + (concatenatedIntervals.size() - dividerIndex) / 2;</span>
<span class="fc" id="L878">        int aLower = 0;</span>

<span class="fc" id="L880">        int intervalB = sizeA;</span>
<span class="fc" id="L881">        int writePoint = 0;</span>

<span class="fc" id="L883">        int aUpperSize = sizeB;</span>
<span class="fc" id="L884">        int aUpper = sizeB;</span>

<span class="fc bfc" id="L886" title="All 6 branches covered.">        while ((aLower &lt; sizeA || aUpper &lt; aUpperSize) &amp;&amp; intervalB &lt; sizeB) {</span>

<span class="fc bfc" id="L888" title="All 2 branches covered.">            int intervalA = aUpper &lt; aUpperSize ? aUpper : aLower;</span>
<span class="fc" id="L889">            long aLo = concatenatedIntervals.getQuick(intervalA * 2);</span>
<span class="fc" id="L890">            long aHi = concatenatedIntervals.getQuick(intervalA * 2 + 1);</span>

<span class="fc" id="L892">            long bLo = concatenatedIntervals.getQuick(intervalB * 2);</span>
<span class="fc" id="L893">            long bHi = concatenatedIntervals.getQuick(intervalB * 2 + 1);</span>

<span class="fc bfc" id="L895" title="All 2 branches covered.">            if (aHi &lt; bLo) {</span>
                // a fully above b
                // a loses
<span class="fc bfc" id="L898" title="All 2 branches covered.">                if (aUpper &lt; aUpperSize) {</span>
<span class="fc" id="L899">                    aUpper++;</span>
                } else {
<span class="fc" id="L901">                    aLower++;</span>
                }
<span class="fc bfc" id="L903" title="All 2 branches covered.">            } else if (aLo &gt; bHi) {</span>
                // a fully below b
                // b loses
<span class="fc" id="L906">                intervalB++;</span>
            } else {
<span class="fc bfc" id="L908" title="All 2 branches covered.">                if (aHi &lt; bHi) {</span>
                    // b hanging lower than a
                    // a loses
<span class="fc bfc" id="L911" title="All 2 branches covered.">                    if (aUpper &lt; aUpperSize) {</span>
<span class="fc" id="L912">                        aUpper++;</span>
                    } else {
<span class="fc" id="L914">                        aLower++;</span>
                    }
                } else {
                    // otherwise a lower than b
                    // a loses
<span class="fc" id="L919">                    intervalB++;</span>
                }

<span class="pc bpc" id="L922" title="1 of 4 branches missed.">                assert writePoint &lt;= aLower || writePoint &gt;= sizeA;</span>
<span class="fc bfc" id="L923" title="All 4 branches covered.">                if (writePoint == aLower &amp;&amp; aLower &lt; sizeA) {</span>
                    // We cannot keep A position, it will be overwritten, hence intervalB++; is not possible
                    // Copy a point to A area instead
<span class="fc" id="L926">                    concatenatedIntervals.add(</span>
<span class="fc" id="L927">                            concatenatedIntervals.getQuick(writePoint * 2),</span>
<span class="fc" id="L928">                            concatenatedIntervals.getQuick(writePoint * 2 + 1)</span>
                    );
<span class="fc" id="L930">                    aUpperSize = concatenatedIntervals.size() / 2;</span>
<span class="fc" id="L931">                    aLower++;</span>
                }

<span class="fc" id="L934">                writePoint = append(concatenatedIntervals, writePoint, Math.max(aLo, bLo), Math.min(aHi, bHi));</span>
            }
<span class="fc" id="L936">        }</span>

<span class="fc" id="L938">        concatenatedIntervals.setPos(2 * writePoint);</span>
<span class="fc" id="L939">    }</span>

    /**
     * Inverts intervals. This method also produces inclusive edges that differ from source ones by 1 milli.
     *
     * @param intervals collection of intervals
     */
    static void invert(LongList intervals) {
<span class="fc" id="L947">        invert(intervals, 0);</span>
<span class="fc" id="L948">    }</span>

    /**
     * Inverts intervals. This method also produces inclusive edges that differ from source ones by 1 milli.
     *
     * @param intervals collection of intervals
     */
    static void invert(LongList intervals, int startIndex) {
<span class="fc" id="L956">        long last = Long.MIN_VALUE;</span>
<span class="fc" id="L957">        int n = intervals.size();</span>
<span class="fc" id="L958">        int writeIndex = startIndex;</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">        for (int i = startIndex; i &lt; n; i += 2) {</span>
<span class="fc" id="L960">            final long lo = intervals.getQuick(i);</span>
<span class="fc" id="L961">            final long hi = intervals.getQuick(i + 1);</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">            if (lo &gt; last) {</span>
<span class="fc" id="L963">                intervals.setQuick(writeIndex, last);</span>
<span class="fc" id="L964">                intervals.setQuick(writeIndex + 1, lo - 1);</span>
<span class="fc" id="L965">                writeIndex += 2;</span>
            }
<span class="fc" id="L967">            last = hi + 1;</span>
        }

        // If last hi was Long.MAX_VALUE then last will be Long.MIN_VALUE after +1 overflow
<span class="fc bfc" id="L971" title="All 2 branches covered.">        if (last != Long.MIN_VALUE) {</span>
<span class="fc" id="L972">            intervals.extendAndSet(writeIndex + 1, Long.MAX_VALUE);</span>
<span class="fc" id="L973">            intervals.setQuick(writeIndex, last);</span>
<span class="fc" id="L974">            writeIndex += 2;</span>
        }

<span class="fc" id="L977">        intervals.setPos(writeIndex);</span>
<span class="fc" id="L978">    }</span>

    /**
     * Unions two lists of intervals compacted in one list in place.
     * Intervals to be chronologically ordered and result list will be ordered as well.
     * &lt;p&gt;
     * Treat a as 2 lists,
     * a: first from 0 to divider
     * b: from divider to the end of list
     *
     * @param intervals 2 lists of intervals concatenated in 1
     */
    static void unionInplace(LongList intervals, int dividerIndex) {
<span class="fc" id="L991">        final int sizeB = dividerIndex + (intervals.size() - dividerIndex);</span>
<span class="fc" id="L992">        int aLower = 0;</span>

<span class="fc" id="L994">        int intervalB = dividerIndex;</span>
<span class="fc" id="L995">        int writePoint = 0;</span>

<span class="fc" id="L997">        int aUpperSize = sizeB;</span>
<span class="fc" id="L998">        int aUpper = sizeB;</span>
<span class="fc" id="L999">        long aLo = 0, aHi = 0, bLo = 0, bHi = 0;</span>

<span class="fc bfc" id="L1001" title="All 6 branches covered.">        while (aLower &lt; dividerIndex || aUpper &lt; aUpperSize || intervalB &lt; sizeB) {</span>

            // This tries to get either interval from A or from B
            // where it's available
            // and union with last interval in writePoint position
<span class="fc bfc" id="L1006" title="All 4 branches covered.">            boolean hasA = aLower &lt; dividerIndex || aUpper &lt; aUpperSize;</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">            if (hasA) {</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">                int intervalA = aUpper &lt; aUpperSize ? aUpper : aLower;</span>
<span class="fc" id="L1009">                aLo = intervals.getQuick(intervalA);</span>
<span class="fc" id="L1010">                aHi = intervals.getQuick(intervalA + 1);</span>
            }

<span class="fc bfc" id="L1013" title="All 2 branches covered.">            boolean hasB = intervalB &lt; sizeB;</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">            if (hasB) {</span>
<span class="fc" id="L1015">                bLo = intervals.getQuick(intervalB);</span>
<span class="fc" id="L1016">                bHi = intervals.getQuick(intervalB + 1);</span>
            }

            long nextLo, nextHi;

<span class="fc bfc" id="L1021" title="All 2 branches covered.">            if (hasA) {</span>
<span class="fc bfc" id="L1022" title="All 4 branches covered.">                if (hasB &amp;&amp; bLo &lt; aLo) {</span>
<span class="fc" id="L1023">                    nextLo = bLo;</span>
<span class="fc" id="L1024">                    nextHi = bHi;</span>
<span class="fc" id="L1025">                    intervalB += 2;</span>
                } else {
<span class="fc" id="L1027">                    nextLo = aLo;</span>
<span class="fc" id="L1028">                    nextHi = aHi;</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">                    if (aUpper &lt; aUpperSize) {</span>
<span class="fc" id="L1030">                        aUpper += 2;</span>
                    } else {
<span class="fc" id="L1032">                        aLower += 2;</span>
                    }
                }
            } else {
<span class="fc" id="L1036">                nextLo = bLo;</span>
<span class="fc" id="L1037">                nextHi = bHi;</span>
<span class="fc" id="L1038">                intervalB += 2;</span>
            }

<span class="fc bfc" id="L1041" title="All 2 branches covered.">            if (writePoint &gt; 0) {</span>
<span class="fc" id="L1042">                long prevHi = intervals.getQuick(writePoint - 1);</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">                if (nextLo &lt;= prevHi) {</span>
                    // Intersection with previously safed interval
<span class="fc" id="L1045">                    intervals.setQuick(writePoint - 1, Math.max(nextHi, prevHi));</span>
<span class="fc" id="L1046">                    continue;</span>
                }
            }

            // new interval to save
<span class="pc bpc" id="L1051" title="1 of 4 branches missed.">            assert writePoint &lt;= aLower || writePoint &gt;= dividerIndex;</span>
<span class="fc bfc" id="L1052" title="All 4 branches covered.">            if (writePoint == aLower &amp;&amp; aLower &lt; dividerIndex) {</span>
                // We cannot keep A position, it will be overwritten
                // Copy a point to A area instead
<span class="fc" id="L1055">                intervals.add(</span>
<span class="fc" id="L1056">                        intervals.getQuick(writePoint),</span>
<span class="fc" id="L1057">                        intervals.getQuick(writePoint + 1)</span>
                );
<span class="fc" id="L1059">                aUpperSize = intervals.size();</span>
<span class="fc" id="L1060">                aLower += 2;</span>
            }
<span class="fc" id="L1062">            intervals.setQuick(writePoint++, nextLo);</span>
<span class="fc" id="L1063">            intervals.setQuick(writePoint++, nextHi);</span>
<span class="fc" id="L1064">        }</span>

<span class="fc" id="L1066">        intervals.setPos(writePoint);</span>
<span class="fc" id="L1067">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>