<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExpressionParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin</a> &gt; <span class="el_source">ExpressionParser.java</span></div><h1>ExpressionParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin;

import io.questdb.cairo.ColumnType;
import io.questdb.griffin.model.ExpressionNode;
import io.questdb.std.*;

import static io.questdb.griffin.OperatorExpression.DOT_PRECEDENCE;

class ExpressionParser {

    private static final int BRANCH_BETWEEN_END = 14;
    private static final int BRANCH_BETWEEN_START = 13;
    private static final int BRANCH_CASE_CONTROL = 10;
    private static final int BRANCH_CASE_START = 9;
    private static final int BRANCH_CAST_AS = 11;
    private static final int BRANCH_COMMA = 1;
    private static final int BRANCH_CONSTANT = 4;
    private static final int BRANCH_DOT = 12;
    private static final int BRANCH_DOT_DEREFERENCE = 17;
    private static final int BRANCH_GEOHASH = 18;
    private static final int BRANCH_LAMBDA = 7;
    private static final int BRANCH_LEFT_BRACKET = 15;
    private static final int BRANCH_LEFT_PARENTHESIS = 2;
    private static final int BRANCH_LITERAL = 6;
    private static final int BRANCH_NONE = 0;
    private static final int BRANCH_OPERATOR = 5;
    private static final int BRANCH_RIGHT_BRACKET = 16;
    private static final int BRANCH_RIGHT_PARENTHESIS = 3;
    private static final int BRANCH_TIMESTAMP_ZONE = 19;
<span class="fc" id="L54">    private static final LowerCaseAsciiCharSequenceObjHashMap&lt;CharSequence&gt; allFunctions = new LowerCaseAsciiCharSequenceObjHashMap&lt;&gt;();</span>
<span class="fc" id="L55">    private static final LowerCaseAsciiCharSequenceIntHashMap caseKeywords = new LowerCaseAsciiCharSequenceIntHashMap();</span>
<span class="fc" id="L56">    private static final IntHashSet nonLiteralBranches = new IntHashSet();</span>
<span class="fc" id="L57">    private final IntStack argStackDepthStack = new IntStack();</span>
<span class="fc" id="L58">    private final IntStack backupArgStackDepthStack = new IntStack();</span>
<span class="fc" id="L59">    private final IntStack backupCaseBraceCountStack = new IntStack();</span>
<span class="fc" id="L60">    private final IntStack backupCastBraceCountStack = new IntStack();</span>
<span class="fc" id="L61">    private final IntStack backupParamCountStack = new IntStack();</span>
<span class="fc" id="L62">    private final IntStack braceCountStack = new IntStack();</span>
<span class="fc" id="L63">    private final IntStack bracketCountStack = new IntStack();</span>
<span class="fc" id="L64">    private final IntStack caseBraceCountStack = new IntStack();</span>
<span class="fc" id="L65">    private final IntStack castBraceCountStack = new IntStack();</span>
    private final CharacterStore characterStore;
    private final ObjectPool&lt;ExpressionNode&gt; expressionNodePool;
<span class="fc" id="L68">    private final ObjStack&lt;ExpressionNode&gt; opStack = new ObjStack&lt;&gt;();</span>
<span class="fc" id="L69">    private final IntStack paramCountStack = new IntStack();</span>
    private final SqlParser sqlParser;

<span class="fc" id="L72">    ExpressionParser(ObjectPool&lt;ExpressionNode&gt; expressionNodePool, SqlParser sqlParser, CharacterStore characterStore) {</span>
<span class="fc" id="L73">        this.expressionNodePool = expressionNodePool;</span>
<span class="fc" id="L74">        this.sqlParser = sqlParser;</span>
<span class="fc" id="L75">        this.characterStore = characterStore;</span>
<span class="fc" id="L76">    }</span>

    public static int extractGeoHashSuffix(int position, CharSequence tok) throws SqlException {
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        assert tok.charAt(0) == '#'; // ^ ^</span>
        // EP has already checked that the 'd' in '/d', '/dd' are numeric [0..9]
<span class="fc" id="L81">        int tokLen = tok.length();</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">        if (tokLen &gt; 1) {</span>
<span class="fc bfc" id="L83" title="All 4 branches covered.">            if (tokLen &gt;= 3 &amp;&amp; tok.charAt(tokLen - 3) == '/') { // '/dd'</span>
<span class="fc" id="L84">                short bits = (short) (10 * tok.charAt(tokLen - 2) + tok.charAt(tokLen - 1) - 528); // 10 * 48 + 48</span>
<span class="fc bfc" id="L85" title="All 4 branches covered.">                if (bits &gt;= 1 &amp;&amp; bits &lt;= ColumnType.GEO_HASH_MAX_BITS_LENGTH) {</span>
<span class="fc" id="L86">                    return Numbers.encodeLowHighShorts((short) 3, bits);</span>
                }
<span class="fc" id="L88">                throw SqlException.$(position, &quot;invalid bits size for GEOHASH constant: &quot;).put(tok);</span>
            }
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (tok.charAt(tokLen - 2) == '/') { // '/d'</span>
<span class="fc" id="L91">                char du = tok.charAt(tokLen - 1);</span>
<span class="fc bfc" id="L92" title="All 4 branches covered.">                if (du &gt;= '1' &amp;&amp; du &lt;= '9') {</span>
<span class="fc" id="L93">                    return Numbers.encodeLowHighShorts((short) 2, (short) (du - 48));</span>
                }
<span class="fc" id="L95">                throw SqlException.$(position, &quot;invalid bits size for GEOHASH constant: &quot;).put(tok);</span>
            }
        }
<span class="fc" id="L98">        return Numbers.encodeLowHighShorts((short) 0, (short) (5 * Math.max(tokLen - 1, 0))); // - 1 to exclude '#'</span>
    }

    public static boolean isGeoHashBitsConstant(CharSequence tok) {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        assert tok.charAt(0) == '#'; // ^ ^, also suffix not allowed</span>
<span class="fc" id="L103">        int len = tok.length();</span>
        // 2nd '#'
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">        return len &gt; 1 &amp;&amp; tok.charAt(1) == '#';</span>
    }

    public static boolean isGeoHashCharsConstant(CharSequence tok) {
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        assert tok.charAt(0) == '#'; // called by ExpressionParser where this has been checked.</span>
        // the EP will eagerly try to detect '/dd' following the geohash token, and if so
        // it will create a FloatingSequencePair with '/' as separator. At this point
        // however, '/dd' does not exist, tok is just the potential geohash chars constant, with leading '#'
<span class="fc" id="L113">        final int len = tok.length();</span>
<span class="fc bfc" id="L114" title="All 4 branches covered.">        return len &lt;= 1 || tok.charAt(1) != '#';</span>
    }

    private static SqlException missingArgs(int position) {
<span class="fc" id="L118">        return SqlException.$(position, &quot;missing arguments&quot;);</span>
    }

    private int copyToBackup(IntStack paramCountStack, IntStack backupParamCountStack) {
<span class="fc" id="L122">        final int size = paramCountStack.size();</span>
<span class="fc" id="L123">        paramCountStack.copyTo(backupParamCountStack, size);</span>
<span class="fc" id="L124">        return size;</span>
    }

    private boolean isCount() {
<span class="pc bpc" id="L128" title="2 of 6 branches missed.">        return opStack.size() == 2 &amp;&amp; Chars.equals(opStack.peek().token, '(') &amp;&amp; SqlKeywords.isCountKeyword(opStack.peek(1).token);</span>
    }

    private boolean isExtractFunctionOnStack() {
<span class="fc" id="L132">        boolean found = false;</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (int i = 0, n = opStack.size(); i &lt; n; i++) {</span>
<span class="fc" id="L134">            ExpressionNode peek = opStack.peek(i);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (Chars.equals(peek.token, '(')) {</span>
<span class="fc bfc" id="L136" title="All 4 branches covered.">                if ((i + 1) &lt; n &amp;&amp; SqlKeywords.isExtractKeyword(opStack.peek(i + 1).token)) {</span>
<span class="fc" id="L137">                    found = true;</span>
<span class="fc" id="L138">                    break;</span>
                }
            }
        }
<span class="fc" id="L142">        return found;</span>
    }

    private boolean isTypeQualifier() {
<span class="fc bfc" id="L146" title="All 4 branches covered.">        return opStack.size() &gt;= 2 &amp;&amp; SqlKeywords.isColonColon(opStack.peek(1).token);</span>
    }

    private int onNode(ExpressionParserListener listener, ExpressionNode node, int argStackDepth) throws SqlException {
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (argStackDepth &lt; node.paramCount) {</span>
<span class="fc" id="L151">            throw SqlException.position(node.position).put(&quot;too few arguments for '&quot;).put(node.token).put(&quot;' [found=&quot;).put(argStackDepth).put(&quot;,expected=&quot;).put(node.paramCount).put(']');</span>
        }
<span class="fc" id="L153">        listener.onNode(node);</span>
<span class="fc" id="L154">        return argStackDepth - node.paramCount + 1;</span>
    }

    private int processLambdaQuery(GenericLexer lexer, ExpressionParserListener listener, int argStackDepth) throws SqlException {
        // It is highly likely this expression parser will be re-entered when
        // parsing sub-query. To prevent sub-query consuming operation stack we must add a
        // control node, which would prevent such consumption

        // precedence must be max value to make sure control node isn't
        // consumed as parameter to a greedy function
<span class="fc" id="L164">        opStack.push(expressionNodePool.next().of(ExpressionNode.CONTROL, &quot;|&quot;, Integer.MAX_VALUE, lexer.lastTokenPosition()));</span>

<span class="fc" id="L166">        final int paramCountStackSize = copyToBackup(paramCountStack, backupParamCountStack);</span>
<span class="fc" id="L167">        final int argStackDepthStackSize = copyToBackup(argStackDepthStack, backupArgStackDepthStack);</span>
<span class="fc" id="L168">        final int castBraceCountStackSize = copyToBackup(castBraceCountStack, backupCastBraceCountStack);</span>
<span class="fc" id="L169">        final int caseBraceCountStackSize = copyToBackup(caseBraceCountStack, backupCaseBraceCountStack);</span>

<span class="fc" id="L171">        int pos = lexer.lastTokenPosition();</span>
        // allow sub-query to parse &quot;select&quot; keyword
<span class="fc" id="L173">        lexer.unparseLast();</span>

<span class="fc" id="L175">        ExpressionNode node = expressionNodePool.next().of(ExpressionNode.QUERY, null, 0, pos);</span>
        // validate is Query is allowed
<span class="fc" id="L177">        onNode(listener, node, argStackDepth);</span>
        // we can compile query if all is well
<span class="fc" id="L179">        node.queryModel = sqlParser.parseAsSubQuery(lexer, null);</span>
<span class="fc" id="L180">        argStackDepth = onNode(listener, node, argStackDepth);</span>

        // pop our control node if sub-query hasn't done it
<span class="fc" id="L183">        ExpressionNode control = opStack.peek();</span>
<span class="pc bpc" id="L184" title="3 of 6 branches missed.">        if (control != null &amp;&amp; control.type == ExpressionNode.CONTROL &amp;&amp; Chars.equals(control.token, '|')) {</span>
<span class="fc" id="L185">            opStack.pop();</span>
        }

<span class="fc" id="L188">        backupParamCountStack.copyTo(paramCountStack, paramCountStackSize);</span>
<span class="fc" id="L189">        backupArgStackDepthStack.copyTo(argStackDepthStack, argStackDepthStackSize);</span>
<span class="fc" id="L190">        backupCastBraceCountStack.copyTo(castBraceCountStack, castBraceCountStackSize);</span>
<span class="fc" id="L191">        backupCaseBraceCountStack.copyTo(caseBraceCountStack, caseBraceCountStackSize);</span>
<span class="fc" id="L192">        return argStackDepth;</span>
    }

    @SuppressWarnings(&quot;ConstantConditions&quot;)
    void parseExpr(GenericLexer lexer, ExpressionParserListener listener) throws SqlException {
        try {
<span class="fc" id="L198">            int paramCount = 0;</span>
<span class="fc" id="L199">            int braceCount = 0;</span>
<span class="fc" id="L200">            int bracketCount = 0;</span>
<span class="fc" id="L201">            int betweenCount = 0;</span>
<span class="fc" id="L202">            int betweenAndCount = 0;</span>
<span class="fc" id="L203">            int caseCount = 0;</span>
<span class="fc" id="L204">            int argStackDepth = 0;</span>
<span class="fc" id="L205">            int castAsCount = 0;</span>
<span class="fc" id="L206">            int castBraceCount = 0;</span>
<span class="fc" id="L207">            int betweenStartCaseCount = 0;</span>

            ExpressionNode node;
            CharSequence tok;
            char thisChar;
            int prevBranch;
<span class="fc" id="L213">            int thisBranch = BRANCH_NONE;</span>
<span class="fc" id="L214">            boolean asPoppedNull = false;</span>
            OUT:
<span class="fc bfc" id="L216" title="All 2 branches covered.">            while ((tok = SqlUtil.fetchNext(lexer)) != null) {</span>
<span class="fc" id="L217">                thisChar = tok.charAt(0);</span>
<span class="fc" id="L218">                prevBranch = thisBranch;</span>
<span class="fc" id="L219">                boolean processDefaultBranch = false;</span>
<span class="fc" id="L220">                final int lastPos = lexer.lastTokenPosition();</span>
<span class="fc bfc" id="L221" title="All 19 branches covered.">                switch (thisChar) {</span>
                    case '-':
                    case '+':
<span class="fc" id="L224">                        processDefaultBranch = true;</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">                        if (prevBranch == BRANCH_CONSTANT) {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">                            if (lastPos &gt; 0) {</span>
<span class="fc" id="L227">                                char c = lexer.getContent().charAt(lastPos - 1);</span>
<span class="fc bfc" id="L228" title="All 4 branches covered.">                                if (c == 'e' || c == 'E') { // Incomplete scientific floating-point literal</span>
<span class="fc" id="L229">                                    ExpressionNode en = opStack.peek();</span>
<span class="fc" id="L230">                                    ((GenericLexer.FloatingSequence) en.token).setHi(lastPos + 1);</span>
<span class="fc" id="L231">                                    processDefaultBranch = false;</span>
                                }
<span class="fc" id="L233">                            }</span>
                        }
                        break;
                    case '.':
                        // Check what is on stack. If we have 'a .b' we have to stop processing
<span class="fc bfc" id="L238" title="All 4 branches covered.">                        if (thisBranch == BRANCH_LITERAL || thisBranch == BRANCH_CONSTANT) {</span>
<span class="fc" id="L239">                            char c = lexer.getContent().charAt(lastPos - 1);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                            if (GenericLexer.WHITESPACE_CH.contains(c)) {</span>
<span class="fc" id="L241">                                lexer.unparseLast();</span>
<span class="fc" id="L242">                                break OUT;</span>
                            }

<span class="fc bfc" id="L245" title="All 2 branches covered.">                            if (Chars.isQuote(c)) {</span>
<span class="fc" id="L246">                                ExpressionNode en = opStack.pop();</span>
<span class="fc" id="L247">                                CharacterStoreEntry cse = characterStore.newEntry();</span>
<span class="fc" id="L248">                                cse.put(GenericLexer.unquote(en.token)).put('.');</span>
<span class="fc" id="L249">                                opStack.push(expressionNodePool.next().of(ExpressionNode.LITERAL, cse.toImmutable(), Integer.MIN_VALUE, en.position));</span>
<span class="fc" id="L250">                            } else {</span>
                                // attach dot to existing literal or constant
<span class="fc" id="L252">                                ExpressionNode en = opStack.peek();</span>
<span class="fc" id="L253">                                ((GenericLexer.FloatingSequence) en.token).setHi(lastPos + 1);</span>
                            }
                        }
<span class="fc bfc" id="L256" title="All 4 branches covered.">                        if (prevBranch == BRANCH_DOT || prevBranch == BRANCH_DOT_DEREFERENCE) {</span>
<span class="fc" id="L257">                            throw SqlException.$(lastPos, &quot;too many dots&quot;);</span>
                        }

<span class="fc bfc" id="L260" title="All 2 branches covered.">                        if (prevBranch == BRANCH_RIGHT_PARENTHESIS) {</span>
<span class="fc" id="L261">                            thisBranch = BRANCH_DOT_DEREFERENCE;</span>
                        } else {
<span class="fc" id="L263">                            thisBranch = BRANCH_DOT;</span>
                        }
<span class="fc" id="L265">                        break;</span>
                    case ',':
<span class="fc bfc" id="L267" title="All 4 branches covered.">                        if (prevBranch == BRANCH_COMMA || prevBranch == BRANCH_LEFT_PARENTHESIS) {</span>
<span class="fc" id="L268">                            throw missingArgs(lastPos);</span>
                        }
<span class="fc" id="L270">                        thisBranch = BRANCH_COMMA;</span>

<span class="fc bfc" id="L272" title="All 2 branches covered.">                        if (braceCount == 0) {</span>
                            // comma outside of braces
<span class="fc" id="L274">                            lexer.unparseLast();</span>
<span class="fc" id="L275">                            break OUT;</span>
                        }

<span class="fc bfc" id="L278" title="All 4 branches covered.">                        if (castBraceCount &gt; 0 &amp;&amp; castBraceCountStack.peek() == castBraceCount) {</span>
<span class="fc" id="L279">                            throw SqlException.$(lastPos, &quot;',' is not expected here&quot;);</span>
                        }

                        // If the token is a function argument separator (e.g., a comma):
                        // Until the token at the top of the stack is a left parenthesis,
                        // pop operators off the stack onto the output queue. If no left
                        // parentheses are encountered, either the separator was misplaced or
                        // parentheses were mismatched.
<span class="pc bpc" id="L287" title="1 of 4 branches missed.">                        while ((node = opStack.pop()) != null &amp;&amp; node.token.charAt(0) != '(') {</span>
<span class="fc" id="L288">                            argStackDepth = onNode(listener, node, argStackDepth);</span>
                        }

<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                        if (node != null) {</span>
<span class="fc" id="L292">                            opStack.push(node);</span>
                        }

<span class="fc" id="L295">                        paramCount++;</span>
<span class="fc" id="L296">                        break;</span>

                    case '[':
<span class="fc bfc" id="L299" title="All 2 branches covered.">                        if (isTypeQualifier()) {</span>
<span class="fc" id="L300">                            ExpressionNode en = opStack.peek();</span>
<span class="fc" id="L301">                            ((GenericLexer.FloatingSequence) en.token).setHi(lastPos + 1);</span>
<span class="fc" id="L302">                        } else {</span>
<span class="fc" id="L303">                            thisBranch = BRANCH_LEFT_BRACKET;</span>

                            // If the token is a left parenthesis, then push it onto the stack.
<span class="fc" id="L306">                            paramCountStack.push(paramCount);</span>
<span class="fc" id="L307">                            paramCount = 0;</span>

<span class="fc" id="L309">                            argStackDepthStack.push(argStackDepth);</span>
<span class="fc" id="L310">                            argStackDepth = 0;</span>

                            // pop left literal or . expression, e.g. &quot;a.b[i]&quot;
                            // the precedence of [ is fixed to 2
                            ExpressionNode other;
<span class="fc bfc" id="L315" title="All 2 branches covered.">                            while ((other = opStack.peek()) != null) {</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">                                if ((2 &gt; other.precedence)) {</span>
<span class="fc" id="L317">                                    argStackDepth = onNode(listener, other, argStackDepth);</span>
<span class="fc" id="L318">                                    opStack.pop();</span>
                                } else {
                                    break;
                                }
                            }

                            // precedence must be max value to make sure control node isn't
                            // consumed as parameter to a greedy function
<span class="fc" id="L326">                            opStack.push(expressionNodePool.next().of(ExpressionNode.CONTROL, &quot;[&quot;, Integer.MAX_VALUE, lastPos));</span>
<span class="fc" id="L327">                            bracketCount++;</span>

<span class="fc" id="L329">                            braceCountStack.push(braceCount);</span>
<span class="fc" id="L330">                            braceCount = 0;</span>
                        }

<span class="fc" id="L333">                        break;</span>

                    case ']':
<span class="fc bfc" id="L336" title="All 2 branches covered.">                        if (isTypeQualifier()) {</span>
<span class="fc" id="L337">                            ExpressionNode en = opStack.peek();</span>
<span class="fc" id="L338">                            ((GenericLexer.FloatingSequence) en.token).setHi(lastPos + 1);</span>
<span class="fc" id="L339">                        } else {</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                            if (bracketCount == 0) {</span>
<span class="fc" id="L341">                                lexer.unparseLast();</span>
<span class="fc" id="L342">                                break OUT;</span>
                            }

<span class="fc" id="L345">                            thisBranch = BRANCH_RIGHT_BRACKET;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                            if (prevBranch == BRANCH_LEFT_BRACKET) {</span>
<span class="fc" id="L347">                                throw SqlException.$(lastPos, &quot;missing array index&quot;);</span>
                            }

<span class="fc" id="L350">                            bracketCount--;</span>

                            // pop the array index from the stack, it could be an operator
<span class="pc bpc" id="L353" title="2 of 6 branches missed.">                            while ((node = opStack.pop()) != null &amp;&amp; (node.type != ExpressionNode.CONTROL || node.token.charAt(0) != '[')) {</span>
<span class="fc" id="L354">                                argStackDepth = onNode(listener, node, argStackDepth);</span>
                            }

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">                            if (argStackDepthStack.notEmpty()) {</span>
<span class="fc" id="L358">                                argStackDepth += argStackDepthStack.pop();</span>
                            }

<span class="pc bpc" id="L361" title="1 of 2 branches missed.">                            if (paramCountStack.notEmpty()) {</span>
<span class="fc" id="L362">                                paramCount = paramCountStack.pop();</span>
                            }

<span class="pc bpc" id="L365" title="1 of 2 branches missed.">                            if (braceCountStack.notEmpty()) {</span>
<span class="fc" id="L366">                                braceCount = braceCountStack.pop();</span>
                            }

<span class="fc" id="L369">                            node = expressionNodePool.next().of(</span>
                                    ExpressionNode.ARRAY_ACCESS,
                                    &quot;[]&quot;,
                                    2,
                                    lastPos
                            );
<span class="fc" id="L375">                            node.paramCount = 2;</span>
<span class="fc" id="L376">                            opStack.push(node);</span>
                        }

<span class="fc" id="L379">                        break;</span>

                    case 'g':
                    case 'G':
<span class="fc bfc" id="L383" title="All 2 branches covered.">                        if (SqlKeywords.isGeoHashKeyword(tok)) {</span>
<span class="fc" id="L384">                            CharSequence geohashTok = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L385">                            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L386" title="All 4 branches covered.">                            if (tok == null || tok.charAt(0) != '(') {</span>
<span class="fc" id="L387">                                lexer.backTo(lastPos + SqlKeywords.GEOHASH_KEYWORD_LENGTH, geohashTok);</span>
<span class="fc" id="L388">                                tok = geohashTok;</span>
<span class="fc" id="L389">                                processDefaultBranch = true;</span>
<span class="fc" id="L390">                                break;</span>
                            }
<span class="fc" id="L392">                            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L393" title="All 4 branches covered.">                            if (tok != null &amp;&amp; tok.charAt(0) != ')') {</span>
<span class="fc" id="L394">                                opStack.push(expressionNodePool.next().of(</span>
                                        ExpressionNode.CONSTANT,
<span class="fc" id="L396">                                        lexer.immutablePairOf(geohashTok, tok),</span>
                                        Integer.MIN_VALUE,
                                        lastPos));
<span class="fc" id="L399">                                tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L400" title="All 4 branches covered.">                                if (tok == null || tok.charAt(0) != ')') {</span>
<span class="fc" id="L401">                                    throw SqlException.$(lexer.lastTokenPosition(), &quot;invalid GEOHASH, missing ')'&quot;);</span>
                                }
                            } else {
<span class="fc" id="L404">                                throw SqlException.$(lexer.lastTokenPosition(), &quot;invalid GEOHASH, invalid type precision&quot;);</span>
                            }
<span class="fc" id="L406">                            thisBranch = BRANCH_GEOHASH;</span>
<span class="fc" id="L407">                        } else {</span>
<span class="fc" id="L408">                            processDefaultBranch = true;</span>
                        }
<span class="fc" id="L410">                        break;</span>

                    case '#':
<span class="fc bfc" id="L413" title="All 2 branches covered.">                        if (isGeoHashCharsConstant(tok)) { // e.g. #sp052w92p1p8</span>
<span class="fc" id="L414">                            thisBranch = BRANCH_CONSTANT;</span>
<span class="fc" id="L415">                            CharSequence geohashTok = GenericLexer.immutableOf(tok);</span>
                            // optional / bits '/dd', '/d'
<span class="fc" id="L417">                            CharSequence slash = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L418" title="All 4 branches covered.">                            if (slash == null || slash.charAt(0) != '/') {</span>
<span class="fc" id="L419">                                lexer.unparseLast();</span>
<span class="fc" id="L420">                                opStack.push(expressionNodePool.next().of(</span>
                                        ExpressionNode.CONSTANT,
                                        geohashTok, // standard token, no suffix '/d', '/dd'
                                        Integer.MIN_VALUE,
                                        lastPos));
<span class="fc" id="L425">                                break;</span>
                            }
<span class="fc" id="L427">                            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L428" title="All 4 branches covered.">                            if (tok == null || !Chars.isOnlyDecimals(tok)) { // ranges are checked later by FunctionParser.createConstant</span>
<span class="fc" id="L429">                                throw SqlException.$(lexer.lastTokenPosition(), &quot;missing bits size for GEOHASH constant&quot;);</span>
                            }
<span class="fc" id="L431">                            opStack.push(expressionNodePool.next().of(</span>
                                    ExpressionNode.CONSTANT,
<span class="fc" id="L433">                                    lexer.immutablePairOf(geohashTok, '/', tok), // token plus suffix '/d', '/dd', where d in [0..9]</span>
                                    Integer.MIN_VALUE,
                                    lastPos));
<span class="fc" id="L436">                            break;</span>
                        }

<span class="pc bpc" id="L439" title="1 of 2 branches missed.">                        if (isGeoHashBitsConstant(tok)) { // e.g. ##01110001</span>
<span class="fc" id="L440">                            thisBranch = BRANCH_CONSTANT;</span>
<span class="fc" id="L441">                            opStack.push(expressionNodePool.next().of(</span>
                                    ExpressionNode.CONSTANT,
<span class="fc" id="L443">                                    GenericLexer.immutableOf(tok), // geohash bit literals do not allow suffix syntax</span>
                                    Integer.MIN_VALUE,
                                    lastPos));
<span class="fc" id="L446">                            break;</span>
                        }

<span class="nc" id="L449">                        processDefaultBranch = true;</span>
<span class="nc" id="L450">                        break;</span>

                    case '(':
<span class="fc bfc" id="L453" title="All 2 branches covered.">                        if (prevBranch == BRANCH_RIGHT_PARENTHESIS) {</span>
<span class="fc" id="L454">                            throw SqlException.$(lastPos, &quot;not a method call&quot;);</span>
                        }

<span class="fc" id="L457">                        thisBranch = BRANCH_LEFT_PARENTHESIS;</span>
                        // If the token is a left parenthesis, then push it onto the stack.
<span class="fc" id="L459">                        paramCountStack.push(paramCount);</span>
<span class="fc" id="L460">                        paramCount = 0;</span>

<span class="fc" id="L462">                        argStackDepthStack.push(argStackDepth);</span>
<span class="fc" id="L463">                        argStackDepth = 0;</span>

<span class="fc" id="L465">                        bracketCountStack.push(bracketCount);</span>
<span class="fc" id="L466">                        bracketCount = 0;</span>

                        // precedence must be max value to make sure control node isn't
                        // consumed as parameter to a greedy function
<span class="fc" id="L470">                        opStack.push(expressionNodePool.next().of(ExpressionNode.CONTROL, &quot;(&quot;, Integer.MAX_VALUE, lastPos));</span>

                        // check if this brace was opened after 'cast'
<span class="fc bfc" id="L473" title="All 4 branches covered.">                        if (castBraceCountStack.size() &gt; 0 &amp;&amp; castBraceCountStack.peek() == -1) {</span>
<span class="fc" id="L474">                            castBraceCountStack.update(castBraceCount + 1);</span>
                        }
                        // if this brace is inside a 'cast', use the helper counter to parse inner braces
<span class="fc bfc" id="L477" title="All 2 branches covered.">                        if (castBraceCountStack.size() &gt; 0) {</span>
<span class="fc" id="L478">                            castBraceCount++;</span>
                        }

<span class="fc" id="L481">                        braceCount++;</span>
<span class="fc" id="L482">                        break;</span>

                    case ')':
<span class="fc bfc" id="L485" title="All 2 branches covered.">                        if (prevBranch == BRANCH_COMMA) {</span>
<span class="fc" id="L486">                            throw missingArgs(lastPos);</span>
                        }

<span class="fc bfc" id="L489" title="All 2 branches covered.">                        if (braceCount == 0) {</span>
<span class="fc" id="L490">                            lexer.unparseLast();</span>
<span class="fc" id="L491">                            break OUT;</span>
                        }

<span class="fc" id="L494">                        thisBranch = BRANCH_RIGHT_PARENTHESIS;</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">                        int localParamCount = (prevBranch == BRANCH_LEFT_PARENTHESIS ? 0 : paramCount + 1);</span>
                        final boolean thisWasCast;

<span class="fc bfc" id="L498" title="All 4 branches covered.">                        if (castBraceCountStack.size() &gt; 0 &amp;&amp; castBraceCountStack.peek() == castBraceCount) {</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">                            if (castAsCount == 0) {</span>
<span class="fc" id="L500">                                throw SqlException.$(lastPos, &quot;'as' missing&quot;);</span>
                            }

<span class="fc" id="L503">                            castAsCount--;</span>
<span class="fc" id="L504">                            castBraceCountStack.pop();</span>
<span class="fc" id="L505">                            thisWasCast = true;</span>
                        } else {
<span class="fc" id="L507">                            thisWasCast = false;</span>
                        }

<span class="fc bfc" id="L510" title="All 2 branches covered.">                        if (castBraceCount &gt; 0) {</span>
<span class="fc" id="L511">                            castBraceCount--;</span>
                        }

<span class="fc" id="L514">                        braceCount--;</span>
                        // If the token is a right parenthesis:
                        // Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.
                        // Pop the left parenthesis from the stack, but not onto the output queue.
                        //        If the token at the top of the stack is a function token, pop it onto the output queue.
                        //        If the stack runs out without finding a left parenthesis, then there are mismatched parentheses.
<span class="pc bpc" id="L520" title="1 of 4 branches missed.">                        while ((node = opStack.pop()) != null &amp;&amp; node.token.charAt(0) != '(') {</span>
                            // special case - (*) expression
<span class="fc bfc" id="L522" title="All 6 branches covered.">                            if (Chars.equals(node.token, '*') &amp;&amp; argStackDepth == 0 &amp;&amp; isCount()) {</span>
<span class="fc" id="L523">                                argStackDepth = onNode(listener, node, 2);</span>
                            } else {
<span class="fc bfc" id="L525" title="All 2 branches covered.">                                if (thisWasCast) {</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                                    if (prevBranch != BRANCH_GEOHASH) {</span>
                                        // validate type
<span class="fc" id="L528">                                        final short columnTypeTag = ColumnType.tagOf(node.token);</span>
<span class="pc bpc" id="L529" title="1 of 12 branches missed.">                                        if (((columnTypeTag &lt; ColumnType.BOOLEAN || (columnTypeTag &gt; ColumnType.LONG256 &amp;&amp; columnTypeTag != ColumnType.UUID)) &amp;&amp; !asPoppedNull) ||</span>
                                                (columnTypeTag == ColumnType.GEOHASH &amp;&amp; node.type == ExpressionNode.LITERAL)) {
<span class="fc" id="L531">                                            throw SqlException.$(node.position, &quot;unsupported cast&quot;);</span>
                                        }
<span class="fc" id="L533">                                        node.type = ExpressionNode.CONSTANT;</span>
                                    }
                                }
<span class="fc" id="L536">                                argStackDepth = onNode(listener, node, argStackDepth);</span>
                            }
                        }

<span class="pc bpc" id="L540" title="1 of 2 branches missed.">                        if (argStackDepthStack.notEmpty()) {</span>
<span class="fc" id="L541">                            argStackDepth += argStackDepthStack.pop();</span>
                        }

                        // enable operation or literal absorb parameters
<span class="fc bfc" id="L545" title="All 6 branches covered.">                        if ((node = opStack.peek()) != null &amp;&amp; (node.type == ExpressionNode.LITERAL || (node.type == ExpressionNode.SET_OPERATION))) {</span>
<span class="fc bfc" id="L546" title="All 4 branches covered.">                            if (!SqlKeywords.isBetweenKeyword(node.token) || betweenCount == betweenAndCount) {</span>
<span class="fc" id="L547">                                node.paramCount = localParamCount + Math.max(0, node.paramCount - 1);</span>
<span class="fc" id="L548">                                node.type = ExpressionNode.FUNCTION;</span>
<span class="fc" id="L549">                                argStackDepth = onNode(listener, node, argStackDepth);</span>
<span class="fc" id="L550">                                opStack.pop();</span>
                            }
                        } else {
                            // not at function?
                            // peek the op stack to make sure it isn't a repeating brace
<span class="fc bfc" id="L555" title="All 2 branches covered.">                            if (localParamCount &gt; 1</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">                                    &amp;&amp; (node = opStack.peek()) != null</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                                    &amp;&amp; node.token.charAt(0) == '('</span>
                            ) {
<span class="fc" id="L559">                                throw SqlException.$(lastPos, &quot;no function or operator?&quot;);</span>
                            }
                        }

<span class="pc bpc" id="L563" title="1 of 2 branches missed.">                        if (paramCountStack.notEmpty()) {</span>
<span class="fc" id="L564">                            paramCount = paramCountStack.pop();</span>
                        }

<span class="pc bpc" id="L567" title="1 of 2 branches missed.">                        if (bracketCountStack.notEmpty()) {</span>
<span class="fc" id="L568">                            bracketCount = bracketCountStack.pop();</span>
                        }

                        break;
                    case 'c':
                    case 'C':
<span class="fc bfc" id="L574" title="All 2 branches covered.">                        if (SqlKeywords.isCastKeyword(tok)) {</span>
<span class="fc" id="L575">                            CharSequence caseTok = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L576">                            tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L577" title="1 of 4 branches missed.">                            if (tok == null || tok.charAt(0) != '(') {</span>
<span class="fc" id="L578">                                lexer.backTo(lastPos + SqlKeywords.CASE_KEYWORD_LENGTH, caseTok);</span>
<span class="fc" id="L579">                                tok = caseTok;</span>
<span class="fc" id="L580">                                processDefaultBranch = true;</span>
<span class="fc" id="L581">                                break;</span>
                            }

<span class="fc" id="L584">                            lexer.backTo(lastPos + SqlKeywords.CASE_KEYWORD_LENGTH, caseTok);</span>
<span class="fc" id="L585">                            tok = caseTok;</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">                            if (prevBranch != BRANCH_DOT_DEREFERENCE) {</span>
<span class="fc" id="L587">                                castBraceCountStack.push(-1);</span>
<span class="fc" id="L588">                                thisBranch = BRANCH_OPERATOR;</span>
<span class="fc" id="L589">                                opStack.push(expressionNodePool.next().of(ExpressionNode.LITERAL, &quot;cast&quot;, Integer.MIN_VALUE, lastPos));</span>
<span class="fc" id="L590">                                break;</span>
                            } else {
<span class="fc" id="L592">                                throw SqlException.$(lastPos, &quot;'cast' is not allowed here&quot;);</span>
                            }
                        }
<span class="fc" id="L595">                        processDefaultBranch = true;</span>
<span class="fc" id="L596">                        break;</span>
                    case 'a':
                    case 'A':
<span class="fc bfc" id="L599" title="All 2 branches covered.">                        if (SqlKeywords.isAsKeyword(tok)) {</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">                            if (castAsCount &lt; castBraceCountStack.size()) {</span>

<span class="fc" id="L602">                                thisBranch = BRANCH_CAST_AS;</span>

                                // push existing args to the listener
<span class="fc" id="L605">                                int nodeCount = 0;</span>
<span class="pc bpc" id="L606" title="1 of 4 branches missed.">                                while ((node = opStack.pop()) != null &amp;&amp; node.token.charAt(0) != '(') {</span>
<span class="fc" id="L607">                                    nodeCount++;</span>
<span class="fc" id="L608">                                    asPoppedNull = SqlKeywords.isNullKeyword(node.token);</span>
<span class="fc" id="L609">                                    argStackDepth = onNode(listener, node, argStackDepth);</span>
                                }

<span class="fc bfc" id="L612" title="All 2 branches covered.">                                if (nodeCount != 1) {</span>
<span class="fc" id="L613">                                    asPoppedNull = false;</span>
                                }

<span class="pc bpc" id="L616" title="1 of 2 branches missed.">                                if (node != null) {</span>
<span class="fc" id="L617">                                    opStack.push(node);</span>
                                }

<span class="fc" id="L620">                                paramCount++;</span>
<span class="fc" id="L621">                                castAsCount++;</span>
<span class="fc" id="L622">                            } else {</span>
<span class="fc" id="L623">                                processDefaultBranch = true;</span>
                            }
<span class="fc bfc" id="L625" title="All 2 branches covered.">                        } else if (SqlKeywords.isAndKeyword(tok)) {</span>
<span class="fc bfc" id="L626" title="All 4 branches covered.">                            if (caseCount == betweenStartCaseCount &amp;&amp; betweenCount &gt; betweenAndCount) {</span>
<span class="fc" id="L627">                                betweenAndCount++;</span>
<span class="fc" id="L628">                                thisBranch = BRANCH_BETWEEN_END;</span>
<span class="pc bpc" id="L629" title="1 of 4 branches missed.">                                while ((node = opStack.pop()) != null &amp;&amp; !SqlKeywords.isBetweenKeyword(node.token)) {</span>
<span class="fc" id="L630">                                    argStackDepth = onNode(listener, node, argStackDepth);</span>
                                }

<span class="pc bpc" id="L633" title="1 of 2 branches missed.">                                if (node != null) {</span>
<span class="fc" id="L634">                                    opStack.push(node);</span>
                                }
                            } else {
<span class="fc" id="L637">                                processDefaultBranch = true;</span>
                            }
<span class="fc bfc" id="L639" title="All 2 branches covered.">                        } else if (SqlKeywords.isAllKeyword(tok)) {</span>
<span class="fc" id="L640">                            ExpressionNode operator = opStack.peek();</span>
<span class="pc bpc" id="L641" title="1 of 4 branches missed.">                            if (operator == null || operator.type != ExpressionNode.OPERATION) {</span>
<span class="fc" id="L642">                                throw SqlException.$(lastPos, &quot;missing operator&quot;);</span>
                            }
<span class="fc" id="L644">                            CharSequence funcName = allFunctions.get(operator.token);</span>
<span class="pc bpc" id="L645" title="1 of 4 branches missed.">                            if (funcName != null &amp;&amp; operator.paramCount == 2) {</span>
<span class="fc" id="L646">                                operator.type = ExpressionNode.FUNCTION;</span>
<span class="fc" id="L647">                                operator.token = funcName;</span>
                            } else {
<span class="fc" id="L649">                                throw SqlException.$(operator.position, &quot;unexpected operator&quot;);</span>
                            }
<span class="fc bfc" id="L651" title="All 8 branches covered.">                        } else if ((prevBranch == BRANCH_LITERAL || prevBranch == BRANCH_CONSTANT || prevBranch == BRANCH_RIGHT_PARENTHESIS) &amp;&amp; SqlKeywords.isAtKeyword(tok)) {</span>
<span class="fc" id="L652">                            int pos = lexer.getPosition();</span>
                            // '.' processing expects floating char sequence
<span class="fc" id="L654">                            CharSequence atTok = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L655">                            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L656" title="All 4 branches covered.">                            if (tok != null &amp;&amp; SqlKeywords.isTimeKeyword(tok)) {</span>
<span class="fc" id="L657">                                tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L658" title="All 4 branches covered.">                                if (tok != null &amp;&amp; SqlKeywords.isZoneKeyword(tok)) {</span>
                                    // do the zone thing
<span class="fc" id="L660">                                    thisBranch = BRANCH_TIMESTAMP_ZONE;</span>
                                } else {
<span class="fc" id="L662">                                    throw SqlException.$(</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">                                            tok == null ? lexer.getPosition() : lexer.lastTokenPosition(),</span>
                                            &quot;did you mean 'at time zone &lt;tz&gt;'?&quot;
                                    );
                                }
                            } else {
<span class="fc" id="L668">                                tok = atTok;</span>
                                // non-literal branches use 'tok' to create expressions
                                // however literal branches exit, pushing literal back into lexer (unparse)
                                // so for non-literal branches we have to preserve the very last token we
                                // had to peek at
<span class="pc bpc" id="L673" title="2 of 4 branches missed.">                                if (caseCount &gt; 0 || nonLiteralBranches.excludes(thisBranch)) {</span>
<span class="nc" id="L674">                                    lexer.unparseLast();</span>
                                } else {
<span class="fc" id="L676">                                    lexer.unparse(tok, lastPos, pos);</span>
                                }
<span class="fc" id="L678">                                processDefaultBranch = true;</span>
                            }

<span class="fc" id="L681">                        } else {</span>
<span class="fc" id="L682">                            processDefaultBranch = true;</span>
                        }
<span class="fc" id="L684">                        break;</span>
                    case 'b':
                    case 'B':
<span class="fc bfc" id="L687" title="All 2 branches covered.">                        if (SqlKeywords.isBetweenKeyword(tok)) {</span>
<span class="fc" id="L688">                            thisBranch = BRANCH_BETWEEN_START;</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">                            if (betweenCount &gt; betweenAndCount) {</span>
                                // Nested between are not supported
<span class="fc" id="L691">                                throw SqlException.$(lastPos, &quot;between statements cannot be nested&quot;);</span>
                            }
<span class="fc" id="L693">                            betweenCount++;</span>
<span class="fc" id="L694">                            betweenStartCaseCount = caseCount;</span>
                        }
<span class="fc" id="L696">                        processDefaultBranch = true;</span>
<span class="fc" id="L697">                        break;</span>
                    case 's':
                    case 'S':
<span class="fc bfc" id="L700" title="All 2 branches covered.">                        if (SqlKeywords.isSelectKeyword(tok)) {</span>
<span class="fc" id="L701">                            thisBranch = BRANCH_LAMBDA;</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">                            if (betweenCount &gt; 0) {</span>
<span class="fc" id="L703">                                throw SqlException.$(lastPos, &quot;constant expected&quot;);</span>
                            }
<span class="fc" id="L705">                            argStackDepth = processLambdaQuery(lexer, listener, argStackDepth);</span>
                        } else {
<span class="fc" id="L707">                            processDefaultBranch = true;</span>
                        }
<span class="fc" id="L709">                        break;</span>
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case '\'':
                    case 'E':

<span class="fc bfc" id="L723" title="All 2 branches covered.">                        if (prevBranch != BRANCH_DOT_DEREFERENCE) {</span>
                            // check if this is E'str'
<span class="fc bfc" id="L725" title="All 6 branches covered.">                            if (thisChar == 'E' &amp;&amp; (tok.length() &lt; 3 || tok.charAt(1) != '\'')) {</span>
<span class="fc" id="L726">                                processDefaultBranch = true;</span>
<span class="fc" id="L727">                                break;</span>
                            }

<span class="fc" id="L730">                            thisBranch = BRANCH_CONSTANT;</span>
<span class="pc bpc" id="L731" title="1 of 4 branches missed.">                            if (prevBranch == BRANCH_CONSTANT &amp;&amp; lastPos &gt; 0) {</span>
<span class="fc" id="L732">                                char prevChar = lexer.getContent().charAt(lastPos - 1);</span>
<span class="fc bfc" id="L733" title="All 4 branches covered.">                                if (prevChar == '-' || prevChar == '+') {</span>
<span class="fc" id="L734">                                    final ExpressionNode en = opStack.peek();</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">                                    if (en.token instanceof GenericLexer.FloatingSequence) {</span>
<span class="fc" id="L736">                                        ((GenericLexer.FloatingSequence) en.token).setHi(lexer.getTokenHi());</span>
<span class="fc" id="L737">                                        break;</span>
                                    } else {
<span class="nc" id="L739">                                        assert false;</span>
                                    }
                                }
                            }
<span class="fc bfc" id="L743" title="All 2 branches covered.">                            if (prevBranch == BRANCH_DOT) {</span>
<span class="fc" id="L744">                                final ExpressionNode en = opStack.peek();</span>
<span class="fc bfc" id="L745" title="All 6 branches covered.">                                if (en != null &amp;&amp; en.type != ExpressionNode.CONTROL &amp;&amp; en.type != ExpressionNode.OPERATION) {</span>
                                    // check if this is '1.2' or '1. 2'
<span class="pc bpc" id="L747" title="1 of 4 branches missed.">                                    if (lastPos &gt; 0 &amp;&amp; lexer.getContent().charAt(lastPos - 1) == '.') {</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">                                        if (en.token instanceof GenericLexer.FloatingSequence) {</span>
<span class="fc" id="L749">                                            ((GenericLexer.FloatingSequence) en.token).setHi(lexer.getTokenHi());</span>
                                        } else {
<span class="fc" id="L751">                                            opStack.pop();</span>
<span class="fc" id="L752">                                            CharacterStoreEntry cse = characterStore.newEntry();</span>
<span class="fc" id="L753">                                            cse.put(en.token).put(GenericLexer.unquote(tok));</span>
<span class="fc" id="L754">                                            opStack.push(expressionNodePool.next().of(ExpressionNode.LITERAL, cse.toImmutable(), Integer.MIN_VALUE, en.position));</span>
                                        }
<span class="fc" id="L756">                                        break;</span>
                                    }
                                } else {
<span class="fc" id="L759">                                    opStack.push(</span>
<span class="fc" id="L760">                                            expressionNodePool.next().of(</span>
                                                    ExpressionNode.CONSTANT,
<span class="fc" id="L762">                                                    lexer.immutableBetween(lastPos - 1, lexer.getTokenHi()),</span>
                                                    0,
                                                    lastPos
                                            )
                                    );
<span class="fc" id="L767">                                    break;</span>
                                }
                            }
<span class="fc bfc" id="L770" title="All 4 branches covered.">                            if (prevBranch != BRANCH_DOT &amp;&amp; nonLiteralBranches.excludes(prevBranch)) {</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">                                if (SqlKeywords.isQuote(tok)) {</span>
<span class="fc" id="L772">                                    throw SqlException.$(lastPos, &quot;unclosed quoted string?&quot;);</span>
                                }

<span class="fc" id="L775">                                ExpressionNode constNode = expressionNodePool.next().of(ExpressionNode.CONSTANT,</span>
<span class="fc" id="L776">                                        GenericLexer.immutableOf(tok),</span>
                                        0,
                                        lastPos
                                );

<span class="fc bfc" id="L781" title="All 2 branches covered.">                                if (prevBranch == BRANCH_TIMESTAMP_ZONE) {</span>
<span class="fc" id="L782">                                    argStackDepth = onNode(</span>
                                            listener,
                                            constNode,
                                            argStackDepth
                                    );

                                    // replace const node with 'to_timezone' function node
<span class="fc" id="L789">                                    constNode = expressionNodePool.next().of(ExpressionNode.FUNCTION,</span>
                                            &quot;to_timezone&quot;,
                                            Integer.MIN_VALUE,
                                            lastPos
                                    );
<span class="fc" id="L794">                                    constNode.paramCount = 2;</span>
                                    // fall thru
                                }
<span class="fc" id="L797">                                opStack.push(constNode);</span>
<span class="fc" id="L798">                                break;</span>
                            } else {
<span class="fc bfc" id="L800" title="All 6 branches covered.">                                if (opStack.size() &gt; 0 &amp;&amp; prevBranch == BRANCH_LITERAL &amp;&amp; thisChar == '\'') {</span>
<span class="fc" id="L801">                                    ExpressionNode prevNode = opStack.pop();</span>
                                    // This is postgres syntax to cast string literal to a type
                                    // timestamp '2005-04-02 12:00:00-07'
                                    // long '12321312'
                                    // timestamp with time zone '2005-04-02 12:00:00-07'

                                    // validate type
<span class="fc" id="L808">                                    final short columnType = ColumnType.tagOf(prevNode.token);</span>
<span class="pc bpc" id="L809" title="1 of 6 branches missed.">                                    if (columnType &lt; ColumnType.BOOLEAN || (columnType &gt; ColumnType.LONG256 &amp;&amp; columnType != ColumnType.UUID)) {</span>
<span class="fc" id="L810">                                        throw SqlException.$(prevNode.position, &quot;invalid type&quot;);</span>
                                    } else {
<span class="fc" id="L812">                                        ExpressionNode stringLiteral = expressionNodePool.next().of(ExpressionNode.CONSTANT, GenericLexer.immutableOf(tok), 0, lastPos);</span>
<span class="fc" id="L813">                                        onNode(listener, stringLiteral, 0);</span>

<span class="fc" id="L815">                                        prevNode.type = ExpressionNode.CONSTANT;</span>
<span class="fc" id="L816">                                        onNode(listener, prevNode, 0);</span>

<span class="fc" id="L818">                                        ExpressionNode cast = expressionNodePool.next().of(ExpressionNode.FUNCTION, &quot;cast&quot;, 0, prevNode.position);</span>
<span class="fc" id="L819">                                        cast.paramCount = 2;</span>

<span class="fc" id="L821">                                        onNode(listener, cast, argStackDepth + 2);</span>
<span class="fc" id="L822">                                        argStackDepth++;</span>
<span class="fc" id="L823">                                        break;</span>
                                    }
                                }

<span class="fc bfc" id="L827" title="All 2 branches covered.">                                if (opStack.size() &gt; 1) {</span>
<span class="fc" id="L828">                                    throw SqlException.$(lastPos, &quot;dangling expression&quot;);</span>
                                }
<span class="fc" id="L830">                                lexer.unparseLast();</span>
<span class="fc" id="L831">                                break OUT;</span>
                            }
                        } else {
<span class="fc" id="L834">                            throw SqlException.$(lastPos, &quot;constant is not allowed here&quot;);</span>
                        }
                    case 'N':
                    case 'n':
<span class="fc bfc" id="L838" title="All 2 branches covered.">                        if (SqlKeywords.isNotKeyword(tok)) {</span>
<span class="fc" id="L839">                            ExpressionNode nn = opStack.peek();</span>
<span class="fc bfc" id="L840" title="All 4 branches covered.">                            if (nn != null &amp;&amp; nn.type == ExpressionNode.LITERAL) {</span>
<span class="fc" id="L841">                                opStack.pop();</span>

<span class="fc" id="L843">                                node = expressionNodePool.next().of(</span>
                                        ExpressionNode.OPERATION,
<span class="fc" id="L845">                                        GenericLexer.immutableOf(tok),</span>
                                        11,
                                        lastPos
                                );
<span class="fc" id="L849">                                node.paramCount = 1;</span>
<span class="fc" id="L850">                                opStack.push(node);</span>
<span class="fc" id="L851">                                opStack.push(nn);</span>
<span class="fc" id="L852">                                break;</span>
                            }
                        }
                    case 't':
                    case 'T':
                    case 'f':
                    case 'F':
<span class="fc bfc" id="L859" title="All 2 branches covered.">                        if (SqlKeywords.isNanKeyword(tok)</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">                                || SqlKeywords.isNullKeyword(tok)</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">                                || SqlKeywords.isTrueKeyword(tok)</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">                                || SqlKeywords.isFalseKeyword(tok)</span>
                        ) {
<span class="fc bfc" id="L864" title="All 2 branches covered.">                            if (prevBranch != BRANCH_DOT_DEREFERENCE) {</span>
<span class="fc" id="L865">                                thisBranch = BRANCH_CONSTANT;</span>
                                // If the token is a number, then add it to the output queue.
<span class="fc" id="L867">                                opStack.push(expressionNodePool.next().of(ExpressionNode.CONSTANT, GenericLexer.immutableOf(tok), 0, lastPos));</span>
                            } else {
<span class="fc" id="L869">                                throw SqlException.$(lastPos, &quot;constant is not allowed here&quot;);</span>
                            }
                            break;
                        }
<span class="fc" id="L873">                        processDefaultBranch = true;</span>
<span class="fc" id="L874">                        break;</span>
                    case 'i':
                    case 'I':
<span class="fc bfc" id="L877" title="All 2 branches covered.">                        if (SqlKeywords.isIsKeyword(tok)) {</span>
                            // replace:
                            // &lt;literal or constant&gt; IS NULL     -&gt; &lt;literal or constant&gt; = NULL
                            // &lt;literal or constant&gt; IS NOT NULL -&gt; &lt;literal or constant&gt; != NULL
<span class="fc bfc" id="L881" title="All 6 branches covered.">                            if (prevBranch == BRANCH_LITERAL || prevBranch == BRANCH_CONSTANT || prevBranch == BRANCH_RIGHT_PARENTHESIS) {</span>
<span class="fc" id="L882">                                final CharSequence isTok = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L883">                                tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">                                if (tok == null) {</span>
<span class="fc" id="L885">                                    throw SqlException.$(lastPos, &quot;IS must be followed by [NOT] NULL&quot;);</span>
                                }
<span class="fc bfc" id="L887" title="All 2 branches covered.">                                if (SqlKeywords.isNotKeyword(tok)) {</span>
<span class="fc" id="L888">                                    final int notTokPosition = lexer.lastTokenPosition();</span>
<span class="fc" id="L889">                                    final CharSequence notTok = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L890">                                    tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L891" title="All 4 branches covered.">                                    if (tok != null &amp;&amp; SqlKeywords.isNullKeyword(tok)) {</span>
<span class="fc" id="L892">                                        lexer.backTo(notTokPosition + 3, notTok);</span>
<span class="fc" id="L893">                                        tok = &quot;!=&quot;;</span>
                                    } else {
<span class="fc" id="L895">                                        throw SqlException.$(lastPos, &quot;IS NOT must be followed by NULL&quot;);</span>
                                    }
<span class="fc bfc" id="L897" title="All 2 branches covered.">                                } else if (SqlKeywords.isNullKeyword(tok)) {</span>
<span class="fc" id="L898">                                    lexer.backTo(lastPos + 2, isTok);</span>
<span class="fc" id="L899">                                    tok = &quot;=&quot;;</span>
                                } else {
<span class="fc" id="L901">                                    throw SqlException.$(lastPos, &quot;IS must be followed by NULL&quot;);</span>
                                }
<span class="fc" id="L903">                            } else {</span>
<span class="fc" id="L904">                                throw SqlException.$(lastPos, &quot;IS [NOT] not allowed here&quot;);</span>
                            }
                        }
<span class="fc" id="L907">                        processDefaultBranch = true;</span>
<span class="fc" id="L908">                        break;</span>
                    case '*':
                        // special case for tab.*
<span class="fc bfc" id="L911" title="All 2 branches covered.">                        if (prevBranch == BRANCH_DOT) {</span>
<span class="fc" id="L912">                            thisBranch = BRANCH_LITERAL;</span>
<span class="fc" id="L913">                            final ExpressionNode en = opStack.peek();</span>
<span class="pc bpc" id="L914" title="1 of 4 branches missed.">                            if (en != null &amp;&amp; en.type != ExpressionNode.CONTROL) {</span>
                                // leverage the fact '*' is dedicated token and it returned from cache
                                // therefore lexer.tokenHi does not move when * follows dot without whitespace
                                // e.g. 'a.*'
<span class="fc bfc" id="L918" title="All 2 branches covered.">                                if (GenericLexer.WHITESPACE_CH.excludes(lexer.getContent().charAt(lastPos - 1))) {</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">                                    if (en.token instanceof GenericLexer.FloatingSequence) {</span>
<span class="fc" id="L920">                                        GenericLexer.FloatingSequence fs = (GenericLexer.FloatingSequence) en.token;</span>
<span class="fc" id="L921">                                        fs.setHi(lastPos + 1);</span>
<span class="fc" id="L922">                                    } else {</span>
                                        // &quot;foo&quot;.* or 'foo'.*
                                        // foo was unquoted, and we cannot simply move hi to include the *
<span class="fc" id="L925">                                        opStack.pop();</span>
<span class="fc" id="L926">                                        CharacterStoreEntry cse = characterStore.newEntry();</span>
<span class="fc" id="L927">                                        cse.put(en.token).put('*');</span>
<span class="fc" id="L928">                                        opStack.push(expressionNodePool.next().of(ExpressionNode.LITERAL, cse.toImmutable(), Integer.MIN_VALUE, en.position));</span>
<span class="fc" id="L929">                                    }</span>
                                } else {
                                    // in this case we have whitespace, e.g. 'a. *'
<span class="fc" id="L932">                                    processDefaultBranch = true;</span>
                                }
                            } else {
<span class="fc" id="L935">                                opStack.push(</span>
<span class="fc" id="L936">                                        expressionNodePool.next().of(</span>
                                                ExpressionNode.CONSTANT,
<span class="fc" id="L938">                                                lexer.immutableBetween(lastPos - 1, lexer.getTokenHi()),</span>
                                                0,
                                                lastPos
                                        )
                                );
                            }
<span class="fc" id="L944">                            break;</span>
                        }
                    default:
<span class="fc" id="L947">                        processDefaultBranch = true;</span>
                        break;
                }

<span class="fc bfc" id="L951" title="All 2 branches covered.">                if (processDefaultBranch) {</span>
                    OperatorExpression op;
<span class="fc bfc" id="L953" title="All 2 branches covered.">                    if ((op = OperatorExpression.opMap.get(tok)) != null) {</span>

<span class="fc" id="L955">                        thisBranch = BRANCH_OPERATOR;</span>

                        // If the token is an operator, o1, then:
                        // while there is an operator token, o2, at the top of the operator stack, and either
                        // o1 is left-associative and its precedence is less than or equal to that of o2, or
                        // o1 is right associative, and has precedence less than that of o2,
                        //        then pop o2 off the operator stack, onto the output queue;
                        // push o1 onto the operator stack.

<span class="fc" id="L964">                        int operatorType = op.type;</span>

<span class="fc bfc" id="L966" title="All 4 branches covered.">                        if (thisChar == '-' || thisChar == '~') {</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">                            switch (prevBranch) {</span>
                                case BRANCH_OPERATOR:
                                case BRANCH_LEFT_PARENTHESIS:
                                case BRANCH_COMMA:
                                case BRANCH_NONE:
                                case BRANCH_CASE_CONTROL:
                                    // we have unary minus
<span class="fc" id="L974">                                    operatorType = OperatorExpression.UNARY;</span>
<span class="fc" id="L975">                                    break;</span>
                                default:
                                    break;
                            }
                        }

                        ExpressionNode other;
                        // UNARY operators must never pop BINARY ones regardless of precedence
                        // this is to maintain correctness of -a^b
<span class="fc bfc" id="L984" title="All 2 branches covered.">                        while ((other = opStack.peek()) != null) {</span>
<span class="fc bfc" id="L985" title="All 8 branches covered.">                            boolean greaterPrecedence = (op.leftAssociative &amp;&amp; op.precedence &gt;= other.precedence) || (!op.leftAssociative &amp;&amp; op.precedence &gt; other.precedence);</span>
<span class="pc bpc" id="L986" title="2 of 8 branches missed.">                            if (greaterPrecedence &amp;&amp;</span>
                                    (operatorType != OperatorExpression.UNARY || (operatorType == OperatorExpression.UNARY &amp;&amp; other.paramCount == 1))) {
<span class="fc" id="L988">                                argStackDepth = onNode(listener, other, argStackDepth);</span>
<span class="fc" id="L989">                                opStack.pop();</span>
                            } else {
                                break;
                            }
<span class="fc" id="L993">                        }</span>
<span class="fc" id="L994">                        node = expressionNodePool.next().of(</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">                                op.type == OperatorExpression.SET ? ExpressionNode.SET_OPERATION : ExpressionNode.OPERATION,</span>
                                op.token,
                                op.precedence,
                                lastPos
                        );
<span class="fc bfc" id="L1000" title="All 2 branches covered.">                        if (operatorType == OperatorExpression.UNARY) {</span>
<span class="fc" id="L1001">                            node.paramCount = 1;</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">                        } else if (SqlKeywords.isBetweenKeyword(node.token)) {</span>
<span class="fc" id="L1003">                            node.paramCount = 3;</span>
                        } else {
<span class="fc" id="L1005">                            node.paramCount = 2;</span>
                        }
<span class="fc" id="L1007">                        opStack.push(node);</span>
<span class="fc bfc" id="L1008" title="All 4 branches covered.">                    } else if (caseCount &gt; 0 || nonLiteralBranches.excludes(thisBranch)) {</span>
                        // here we handle literals, in case of &quot;case&quot; statement some of these literals
                        // are going to flush operation stack
<span class="fc bfc" id="L1011" title="All 4 branches covered.">                        if (Chars.toLowerCaseAscii(thisChar) == 'c' &amp;&amp; SqlKeywords.isCaseKeyword(tok)) {</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">                            if (prevBranch != BRANCH_DOT_DEREFERENCE) {</span>
<span class="fc" id="L1013">                                caseCount++;</span>
<span class="fc" id="L1014">                                paramCountStack.push(paramCount);</span>
<span class="fc" id="L1015">                                paramCount = 0;</span>

<span class="fc" id="L1017">                                caseBraceCountStack.push(braceCount);</span>
<span class="fc" id="L1018">                                braceCount = 0;</span>

<span class="fc" id="L1020">                                argStackDepthStack.push(argStackDepth);</span>
<span class="fc" id="L1021">                                argStackDepth = 0;</span>
<span class="fc" id="L1022">                                opStack.push(expressionNodePool.next().of(ExpressionNode.FUNCTION, &quot;case&quot;, Integer.MAX_VALUE, lastPos));</span>
<span class="fc" id="L1023">                                thisBranch = BRANCH_CASE_START;</span>
<span class="fc" id="L1024">                                continue;</span>
                            } else {
<span class="fc" id="L1026">                                throw SqlException.$(lastPos, &quot;'case' is not allowed here&quot;);</span>
                            }
                        }

<span class="fc" id="L1030">                        thisBranch = BRANCH_LITERAL;</span>

<span class="fc bfc" id="L1032" title="All 2 branches covered.">                        if (caseCount &gt; 0) {</span>
<span class="fc bfc" id="L1033" title="All 3 branches covered.">                            switch (Chars.toLowerCaseAscii(thisChar)) {</span>
                                case 'e':
<span class="fc bfc" id="L1035" title="All 2 branches covered.">                                    if (SqlKeywords.isEndKeyword(tok)) {</span>
<span class="fc bfc" id="L1036" title="All 2 branches covered.">                                        if (prevBranch == BRANCH_CASE_CONTROL) {</span>
<span class="fc" id="L1037">                                            throw missingArgs(lastPos);</span>
                                        }

<span class="fc bfc" id="L1040" title="All 2 branches covered.">                                        if (paramCount == 0) {</span>
<span class="fc" id="L1041">                                            throw SqlException.$(lastPos, &quot;'when' expected&quot;);</span>
                                        }

                                        // If the token is a right parenthesis:
                                        // Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.
                                        // Pop the left parenthesis from the stack, but not onto the output queue.
                                        //        If the token at the top of the stack is a function token, pop it onto the output queue.
                                        //        If the stack runs out without finding a left parenthesis, then there are mismatched parentheses.
<span class="pc bpc" id="L1049" title="1 of 4 branches missed.">                                        while ((node = opStack.pop()) != null &amp;&amp; !SqlKeywords.isCaseKeyword(node.token)) {</span>
<span class="fc" id="L1050">                                            argStackDepth = onNode(listener, node, argStackDepth);</span>
                                        }

                                        // 'when/else' have been clearing argStackDepth to ensure
                                        // expressions between 'when' and 'when' do not pick up arguments outside of scope
                                        // now we need to restore stack depth before 'case' entry
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">                                        if (argStackDepthStack.notEmpty()) {</span>
<span class="fc" id="L1057">                                            argStackDepth += argStackDepthStack.pop();</span>
                                        }

<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">                                        if (caseBraceCountStack.notEmpty()) {</span>
<span class="fc" id="L1061">                                            braceCount = caseBraceCountStack.pop();</span>
                                        }

<span class="fc" id="L1064">                                        node.paramCount = paramCount;</span>
                                        // we also add number of 'case' arguments to original stack depth
<span class="fc" id="L1066">                                        argStackDepth = onNode(listener, node, argStackDepth + paramCount);</span>

                                        // make sure we restore paramCount
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">                                        if (paramCountStack.notEmpty()) {</span>
<span class="fc" id="L1070">                                            paramCount = paramCountStack.pop();</span>
                                        }

<span class="fc" id="L1073">                                        caseCount--;</span>
<span class="fc" id="L1074">                                        continue;</span>
                                    }
                                    // fall through
                                case 'w':
                                case 't':
<span class="fc" id="L1079">                                    int keywordIndex = caseKeywords.get(tok);</span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">                                    if (keywordIndex &gt; -1) {</span>

<span class="fc bfc" id="L1082" title="All 2 branches covered.">                                        if (prevBranch == BRANCH_CASE_CONTROL) {</span>
<span class="fc" id="L1083">                                            throw missingArgs(lastPos);</span>
                                        }

                                        // we need to track argument consumption so that operators and functions
                                        // do no steal parameters outside of local 'case' scope
<span class="fc" id="L1088">                                        int argCount = 0;</span>
<span class="pc bpc" id="L1089" title="1 of 4 branches missed.">                                        while ((node = opStack.pop()) != null &amp;&amp; !SqlKeywords.isCaseKeyword(node.token)) {</span>
<span class="fc" id="L1090">                                            argStackDepth = onNode(listener, node, argStackDepth);</span>
<span class="fc" id="L1091">                                            argCount++;</span>
                                        }

<span class="fc bfc" id="L1094" title="All 2 branches covered.">                                        if (paramCount == 0) {</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">                                            if (argCount == 0) {</span>
                                                // this is 'case when', we will
                                                // indicate that this is regular 'case' to the rewrite logic
<span class="fc" id="L1098">                                                onNode(listener, expressionNodePool.next().of(ExpressionNode.LITERAL, null, Integer.MIN_VALUE, -1), argStackDepth);</span>
                                            }
<span class="fc" id="L1100">                                            paramCount++;</span>
                                        }

<span class="fc bfc" id="L1103" title="All 2 branches covered.">                                        switch (keywordIndex) {</span>
                                            case 0: // when
                                            case 2: // else
<span class="fc bfc" id="L1106" title="All 2 branches covered.">                                                if ((paramCount % 2) == 0) {</span>
<span class="fc" id="L1107">                                                    throw SqlException.$(lastPos, &quot;'then' expected&quot;);</span>
                                                }
                                                break;
                                            default: // then
<span class="fc bfc" id="L1111" title="All 2 branches covered.">                                                if ((paramCount % 2) != 0) {</span>
<span class="fc" id="L1112">                                                    throw SqlException.$(lastPos, &quot;'when' expected&quot;);</span>
                                                }
                                                break;
                                        }

<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">                                        if (node != null) {</span>
<span class="fc" id="L1118">                                            opStack.push(node);</span>
                                        }

<span class="fc" id="L1121">                                        argStackDepth = 0;</span>
<span class="fc" id="L1122">                                        paramCount++;</span>
<span class="fc" id="L1123">                                        thisBranch = BRANCH_CASE_CONTROL;</span>
<span class="fc" id="L1124">                                        continue;</span>
                                    }
                                    break;
                                default:
                                    break;
                            }
                        }

<span class="fc bfc" id="L1132" title="All 2 branches covered.">                        if (prevBranch == BRANCH_DOT) {</span>
                            // this deals with 'table.column' situations
<span class="fc" id="L1134">                            ExpressionNode en = opStack.peek();</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">                            if (en == null) {</span>
<span class="fc" id="L1136">                                throw SqlException.$(lastPos, &quot;qualifier expected&quot;);</span>
                            }
                            // two possibilities here:
                            // 1. 'a.b'
                            // 2. 'a. b'

<span class="fc bfc" id="L1142" title="All 2 branches covered.">                            if (GenericLexer.WHITESPACE_CH.contains(lexer.getContent().charAt(lastPos - 1))) {</span>
                                // 'a. b'
<span class="fc" id="L1144">                                lexer.unparseLast();</span>
<span class="fc" id="L1145">                                break;</span>
                            }

<span class="fc bfc" id="L1148" title="All 4 branches covered.">                            if (Chars.isQuoted(tok) || en.token instanceof CharacterStore.NameAssemblerCharSequence) {</span>
                                // replacing node, must remove old one from stack
<span class="fc" id="L1150">                                opStack.pop();</span>
                                // this was more analogous to 'a.&quot;b&quot;'
<span class="fc" id="L1152">                                CharacterStoreEntry cse = characterStore.newEntry();</span>
<span class="fc" id="L1153">                                cse.put(en.token).put(GenericLexer.unquote(tok));</span>
<span class="fc" id="L1154">                                opStack.push(expressionNodePool.next().of(ExpressionNode.LITERAL, cse.toImmutable(), Integer.MIN_VALUE, en.position));</span>
<span class="fc" id="L1155">                            } else {</span>
<span class="fc" id="L1156">                                final GenericLexer.FloatingSequence fsA = (GenericLexer.FloatingSequence) en.token;</span>
                                // vanilla 'a.b', just concat tokens efficiently
<span class="fc" id="L1158">                                fsA.setHi(lexer.getTokenHi());</span>
                            }
<span class="fc bfc" id="L1160" title="All 2 branches covered.">                        } else if (prevBranch != BRANCH_DOT_DEREFERENCE) {</span>
                            // If the token is a function token, then push it onto the stack.
<span class="fc" id="L1162">                            opStack.push(expressionNodePool.next().of(ExpressionNode.LITERAL, GenericLexer.unquote(tok), Integer.MIN_VALUE, lastPos));</span>
                        } else {
<span class="fc" id="L1164">                            argStackDepth++;</span>
<span class="fc" id="L1165">                            final ExpressionNode dotDereference = expressionNodePool.next().of(ExpressionNode.OPERATION, &quot;.&quot;, DOT_PRECEDENCE, lastPos);</span>
<span class="fc" id="L1166">                            dotDereference.paramCount = 2;</span>
<span class="fc" id="L1167">                            opStack.push(dotDereference);</span>
<span class="fc" id="L1168">                            opStack.push(expressionNodePool.next().of(ExpressionNode.MEMBER_ACCESS, GenericLexer.unquote(tok), Integer.MIN_VALUE, lastPos));</span>
<span class="fc" id="L1169">                        }</span>
                    } else {
<span class="fc" id="L1171">                        ExpressionNode last = this.opStack.peek();</span>
                        // Handle `timestamp with time zone`
<span class="fc bfc" id="L1173" title="All 2 branches covered.">                        if (last != null) {</span>
<span class="fc bfc" id="L1174" title="All 4 branches covered.">                            if (SqlKeywords.isTimestampKeyword(last.token) &amp;&amp; SqlKeywords.isWithKeyword(tok)) {</span>
<span class="fc" id="L1175">                                CharSequence withTok = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L1176">                                int withTokPosition = lexer.getPosition();</span>
<span class="fc" id="L1177">                                tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L1178" title="1 of 4 branches missed.">                                if (tok != null &amp;&amp; SqlKeywords.isTimeKeyword(tok)) {</span>
<span class="fc" id="L1179">                                    tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L1180" title="1 of 4 branches missed.">                                    if (tok != null &amp;&amp; SqlKeywords.isZoneKeyword(tok)) {</span>
<span class="fc" id="L1181">                                        CharSequence zoneTok = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L1182">                                        int zoneTokPosition = lexer.getTokenHi();</span>
<span class="fc" id="L1183">                                        tok = SqlUtil.fetchNext(lexer);</span>
                                        // Next token is string literal, or we are in 'as' part of cast function
<span class="fc bfc" id="L1185" title="All 4 branches covered.">                                        boolean isInActiveCastAs = (castBraceCountStack.size() &gt; 0 &amp;&amp; (castBraceCountStack.size() == castAsCount));</span>
<span class="pc bpc" id="L1186" title="1 of 6 branches missed.">                                        if (tok != null &amp;&amp; (isInActiveCastAs || tok.charAt(0) == '\'')) {</span>
<span class="fc" id="L1187">                                            lexer.backTo(zoneTokPosition, zoneTok);</span>
<span class="fc" id="L1188">                                            continue;</span>
                                        }
<span class="fc" id="L1190">                                        throw SqlException.$(zoneTokPosition, &quot;String literal expected after 'timestamp with time zone'&quot;);</span>
                                    }
                                }
<span class="fc" id="L1193">                                lexer.backTo(withTokPosition, withTok);</span>
<span class="fc bfc" id="L1194" title="All 2 branches covered.">                            } else if (SqlKeywords.isFromKeyword(tok)) {</span>
                                // check if this is &quot;extract(something from ...)&quot;
                                // we can do this by analyzing opStack
<span class="fc bfc" id="L1197" title="All 2 branches covered.">                                if (opStack.size() &gt; 2) {</span>
<span class="fc" id="L1198">                                    boolean extractError = true;</span>
<span class="fc" id="L1199">                                    ExpressionNode member = opStack.peek(0);</span>
<span class="fc bfc" id="L1200" title="All 4 branches covered.">                                    if (member.type == ExpressionNode.LITERAL || (member.type == ExpressionNode.CONSTANT)) {</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">                                        if (Chars.equals(opStack.peek(1).token, '(')) {</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">                                            if (SqlKeywords.isExtractKeyword(opStack.peek(2).token)) {</span>
                                                // validate part
<span class="fc bfc" id="L1204" title="All 2 branches covered.">                                                if (SqlKeywords.validateExtractPart(GenericLexer.unquote(member.token))) {</span>
                                                    // in this case &quot;from&quot; keyword acts as ',' in function call
<span class="fc" id="L1206">                                                    member.type = ExpressionNode.MEMBER_ACCESS;</span>
<span class="fc" id="L1207">                                                    argStackDepth = onNode(</span>
                                                            listener,
                                                            member,
                                                            argStackDepth
                                                    );
<span class="fc" id="L1212">                                                    opStack.pop();</span>
<span class="fc" id="L1213">                                                    paramCount++;</span>
<span class="fc" id="L1214">                                                    thisBranch = BRANCH_COMMA;</span>
<span class="fc" id="L1215">                                                    continue;</span>
                                                } else {
<span class="fc" id="L1217">                                                    throw SqlException.$(member.position, &quot;unsupported timestamp part: &quot;).put(member.token);</span>
                                                }
                                            } else {
<span class="fc" id="L1220">                                                extractError = false;</span>
                                            }
                                        }
                                    }

                                    // report error on extract
<span class="fc bfc" id="L1226" title="All 4 branches covered.">                                    if (extractError &amp;&amp; isExtractFunctionOnStack()) {</span>
<span class="fc" id="L1227">                                        throw SqlException.$(member.position, &quot;we expect timestamp part here&quot;);</span>
                                    }

                                }
                            }
                        }
                        // literal can be at start of input, after a bracket or part of an operator
                        // all other cases are illegal and will be considered end-of-input
<span class="fc" id="L1235">                        lexer.unparseLast();</span>
<span class="fc" id="L1236">                        break;</span>
                    }
                }
<span class="fc" id="L1239">            }</span>

<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">            if (thisBranch == BRANCH_TIMESTAMP_ZONE) {</span>
<span class="nc" id="L1242">                throw SqlException.$(lexer.lastTokenPosition(), &quot;did you mean 'at time zone &lt;tz&gt;'?&quot;);</span>
            }

<span class="fc bfc" id="L1245" title="All 2 branches covered.">            while ((node = opStack.pop()) != null) {</span>

<span class="pc bpc" id="L1247" title="1 of 4 branches missed.">                if (node.token.length() != 0 &amp;&amp; node.token.charAt(0) == '(') {</span>
<span class="fc" id="L1248">                    throw SqlException.$(node.position, &quot;unbalanced (&quot;);</span>
                }

                // our array dereference is dangling
<span class="fc bfc" id="L1252" title="All 4 branches covered.">                if (node.type == ExpressionNode.CONTROL &amp;&amp; node.token.charAt(0) == '[') {</span>
<span class="fc" id="L1253">                    throw SqlException.$(node.position, &quot;unbalanced ]&quot;);</span>
                }

<span class="fc bfc" id="L1256" title="All 2 branches covered.">                if (SqlKeywords.isCaseKeyword(node.token)) {</span>
<span class="fc" id="L1257">                    throw SqlException.$(node.position, &quot;unbalanced 'case'&quot;);</span>
                }

<span class="fc bfc" id="L1260" title="All 2 branches covered.">                if (node.type == ExpressionNode.CONTROL) {</span>
                    // break on any other control node to allow parser to be re-enterable
                    // put control node back on stack because we don't own it
<span class="fc" id="L1263">                    opStack.push(node);</span>
<span class="fc" id="L1264">                    break;</span>
                }

<span class="fc" id="L1267">                argStackDepth = onNode(listener, node, argStackDepth);</span>
            }

<span class="fc" id="L1270">        } catch (SqlException e) {</span>
<span class="fc" id="L1271">            opStack.clear();</span>
<span class="fc" id="L1272">            backupCastBraceCountStack.clear();</span>
<span class="fc" id="L1273">            backupParamCountStack.clear();</span>
<span class="fc" id="L1274">            backupArgStackDepthStack.clear();</span>
<span class="fc" id="L1275">            throw e;</span>
        } finally {
<span class="fc" id="L1277">            argStackDepthStack.clear();</span>
<span class="fc" id="L1278">            paramCountStack.clear();</span>
<span class="fc" id="L1279">            castBraceCountStack.clear();</span>
<span class="fc" id="L1280">            caseBraceCountStack.clear();</span>
        }
<span class="fc" id="L1282">    }</span>

    static {
<span class="fc" id="L1285">        nonLiteralBranches.add(BRANCH_RIGHT_PARENTHESIS);</span>
<span class="fc" id="L1286">        nonLiteralBranches.add(BRANCH_CONSTANT);</span>
<span class="fc" id="L1287">        nonLiteralBranches.add(BRANCH_LITERAL);</span>
<span class="fc" id="L1288">        nonLiteralBranches.add(BRANCH_LAMBDA);</span>

<span class="fc" id="L1290">        caseKeywords.put(&quot;when&quot;, 0);</span>
<span class="fc" id="L1291">        caseKeywords.put(&quot;then&quot;, 1);</span>
<span class="fc" id="L1292">        caseKeywords.put(&quot;else&quot;, 2);</span>

<span class="fc" id="L1294">        allFunctions.put(&quot;&lt;&gt;&quot;, &quot;&lt;&gt;all&quot;);</span>
<span class="fc" id="L1295">        allFunctions.put(&quot;!=&quot;, &quot;&lt;&gt;all&quot;);</span>
<span class="fc" id="L1296">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>