<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlCompiler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin</a> &gt; <span class="el_source">SqlCompiler.java</span></div><h1>SqlCompiler.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin;

import io.questdb.MessageBus;
import io.questdb.PropServerConfiguration;
import io.questdb.TelemetryOrigin;
import io.questdb.cairo.*;
import io.questdb.cairo.pool.WriterPool;
import io.questdb.cairo.sql.Record;
import io.questdb.cairo.sql.*;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryMARW;
import io.questdb.cutlass.text.*;
import io.questdb.griffin.engine.functions.catalogue.*;
import io.questdb.griffin.engine.ops.AlterOperationBuilder;
import io.questdb.griffin.engine.ops.CopyFactory;
import io.questdb.griffin.engine.ops.InsertOperationImpl;
import io.questdb.griffin.engine.ops.UpdateOperation;
import io.questdb.griffin.engine.table.ShowColumnsRecordCursorFactory;
import io.questdb.griffin.engine.table.TableListRecordCursorFactory;
import io.questdb.griffin.model.*;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.network.PeerDisconnectedException;
import io.questdb.network.PeerIsSlowToReadException;
import io.questdb.network.QueryPausedException;
import io.questdb.std.*;
import io.questdb.std.datetime.DateFormat;
import io.questdb.std.str.Path;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.TestOnly;

import java.io.Closeable;
import java.util.ServiceLoader;

import static io.questdb.TelemetrySystemEvent.WAL_APPLY_RESUME;
import static io.questdb.cairo.TableUtils.COLUMN_NAME_TXN_NONE;
import static io.questdb.griffin.SqlKeywords.*;

public class SqlCompiler implements Closeable {
<span class="fc" id="L65">    public static final ObjList&lt;String&gt; sqlControlSymbols = new ObjList&lt;&gt;(8);</span>
    //null object used to skip null checks in batch method
<span class="fc" id="L67">    private static final BatchCallback EMPTY_CALLBACK = new BatchCallback() {</span>
        @Override
        public void postCompile(SqlCompiler compiler, CompiledQuery cq, CharSequence queryText) {
<span class="fc" id="L70">        }</span>

        @Override
        public void preCompile(SqlCompiler compiler) {
<span class="fc" id="L74">        }</span>
    };
<span class="fc" id="L76">    private final static Log LOG = LogFactory.getLog(SqlCompiler.class);</span>
<span class="fc" id="L77">    private static final IntList castGroups = new IntList();</span>
    protected final CairoEngine engine;
    private final AlterOperationBuilder alterOperationBuilder;
<span class="fc" id="L80">    private final BytecodeAssembler asm = new BytecodeAssembler();</span>
    private final DatabaseBackupAgent backupAgent;
    private final CharacterStore characterStore;
    private final SqlCodeGenerator codeGenerator;
    private final CompiledQueryImpl compiledQuery;
    private final CairoConfiguration configuration;
<span class="fc" id="L86">    private final EntityColumnFilter entityColumnFilter = new EntityColumnFilter();</span>
    private final FilesFacade ff;
    private final FunctionParser functionParser;
<span class="fc" id="L89">    private final CharSequenceObjHashMap&lt;KeywordBasedExecutor&gt; keywordBasedExecutors = new CharSequenceObjHashMap&lt;&gt;();</span>
    private final GenericLexer lexer;
<span class="fc" id="L91">    private final ListColumnFilter listColumnFilter = new ListColumnFilter();</span>
<span class="fc" id="L92">    private final MemoryMARW mem = Vm.getMARWInstance();</span>
    private final MessageBus messageBus;
    private final SqlOptimiser optimiser;
    private final SqlParser parser;
<span class="fc" id="L96">    private final TimestampValueRecord partitionFunctionRec = new TimestampValueRecord();</span>
<span class="fc" id="L97">    private final Path path = new Path();</span>
<span class="fc" id="L98">    private final ExecutableMethod insertAsSelectMethod = this::insertAsSelect;</span>
    private final ObjectPool&lt;QueryColumn&gt; queryColumnPool;
    private final ObjectPool&lt;QueryModel&gt; queryModelPool;
<span class="fc" id="L101">    private final IndexBuilder rebuildIndex = new IndexBuilder();</span>
<span class="fc" id="L102">    private final Path renamePath = new Path();</span>
    private final DatabaseSnapshotAgent snapshotAgent;
    private final ObjectPool&lt;ExpressionNode&gt; sqlNodePool;
<span class="fc" id="L105">    private final TableStructureAdapter tableStructureAdapter = new TableStructureAdapter();</span>
<span class="fc" id="L106">    private final ObjList&lt;TableWriterAPI&gt; tableWriters = new ObjList&lt;&gt;();</span>
    private final TextLoader textLoader;
<span class="fc" id="L108">    private final IntIntHashMap typeCast = new IntIntHashMap();</span>
    private final VacuumColumnVersions vacuumColumnVersions;
    // Helper var used to pass back count in cases it can't be done via method result.
    private long insertCount;
<span class="fc" id="L112">    private final ExecutableMethod createTableMethod = this::createTable;</span>
    //determines how compiler parses query text
    //true - compiler treats whole input as single query and doesn't stop on ';'. Default mode.
    //false - compiler treats input as list of statements and stops processing statement on ';'. Used in batch processing.
<span class="fc" id="L116">    private boolean isSingleQueryMode = true;</span>

    // Exposed for embedded API users.
    public SqlCompiler(CairoEngine engine) {
<span class="fc" id="L120">        this(engine, null, null);</span>
<span class="fc" id="L121">    }</span>

<span class="fc" id="L123">    public SqlCompiler(CairoEngine engine, @Nullable FunctionFactoryCache functionFactoryCache, @Nullable DatabaseSnapshotAgent snapshotAgent) {</span>
<span class="fc" id="L124">        this.engine = engine;</span>
<span class="fc" id="L125">        this.configuration = engine.getConfiguration();</span>
<span class="fc" id="L126">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L127">        this.messageBus = engine.getMessageBus();</span>
<span class="fc" id="L128">        this.sqlNodePool = new ObjectPool&lt;&gt;(ExpressionNode.FACTORY, configuration.getSqlExpressionPoolCapacity());</span>
<span class="fc" id="L129">        this.queryColumnPool = new ObjectPool&lt;&gt;(QueryColumn.FACTORY, configuration.getSqlColumnPoolCapacity());</span>
<span class="fc" id="L130">        this.queryModelPool = new ObjectPool&lt;&gt;(QueryModel.FACTORY, configuration.getSqlModelPoolCapacity());</span>
<span class="fc" id="L131">        this.compiledQuery = new CompiledQueryImpl(engine);</span>
<span class="fc" id="L132">        this.characterStore = new CharacterStore(</span>
<span class="fc" id="L133">                configuration.getSqlCharacterStoreCapacity(),</span>
<span class="fc" id="L134">                configuration.getSqlCharacterStoreSequencePoolCapacity());</span>

<span class="fc" id="L136">        this.lexer = new GenericLexer(configuration.getSqlLexerPoolCapacity());</span>
<span class="fc" id="L137">        this.functionParser = new FunctionParser(</span>
                configuration,
<span class="fc bfc" id="L139" title="All 2 branches covered.">                functionFactoryCache != null</span>
<span class="fc" id="L140">                        ? functionFactoryCache</span>
<span class="fc" id="L141">                        : new FunctionFactoryCache(engine.getConfiguration(), ServiceLoader.load(</span>
<span class="fc" id="L142">                        FunctionFactory.class, FunctionFactory.class.getClassLoader()))</span>
        );
<span class="fc" id="L144">        this.codeGenerator = new SqlCodeGenerator(engine, configuration, functionParser, sqlNodePool);</span>
<span class="fc" id="L145">        this.vacuumColumnVersions = new VacuumColumnVersions(engine);</span>

        // we have cyclical dependency here
<span class="fc" id="L148">        functionParser.setSqlCodeGenerator(codeGenerator);</span>

<span class="fc" id="L150">        this.backupAgent = new DatabaseBackupAgent();</span>
<span class="fc" id="L151">        this.snapshotAgent = snapshotAgent;</span>

        // For each 'this::method' reference java compiles a class
        // We need to minimize repetition of this syntax as each site generates garbage
<span class="fc" id="L155">        final KeywordBasedExecutor compileSet = this::compileSet;</span>
<span class="fc" id="L156">        final KeywordBasedExecutor compileBegin = this::compileBegin;</span>
<span class="fc" id="L157">        final KeywordBasedExecutor compileCommit = this::compileCommit;</span>
<span class="fc" id="L158">        final KeywordBasedExecutor compileRollback = this::compileRollback;</span>
<span class="fc" id="L159">        final KeywordBasedExecutor truncateTables = this::truncateTables;</span>
<span class="fc" id="L160">        final KeywordBasedExecutor alterTable = this::alterTable;</span>
<span class="fc" id="L161">        final KeywordBasedExecutor repairTables = this::repairTables;</span>
<span class="fc" id="L162">        final KeywordBasedExecutor reindexTable = this::reindexTable;</span>
<span class="fc" id="L163">        final KeywordBasedExecutor dropTable = this::dropTable;</span>
<span class="fc" id="L164">        final KeywordBasedExecutor sqlBackup = backupAgent::sqlBackup;</span>
<span class="fc" id="L165">        final KeywordBasedExecutor sqlShow = this::sqlShow;</span>
<span class="fc" id="L166">        final KeywordBasedExecutor vacuumTable = this::vacuum;</span>
<span class="fc" id="L167">        final KeywordBasedExecutor snapshotDatabase = this::snapshotDatabase;</span>
<span class="fc" id="L168">        final KeywordBasedExecutor compileDeallocate = this::compileDeallocate;</span>

<span class="fc" id="L170">        keywordBasedExecutors.put(&quot;truncate&quot;, truncateTables);</span>
<span class="fc" id="L171">        keywordBasedExecutors.put(&quot;TRUNCATE&quot;, truncateTables);</span>
<span class="fc" id="L172">        keywordBasedExecutors.put(&quot;alter&quot;, alterTable);</span>
<span class="fc" id="L173">        keywordBasedExecutors.put(&quot;ALTER&quot;, alterTable);</span>
<span class="fc" id="L174">        keywordBasedExecutors.put(&quot;repair&quot;, repairTables);</span>
<span class="fc" id="L175">        keywordBasedExecutors.put(&quot;REPAIR&quot;, repairTables);</span>
<span class="fc" id="L176">        keywordBasedExecutors.put(&quot;reindex&quot;, reindexTable);</span>
<span class="fc" id="L177">        keywordBasedExecutors.put(&quot;REINDEX&quot;, reindexTable);</span>
<span class="fc" id="L178">        keywordBasedExecutors.put(&quot;set&quot;, compileSet);</span>
<span class="fc" id="L179">        keywordBasedExecutors.put(&quot;SET&quot;, compileSet);</span>
<span class="fc" id="L180">        keywordBasedExecutors.put(&quot;begin&quot;, compileBegin);</span>
<span class="fc" id="L181">        keywordBasedExecutors.put(&quot;BEGIN&quot;, compileBegin);</span>
<span class="fc" id="L182">        keywordBasedExecutors.put(&quot;commit&quot;, compileCommit);</span>
<span class="fc" id="L183">        keywordBasedExecutors.put(&quot;COMMIT&quot;, compileCommit);</span>
<span class="fc" id="L184">        keywordBasedExecutors.put(&quot;rollback&quot;, compileRollback);</span>
<span class="fc" id="L185">        keywordBasedExecutors.put(&quot;ROLLBACK&quot;, compileRollback);</span>
<span class="fc" id="L186">        keywordBasedExecutors.put(&quot;discard&quot;, compileSet);</span>
<span class="fc" id="L187">        keywordBasedExecutors.put(&quot;DISCARD&quot;, compileSet);</span>
<span class="fc" id="L188">        keywordBasedExecutors.put(&quot;close&quot;, compileSet); //no-op</span>
<span class="fc" id="L189">        keywordBasedExecutors.put(&quot;CLOSE&quot;, compileSet);  //no-op</span>
<span class="fc" id="L190">        keywordBasedExecutors.put(&quot;unlisten&quot;, compileSet);  //no-op</span>
<span class="fc" id="L191">        keywordBasedExecutors.put(&quot;UNLISTEN&quot;, compileSet);  //no-op</span>
<span class="fc" id="L192">        keywordBasedExecutors.put(&quot;reset&quot;, compileSet);  //no-op</span>
<span class="fc" id="L193">        keywordBasedExecutors.put(&quot;RESET&quot;, compileSet);  //no-op</span>
<span class="fc" id="L194">        keywordBasedExecutors.put(&quot;drop&quot;, dropTable);</span>
<span class="fc" id="L195">        keywordBasedExecutors.put(&quot;DROP&quot;, dropTable);</span>
<span class="fc" id="L196">        keywordBasedExecutors.put(&quot;backup&quot;, sqlBackup);</span>
<span class="fc" id="L197">        keywordBasedExecutors.put(&quot;BACKUP&quot;, sqlBackup);</span>
<span class="fc" id="L198">        keywordBasedExecutors.put(&quot;show&quot;, sqlShow);</span>
<span class="fc" id="L199">        keywordBasedExecutors.put(&quot;SHOW&quot;, sqlShow);</span>
<span class="fc" id="L200">        keywordBasedExecutors.put(&quot;vacuum&quot;, vacuumTable);</span>
<span class="fc" id="L201">        keywordBasedExecutors.put(&quot;VACUUM&quot;, vacuumTable);</span>
<span class="fc" id="L202">        keywordBasedExecutors.put(&quot;snapshot&quot;, snapshotDatabase);</span>
<span class="fc" id="L203">        keywordBasedExecutors.put(&quot;SNAPSHOT&quot;, snapshotDatabase);</span>
<span class="fc" id="L204">        keywordBasedExecutors.put(&quot;deallocate&quot;, compileDeallocate);</span>
<span class="fc" id="L205">        keywordBasedExecutors.put(&quot;DEALLOCATE&quot;, compileDeallocate);</span>

<span class="fc" id="L207">        configureLexer(lexer);</span>

<span class="fc" id="L209">        final PostOrderTreeTraversalAlgo postOrderTreeTraversalAlgo = new PostOrderTreeTraversalAlgo();</span>
<span class="fc" id="L210">        optimiser = new SqlOptimiser(</span>
                configuration,
                characterStore,
                sqlNodePool,
                queryColumnPool,
                queryModelPool,
                postOrderTreeTraversalAlgo,
                functionParser,
                path
        );

<span class="fc" id="L221">        parser = new SqlParser(</span>
                configuration,
                optimiser,
                characterStore,
                sqlNodePool,
                queryColumnPool,
                queryModelPool,
                postOrderTreeTraversalAlgo
        );
<span class="fc" id="L230">        this.textLoader = new TextLoader(engine);</span>
<span class="fc" id="L231">        alterOperationBuilder = new AlterOperationBuilder();</span>
<span class="fc" id="L232">    }</span>

    public static void configureLexer(GenericLexer lexer) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (int i = 0, k = sqlControlSymbols.size(); i &lt; k; i++) {</span>
<span class="fc" id="L236">            lexer.defineSymbol(sqlControlSymbols.getQuick(i));</span>
        }
<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (int i = 0, k = OperatorExpression.operators.size(); i &lt; k; i++) {</span>
<span class="fc" id="L239">            OperatorExpression op = OperatorExpression.operators.getQuick(i);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (op.symbol) {</span>
<span class="fc" id="L241">                lexer.defineSymbol(op.token);</span>
            }
        }
<span class="fc" id="L244">    }</span>

    @Override
    public void close() {
<span class="fc" id="L248">        backupAgent.close();</span>
<span class="fc" id="L249">        vacuumColumnVersions.close();</span>
<span class="fc" id="L250">        Misc.free(path);</span>
<span class="fc" id="L251">        Misc.free(renamePath);</span>
<span class="fc" id="L252">        Misc.free(textLoader);</span>
<span class="fc" id="L253">        Misc.free(rebuildIndex);</span>
<span class="fc" id="L254">        Misc.free(codeGenerator);</span>
<span class="fc" id="L255">        Misc.free(mem);</span>
<span class="fc" id="L256">        Misc.freeObjList(tableWriters);</span>
<span class="fc" id="L257">    }</span>

    @NotNull
    public CompiledQuery compile(@NotNull CharSequence query, @NotNull SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L261">        clear();</span>
        // these are quick executions that do not require building of a model
<span class="fc" id="L263">        lexer.of(query);</span>
<span class="fc" id="L264">        isSingleQueryMode = true;</span>

<span class="fc" id="L266">        compileInner(executionContext, query);</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        return compiledQuery;</span>
    }

    /**
     * Allows processing of batches of sql statements (sql scripts) separated by ';' .
     * Each query is processed in sequence and processing stops on first error and whole batch gets discarded.
     * Noteworthy difference between this and 'normal' query is that all empty queries get ignored, e.g.
     * &lt;br&gt;
     * select 1;&lt;br&gt;
     * ; ;/* comment \*\/;--comment\n; - these get ignored &lt;br&gt;
     * update a set b=c  ; &lt;br&gt;
     * &lt;p&gt;
     * Useful PG doc link :
     *
     * @param query            - block of queries to process
     * @param executionContext - SQL execution context
     * @param batchCallback    - callback to perform actions prior to or after batch part compilation, e.g. clear caches or execute command
     * @throws SqlException              - in case of syntax error
     * @throws PeerDisconnectedException - when peer is disconnected
     * @throws PeerIsSlowToReadException - when peer is too slow
     * @throws QueryPausedException      - when query is paused
     * @see &lt;a href=&quot;https://www.postgresql.org/docs/current/protocol-flow.html#id-1.10.5.7.4&quot;&gt;PostgreSQL documentation&lt;/a&gt;
     */
    public void compileBatch(
            @NotNull CharSequence query,
            @NotNull SqlExecutionContext executionContext,
            BatchCallback batchCallback
    ) throws PeerIsSlowToReadException, PeerDisconnectedException, QueryPausedException, SqlException {

<span class="fc" id="L296">        LOG.info().$(&quot;batch [text=&quot;).$(query).I$();</span>

<span class="fc" id="L298">        clear();</span>
<span class="fc" id="L299">        lexer.of(query);</span>
<span class="fc" id="L300">        isSingleQueryMode = false;</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (batchCallback == null) {</span>
<span class="fc" id="L303">            batchCallback = EMPTY_CALLBACK;</span>
        }

        int position;

<span class="fc bfc" id="L308" title="All 2 branches covered.">        while (lexer.hasNext()) {</span>
            // skip over empty statements that'd cause error in parser
<span class="fc" id="L310">            position = getNextValidTokenPosition();</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (position == -1) {</span>
<span class="fc" id="L312">                return;</span>
            }

<span class="fc" id="L315">            boolean recompileStale = true;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">            for (int retries = 0; recompileStale; retries++) {</span>
                try {
<span class="fc" id="L318">                    batchCallback.preCompile(this);</span>
<span class="fc" id="L319">                    clear(); // we don't use normal compile here because we can't reset existing lexer</span>
<span class="fc" id="L320">                    CompiledQuery current = compileInner(executionContext, query);</span>
                    // We've to move lexer because some query handlers don't consume all tokens (e.g. SET )
                    // some code in postCompile might need full text of current query
<span class="fc" id="L323">                    CharSequence currentQuery = query.subSequence(position, goToQueryEnd());</span>
<span class="fc" id="L324">                    batchCallback.postCompile(this, current, currentQuery);</span>
<span class="fc" id="L325">                    recompileStale = false;</span>
<span class="nc" id="L326">                } catch (TableReferenceOutOfDateException e) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                    if (retries == TableReferenceOutOfDateException.MAX_RETRY_ATTEMPS) {</span>
<span class="nc" id="L328">                        throw e;</span>
                    }
<span class="nc" id="L330">                    LOG.info().$(e.getFlyweightMessage()).$();</span>
                    // will recompile
<span class="nc" id="L332">                    lexer.restart();</span>
<span class="fc" id="L333">                }</span>
            }
<span class="fc" id="L335">        }</span>
<span class="fc" id="L336">    }</span>

    public CairoEngine getEngine() {
<span class="fc" id="L339">        return engine;</span>
    }

    public FunctionFactoryCache getFunctionFactoryCache() {
<span class="fc" id="L343">        return functionParser.getFunctionFactoryCache();</span>
    }

    private static void expectKeyword(GenericLexer lexer, CharSequence keyword) throws SqlException {
<span class="fc" id="L347">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>

<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L350">            throw SqlException.position(lexer.getPosition()).put('\'').put(keyword).put(&quot;' expected&quot;);</span>
        }

<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (!Chars.equalsLowerCaseAscii(tok, keyword)) {</span>
<span class="fc" id="L354">            throw SqlException.position(lexer.lastTokenPosition()).put('\'').put(keyword).put(&quot;' expected&quot;);</span>
        }
<span class="fc" id="L356">    }</span>

    private static CharSequence expectToken(GenericLexer lexer, CharSequence expected) throws SqlException {
<span class="fc" id="L359">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L362">            throw SqlException.position(lexer.getPosition()).put(expected).put(&quot; expected&quot;);</span>
        }

<span class="fc" id="L365">        return tok;</span>
    }

    private static boolean isCompatibleCase(int from, int to) {
<span class="fc bfc" id="L369" title="All 2 branches covered.">        return castGroups.getQuick(ColumnType.tagOf(from)) == castGroups.getQuick(ColumnType.tagOf(to));</span>
    }

    private static CharSequence maybeExpectToken(GenericLexer lexer, CharSequence expected, boolean expect) throws SqlException {
<span class="fc" id="L373">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>

<span class="fc bfc" id="L375" title="All 4 branches covered.">        if (expect &amp;&amp; tok == null) {</span>
<span class="fc" id="L376">            throw SqlException.position(lexer.getPosition()).put(expected).put(&quot; expected&quot;);</span>
        }

<span class="fc" id="L379">        return tok;</span>
    }

    private CompiledQuery alterSystemLockWriter(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L383">        final int tableNamePosition = lexer.getPosition();</span>
<span class="fc" id="L384">        CharSequence tok = GenericLexer.unquote(expectToken(lexer, &quot;table name&quot;));</span>
<span class="fc" id="L385">        TableToken tableToken = tableExistsOrFail(tableNamePosition, tok, executionContext);</span>
        try {
<span class="fc" id="L387">            CharSequence lockedReason = engine.lockWriter(executionContext.getCairoSecurityContext(), tableToken, &quot;alterSystem&quot;);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (lockedReason != WriterPool.OWNERSHIP_REASON_NONE) {</span>
<span class="fc" id="L389">                throw SqlException.$(tableNamePosition, &quot;could not lock, busy [table=`&quot;).put(tok).put(&quot;, lockedReason=&quot;).put(lockedReason).put(&quot;`]&quot;);</span>
            }
<span class="fc" id="L391">            return compiledQuery.ofLock();</span>
<span class="fc" id="L392">        } catch (CairoException e) {</span>
<span class="fc" id="L393">            throw SqlException.position(tableNamePosition)</span>
<span class="fc" id="L394">                    .put(e.getFlyweightMessage())</span>
<span class="fc" id="L395">                    .put(&quot;[errno=&quot;).put(e.getErrno()).put(']');</span>
        }
    }

    private CompiledQuery alterSystemUnlockWriter(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L400">        final int tableNamePosition = lexer.getPosition();</span>
<span class="fc" id="L401">        CharSequence tok = GenericLexer.unquote(expectToken(lexer, &quot;table name&quot;));</span>
<span class="fc" id="L402">        TableToken tableToken = tableExistsOrFail(tableNamePosition, tok, executionContext);</span>
        try {
<span class="fc" id="L404">            engine.unlockWriter(executionContext.getCairoSecurityContext(), tableToken);</span>
<span class="fc" id="L405">            return compiledQuery.ofUnlock();</span>
<span class="fc" id="L406">        } catch (CairoException e) {</span>
<span class="fc" id="L407">            throw SqlException.position(tableNamePosition)</span>
<span class="fc" id="L408">                    .put(e.getFlyweightMessage())</span>
<span class="fc" id="L409">                    .put(&quot;[errno=&quot;).put(e.getErrno()).put(']');</span>
        }
    }

    private CompiledQuery alterTable(SqlExecutionContext executionContext) throws SqlException {
        CharSequence tok;
<span class="fc" id="L415">        tok = expectToken(lexer, &quot;'table' or 'system'&quot;);</span>

<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (SqlKeywords.isTableKeyword(tok)) {</span>
<span class="fc" id="L418">            final int tableNamePosition = lexer.getPosition();</span>
<span class="fc" id="L419">            tok = GenericLexer.unquote(expectToken(lexer, &quot;table name&quot;));</span>
<span class="fc" id="L420">            TableToken tableToken = tableExistsOrFail(tableNamePosition, tok, executionContext);</span>

<span class="fc" id="L422">            try (TableRecordMetadata tableMetadata = executionContext.getMetadata(tableToken)) {</span>
<span class="fc" id="L423">                tok = expectToken(lexer, &quot;'add', 'alter' or 'drop'&quot;);</span>

<span class="fc bfc" id="L425" title="All 2 branches covered.">                if (SqlKeywords.isAddKeyword(tok)) {</span>
<span class="fc" id="L426">                    return alterTableAddColumn(tableNamePosition, tableToken, tableMetadata);</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">                } else if (SqlKeywords.isDropKeyword(tok)) {</span>
<span class="fc" id="L428">                    tok = expectToken(lexer, &quot;'column' or 'partition'&quot;);</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                    if (SqlKeywords.isColumnKeyword(tok)) {</span>
<span class="fc" id="L430">                        return alterTableDropColumn(tableNamePosition, tableToken, tableMetadata);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">                    } else if (SqlKeywords.isPartitionKeyword(tok)) {</span>
<span class="fc" id="L432">                        return alterTableDropDetachOrAttachPartition(tableMetadata, tableToken, PartitionAction.DROP, executionContext);</span>
                    } else {
<span class="fc" id="L434">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;'column' or 'partition' expected&quot;);</span>
                    }
<span class="fc bfc" id="L436" title="All 2 branches covered.">                } else if (SqlKeywords.isRenameKeyword(tok)) {</span>
<span class="fc" id="L437">                    tok = expectToken(lexer, &quot;'column'&quot;);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                    if (SqlKeywords.isColumnKeyword(tok)) {</span>
<span class="fc" id="L439">                        return alterTableRenameColumn(tableNamePosition, tableToken, tableMetadata);</span>
                    } else {
<span class="fc" id="L441">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;'column' expected&quot;);</span>
                    }
<span class="fc bfc" id="L443" title="All 2 branches covered.">                } else if (SqlKeywords.isAttachKeyword(tok)) {</span>
<span class="fc" id="L444">                    tok = expectToken(lexer, &quot;'partition'&quot;);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">                    if (SqlKeywords.isPartitionKeyword(tok)) {</span>
<span class="fc" id="L446">                        return alterTableDropDetachOrAttachPartition(tableMetadata, tableToken, PartitionAction.ATTACH, executionContext);</span>
                    } else {
<span class="fc" id="L448">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;'partition' expected&quot;);</span>
                    }
<span class="fc bfc" id="L450" title="All 2 branches covered.">                } else if (SqlKeywords.isDetachKeyword(tok)) {</span>
<span class="fc" id="L451">                    tok = expectToken(lexer, &quot;'partition'&quot;);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">                    if (SqlKeywords.isPartitionKeyword(tok)) {</span>
<span class="fc" id="L453">                        return alterTableDropDetachOrAttachPartition(tableMetadata, tableToken, PartitionAction.DETACH, executionContext);</span>
                    } else {
<span class="fc" id="L455">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;'partition' expected&quot;);</span>
                    }
<span class="fc bfc" id="L457" title="All 2 branches covered.">                } else if (SqlKeywords.isAlterKeyword(tok)) {</span>
<span class="fc" id="L458">                    tok = expectToken(lexer, &quot;'column'&quot;);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">                    if (SqlKeywords.isColumnKeyword(tok)) {</span>
<span class="fc" id="L460">                        final int columnNamePosition = lexer.getPosition();</span>
<span class="fc" id="L461">                        tok = expectToken(lexer, &quot;column name&quot;);</span>
<span class="fc" id="L462">                        final CharSequence columnName = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L463">                        tok = expectToken(lexer, &quot;'add index' or 'drop index' or 'cache' or 'nocache'&quot;);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">                        if (SqlKeywords.isAddKeyword(tok)) {</span>
<span class="fc" id="L465">                            expectKeyword(lexer, &quot;index&quot;);</span>
<span class="fc" id="L466">                            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc" id="L467">                            int indexValueCapacity = -1;</span>

<span class="fc bfc" id="L469" title="All 4 branches covered.">                            if (tok != null &amp;&amp; (!isSemicolon(tok))) {</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">                                if (!SqlKeywords.isCapacityKeyword(tok)) {</span>
<span class="fc" id="L471">                                    throw SqlException.$(lexer.lastTokenPosition(), &quot;'capacity' expected&quot;);</span>
                                } else {
<span class="fc" id="L473">                                    tok = expectToken(lexer, &quot;capacity value&quot;);</span>
                                    try {
<span class="fc" id="L475">                                        indexValueCapacity = Numbers.parseInt(tok);</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">                                        if (indexValueCapacity &lt;= 0) {</span>
<span class="nc" id="L477">                                            throw SqlException.$(lexer.lastTokenPosition(), &quot;positive integer literal expected as index capacity&quot;);</span>
                                        }
<span class="fc" id="L479">                                    } catch (NumericException e) {</span>
<span class="fc" id="L480">                                        throw SqlException.$(lexer.lastTokenPosition(), &quot;positive integer literal expected as index capacity&quot;);</span>
<span class="fc" id="L481">                                    }</span>
                                }
                            }

<span class="fc" id="L485">                            return alterTableColumnAddIndex(tableNamePosition, tableToken, columnNamePosition, columnName, tableMetadata, indexValueCapacity);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                        } else if (SqlKeywords.isDropKeyword(tok)) {</span>
                            // alter table &lt;table name&gt; alter column drop index
<span class="fc" id="L488">                            expectKeyword(lexer, &quot;index&quot;);</span>
<span class="fc" id="L489">                            tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L490" title="1 of 4 branches missed.">                            if (tok != null &amp;&amp; !isSemicolon(tok)) {</span>
<span class="fc" id="L491">                                throw SqlException.$(lexer.lastTokenPosition(), &quot;unexpected token [&quot;).put(tok).put(&quot;] while trying to drop index&quot;);</span>
                            }
<span class="fc" id="L493">                            return alterTableColumnDropIndex(tableNamePosition, tableToken, columnNamePosition, columnName, tableMetadata);</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                        } else if (SqlKeywords.isCacheKeyword(tok)) {</span>
<span class="fc" id="L495">                            return alterTableColumnCacheFlag(tableNamePosition, tableToken, columnName, tableMetadata, true);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">                        } else if (SqlKeywords.isNoCacheKeyword(tok)) {</span>
<span class="fc" id="L497">                            return alterTableColumnCacheFlag(tableNamePosition, tableToken, columnName, tableMetadata, false);</span>
                        } else {
<span class="fc" id="L499">                            throw SqlException.$(lexer.lastTokenPosition(), &quot;'add', 'drop', 'cache' or 'nocache' expected&quot;).put(&quot; found '&quot;).put(tok).put('\'');</span>
                        }
                    } else {
<span class="fc" id="L502">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;'column' or 'partition' expected&quot;);</span>
                    }
<span class="fc bfc" id="L504" title="All 2 branches covered.">                } else if (SqlKeywords.isSetKeyword(tok)) {</span>
<span class="fc" id="L505">                    tok = expectToken(lexer, &quot;'param' or 'type'&quot;);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">                    if (SqlKeywords.isParamKeyword(tok)) {</span>
<span class="fc" id="L507">                        final int paramNamePosition = lexer.getPosition();</span>
<span class="fc" id="L508">                        tok = expectToken(lexer, &quot;param name&quot;);</span>
<span class="fc" id="L509">                        final CharSequence paramName = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L510">                        tok = expectToken(lexer, &quot;'='&quot;);</span>
<span class="pc bpc" id="L511" title="1 of 4 branches missed.">                        if (tok.length() == 1 &amp;&amp; tok.charAt(0) == '=') {</span>
<span class="fc" id="L512">                            CharSequence value = GenericLexer.immutableOf(SqlUtil.fetchNext(lexer));</span>
<span class="fc" id="L513">                            return alterTableSetParam(paramName, value, paramNamePosition, tableToken, tableNamePosition, tableMetadata.getTableId());</span>
                        } else {
<span class="fc" id="L515">                            throw SqlException.$(lexer.lastTokenPosition(), &quot;'=' expected&quot;);</span>
                        }
<span class="fc bfc" id="L517" title="All 2 branches covered.">                    } else if (SqlKeywords.isTypeKeyword(tok)) {</span>
<span class="fc" id="L518">                        tok = expectToken(lexer, &quot;'bypass' or 'wal'&quot;);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">                        if (SqlKeywords.isBypassKeyword(tok)) {</span>
<span class="fc" id="L520">                            tok = expectToken(lexer, &quot;'wal'&quot;);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">                            if (SqlKeywords.isWalKeyword(tok)) {</span>
<span class="fc" id="L522">                                return alterTableSetType(executionContext, tableNamePosition, tableToken, (byte) 0);</span>
                            } else {
<span class="fc" id="L524">                                throw SqlException.$(lexer.lastTokenPosition(), &quot;'wal' expected&quot;);</span>
                            }
<span class="fc bfc" id="L526" title="All 2 branches covered.">                        } else if (SqlKeywords.isWalKeyword(tok)) {</span>
<span class="fc" id="L527">                            return alterTableSetType(executionContext, tableNamePosition, tableToken, (byte) 1);</span>
                        } else {
<span class="fc" id="L529">                            throw SqlException.$(lexer.lastTokenPosition(), &quot;'bypass' or 'wal' expected&quot;);</span>
                        }
                    } else {
<span class="fc" id="L532">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;'param' or 'type' expected&quot;);</span>
                    }
<span class="fc bfc" id="L534" title="All 2 branches covered.">                } else if (SqlKeywords.isResumeKeyword(tok)) {</span>
<span class="fc" id="L535">                    tok = expectToken(lexer, &quot;'wal'&quot;);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">                    if (!SqlKeywords.isWalKeyword(tok)) {</span>
<span class="fc" id="L537">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;'wal' expected&quot;);</span>
                    }

<span class="fc" id="L540">                    tok = SqlUtil.fetchNext(lexer); // optional from part</span>
<span class="fc" id="L541">                    long fromTxn = -1;</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                    if (tok != null) {</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">                        if (SqlKeywords.isFromKeyword(tok)) {</span>
<span class="fc" id="L544">                            tok = expectToken(lexer, &quot;'transaction' or 'txn'&quot;);</span>
<span class="fc bfc" id="L545" title="All 4 branches covered.">                            if (!(SqlKeywords.isTransactionKeyword(tok) || SqlKeywords.isTxnKeyword(tok))) {</span>
<span class="fc" id="L546">                                throw SqlException.$(lexer.lastTokenPosition(), &quot;'transaction' or 'txn' expected&quot;);</span>
                            }
<span class="fc" id="L548">                            CharSequence txnValue = expectToken(lexer, &quot;transaction value&quot;);</span>
                            try {
<span class="fc" id="L550">                                fromTxn = Numbers.parseLong(txnValue);</span>
<span class="fc" id="L551">                            } catch (NumericException e) {</span>
<span class="fc" id="L552">                                throw SqlException.$(lexer.lastTokenPosition(), &quot;invalid value [value=&quot;).put(txnValue).put(']');</span>
<span class="fc" id="L553">                            }</span>
<span class="fc" id="L554">                        } else {</span>
<span class="fc" id="L555">                            throw SqlException.$(lexer.lastTokenPosition(), &quot;'from' expected&quot;);</span>
                        }
                    }
<span class="fc bfc" id="L558" title="All 2 branches covered.">                    if (!engine.isWalTable(tableToken)) {</span>
<span class="fc" id="L559">                        throw SqlException.$(lexer.lastTokenPosition(), tableToken.getTableName()).put(&quot; is not a WAL table.&quot;);</span>
                    }
<span class="fc" id="L561">                    return alterTableResume(tableNamePosition, tableToken, fromTxn, executionContext);</span>
                } else {
<span class="fc" id="L563">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;'add', 'drop', 'attach', 'detach', 'set', 'rename' or 'resume' expected&quot;);</span>
                }
<span class="pc bpc" id="L565" title="13 of 26 branches missed.">            } catch (CairoException e) {</span>
<span class="fc" id="L566">                LOG.info().$(&quot;could not alter table [table=&quot;).$(tableToken.getTableName()).$(&quot;, ex=&quot;).$((Throwable) e).$();</span>
<span class="fc" id="L567">                e.position(lexer.lastTokenPosition());</span>
<span class="fc" id="L568">                throw e;</span>
            }
<span class="fc bfc" id="L570" title="All 2 branches covered.">        } else if (SqlKeywords.isSystemKeyword(tok)) {</span>
<span class="fc" id="L571">            tok = expectToken(lexer, &quot;'lock' or 'unlock'&quot;);</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">            if (SqlKeywords.isLockKeyword(tok)) {</span>
<span class="fc" id="L574">                tok = expectToken(lexer, &quot;'writer'&quot;);</span>

<span class="fc bfc" id="L576" title="All 2 branches covered.">                if (SqlKeywords.isWriterKeyword(tok)) {</span>
<span class="fc" id="L577">                    return alterSystemLockWriter(executionContext);</span>
                } else {
<span class="fc" id="L579">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;'writer' expected&quot;);</span>
                }
<span class="fc bfc" id="L581" title="All 2 branches covered.">            } else if (SqlKeywords.isUnlockKeyword(tok)) {</span>
<span class="fc" id="L582">                tok = expectToken(lexer, &quot;'writer'&quot;);</span>

<span class="fc bfc" id="L584" title="All 2 branches covered.">                if (SqlKeywords.isWriterKeyword(tok)) {</span>
<span class="fc" id="L585">                    return alterSystemUnlockWriter(executionContext);</span>
                } else {
<span class="fc" id="L587">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;'writer' expected&quot;);</span>
                }
            } else {
<span class="fc" id="L590">                throw SqlException.$(lexer.lastTokenPosition(), &quot;'lock' or 'unlock' expected&quot;);</span>
            }
        } else {
<span class="fc" id="L593">            throw SqlException.$(lexer.lastTokenPosition(), &quot;'table' or 'system' expected&quot;);</span>
        }
    }

    private CompiledQuery alterTableAddColumn(
            int tableNamePosition,
            TableToken tableToken,
            TableRecordMetadata tableMetadata
    ) throws SqlException {
        // add columns to table
<span class="fc" id="L603">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>
        //ignoring `column`
<span class="fc bfc" id="L605" title="All 4 branches covered.">        if (tok != null &amp;&amp; !SqlKeywords.isColumnKeyword(tok)) {</span>
<span class="fc" id="L606">            lexer.unparseLast();</span>
        }

<span class="fc" id="L609">        AlterOperationBuilder addColumn = alterOperationBuilder.ofAddColumn(</span>
                tableNamePosition,
                tableToken,
<span class="fc" id="L612">                tableMetadata.getTableId()</span>
        );

<span class="fc" id="L615">        int semicolonPos = -1;</span>
        do {
<span class="fc bfc" id="L617" title="All 2 branches covered.">            tok = maybeExpectToken(lexer, &quot;'column' or column name&quot;, semicolonPos &lt; 0);</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">            if (semicolonPos &gt;= 0) {</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">                if (tok != null) {</span>
<span class="fc" id="L620">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;',' expected&quot;);</span>
                }
                break;
            }

<span class="fc" id="L625">            int index = tableMetadata.getColumnIndexQuiet(tok);</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">            if (index != -1) {</span>
<span class="fc" id="L627">                throw SqlException.$(lexer.lastTokenPosition(), &quot;column '&quot;).put(tok).put(&quot;' already exists&quot;);</span>
            }

<span class="fc" id="L630">            CharSequence columnName = GenericLexer.immutableOf(GenericLexer.unquote(tok));</span>
<span class="fc" id="L631">            int columnNamePosition = lexer.lastTokenPosition();</span>

<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (!TableUtils.isValidColumnName(columnName, configuration.getMaxFileNameLength())) {</span>
<span class="fc" id="L634">                throw SqlException.$(lexer.lastTokenPosition(), &quot; new column name contains invalid characters&quot;);</span>
            }

<span class="fc" id="L637">            tok = expectToken(lexer, &quot;column type&quot;);</span>

<span class="fc" id="L639">            int type = ColumnType.tagOf(tok);</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">            if (type == -1) {</span>
<span class="fc" id="L641">                throw SqlException.$(lexer.lastTokenPosition(), &quot;invalid type&quot;);</span>
            }

<span class="fc bfc" id="L644" title="All 2 branches covered.">            if (type == ColumnType.GEOHASH) {</span>
<span class="fc" id="L645">                tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L646" title="1 of 4 branches missed.">                if (tok == null || tok.charAt(0) != '(') {</span>
<span class="fc" id="L647">                    throw SqlException.position(lexer.getPosition()).put(&quot;missing GEOHASH precision&quot;);</span>
                }

<span class="fc" id="L650">                tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L651" title="1 of 4 branches missed.">                if (tok != null &amp;&amp; tok.charAt(0) != ')') {</span>
<span class="fc" id="L652">                    int geoHashBits = GeoHashUtil.parseGeoHashBits(lexer.lastTokenPosition(), 0, tok);</span>
<span class="fc" id="L653">                    tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L654" title="All 4 branches covered.">                    if (tok == null || tok.charAt(0) != ')') {</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">                        if (tok != null) {</span>
<span class="fc" id="L656">                            throw SqlException.position(lexer.lastTokenPosition())</span>
<span class="fc" id="L657">                                    .put(&quot;invalid GEOHASH type literal, expected ')'&quot;)</span>
<span class="fc" id="L658">                                    .put(&quot; found='&quot;).put(tok.charAt(0)).put(&quot;'&quot;);</span>
                        }
<span class="fc" id="L660">                        throw SqlException.position(lexer.getPosition())</span>
<span class="fc" id="L661">                                .put(&quot;invalid GEOHASH type literal, expected ')'&quot;);</span>
                    }
<span class="fc" id="L663">                    type = ColumnType.getGeoHashTypeWithBits(geoHashBits);</span>
<span class="fc" id="L664">                } else {</span>
<span class="fc" id="L665">                    throw SqlException.position(lexer.lastTokenPosition())</span>
<span class="fc" id="L666">                            .put(&quot;missing GEOHASH precision&quot;);</span>
                }
            }

<span class="fc" id="L670">            tok = SqlUtil.fetchNext(lexer);</span>
            final int indexValueBlockCapacity;
            final boolean cache;
            int symbolCapacity;
            final boolean indexed;

<span class="fc" id="L676">            if (</span>
<span class="fc bfc" id="L677" title="All 4 branches covered.">                    ColumnType.isSymbol(type)</span>
                            &amp;&amp; tok != null
                            &amp;&amp;
<span class="fc bfc" id="L680" title="All 2 branches covered.">                            !Chars.equals(tok, ',')</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">                            &amp;&amp; !Chars.equals(tok, ';')</span>
            ) {

<span class="fc bfc" id="L684" title="All 2 branches covered.">                if (isCapacityKeyword(tok)) {</span>
<span class="fc" id="L685">                    tok = expectToken(lexer, &quot;symbol capacity&quot;);</span>

                    final boolean negative;
<span class="fc" id="L688">                    final int errorPos = lexer.lastTokenPosition();</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">                    if (Chars.equals(tok, '-')) {</span>
<span class="fc" id="L690">                        negative = true;</span>
<span class="fc" id="L691">                        tok = expectToken(lexer, &quot;symbol capacity&quot;);</span>
                    } else {
<span class="fc" id="L693">                        negative = false;</span>
                    }

                    try {
<span class="fc" id="L697">                        symbolCapacity = Numbers.parseInt(tok);</span>
<span class="fc" id="L698">                    } catch (NumericException e) {</span>
<span class="fc" id="L699">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;numeric capacity expected&quot;);</span>
<span class="fc" id="L700">                    }</span>

<span class="fc bfc" id="L702" title="All 2 branches covered.">                    if (negative) {</span>
<span class="fc" id="L703">                        symbolCapacity = -symbolCapacity;</span>
                    }

<span class="fc" id="L706">                    TableUtils.validateSymbolCapacity(errorPos, symbolCapacity);</span>

<span class="fc" id="L708">                    tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc" id="L709">                } else {</span>
<span class="fc" id="L710">                    symbolCapacity = configuration.getDefaultSymbolCapacity();</span>
                }

<span class="fc bfc" id="L713" title="All 2 branches covered.">                if (Chars.equalsLowerCaseAsciiNc(&quot;cache&quot;, tok)) {</span>
<span class="fc" id="L714">                    cache = true;</span>
<span class="fc" id="L715">                    tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">                } else if (Chars.equalsLowerCaseAsciiNc(&quot;nocache&quot;, tok)) {</span>
<span class="fc" id="L717">                    cache = false;</span>
<span class="fc" id="L718">                    tok = SqlUtil.fetchNext(lexer);</span>
                } else {
<span class="fc" id="L720">                    cache = configuration.getDefaultSymbolCacheFlag();</span>
                }

<span class="fc" id="L723">                TableUtils.validateSymbolCapacityCached(cache, symbolCapacity, lexer.lastTokenPosition());</span>

<span class="fc" id="L725">                indexed = Chars.equalsLowerCaseAsciiNc(&quot;index&quot;, tok);</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                if (indexed) {</span>
<span class="fc" id="L727">                    tok = SqlUtil.fetchNext(lexer);</span>
                }

<span class="fc bfc" id="L730" title="All 2 branches covered.">                if (Chars.equalsLowerCaseAsciiNc(&quot;capacity&quot;, tok)) {</span>
<span class="fc" id="L731">                    tok = expectToken(lexer, &quot;symbol index capacity&quot;);</span>

                    try {
<span class="fc" id="L734">                        indexValueBlockCapacity = Numbers.parseInt(tok);</span>
<span class="fc" id="L735">                    } catch (NumericException e) {</span>
<span class="fc" id="L736">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;numeric capacity expected&quot;);</span>
<span class="fc" id="L737">                    }</span>
<span class="fc" id="L738">                    tok = SqlUtil.fetchNext(lexer);</span>
                } else {
<span class="fc" id="L740">                    indexValueBlockCapacity = configuration.getIndexValueBlockSize();</span>
                }
            } else { //set defaults

                //ignoring `NULL` and `NOT NULL`
<span class="fc bfc" id="L745" title="All 4 branches covered.">                if (tok != null &amp;&amp; SqlKeywords.isNotKeyword(tok)) {</span>
<span class="fc" id="L746">                    tok = SqlUtil.fetchNext(lexer);</span>
                }

<span class="fc bfc" id="L749" title="All 4 branches covered.">                if (tok != null &amp;&amp; SqlKeywords.isNullKeyword(tok)) {</span>
<span class="fc" id="L750">                    tok = SqlUtil.fetchNext(lexer);</span>
                }

<span class="fc" id="L753">                cache = configuration.getDefaultSymbolCacheFlag();</span>
<span class="fc" id="L754">                indexValueBlockCapacity = configuration.getIndexValueBlockSize();</span>
<span class="fc" id="L755">                symbolCapacity = configuration.getDefaultSymbolCapacity();</span>
<span class="fc" id="L756">                indexed = false;</span>
            }

<span class="fc" id="L759">            addColumn.addColumnToList(</span>
                    columnName,
                    columnNamePosition,
                    type,
<span class="fc" id="L763">                    Numbers.ceilPow2(symbolCapacity),</span>
                    cache,
                    indexed,
<span class="fc" id="L766">                    Numbers.ceilPow2(indexValueBlockCapacity)</span>
            );

<span class="pc bpc" id="L769" title="1 of 6 branches missed.">            if (tok == null || (!isSingleQueryMode &amp;&amp; isSemicolon(tok))) {</span>
<span class="fc" id="L770">                break;</span>
            }

<span class="fc bfc" id="L773" title="All 2 branches covered.">            semicolonPos = Chars.equals(tok, ';') ? lexer.lastTokenPosition() : -1;</span>
<span class="fc bfc" id="L774" title="All 4 branches covered.">            if (semicolonPos &lt; 0 &amp;&amp; !Chars.equals(tok, ',')) {</span>
<span class="fc" id="L775">                throw SqlException.$(lexer.lastTokenPosition(), &quot;',' expected&quot;);</span>
            }

<span class="fc" id="L778">        } while (true);</span>
<span class="fc" id="L779">        return compiledQuery.ofAlter(alterOperationBuilder.build());</span>
    }

    private CompiledQuery alterTableColumnAddIndex(
            int tableNamePosition,
            TableToken tableToken,
            int columnNamePosition,
            CharSequence columnName,
            TableRecordMetadata metadata,
            int indexValueBlockSize
    ) throws SqlException {

<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (metadata.getColumnIndexQuiet(columnName) == -1) {</span>
<span class="fc" id="L792">            throw SqlException.invalidColumn(columnNamePosition, columnName);</span>
        }
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (indexValueBlockSize == -1) {</span>
<span class="fc" id="L795">            indexValueBlockSize = configuration.getIndexValueBlockSize();</span>
        }
<span class="fc" id="L797">        return compiledQuery.ofAlter(</span>
                alterOperationBuilder
<span class="fc" id="L799">                        .ofAddIndex(</span>
                                tableNamePosition,
                                tableToken,
<span class="fc" id="L802">                                metadata.getTableId(),</span>
                                columnName,
<span class="fc" id="L804">                                Numbers.ceilPow2(indexValueBlockSize)</span>
                        )
<span class="fc" id="L806">                        .build()</span>
        );
    }

    private CompiledQuery alterTableColumnCacheFlag(
            int tableNamePosition,
            TableToken tableToken,
            CharSequence columnName,
            TableRecordMetadata metadata,
            boolean cache
    ) throws SqlException {
<span class="fc" id="L817">        int columnIndex = metadata.getColumnIndexQuiet(columnName);</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">        if (columnIndex == -1) {</span>
<span class="fc" id="L819">            throw SqlException.invalidColumn(lexer.lastTokenPosition(), columnName);</span>
        }

<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (!ColumnType.isSymbol(metadata.getColumnType(columnIndex))) {</span>
<span class="fc" id="L823">            throw SqlException.$(lexer.lastTokenPosition(), &quot;Invalid column type - Column should be of type symbol&quot;);</span>
        }

<span class="fc bfc" id="L826" title="All 2 branches covered.">        return cache ? compiledQuery.ofAlter(</span>
<span class="fc" id="L827">                alterOperationBuilder.ofCacheSymbol(tableNamePosition, tableToken, metadata.getTableId(), columnName).build()</span>
        )
<span class="fc" id="L829">                : compiledQuery.ofAlter(</span>
<span class="fc" id="L830">                alterOperationBuilder.ofRemoveCacheSymbol(tableNamePosition, tableToken, metadata.getTableId(), columnName).build()</span>
        );
    }

    private CompiledQuery alterTableColumnDropIndex(
            int tableNamePosition,
            TableToken tableToken,
            int columnNamePosition,
            CharSequence columnName,
            TableRecordMetadata metadata
    ) throws SqlException {
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">        if (metadata.getColumnIndexQuiet(columnName) == -1) {</span>
<span class="nc" id="L842">            throw SqlException.invalidColumn(columnNamePosition, columnName);</span>
        }
<span class="fc" id="L844">        return compiledQuery.ofAlter(</span>
                alterOperationBuilder
<span class="fc" id="L846">                        .ofDropIndex(tableNamePosition, tableToken, metadata.getTableId(), columnName, columnNamePosition)</span>
<span class="fc" id="L847">                        .build()</span>
        );
    }

    private CompiledQuery alterTableSetType(SqlExecutionContext executionContext,
                                            int pos,
                                            TableToken token,
                                            byte walFlag) throws SqlException {
        try {
<span class="fc" id="L856">            try (TableReader reader = executionContext.getReader(token)) {</span>
<span class="pc bpc" id="L857" title="1 of 4 branches missed.">                if (reader != null &amp;&amp; !PartitionBy.isPartitioned(reader.getMetadata().getPartitionBy())) {</span>
<span class="fc" id="L858">                    throw SqlException.$(pos, &quot;Cannot convert non-partitioned table&quot;);</span>
                }
            }

<span class="fc" id="L862">            path.of(configuration.getRoot()).concat(token.getDirName());</span>
<span class="fc" id="L863">            TableUtils.createConvertFile(ff, path, walFlag);</span>
<span class="fc" id="L864">            return compiledQuery.ofTableSetType();</span>
<span class="nc" id="L865">        } catch (CairoException e) {</span>
<span class="nc" id="L866">            throw SqlException.position(pos)</span>
<span class="nc" id="L867">                    .put(e.getFlyweightMessage())</span>
<span class="nc" id="L868">                    .put(&quot;[errno=&quot;).put(e.getErrno()).put(']');</span>
        }
    }

    private CompiledQuery alterTableDropColumn(int tableNamePosition, TableToken tableToken, TableRecordMetadata metadata) throws SqlException {
<span class="fc" id="L873">        AlterOperationBuilder dropColumnStatement = alterOperationBuilder.ofDropColumn(tableNamePosition, tableToken, metadata.getTableId());</span>
<span class="fc" id="L874">        int semicolonPos = -1;</span>
        do {
<span class="fc bfc" id="L876" title="All 2 branches covered.">            CharSequence tok = GenericLexer.unquote(maybeExpectToken(lexer, &quot;column name&quot;, semicolonPos &lt; 0));</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">            if (semicolonPos &gt;= 0) {</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">                if (tok != null) {</span>
<span class="fc" id="L879">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;',' expected&quot;);</span>
                }
                break;
            }

<span class="fc bfc" id="L884" title="All 2 branches covered.">            if (metadata.getColumnIndexQuiet(tok) == -1) {</span>
<span class="fc" id="L885">                throw SqlException.invalidColumn(lexer.lastTokenPosition(), tok);</span>
            }

<span class="fc" id="L888">            CharSequence columnName = tok;</span>
<span class="fc" id="L889">            dropColumnStatement.ofDropColumn(columnName);</span>
<span class="fc" id="L890">            tok = SqlUtil.fetchNext(lexer);</span>

<span class="pc bpc" id="L892" title="1 of 6 branches missed.">            if (tok == null || (!isSingleQueryMode &amp;&amp; isSemicolon(tok))) {</span>
<span class="fc" id="L893">                break;</span>
            }

<span class="fc bfc" id="L896" title="All 2 branches covered.">            semicolonPos = Chars.equals(tok, ';') ? lexer.lastTokenPosition() : -1;</span>
<span class="fc bfc" id="L897" title="All 4 branches covered.">            if (semicolonPos &lt; 0 &amp;&amp; !Chars.equals(tok, ',')) {</span>
<span class="fc" id="L898">                throw SqlException.$(lexer.lastTokenPosition(), &quot;',' expected&quot;);</span>
            }
<span class="fc" id="L900">        } while (true);</span>

<span class="fc" id="L902">        return compiledQuery.ofAlter(alterOperationBuilder.build());</span>
    }

    private CompiledQuery alterTableDropDetachOrAttachPartition(
            TableRecordMetadata tableMetadata,
            TableToken tableToken,
            int action,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L911">        final int pos = lexer.lastTokenPosition();</span>
<span class="fc" id="L912">        TableReader reader = null;</span>
<span class="fc bfc" id="L913" title="All 4 branches covered.">        if (!tableMetadata.isWalEnabled() || executionContext.isWalApplication()) {</span>
<span class="fc" id="L914">            reader = executionContext.getReader(tableToken);</span>
        }

        try {
<span class="fc bfc" id="L918" title="All 4 branches covered.">            if (reader != null &amp;&amp; !PartitionBy.isPartitioned(reader.getMetadata().getPartitionBy())) {</span>
<span class="fc" id="L919">                throw SqlException.$(pos, &quot;table is not partitioned&quot;);</span>
            }

<span class="fc" id="L922">            final CharSequence tok = expectToken(lexer, &quot;'list' or 'where'&quot;);</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">            if (SqlKeywords.isListKeyword(tok)) {</span>
<span class="fc" id="L924">                return alterTableDropDetachOrAttachPartitionByList(tableMetadata, tableToken, reader, pos, action);</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">            } else if (SqlKeywords.isWhereKeyword(tok)) {</span>
                AlterOperationBuilder alterOperationBuilder;
<span class="pc bpc" id="L927" title="2 of 3 branches missed.">                switch (action) {</span>
                    case PartitionAction.DROP:
<span class="fc" id="L929">                        alterOperationBuilder = this.alterOperationBuilder.ofDropPartition(pos, tableToken, tableMetadata.getTableId());</span>
<span class="fc" id="L930">                        break;</span>
                    case PartitionAction.DETACH:
<span class="nc" id="L932">                        alterOperationBuilder = this.alterOperationBuilder.ofDetachPartition(pos, tableToken, tableMetadata.getTableId());</span>
<span class="nc" id="L933">                        break;</span>
                    default:
<span class="nc" id="L935">                        throw SqlException.$(pos, &quot;WHERE clause can only be used with command DROP PARTITION, or DETACH PARTITION&quot;);</span>
                }

<span class="fc" id="L938">                final int functionPosition = lexer.getPosition();</span>
<span class="fc" id="L939">                ExpressionNode expr = parser.expr(lexer, (QueryModel) null);</span>
<span class="fc" id="L940">                String designatedTimestampColumnName = null;</span>
<span class="fc" id="L941">                int tsIndex = tableMetadata.getTimestampIndex();</span>
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">                if (tsIndex &gt;= 0) {</span>
<span class="fc" id="L943">                    designatedTimestampColumnName = tableMetadata.getColumnName(tsIndex);</span>
                }
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">                if (designatedTimestampColumnName != null) {</span>
<span class="fc" id="L946">                    GenericRecordMetadata metadata = new GenericRecordMetadata();</span>
<span class="fc" id="L947">                    metadata.add(new TableColumnMetadata(designatedTimestampColumnName, ColumnType.TIMESTAMP, null));</span>
<span class="fc" id="L948">                    Function function = functionParser.parseFunction(expr, metadata, executionContext);</span>
                    try {
<span class="pc bpc" id="L950" title="1 of 4 branches missed.">                        if (function != null &amp;&amp; ColumnType.isBoolean(function.getType())) {</span>
<span class="fc" id="L951">                            function.init(null, executionContext);</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">                            if (reader != null) {</span>
<span class="fc" id="L953">                                int affected = filterPartitions(function, functionPosition, reader, alterOperationBuilder);</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">                                if (affected == 0) {</span>
<span class="fc" id="L955">                                    throw SqlException.$(functionPosition, &quot;no partitions matched WHERE clause&quot;);</span>
                                }
                            }
<span class="fc" id="L958">                            return compiledQuery.ofAlter(this.alterOperationBuilder.build());</span>
                        } else {
<span class="fc" id="L960">                            throw SqlException.$(lexer.lastTokenPosition(), &quot;boolean expression expected&quot;);</span>
                        }
                    } finally {
<span class="fc" id="L963">                        Misc.free(function);</span>
                    }
                } else {
<span class="nc" id="L966">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;this table does not have a designated timestamp column&quot;);</span>
                }
            } else {
<span class="nc" id="L969">                throw SqlException.$(lexer.lastTokenPosition(), &quot;'list' or 'where' expected&quot;);</span>
            }
        } finally {
<span class="fc" id="L972">            Misc.free(reader);</span>
        }
    }

    private CompiledQuery alterTableDropDetachOrAttachPartitionByList(
            TableRecordMetadata tableMetadata,
            TableToken tableToken,
            @Nullable TableReader reader,
            int pos,
            int action
    ) throws SqlException {
        final AlterOperationBuilder alterOperationBuilder;
<span class="pc bpc" id="L984" title="1 of 4 branches missed.">        switch (action) {</span>
            case PartitionAction.DROP:
<span class="fc" id="L986">                alterOperationBuilder = this.alterOperationBuilder.ofDropPartition(pos, tableToken, tableMetadata.getTableId());</span>
<span class="fc" id="L987">                break;</span>
            case PartitionAction.DETACH:
<span class="fc" id="L989">                alterOperationBuilder = this.alterOperationBuilder.ofDetachPartition(pos, tableToken, tableMetadata.getTableId());</span>
<span class="fc" id="L990">                break;</span>
            case PartitionAction.ATTACH:
                // attach
<span class="fc" id="L993">                alterOperationBuilder = this.alterOperationBuilder.ofAttachPartition(pos, tableToken, tableMetadata.getTableId());</span>
<span class="fc" id="L994">                break;</span>
            default:
<span class="nc" id="L996">                alterOperationBuilder = null;</span>
<span class="nc" id="L997">                assert false;</span>
        }

<span class="fc" id="L1000">        int semicolonPos = -1;</span>
        do {
<span class="fc bfc" id="L1002" title="All 2 branches covered.">            CharSequence tok = maybeExpectToken(lexer, &quot;partition name&quot;, semicolonPos &lt; 0);</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">            if (semicolonPos &gt;= 0) {</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">                if (tok != null) {</span>
<span class="fc" id="L1005">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;',' expected&quot;);</span>
                }
                break;
            }
<span class="fc bfc" id="L1009" title="All 2 branches covered.">            if (Chars.equals(tok, ',')) {</span>
<span class="fc" id="L1010">                throw SqlException.$(lexer.lastTokenPosition(), &quot;partition name missing&quot;);</span>
            }
<span class="fc" id="L1012">            final CharSequence partitionName = GenericLexer.unquote(tok);</span>
<span class="fc" id="L1013">            final int partitionNamePosition = lexer.lastTokenPosition();</span>

            // reader == null means it's compilation for WAL table
            // before applying to WAL writer
<span class="fc bfc" id="L1017" title="All 2 branches covered.">            if (reader != null) {</span>
                final long timestamp;
                try {
<span class="fc" id="L1020">                    timestamp = PartitionBy.parsePartitionDirName(partitionName, reader.getPartitionedBy());</span>
<span class="fc" id="L1021">                } catch (CairoException e) {</span>
<span class="fc" id="L1022">                    throw SqlException.$(lexer.lastTokenPosition(), e.getFlyweightMessage())</span>
<span class="fc" id="L1023">                            .put(&quot;[errno=&quot;).put(e.getErrno()).put(']');</span>
<span class="fc" id="L1024">                }</span>

<span class="fc" id="L1026">                alterOperationBuilder.addPartitionToList(timestamp, partitionNamePosition);</span>
            }

<span class="fc" id="L1029">            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L1030" title="All 6 branches covered.">            if (tok == null || (!isSingleQueryMode &amp;&amp; isSemicolon(tok))) {</span>
<span class="fc" id="L1031">                break;</span>
            }

<span class="fc bfc" id="L1034" title="All 2 branches covered.">            semicolonPos = Chars.equals(tok, ';') ? lexer.lastTokenPosition() : -1;</span>
<span class="fc bfc" id="L1035" title="All 4 branches covered.">            if (semicolonPos &lt; 0 &amp;&amp; !Chars.equals(tok, ',')) {</span>
<span class="fc" id="L1036">                throw SqlException.$(lexer.lastTokenPosition(), &quot;',' expected&quot;);</span>
            }
<span class="fc" id="L1038">        } while (true);</span>

<span class="fc" id="L1040">        return compiledQuery.ofAlter(this.alterOperationBuilder.build());</span>
    }

    private CompiledQuery alterTableRenameColumn(int tableNamePosition, TableToken tableToken, TableRecordMetadata metadata) throws SqlException {
<span class="fc" id="L1044">        AlterOperationBuilder renameColumnStatement = alterOperationBuilder.ofRenameColumn(tableNamePosition, tableToken, metadata.getTableId());</span>
<span class="fc" id="L1045">        int hadSemicolonPos = -1;</span>

        do {
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            CharSequence tok = GenericLexer.unquote(maybeExpectToken(lexer, &quot;current column name&quot;, hadSemicolonPos &lt; 0));</span>
<span class="fc bfc" id="L1049" title="All 2 branches covered.">            if (hadSemicolonPos &gt;= 0) {</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">                if (tok != null) {</span>
<span class="fc" id="L1051">                    throw SqlException.$(hadSemicolonPos, &quot;',' expected&quot;);</span>
                }
                break;
            }
<span class="fc" id="L1055">            int columnIndex = metadata.getColumnIndexQuiet(tok);</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">            if (columnIndex == -1) {</span>
<span class="fc" id="L1057">                throw SqlException.invalidColumn(lexer.lastTokenPosition(), tok);</span>
            }
<span class="fc" id="L1059">            CharSequence existingName = GenericLexer.immutableOf(tok);</span>

<span class="fc" id="L1061">            tok = expectToken(lexer, &quot;'to' expected&quot;);</span>
<span class="fc bfc" id="L1062" title="All 2 branches covered.">            if (!SqlKeywords.isToKeyword(tok)) {</span>
<span class="fc" id="L1063">                throw SqlException.$(lexer.lastTokenPosition(), &quot;'to' expected'&quot;);</span>
            }

<span class="fc" id="L1066">            tok = GenericLexer.unquote(expectToken(lexer, &quot;new column name&quot;));</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">            if (Chars.equals(existingName, tok)) {</span>
<span class="fc" id="L1068">                throw SqlException.$(lexer.lastTokenPosition(), &quot;new column name is identical to existing name&quot;);</span>
            }

<span class="fc bfc" id="L1071" title="All 2 branches covered.">            if (metadata.getColumnIndexQuiet(tok) &gt; -1) {</span>
<span class="fc" id="L1072">                throw SqlException.$(lexer.lastTokenPosition(), &quot; column already exists&quot;);</span>
            }

<span class="fc bfc" id="L1075" title="All 2 branches covered.">            if (!TableUtils.isValidColumnName(tok, configuration.getMaxFileNameLength())) {</span>
<span class="fc" id="L1076">                throw SqlException.$(lexer.lastTokenPosition(), &quot; new column name contains invalid characters&quot;);</span>
            }

<span class="fc" id="L1079">            CharSequence newName = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L1080">            renameColumnStatement.ofRenameColumn(existingName, newName);</span>

<span class="fc" id="L1082">            tok = SqlUtil.fetchNext(lexer);</span>

<span class="pc bpc" id="L1084" title="1 of 6 branches missed.">            if (tok == null || (!isSingleQueryMode &amp;&amp; isSemicolon(tok))) {</span>
<span class="fc" id="L1085">                break;</span>
            }

<span class="fc bfc" id="L1088" title="All 2 branches covered.">            hadSemicolonPos = Chars.equals(tok, ';') ? lexer.lastTokenPosition() : -1;</span>
<span class="fc bfc" id="L1089" title="All 4 branches covered.">            if (hadSemicolonPos &lt; 0 &amp;&amp; !Chars.equals(tok, ',')) {</span>
<span class="fc" id="L1090">                throw SqlException.$(lexer.lastTokenPosition(), &quot;',' expected&quot;);</span>
            }
<span class="fc" id="L1092">        } while (true);</span>
<span class="fc" id="L1093">        return compiledQuery.ofAlter(alterOperationBuilder.build());</span>
    }

    private CompiledQuery alterTableResume(int tableNamePosition, TableToken tableToken, long resumeFromTxn, SqlExecutionContext executionContext) {
        try {
<span class="fc" id="L1098">            engine.getTableSequencerAPI().resumeTable(tableToken, resumeFromTxn, executionContext.getCairoSecurityContext());</span>
<span class="fc" id="L1099">            executionContext.storeTelemetry(TelemetryOrigin.WAL_APPLY, WAL_APPLY_RESUME);</span>
<span class="fc" id="L1100">            return compiledQuery.ofTableResume();</span>
<span class="fc" id="L1101">        } catch (CairoException ex) {</span>
<span class="fc" id="L1102">            LOG.critical().$(&quot;table resume failed [table=&quot;).$(tableToken)</span>
<span class="fc" id="L1103">                    .$(&quot;, error=&quot;).$(ex.getFlyweightMessage())</span>
<span class="fc" id="L1104">                    .$(&quot;, errno=&quot;).$(ex.getErrno())</span>
<span class="fc" id="L1105">                    .I$();</span>
<span class="fc" id="L1106">            ex.position(tableNamePosition);</span>
<span class="fc" id="L1107">            throw ex;</span>
        }
    }

    private CompiledQuery alterTableSetParam(CharSequence paramName, CharSequence value, int paramNamePosition, TableToken tableToken, int tableNamePosition, int tableId) throws SqlException {
<span class="fc bfc" id="L1112" title="All 2 branches covered.">        if (isMaxUncommittedRowsKeyword(paramName)) {</span>
            int maxUncommittedRows;
            try {
<span class="fc" id="L1115">                maxUncommittedRows = Numbers.parseInt(value);</span>
<span class="fc" id="L1116">            } catch (NumericException e) {</span>
<span class="fc" id="L1117">                throw SqlException.$(paramNamePosition, &quot;invalid value [value=&quot;).put(value).put(&quot;,parameter=&quot;).put(paramName).put(']');</span>
<span class="fc" id="L1118">            }</span>
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">            if (maxUncommittedRows &lt; 0) {</span>
<span class="nc" id="L1120">                throw SqlException.$(paramNamePosition, &quot;maxUncommittedRows must be non negative&quot;);</span>
            }
<span class="fc" id="L1122">            return compiledQuery.ofAlter(alterOperationBuilder.ofSetParamUncommittedRows(tableNamePosition, tableToken, tableId, maxUncommittedRows).build());</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        } else if (isO3MaxLagKeyword(paramName)) {</span>
<span class="fc" id="L1124">            long o3MaxLag = SqlUtil.expectMicros(value, paramNamePosition);</span>
<span class="pc bpc" id="L1125" title="1 of 2 branches missed.">            if (o3MaxLag &lt; 0) {</span>
<span class="nc" id="L1126">                throw SqlException.$(paramNamePosition, &quot;o3MaxLag must be non negative&quot;);</span>
            }
<span class="fc" id="L1128">            return compiledQuery.ofAlter(alterOperationBuilder.ofSetO3MaxLag(tableNamePosition, tableToken, tableId, o3MaxLag).build());</span>
        } else {
<span class="fc" id="L1130">            throw SqlException.$(paramNamePosition, &quot;unknown parameter '&quot;).put(paramName).put('\'');</span>
        }
    }

    private void cancelTextImport(CopyModel model) throws SqlException {
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">        assert model.isCancel();</span>

<span class="fc" id="L1137">        final TextImportExecutionContext textImportExecutionContext = engine.getTextImportExecutionContext();</span>
<span class="fc" id="L1138">        final AtomicBooleanCircuitBreaker circuitBreaker = textImportExecutionContext.getCircuitBreaker();</span>

<span class="fc" id="L1140">        long inProgressImportId = textImportExecutionContext.getActiveImportId();</span>
        // The cancellation is based on the best effort, so we don't worry about potential races with imports.
<span class="fc bfc" id="L1142" title="All 2 branches covered.">        if (inProgressImportId == TextImportExecutionContext.INACTIVE) {</span>
<span class="fc" id="L1143">            throw SqlException.$(0, &quot;No active import to cancel.&quot;);</span>
        }
        long importId;
        try {
<span class="fc" id="L1147">            CharSequence idString = model.getTarget().token;</span>
<span class="fc" id="L1148">            int start = 0;</span>
<span class="fc" id="L1149">            int end = idString.length();</span>
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">            if (Chars.isQuoted(idString)) {</span>
<span class="fc" id="L1151">                start = 1;</span>
<span class="fc" id="L1152">                end--;</span>
            }
<span class="fc" id="L1154">            importId = Numbers.parseHexLong(idString, start, end);</span>
<span class="fc" id="L1155">        } catch (NumericException e) {</span>
<span class="fc" id="L1156">            throw SqlException.$(0, &quot;Provided id has invalid format.&quot;);</span>
<span class="fc" id="L1157">        }</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">        if (inProgressImportId == importId) {</span>
<span class="fc" id="L1159">            circuitBreaker.cancel();</span>
        } else {
<span class="fc" id="L1161">            throw SqlException.$(0, &quot;Active import has different id.&quot;);</span>
        }
<span class="fc" id="L1163">    }</span>

    private void clear() {
<span class="fc" id="L1166">        sqlNodePool.clear();</span>
<span class="fc" id="L1167">        characterStore.clear();</span>
<span class="fc" id="L1168">        queryColumnPool.clear();</span>
<span class="fc" id="L1169">        queryModelPool.clear();</span>
<span class="fc" id="L1170">        optimiser.clear();</span>
<span class="fc" id="L1171">        parser.clear();</span>
<span class="fc" id="L1172">        backupAgent.clear();</span>
<span class="fc" id="L1173">        alterOperationBuilder.clear();</span>
<span class="fc" id="L1174">        backupAgent.clear();</span>
<span class="fc" id="L1175">        functionParser.clear();</span>
<span class="fc" id="L1176">    }</span>

    private CompiledQuery compileBegin(SqlExecutionContext executionContext) {
<span class="fc" id="L1179">        return compiledQuery.ofBegin();</span>
    }

    private CompiledQuery compileCommit(SqlExecutionContext executionContext) {
<span class="fc" id="L1183">        return compiledQuery.ofCommit();</span>
    }

    private CompiledQuery compileDeallocate(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L1187">        CharSequence statementName = GenericLexer.unquote(expectToken(lexer, &quot;statement name&quot;));</span>
<span class="fc" id="L1188">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L1189" title="1 of 4 branches missed.">        if (tok != null &amp;&amp; !Chars.equals(tok, ';')) {</span>
<span class="fc" id="L1190">            throw SqlException.$(lexer.lastTokenPosition(), &quot;unexpected token [&quot;).put(tok).put(&quot;]&quot;);</span>
        }
<span class="fc" id="L1192">        return compiledQuery.ofDeallocate(statementName);</span>
    }

    private ExecutionModel compileExecutionModel(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L1196">        ExecutionModel model = parser.parse(lexer, executionContext);</span>

<span class="fc bfc" id="L1198" title="All 2 branches covered.">        if (ExecutionModel.EXPLAIN != model.getModelType()) {</span>
<span class="fc" id="L1199">            return compileExecutionModel0(executionContext, model);</span>
        } else {
<span class="fc" id="L1201">            ExplainModel explainModel = (ExplainModel) model;</span>
<span class="fc" id="L1202">            explainModel.setModel(compileExecutionModel0(executionContext, explainModel.getInnerExecutionModel()));</span>
<span class="fc" id="L1203">            return explainModel;</span>
        }
    }

    private ExecutionModel compileExecutionModel0(SqlExecutionContext executionContext, ExecutionModel model) throws SqlException {
<span class="fc bfc" id="L1208" title="All 4 branches covered.">        switch (model.getModelType()) {</span>
            case ExecutionModel.QUERY:
<span class="fc" id="L1210">                return optimiser.optimise((QueryModel) model, executionContext);</span>
            case ExecutionModel.INSERT:
<span class="fc" id="L1212">                InsertModel insertModel = (InsertModel) model;</span>
<span class="fc bfc" id="L1213" title="All 2 branches covered.">                if (insertModel.getQueryModel() != null) {</span>
<span class="fc" id="L1214">                    return validateAndOptimiseInsertAsSelect(insertModel, executionContext);</span>
                } else {
<span class="fc" id="L1216">                    return lightlyValidateInsertModel(insertModel);</span>
                }
            case ExecutionModel.UPDATE:
<span class="fc" id="L1219">                final QueryModel queryModel = (QueryModel) model;</span>
<span class="fc" id="L1220">                TableToken tableToken = executionContext.getTableToken(queryModel.getTableName());</span>
<span class="fc" id="L1221">                try (TableRecordMetadata metadata = executionContext.getMetadata(tableToken)) {</span>
<span class="fc" id="L1222">                    optimiser.optimiseUpdate(queryModel, executionContext, metadata);</span>
<span class="fc" id="L1223">                    return model;</span>
                }
            default:
<span class="fc" id="L1226">                return model;</span>
        }
    }

    private CompiledQuery compileInner(@NotNull SqlExecutionContext executionContext, CharSequence query) throws SqlException {
<span class="fc" id="L1231">        SqlExecutionCircuitBreaker circuitBreaker = executionContext.getCircuitBreaker();</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">        if (!circuitBreaker.isTimerSet()) {</span>
<span class="fc" id="L1233">            circuitBreaker.resetTimer();</span>
        }
<span class="fc" id="L1235">        final CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L1236" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L1237">            throw SqlException.$(0, &quot;empty query&quot;);</span>
        }

<span class="fc" id="L1240">        final KeywordBasedExecutor executor = keywordBasedExecutors.get(tok);</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">        final CompiledQuery cq = executor == null ? compileUsingModel(executionContext) : executor.execute(executionContext);</span>
<span class="fc" id="L1242">        final short type = cq.getType();</span>
<span class="fc bfc" id="L1243" title="All 6 branches covered.">        if ((type == CompiledQuery.ALTER || type == CompiledQuery.UPDATE) &amp;&amp; !executionContext.isWalApplication()) {</span>
<span class="fc" id="L1244">            cq.withSqlStatement(Chars.toString(query));</span>
        }
<span class="fc" id="L1246">        cq.withContext(executionContext);</span>
<span class="fc" id="L1247">        return cq;</span>
    }

    private CompiledQuery compileRollback(SqlExecutionContext executionContext) {
<span class="fc" id="L1251">        return compiledQuery.ofRollback();</span>
    }

    private CompiledQuery compileSet(SqlExecutionContext executionContext) {
<span class="fc" id="L1255">        return compiledQuery.ofSet();</span>
    }

    private CopyFactory compileTextImport(CopyModel model) throws SqlException {
<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">        assert !model.isCancel();</span>

<span class="fc" id="L1261">        final CharSequence tableName = GenericLexer.unquote(model.getTarget().token);</span>
<span class="fc" id="L1262">        final ExpressionNode fileNameNode = model.getFileName();</span>
<span class="pc bpc" id="L1263" title="1 of 2 branches missed.">        final CharSequence fileName = fileNameNode != null ? GenericLexer.assertNoDots(GenericLexer.unquote(fileNameNode.token), fileNameNode.position) : null;</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">        assert fileName != null;</span>

<span class="fc" id="L1266">        return new CopyFactory(</span>
                messageBus,
<span class="fc" id="L1268">                engine.getTextImportExecutionContext(),</span>
<span class="fc" id="L1269">                Chars.toString(tableName),</span>
<span class="fc" id="L1270">                Chars.toString(fileName),</span>
                model
        );
    }

    @NotNull
    private CompiledQuery compileUsingModel(SqlExecutionContext executionContext) throws SqlException {
        // This method will not populate sql cache directly;
        // factories are assumed to be non-reentrant and once
        // factory is out of this method the caller assumes
        // full ownership over it. In that however caller may
        // choose to return factory back to this or any other
        // instance of compiler for safekeeping

        // lexer would have parsed first token to determine direction of execution flow
<span class="fc" id="L1285">        lexer.unparseLast();</span>
<span class="fc" id="L1286">        codeGenerator.clear();</span>

<span class="fc" id="L1288">        final ExecutionModel executionModel = compileExecutionModel(executionContext);</span>
<span class="fc bfc" id="L1289" title="All 7 branches covered.">        switch (executionModel.getModelType()) {</span>
            case ExecutionModel.QUERY:
<span class="fc" id="L1291">                LOG.info().$(&quot;plan [q=`&quot;).$((QueryModel) executionModel).$(&quot;`, fd=&quot;).$(executionContext.getRequestFd()).$(']').$();</span>
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">                return compiledQuery.of(generate((QueryModel) executionModel, executionContext));</span>
            case ExecutionModel.CREATE_TABLE:
<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">                return createTableWithRetries(executionModel, executionContext);</span>
            case ExecutionModel.COPY:
<span class="fc" id="L1296">                return executeCopy(executionContext, (CopyModel) executionModel);</span>
            case ExecutionModel.RENAME_TABLE:
<span class="fc" id="L1298">                final RenameTableModel rtm = (RenameTableModel) executionModel;</span>
<span class="fc" id="L1299">                engine.rename(executionContext.getCairoSecurityContext(), path, mem, GenericLexer.unquote(rtm.getFrom().token), renamePath, GenericLexer.unquote(rtm.getTo().token));</span>
<span class="pc bpc" id="L1300" title="1 of 2 branches missed.">                return compiledQuery.ofRenameTable();</span>
            case ExecutionModel.UPDATE:
<span class="fc" id="L1302">                final QueryModel updateQueryModel = (QueryModel) executionModel;</span>
<span class="fc" id="L1303">                TableToken tableToken = executionContext.getTableToken(updateQueryModel.getTableName());</span>
<span class="fc" id="L1304">                try (TableRecordMetadata metadata = executionContext.getMetadata(tableToken)) {</span>
<span class="fc" id="L1305">                    final UpdateOperation updateOperation = generateUpdate(updateQueryModel, executionContext, metadata);</span>
<span class="pc bpc" id="L1306" title="1 of 2 branches missed.">                    return compiledQuery.ofUpdate(updateOperation);</span>
                }
            case ExecutionModel.EXPLAIN:
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">                return compiledQuery.ofExplain(generateExplain((ExplainModel) executionModel, executionContext));</span>
            default:
<span class="fc" id="L1311">                final InsertModel insertModel = (InsertModel) executionModel;</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">                if (insertModel.getQueryModel() != null) {</span>
<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">                    return executeWithRetries(</span>
                            insertAsSelectMethod,
                            executionModel,
<span class="fc" id="L1316">                            configuration.getCreateAsSelectRetryCount(),</span>
                            executionContext
                    );
                } else {
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">                    return insert(executionModel, executionContext);</span>
                }
        }
    }

    private long copyOrdered(
            TableWriterAPI writer,
            RecordMetadata metadata,
            RecordCursor cursor,
            RecordToRowCopier copier,
            int cursorTimestampIndex,
            SqlExecutionCircuitBreaker circuitBreaker
    ) {
        long rowCount;

<span class="fc bfc" id="L1335" title="All 2 branches covered.">        if (ColumnType.isSymbolOrString(metadata.getColumnType(cursorTimestampIndex))) {</span>
<span class="fc" id="L1336">            rowCount = copyOrderedStrTimestamp(writer, cursor, copier, cursorTimestampIndex, circuitBreaker);</span>
        } else {
<span class="fc" id="L1338">            rowCount = copyOrdered0(writer, cursor, copier, cursorTimestampIndex, circuitBreaker);</span>
        }
<span class="fc" id="L1340">        writer.commit();</span>

<span class="fc" id="L1342">        return rowCount;</span>
    }

    private long copyOrdered0(TableWriterAPI writer,
                              RecordCursor cursor,
                              RecordToRowCopier copier,
                              int cursorTimestampIndex,
                              SqlExecutionCircuitBreaker circuitBreaker) {
<span class="fc" id="L1350">        long rowCount = 0;</span>
<span class="fc" id="L1351">        final Record record = cursor.getRecord();</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">        while (cursor.hasNext()) {</span>
<span class="fc" id="L1353">            circuitBreaker.statefulThrowExceptionIfTripped();</span>
<span class="fc" id="L1354">            TableWriter.Row row = writer.newRow(record.getTimestamp(cursorTimestampIndex));</span>
<span class="fc" id="L1355">            copier.copy(record, row);</span>
<span class="fc" id="L1356">            row.append();</span>
<span class="fc" id="L1357">            rowCount++;</span>
<span class="fc" id="L1358">        }</span>

<span class="fc" id="L1360">        return rowCount;</span>
    }

    private long copyOrderedBatched(
            TableWriterAPI writer,
            RecordMetadata metadata,
            RecordCursor cursor,
            RecordToRowCopier copier,
            int cursorTimestampIndex,
            long batchSize,
            long o3MaxLag,
            SqlExecutionCircuitBreaker circuitBreaker
    ) {
        long rowCount;
<span class="fc bfc" id="L1374" title="All 2 branches covered.">        if (ColumnType.isSymbolOrString(metadata.getColumnType(cursorTimestampIndex))) {</span>
<span class="nc" id="L1375">            rowCount = copyOrderedBatchedStrTimestamp(writer, cursor, copier, cursorTimestampIndex, batchSize, o3MaxLag, circuitBreaker);</span>
        } else {
<span class="fc" id="L1377">            rowCount = copyOrderedBatched0(writer, cursor, copier, cursorTimestampIndex, batchSize, o3MaxLag, circuitBreaker);</span>
        }
<span class="fc" id="L1379">        writer.commit();</span>

<span class="fc" id="L1381">        return rowCount;</span>
    }

    //returns number of copied rows
    private long copyOrderedBatched0(
            TableWriterAPI writer,
            RecordCursor cursor,
            RecordToRowCopier copier,
            int cursorTimestampIndex,
            long batchSize,
            long o3MaxLag,
            SqlExecutionCircuitBreaker circuitBreaker
    ) {
<span class="fc" id="L1394">        long deadline = batchSize;</span>
<span class="fc" id="L1395">        long rowCount = 0;</span>
<span class="fc" id="L1396">        final Record record = cursor.getRecord();</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">        while (cursor.hasNext()) {</span>
<span class="fc" id="L1398">            circuitBreaker.statefulThrowExceptionIfTripped();</span>
<span class="fc" id="L1399">            TableWriter.Row row = writer.newRow(record.getTimestamp(cursorTimestampIndex));</span>
<span class="fc" id="L1400">            copier.copy(record, row);</span>
<span class="fc" id="L1401">            row.append();</span>
<span class="fc bfc" id="L1402" title="All 2 branches covered.">            if (++rowCount &gt; deadline) {</span>
<span class="fc" id="L1403">                writer.ic(o3MaxLag);</span>
<span class="fc" id="L1404">                deadline = rowCount + batchSize;</span>
            }
<span class="fc" id="L1406">        }</span>

<span class="fc" id="L1408">        return rowCount;</span>
    }

    //returns number of copied rows
    private long copyOrderedBatchedStrTimestamp(
            TableWriterAPI writer,
            RecordCursor cursor,
            RecordToRowCopier copier,
            int cursorTimestampIndex,
            long batchSize,
            long o3MaxLag,
            SqlExecutionCircuitBreaker circuitBreaker
    ) {
<span class="fc" id="L1421">        long deadline = batchSize;</span>
<span class="fc" id="L1422">        long rowCount = 0;</span>
<span class="fc" id="L1423">        final Record record = cursor.getRecord();</span>
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">        while (cursor.hasNext()) {</span>
<span class="nc" id="L1425">            circuitBreaker.statefulThrowExceptionIfTripped();</span>
<span class="nc" id="L1426">            CharSequence str = record.getStr(cursorTimestampIndex);</span>
            // It's allowed to insert ISO formatted string to timestamp column
<span class="nc" id="L1428">            TableWriter.Row row = writer.newRow(SqlUtil.parseFloorPartialTimestamp(str, -1, ColumnType.TIMESTAMP));</span>
<span class="nc" id="L1429">            copier.copy(record, row);</span>
<span class="nc" id="L1430">            row.append();</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">            if (++rowCount &gt; deadline) {</span>
<span class="nc" id="L1432">                writer.ic(o3MaxLag);</span>
<span class="nc" id="L1433">                deadline = rowCount + batchSize;</span>
            }
<span class="nc" id="L1435">        }</span>

<span class="nc" id="L1437">        return rowCount;</span>
    }

    //returns number of copied rows
    private long copyOrderedStrTimestamp(
            TableWriterAPI writer,
            RecordCursor cursor,
            RecordToRowCopier copier,
            int cursorTimestampIndex,
            SqlExecutionCircuitBreaker circuitBreaker
    ) {
<span class="fc" id="L1448">        long rowCount = 0;</span>
<span class="fc" id="L1449">        final Record record = cursor.getRecord();</span>
<span class="fc bfc" id="L1450" title="All 2 branches covered.">        while (cursor.hasNext()) {</span>
<span class="fc" id="L1451">            circuitBreaker.statefulThrowExceptionIfTripped();</span>
<span class="fc" id="L1452">            final CharSequence str = record.getStr(cursorTimestampIndex);</span>
            // It's allowed to insert ISO formatted string to timestamp column
<span class="fc" id="L1454">            TableWriter.Row row = writer.newRow(SqlUtil.implicitCastStrAsTimestamp(str));</span>
<span class="fc" id="L1455">            copier.copy(record, row);</span>
<span class="fc" id="L1456">            row.append();</span>
<span class="fc" id="L1457">            rowCount++;</span>
<span class="fc" id="L1458">        }</span>

<span class="fc" id="L1460">        return rowCount;</span>
    }

    /*
     * Returns number of copied rows.
     */
    private long copyTableData(
            RecordCursor cursor,
            RecordMetadata metadata,
            TableWriterAPI writer,
            RecordMetadata writerMetadata,
            RecordToRowCopier recordToRowCopier,
            SqlExecutionCircuitBreaker circuitBreaker
    ) {
<span class="fc" id="L1474">        int timestampIndex = writerMetadata.getTimestampIndex();</span>
<span class="fc bfc" id="L1475" title="All 2 branches covered.">        if (timestampIndex == -1) {</span>
<span class="fc" id="L1476">            return copyUnordered(cursor, writer, recordToRowCopier, circuitBreaker);</span>
        } else {
<span class="fc" id="L1478">            return copyOrdered(writer, metadata, cursor, recordToRowCopier, timestampIndex, circuitBreaker);</span>
        }
    }

    /**
     * Sets insertCount to number of copied rows.
     */
    private void copyTableDataAndUnlock(
            CairoSecurityContext securityContext,
            TableToken tableToken,
            boolean isWalEnabled,
            RecordCursor cursor,
            RecordMetadata cursorMetadata,
            int position,
            SqlExecutionCircuitBreaker circuitBreaker
    ) throws SqlException {
<span class="fc" id="L1494">        TableWriterAPI writerAPI = null;</span>
<span class="fc" id="L1495">        TableWriter writer = null;</span>

        try {
<span class="fc bfc" id="L1498" title="All 2 branches covered.">            if (!isWalEnabled) {</span>
<span class="fc" id="L1499">                writerAPI = writer = new TableWriter(</span>
                        configuration,
                        tableToken,
                        messageBus,
                        null,
                        false,
                        DefaultLifecycleManager.INSTANCE,
<span class="fc" id="L1506">                        configuration.getRoot(),</span>
<span class="fc" id="L1507">                        engine.getMetrics());</span>
            } else {
<span class="fc" id="L1509">                writerAPI = engine.getTableWriterAPI(securityContext, tableToken, &quot;create as select&quot;);</span>
            }

<span class="fc" id="L1512">            RecordMetadata writerMetadata = writerAPI.getMetadata();</span>
<span class="fc" id="L1513">            entityColumnFilter.of(writerMetadata.getColumnCount());</span>
<span class="fc" id="L1514">            this.insertCount = copyTableData(</span>
                    cursor,
                    cursorMetadata,
                    writerAPI,
                    writerMetadata,
<span class="fc" id="L1519">                    RecordToRowCopierUtils.generateCopier(</span>
                            asm,
                            cursorMetadata,
                            writerMetadata,
                            entityColumnFilter
                    ),
                    circuitBreaker
            );
<span class="fc" id="L1527">        } catch (CairoException e) {</span>
<span class="fc" id="L1528">            LOG.error().$(&quot;could not create table [error=&quot;).$((Throwable) e).I$();</span>
            // Close writer, directory will be removed
<span class="fc" id="L1530">            writerAPI = Misc.free(writerAPI);</span>
<span class="fc" id="L1531">            writer = null;</span>
<span class="fc bfc" id="L1532" title="All 2 branches covered.">            if (e.isInterruption()) {</span>
<span class="fc" id="L1533">                throw e;</span>
            }
<span class="fc" id="L1535">            throw SqlException.$(position, &quot;Could not create table. See log for details.&quot;);</span>
        } finally {
<span class="fc bfc" id="L1537" title="All 2 branches covered.">            if (isWalEnabled) {</span>
<span class="fc" id="L1538">                Misc.free(writerAPI);</span>
            } else {
<span class="fc" id="L1540">                engine.unlock(securityContext, tableToken, writer, false);</span>
            }
        }
<span class="fc" id="L1543">    }</span>

    private void copyTableReaderMetadataToCreateTableModel(SqlExecutionContext executionContext, CreateTableModel model) throws SqlException {
<span class="fc" id="L1546">        ExpressionNode likeTableName = model.getLikeTableName();</span>
<span class="fc" id="L1547">        CharSequence likeTableNameToken = likeTableName.token;</span>
<span class="fc" id="L1548">        TableToken tableToken = executionContext.getTableToken(likeTableNameToken);</span>
<span class="fc" id="L1549">        try (TableReader rdr = executionContext.getReader(tableToken)) {</span>
<span class="fc" id="L1550">            model.setO3MaxLag(rdr.getO3MaxLag());</span>
<span class="fc" id="L1551">            model.setMaxUncommittedRows(rdr.getMaxUncommittedRows());</span>
<span class="fc" id="L1552">            TableReaderMetadata rdrMetadata = rdr.getMetadata();</span>
<span class="fc bfc" id="L1553" title="All 2 branches covered.">            for (int i = 0; i &lt; rdrMetadata.getColumnCount(); i++) {</span>
<span class="fc" id="L1554">                int columnType = rdrMetadata.getColumnType(i);</span>
<span class="fc" id="L1555">                boolean isSymbol = ColumnType.isSymbol(columnType);</span>
<span class="fc bfc" id="L1556" title="All 2 branches covered.">                int symbolCapacity = isSymbol ? rdr.getSymbolMapReader(i).getSymbolCapacity() : configuration.getDefaultSymbolCapacity();</span>
<span class="fc" id="L1557">                model.addColumn(rdrMetadata.getColumnName(i), columnType, symbolCapacity);</span>
<span class="fc bfc" id="L1558" title="All 2 branches covered.">                if (isSymbol) {</span>
<span class="fc" id="L1559">                    model.cached(rdr.getSymbolMapReader(i).isCached());</span>
                }
<span class="fc" id="L1561">                model.setIndexFlags(rdrMetadata.isColumnIndexed(i), rdrMetadata.getIndexValueBlockCapacity(i));</span>
            }
<span class="fc" id="L1563">            model.setPartitionBy(SqlUtil.nextLiteral(sqlNodePool, PartitionBy.toString(rdr.getPartitionedBy()), 0));</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">            if (rdrMetadata.getTimestampIndex() != -1) {</span>
<span class="fc" id="L1565">                model.setTimestamp(SqlUtil.nextLiteral(sqlNodePool, rdrMetadata.getColumnName(rdrMetadata.getTimestampIndex()), 0));</span>
            }
<span class="pc bpc" id="L1567" title="1 of 4 branches missed.">            model.setWalEnabled(configuration.isWalSupported() &amp;&amp; rdrMetadata.isWalEnabled());</span>
        }
<span class="fc" id="L1569">        model.setLikeTableName(null); // resetting like table name as the metadata is copied already at this point.</span>
<span class="fc" id="L1570">    }</span>

    /**
     * Returns number of copied rows.
     */
    private long copyUnordered(RecordCursor cursor, TableWriterAPI writer, RecordToRowCopier copier, SqlExecutionCircuitBreaker circuitBreaker) {
<span class="fc" id="L1576">        long rowCount = 0;</span>
<span class="fc" id="L1577">        final Record record = cursor.getRecord();</span>
<span class="fc bfc" id="L1578" title="All 2 branches covered.">        while (cursor.hasNext()) {</span>
<span class="fc" id="L1579">            circuitBreaker.statefulThrowExceptionIfTripped();</span>
<span class="fc" id="L1580">            TableWriter.Row row = writer.newRow();</span>
<span class="fc" id="L1581">            copier.copy(record, row);</span>
<span class="fc" id="L1582">            row.append();</span>
<span class="fc" id="L1583">            rowCount++;</span>
<span class="fc" id="L1584">        }</span>
<span class="fc" id="L1585">        writer.commit();</span>

<span class="fc" id="L1587">        return rowCount;</span>
    }

    private CompiledQuery createTable(final ExecutionModel model, SqlExecutionContext executionContext) throws
            SqlException {
<span class="fc" id="L1592">        final CreateTableModel createTableModel = (CreateTableModel) model;</span>
<span class="fc" id="L1593">        final ExpressionNode name = createTableModel.getName();</span>
<span class="fc" id="L1594">        TableToken tableToken = executionContext.getTableTokenIfExists(name.token);</span>

        // Fast path for CREATE TABLE IF NOT EXISTS in scenario when the table already exists
<span class="fc" id="L1597">        int status = executionContext.getStatus(path, tableToken);</span>
<span class="fc bfc" id="L1598" title="All 4 branches covered.">        if (createTableModel.isIgnoreIfExists() &amp;&amp; status != TableUtils.TABLE_DOES_NOT_EXIST) {</span>
<span class="fc" id="L1599">            return compiledQuery.ofCreateTable();</span>
        }

<span class="fc" id="L1602">        this.insertCount = -1;</span>
<span class="fc bfc" id="L1603" title="All 2 branches covered.">        if (status != TableUtils.TABLE_DOES_NOT_EXIST) {</span>
<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">            if (createTableModel.isIgnoreIfExists()) {</span>
<span class="nc" id="L1605">                return compiledQuery.ofCreateTable();</span>
            }
<span class="fc" id="L1607">            throw SqlException.$(name.position, &quot;table already exists&quot;);</span>
        }

<span class="fc bfc" id="L1610" title="All 2 branches covered.">        if (createTableModel.getQueryModel() == null) {</span>
<span class="fc" id="L1611">            executionContext.getCairoSecurityContext().checkWritePermission();</span>
            try {
<span class="fc bfc" id="L1613" title="All 2 branches covered.">                if (createTableModel.getLikeTableName() != null) {</span>
<span class="fc" id="L1614">                    copyTableReaderMetadataToCreateTableModel(executionContext, createTableModel);</span>
                }
<span class="fc" id="L1616">                engine.createTable(executionContext.getCairoSecurityContext(), mem, path, createTableModel.isIgnoreIfExists(), createTableModel, false);</span>
<span class="fc" id="L1617">            } catch (EntryUnavailableException e) {</span>
<span class="fc" id="L1618">                throw SqlException.$(name.position, &quot;table already exists&quot;);</span>
<span class="fc" id="L1619">            } catch (CairoException e) {</span>
<span class="fc" id="L1620">                LOG.error().$(&quot;could not create table [error=&quot;).$((Throwable) e).I$();</span>
<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">                if (e.isInterruption()) {</span>
<span class="nc" id="L1622">                    throw e;</span>
                }
<span class="fc" id="L1624">                throw SqlException.$(name.position, &quot;Could not create table, &quot;).put(e.getFlyweightMessage());</span>
<span class="fc" id="L1625">            }</span>
        } else {
<span class="fc" id="L1627">            createTableFromCursor(createTableModel, executionContext, name.position);</span>
        }

<span class="fc bfc" id="L1630" title="All 2 branches covered.">        if (createTableModel.getQueryModel() == null) {</span>
<span class="fc" id="L1631">            return compiledQuery.ofCreateTable();</span>
        } else {
<span class="fc" id="L1633">            return compiledQuery.ofCreateTableAsSelect(insertCount);</span>
        }
    }

    private void createTableFromCursor(CreateTableModel model, SqlExecutionContext executionContext, int position) throws
            SqlException {
        try (
<span class="fc" id="L1640">                final RecordCursorFactory factory = generate(model.getQueryModel(), executionContext);</span>
<span class="fc" id="L1641">                final RecordCursor cursor = factory.getCursor(executionContext)</span>
        ) {
<span class="fc" id="L1643">            typeCast.clear();</span>
<span class="fc" id="L1644">            final RecordMetadata metadata = factory.getMetadata();</span>
<span class="fc" id="L1645">            validateTableModelAndCreateTypeCast(model, metadata, typeCast);</span>
<span class="fc bfc" id="L1646" title="All 2 branches covered.">            boolean keepLock = !model.isWalEnabled();</span>

<span class="fc" id="L1648">            engine.createTable(</span>
<span class="fc" id="L1649">                    executionContext.getCairoSecurityContext(),</span>
                    mem,
                    path,
                    false,
<span class="fc" id="L1653">                    tableStructureAdapter.of(model, metadata, typeCast),</span>
                    keepLock
            );

<span class="fc" id="L1657">            SqlExecutionCircuitBreaker circuitBreaker = executionContext.getCircuitBreaker();</span>
            try {
<span class="fc" id="L1659">                TableToken tableToken = executionContext.getTableToken(model.getName().token);</span>
<span class="fc" id="L1660">                copyTableDataAndUnlock(executionContext.getCairoSecurityContext(), tableToken, model.isWalEnabled(), cursor, metadata, position, circuitBreaker);</span>
<span class="fc" id="L1661">            } catch (CairoException e) {</span>
<span class="fc" id="L1662">                LOG.error().$(e.getFlyweightMessage()).$(&quot; [errno=&quot;).$(e.getErrno()).$(']').$();</span>
<span class="pc bpc" id="L1663" title="1 of 2 branches missed.">                if (removeTableDirectory(model)) {</span>
<span class="fc" id="L1664">                    throw e;</span>
                }
<span class="nc" id="L1666">                throw SqlException.$(0, &quot;Concurrent modification could not be handled. Failed to clean up. See log for more details.&quot;);</span>
<span class="fc" id="L1667">            }</span>
        }
<span class="fc" id="L1669">    }</span>

    /**
     * Creates new table.
     * &lt;p&gt;
     * Table name must not exist. Existence check relies on directory existence followed by attempt to clarify what
     * that directory is. Sometimes it can be just empty directory, which prevents new table from being created.
     * &lt;p&gt;
     * Table name can be utf8 encoded but must not contain '.' (dot). Dot is used to separate table and field name,
     * where table is uses as an alias.
     * &lt;p&gt;
     * Creating table from column definition looks like:
     * &lt;code&gt;
     * create table x (column_name column_type, ...) [timestamp(column_name)] [partition by ...]
     * &lt;/code&gt;
     * For non-partitioned table partition by value would be NONE. For any other type of partition timestamp
     * has to be defined as reference to TIMESTAMP (type) column.
     *
     * @param executionModel   created from parsed sql.
     * @param executionContext provides access to bind variables and authorization module
     * @throws SqlException contains text of error and error position in SQL text.
     */
    private CompiledQuery createTableWithRetries(
            ExecutionModel executionModel,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L1695">        return executeWithRetries(createTableMethod, executionModel, configuration.getCreateAsSelectRetryCount(), executionContext);</span>
    }

    private CompiledQuery dropTable(SqlExecutionContext executionContext) throws SqlException {
        // expected syntax: DROP TABLE [ IF EXISTS ] name [;]
<span class="fc" id="L1700">        expectKeyword(lexer, &quot;table&quot;);</span>
<span class="fc" id="L1701">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L1703">            throw SqlException.$(lexer.lastTokenPosition(), &quot;expected [if exists] table-name&quot;);</span>
        }
<span class="fc" id="L1705">        boolean hasIfExists = false;</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">        if (SqlKeywords.isIfKeyword(tok)) {</span>
<span class="fc" id="L1707">            tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L1708" title="1 of 4 branches missed.">            if (tok == null || !SqlKeywords.isExistsKeyword(tok)) {</span>
<span class="fc" id="L1709">                throw SqlException.$(lexer.lastTokenPosition(), &quot;expected exists&quot;);</span>
            }
<span class="fc" id="L1711">            hasIfExists = true;</span>
        } else {
<span class="fc" id="L1713">            lexer.unparseLast(); // tok has table name</span>
        }
<span class="fc" id="L1715">        final int tableNamePosition = lexer.getPosition();</span>
<span class="fc" id="L1716">        CharSequence tableName = GenericLexer.unquote(expectToken(lexer, &quot;table name&quot;));</span>
<span class="fc" id="L1717">        TableToken tableToken = executionContext.getTableTokenIfExists(tableName);</span>

<span class="fc" id="L1719">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L1720" title="All 4 branches covered.">        if (tok != null &amp;&amp; !Chars.equals(tok, ';')) {</span>
<span class="fc" id="L1721">            throw SqlException.$(lexer.lastTokenPosition(), &quot;unexpected token [&quot;).put(tok).put(&quot;]&quot;);</span>
        }
<span class="fc bfc" id="L1723" title="All 2 branches covered.">        if (executionContext.getStatus(path, tableToken) != TableUtils.TABLE_EXISTS) {</span>
<span class="fc bfc" id="L1724" title="All 2 branches covered.">            if (hasIfExists) {</span>
<span class="fc" id="L1725">                return compiledQuery.ofDrop();</span>
            }
<span class="fc" id="L1727">            throw SqlException.$(tableNamePosition, &quot;table does not exist [table=&quot;).put(tableName).put(']');</span>
        }
<span class="fc" id="L1729">        engine.drop(executionContext.getCairoSecurityContext(), path, tableToken);</span>
<span class="fc" id="L1730">        return compiledQuery.ofDrop();</span>
    }

    @NotNull
    private CompiledQuery executeCopy(SqlExecutionContext executionContext, CopyModel executionModel) throws SqlException {
<span class="fc" id="L1735">        executionContext.getCairoSecurityContext().checkWritePermission();</span>
<span class="pc bpc" id="L1736" title="1 of 4 branches missed.">        if (!executionModel.isCancel() &amp;&amp; Chars.equalsLowerCaseAscii(executionModel.getFileName().token, &quot;stdin&quot;)) {</span>
            // no-op implementation
<span class="nc" id="L1738">            setupTextLoaderFromModel(executionModel);</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">            return compiledQuery.ofCopyRemote(textLoader);</span>
        }
<span class="fc" id="L1741">        RecordCursorFactory copyFactory = executeCopy0(executionModel);</span>
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">        return compiledQuery.ofCopyLocal(copyFactory);</span>
    }

    @Nullable
    private RecordCursorFactory executeCopy0(CopyModel model) throws SqlException {
        try {
<span class="fc bfc" id="L1748" title="All 2 branches covered.">            if (model.isCancel()) {</span>
<span class="fc" id="L1749">                cancelTextImport(model);</span>
<span class="fc" id="L1750">                return null;</span>
            } else {
<span class="fc bfc" id="L1752" title="All 2 branches covered.">                if (model.getTimestampColumnName() == null &amp;&amp;</span>
<span class="pc bpc" id="L1753" title="1 of 4 branches missed.">                        ((model.getPartitionBy() != -1 &amp;&amp; model.getPartitionBy() != PartitionBy.NONE))) {</span>
<span class="nc" id="L1754">                    throw SqlException.$(-1, &quot;invalid option used for import without a designated timestamp (format or partition by)&quot;);</span>
                }
<span class="fc bfc" id="L1756" title="All 2 branches covered.">                if (model.getDelimiter() &lt; 0) {</span>
<span class="fc" id="L1757">                    model.setDelimiter((byte) ',');</span>
                }
<span class="fc" id="L1759">                return compileTextImport(model);</span>
            }
<span class="nc" id="L1761">        } catch (TextImportException | TextException e) {</span>
<span class="nc" id="L1762">            LOG.error().$((Throwable) e).$();</span>
<span class="nc" id="L1763">            throw SqlException.$(0, e.getMessage());</span>
        }
    }

    private CompiledQuery executeWithRetries(
            ExecutableMethod method,
            ExecutionModel executionModel,
            int retries,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L1773">        int attemptsLeft = retries;</span>
        do {
            try {
<span class="fc" id="L1776">                return method.execute(executionModel, executionContext);</span>
<span class="fc" id="L1777">            } catch (TableReferenceOutOfDateException e) {</span>
<span class="fc" id="L1778">                attemptsLeft--;</span>
<span class="fc" id="L1779">                clear();</span>
<span class="fc" id="L1780">                lexer.restart();</span>
<span class="fc" id="L1781">                executionModel = compileExecutionModel(executionContext);</span>
            }
<span class="fc bfc" id="L1783" title="All 2 branches covered.">        } while (attemptsLeft &gt; 0);</span>

<span class="fc" id="L1785">        throw SqlException.position(0).put(&quot;underlying cursor is extremely volatile&quot;);</span>
    }

    private int filterPartitions(
            Function function,
            int functionPosition,
            TableReader reader,
            AlterOperationBuilder changePartitionStatement
    ) {
<span class="fc" id="L1794">        int affectedPartitions = 0;</span>
        // Iterate partitions in descending order so if folders are missing on disk
        // removePartition does not fail to determine next minTimestamp
<span class="fc" id="L1797">        final int partitionCount = reader.getPartitionCount();</span>
<span class="fc bfc" id="L1798" title="All 2 branches covered.">        if (partitionCount &gt; 0) { // table may be empty</span>
<span class="fc bfc" id="L1799" title="All 2 branches covered.">            for (int i = partitionCount - 2; i &gt; -1; i--) {</span>
<span class="fc" id="L1800">                long partitionTimestamp = reader.getPartitionTimestampByIndex(i);</span>
<span class="fc" id="L1801">                partitionFunctionRec.setTimestamp(partitionTimestamp);</span>
<span class="fc bfc" id="L1802" title="All 2 branches covered.">                if (function.getBool(partitionFunctionRec)) {</span>
<span class="fc" id="L1803">                    changePartitionStatement.addPartitionToList(partitionTimestamp, functionPosition);</span>
<span class="fc" id="L1804">                    affectedPartitions++;</span>
                }
            }

            // do action on last partition at the end, it's more expensive than others
<span class="fc" id="L1809">            long partitionTimestamp = reader.getPartitionTimestampByIndex(partitionCount - 1);</span>
<span class="fc" id="L1810">            partitionFunctionRec.setTimestamp(partitionTimestamp);</span>
<span class="fc bfc" id="L1811" title="All 2 branches covered.">            if (function.getBool(partitionFunctionRec)) {</span>
<span class="fc" id="L1812">                changePartitionStatement.addPartitionToList(partitionTimestamp, functionPosition);</span>
<span class="fc" id="L1813">                affectedPartitions++;</span>
            }
        }
<span class="fc" id="L1816">        return affectedPartitions;</span>
    }

    private RecordCursorFactory generateExplain(ExplainModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc bfc" id="L1820" title="All 2 branches covered.">        if (model.getInnerExecutionModel().getModelType() == ExecutionModel.UPDATE) {</span>
<span class="fc" id="L1821">            QueryModel updateQueryModel = model.getInnerExecutionModel().getQueryModel();</span>
<span class="fc" id="L1822">            final QueryModel selectQueryModel = updateQueryModel.getNestedModel();</span>
<span class="fc" id="L1823">            final RecordCursorFactory recordCursorFactory = prepareForUpdate(</span>
<span class="fc" id="L1824">                    updateQueryModel.getUpdateTableToken(),</span>
                    selectQueryModel,
                    updateQueryModel,
                    executionContext
            );

<span class="fc" id="L1830">            return codeGenerator.generateExplain(updateQueryModel, recordCursorFactory, model.getFormat());</span>
        } else {
<span class="fc" id="L1832">            return codeGenerator.generateExplain(model, executionContext);</span>
        }
    }

    private int getNextValidTokenPosition() {
<span class="fc bfc" id="L1837" title="All 2 branches covered.">        while (lexer.hasNext()) {</span>
<span class="fc" id="L1838">            CharSequence token = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L1839" title="All 2 branches covered.">            if (token == null) {</span>
<span class="fc" id="L1840">                return -1;</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">            } else if (!isSemicolon(token)) {</span>
<span class="fc" id="L1842">                lexer.unparseLast();</span>
<span class="fc" id="L1843">                return lexer.lastTokenPosition();</span>
            }
<span class="fc" id="L1845">        }</span>

<span class="fc" id="L1847">        return -1;</span>
    }

    private int goToQueryEnd() {
        CharSequence token;
<span class="fc" id="L1852">        lexer.unparseLast();</span>
<span class="fc bfc" id="L1853" title="All 2 branches covered.">        while (lexer.hasNext()) {</span>
<span class="fc" id="L1854">            token = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L1855" title="1 of 4 branches missed.">            if (token == null || isSemicolon(token)) {</span>
<span class="fc" id="L1856">                break;</span>
            }
        }

<span class="fc" id="L1860">        return lexer.getPosition();</span>
    }

    private CompiledQuery insert(ExecutionModel executionModel, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L1864">        final InsertModel model = (InsertModel) executionModel;</span>
<span class="fc" id="L1865">        final ExpressionNode tableNameExpr = model.getTableNameExpr();</span>
<span class="fc" id="L1866">        ObjList&lt;Function&gt; valueFunctions = null;</span>
<span class="fc" id="L1867">        TableToken token = tableExistsOrFail(tableNameExpr.position, tableNameExpr.token, executionContext);</span>

<span class="fc" id="L1869">        try (TableRecordMetadata metadata = engine.getMetadata(</span>
<span class="fc" id="L1870">                executionContext.getCairoSecurityContext(),</span>
                token
        )) {
<span class="fc" id="L1873">            final long structureVersion = metadata.getStructureVersion();</span>
<span class="fc" id="L1874">            final InsertOperationImpl insertOperation = new InsertOperationImpl(engine, metadata.getTableToken(), structureVersion);</span>
<span class="fc" id="L1875">            final int metadataTimestampIndex = metadata.getTimestampIndex();</span>
<span class="fc" id="L1876">            final ObjList&lt;CharSequence&gt; columnNameList = model.getColumnNameList();</span>
<span class="fc" id="L1877">            final int columnSetSize = columnNameList.size();</span>
<span class="fc bfc" id="L1878" title="All 2 branches covered.">            for (int tupleIndex = 0, n = model.getRowTupleCount(); tupleIndex &lt; n; tupleIndex++) {</span>
<span class="fc" id="L1879">                Function timestampFunction = null;</span>
<span class="fc" id="L1880">                listColumnFilter.clear();</span>
<span class="fc bfc" id="L1881" title="All 2 branches covered.">                if (columnSetSize &gt; 0) {</span>
<span class="fc" id="L1882">                    valueFunctions = new ObjList&lt;&gt;(columnSetSize);</span>
<span class="fc bfc" id="L1883" title="All 2 branches covered.">                    for (int i = 0; i &lt; columnSetSize; i++) {</span>
<span class="fc" id="L1884">                        int metadataColumnIndex = metadata.getColumnIndexQuiet(columnNameList.getQuick(i));</span>
<span class="fc bfc" id="L1885" title="All 2 branches covered.">                        if (metadataColumnIndex &gt; -1) {</span>
<span class="fc" id="L1886">                            final ExpressionNode node = model.getRowTupleValues(tupleIndex).getQuick(i);</span>
<span class="fc" id="L1887">                            final Function function = functionParser.parseFunction(</span>
                                    node,
                                    EmptyRecordMetadata.INSTANCE,
                                    executionContext
                            );

<span class="fc" id="L1893">                            insertValidateFunctionAndAddToList(</span>
                                    model,
                                    tupleIndex,
                                    valueFunctions,
                                    metadata,
                                    metadataTimestampIndex,
                                    i,
                                    metadataColumnIndex,
                                    function,
                                    node.position,
<span class="fc" id="L1903">                                    executionContext.getBindVariableService()</span>
                            );

<span class="fc bfc" id="L1906" title="All 2 branches covered.">                            if (metadataTimestampIndex == metadataColumnIndex) {</span>
<span class="fc" id="L1907">                                timestampFunction = function;</span>
                            }

<span class="fc" id="L1910">                        } else {</span>
<span class="fc" id="L1911">                            throw SqlException.invalidColumn(model.getColumnPosition(i), columnNameList.getQuick(i));</span>
                        }
                    }
                } else {
<span class="fc" id="L1915">                    final int columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L1916">                    final ObjList&lt;ExpressionNode&gt; values = model.getRowTupleValues(tupleIndex);</span>
<span class="fc" id="L1917">                    final int valueCount = values.size();</span>
<span class="fc bfc" id="L1918" title="All 2 branches covered.">                    if (columnCount != valueCount) {</span>
<span class="fc" id="L1919">                        throw SqlException.$(</span>
<span class="fc" id="L1920">                                        model.getEndOfRowTupleValuesPosition(tupleIndex),</span>
<span class="fc" id="L1921">                                        &quot;row value count does not match column count [expected=&quot;).put(columnCount).put(&quot;, actual=&quot;).put(values.size())</span>
<span class="fc" id="L1922">                                .put(&quot;, tuple=&quot;).put(tupleIndex + 1).put(']');</span>
                    }
<span class="fc" id="L1924">                    valueFunctions = new ObjList&lt;&gt;(columnCount);</span>

<span class="fc bfc" id="L1926" title="All 2 branches covered.">                    for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1927">                        final ExpressionNode node = values.getQuick(i);</span>

<span class="fc" id="L1929">                        Function function = functionParser.parseFunction(node, EmptyRecordMetadata.INSTANCE, executionContext);</span>
<span class="fc" id="L1930">                        insertValidateFunctionAndAddToList(</span>
                                model,
                                tupleIndex,
                                valueFunctions,
                                metadata,
                                metadataTimestampIndex,
                                i,
                                i,
                                function,
                                node.position,
<span class="fc" id="L1940">                                executionContext.getBindVariableService()</span>
                        );

<span class="fc bfc" id="L1943" title="All 2 branches covered.">                        if (metadataTimestampIndex == i) {</span>
<span class="fc" id="L1944">                            timestampFunction = function;</span>
                        }
                    }
                }

                // validate timestamp
<span class="pc bpc" id="L1950" title="1 of 6 branches missed.">                if (metadataTimestampIndex &gt; -1 &amp;&amp; (timestampFunction == null || ColumnType.isNull(timestampFunction.getType()))) {</span>
<span class="fc" id="L1951">                    throw SqlException.$(0, &quot;insert statement must populate timestamp&quot;);</span>
                }

<span class="fc" id="L1954">                VirtualRecord record = new VirtualRecord(valueFunctions);</span>
<span class="fc" id="L1955">                RecordToRowCopier copier = RecordToRowCopierUtils.generateCopier(asm, record, metadata, listColumnFilter);</span>
<span class="fc" id="L1956">                insertOperation.addInsertRow(new InsertRowImpl(record, copier, timestampFunction, tupleIndex));</span>
            }
<span class="fc" id="L1958">            return compiledQuery.ofInsert(insertOperation);</span>
<span class="fc" id="L1959">        } catch (SqlException e) {</span>
<span class="fc" id="L1960">            Misc.freeObjList(valueFunctions);</span>
<span class="fc" id="L1961">            throw e;</span>
        }
    }

    private CompiledQuery insertAsSelect(ExecutionModel executionModel, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L1966">        final InsertModel model = (InsertModel) executionModel;</span>
<span class="fc" id="L1967">        final ExpressionNode tableNameExpr = model.getTableNameExpr();</span>

<span class="fc" id="L1969">        TableToken tableToken = tableExistsOrFail(tableNameExpr.position, tableNameExpr.token, executionContext);</span>
        long insertCount;

        try (
<span class="fc" id="L1973">                TableWriterAPI writer = engine.getTableWriterAPI(executionContext.getCairoSecurityContext(), tableToken, &quot;insertAsSelect&quot;);</span>
<span class="fc" id="L1974">                RecordCursorFactory factory = generate(model.getQueryModel(), executionContext)</span>
        ) {
<span class="fc" id="L1976">            final RecordMetadata cursorMetadata = factory.getMetadata();</span>
            // Convert sparse writer metadata into dense
<span class="fc" id="L1978">            final RecordMetadata writerMetadata = GenericRecordMetadata.copyDense(writer.getMetadata());</span>
<span class="fc" id="L1979">            final int writerTimestampIndex = writerMetadata.getTimestampIndex();</span>
<span class="fc" id="L1980">            final int cursorTimestampIndex = cursorMetadata.getTimestampIndex();</span>
<span class="fc" id="L1981">            final int cursorColumnCount = cursorMetadata.getColumnCount();</span>

            final RecordToRowCopier copier;
<span class="fc" id="L1984">            final ObjList&lt;CharSequence&gt; columnNameList = model.getColumnNameList();</span>
<span class="fc" id="L1985">            final int columnSetSize = columnNameList.size();</span>
<span class="fc" id="L1986">            int timestampIndexFound = -1;</span>
<span class="fc bfc" id="L1987" title="All 2 branches covered.">            if (columnSetSize &gt; 0) {</span>
                // validate type cast

                // clear list column filter to re-populate it again
<span class="fc" id="L1991">                listColumnFilter.clear();</span>

<span class="fc bfc" id="L1993" title="All 2 branches covered.">                for (int i = 0; i &lt; columnSetSize; i++) {</span>
<span class="fc" id="L1994">                    CharSequence columnName = columnNameList.get(i);</span>
<span class="fc" id="L1995">                    int index = writerMetadata.getColumnIndexQuiet(columnName);</span>
<span class="fc bfc" id="L1996" title="All 2 branches covered.">                    if (index == -1) {</span>
<span class="fc" id="L1997">                        throw SqlException.invalidColumn(model.getColumnPosition(i), columnName);</span>
                    }

<span class="fc" id="L2000">                    int fromType = cursorMetadata.getColumnType(i);</span>
<span class="fc" id="L2001">                    int toType = writerMetadata.getColumnType(index);</span>
<span class="fc bfc" id="L2002" title="All 2 branches covered.">                    if (ColumnType.isAssignableFrom(fromType, toType)) {</span>
<span class="fc" id="L2003">                        listColumnFilter.add(index + 1);</span>
                    } else {
<span class="fc" id="L2005">                        throw SqlException.inconvertibleTypes(</span>
<span class="fc" id="L2006">                                model.getColumnPosition(i),</span>
                                fromType,
<span class="fc" id="L2008">                                cursorMetadata.getColumnName(i),</span>
                                toType,
<span class="fc" id="L2010">                                writerMetadata.getColumnName(i)</span>
                        );
                    }

<span class="fc bfc" id="L2014" title="All 2 branches covered.">                    if (index == writerTimestampIndex) {</span>
<span class="fc" id="L2015">                        timestampIndexFound = i;</span>
<span class="pc bpc" id="L2016" title="1 of 4 branches missed.">                        if (fromType != ColumnType.TIMESTAMP &amp;&amp; fromType != ColumnType.STRING) {</span>
<span class="fc" id="L2017">                            throw SqlException.$(tableNameExpr.position, &quot;expected timestamp column but type is &quot;).put(ColumnType.nameOf(fromType));</span>
                        }
                    }
                }

                // fail when target table requires chronological data and cursor cannot provide it
<span class="fc bfc" id="L2023" title="All 4 branches covered.">                if (timestampIndexFound &lt; 0 &amp;&amp; writerTimestampIndex &gt;= 0) {</span>
<span class="fc" id="L2024">                    throw SqlException.$(tableNameExpr.position, &quot;select clause must provide timestamp column&quot;);</span>
                }

<span class="fc" id="L2027">                copier = RecordToRowCopierUtils.generateCopier(asm, cursorMetadata, writerMetadata, listColumnFilter);</span>
            } else {
                // fail when target table requires chronological data and cursor cannot provide it
<span class="fc bfc" id="L2030" title="All 4 branches covered.">                if (writerTimestampIndex &gt; -1 &amp;&amp; cursorTimestampIndex == -1) {</span>
<span class="fc bfc" id="L2031" title="All 2 branches covered.">                    if (cursorColumnCount &lt;= writerTimestampIndex) {</span>
<span class="fc" id="L2032">                        throw SqlException.$(tableNameExpr.position, &quot;select clause must provide timestamp column&quot;);</span>
                    } else {
<span class="fc" id="L2034">                        int columnType = ColumnType.tagOf(cursorMetadata.getColumnType(writerTimestampIndex));</span>
<span class="fc bfc" id="L2035" title="All 6 branches covered.">                        if (columnType != ColumnType.TIMESTAMP &amp;&amp; columnType != ColumnType.STRING &amp;&amp; columnType != ColumnType.NULL) {</span>
<span class="fc" id="L2036">                            throw SqlException.$(tableNameExpr.position, &quot;expected timestamp column but type is &quot;).put(ColumnType.nameOf(columnType));</span>
                        }
                    }
                }

<span class="fc bfc" id="L2041" title="All 6 branches covered.">                if (writerTimestampIndex &gt; -1 &amp;&amp; cursorTimestampIndex &gt; -1 &amp;&amp; writerTimestampIndex != cursorTimestampIndex) {</span>
<span class="fc" id="L2042">                    throw SqlException</span>
<span class="fc" id="L2043">                            .$(tableNameExpr.position, &quot;designated timestamp of existing table (&quot;).put(writerTimestampIndex)</span>
<span class="fc" id="L2044">                            .put(&quot;) does not match designated timestamp in select query (&quot;)</span>
<span class="fc" id="L2045">                            .put(cursorTimestampIndex)</span>
<span class="fc" id="L2046">                            .put(')');</span>
                }
<span class="fc" id="L2048">                timestampIndexFound = writerTimestampIndex;</span>

<span class="fc" id="L2050">                final int n = writerMetadata.getColumnCount();</span>
<span class="fc bfc" id="L2051" title="All 2 branches covered.">                if (n &gt; cursorMetadata.getColumnCount()) {</span>
<span class="fc" id="L2052">                    throw SqlException.$(model.getSelectKeywordPosition(), &quot;not enough columns selected&quot;);</span>
                }

<span class="fc bfc" id="L2055" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2056">                    int fromType = cursorMetadata.getColumnType(i);</span>
<span class="fc" id="L2057">                    int toType = writerMetadata.getColumnType(i);</span>
<span class="fc bfc" id="L2058" title="All 2 branches covered.">                    if (ColumnType.isAssignableFrom(fromType, toType)) {</span>
<span class="fc" id="L2059">                        continue;</span>
                    }

                    // We are going on a limp here. There is nowhere to position this error in our model.
                    // We will try to position on column (i) inside cursor's query model. Assumption is that
                    // it will always have a column, e.g. has been processed by optimiser
<span class="pc bpc" id="L2065" title="1 of 2 branches missed.">                    assert i &lt; model.getQueryModel().getBottomUpColumns().size();</span>
<span class="fc" id="L2066">                    throw SqlException.inconvertibleTypes(</span>
<span class="fc" id="L2067">                            model.getQueryModel().getBottomUpColumns().getQuick(i).getAst().position,</span>
                            fromType,
<span class="fc" id="L2069">                            cursorMetadata.getColumnName(i),</span>
                            toType,
<span class="fc" id="L2071">                            writerMetadata.getColumnName(i)</span>
                    );
                }

<span class="fc" id="L2075">                entityColumnFilter.of(writerMetadata.getColumnCount());</span>

<span class="fc" id="L2077">                copier = RecordToRowCopierUtils.generateCopier(</span>
                        asm,
                        cursorMetadata,
                        writerMetadata,
                        entityColumnFilter
                );
            }

<span class="fc" id="L2085">            SqlExecutionCircuitBreaker circuitBreaker = executionContext.getCircuitBreaker();</span>

<span class="fc" id="L2087">            try (RecordCursor cursor = factory.getCursor(executionContext)) {</span>
                try {
<span class="fc bfc" id="L2089" title="All 2 branches covered.">                    if (writerTimestampIndex == -1) {</span>
<span class="fc" id="L2090">                        insertCount = copyUnordered(cursor, writer, copier, circuitBreaker);</span>
                    } else {
<span class="fc bfc" id="L2092" title="All 2 branches covered.">                        if (model.getBatchSize() != -1) {</span>
<span class="fc" id="L2093">                            insertCount = copyOrderedBatched(</span>
                                    writer,
<span class="fc" id="L2095">                                    factory.getMetadata(),</span>
                                    cursor,
                                    copier,
                                    writerTimestampIndex,
<span class="fc" id="L2099">                                    model.getBatchSize(),</span>
<span class="fc" id="L2100">                                    model.getO3MaxLag(),</span>
                                    circuitBreaker
                            );
                        } else {
<span class="fc" id="L2104">                            insertCount = copyOrdered(writer, factory.getMetadata(), cursor, copier, timestampIndexFound, circuitBreaker);</span>
                        }
                    }
<span class="fc" id="L2107">                } catch (Throwable e) {</span>
                    // rollback data when system error occurs
<span class="fc" id="L2109">                    writer.rollback();</span>
<span class="fc" id="L2110">                    throw e;</span>
<span class="fc" id="L2111">                }</span>
            }
        }
<span class="fc" id="L2114">        return compiledQuery.ofInsertAsSelect(insertCount);</span>
    }

    private void insertValidateFunctionAndAddToList(
            InsertModel model,
            int tupleIndex,
            ObjList&lt;Function&gt; valueFunctions,
            RecordMetadata metadata,
            int metadataTimestampIndex,
            int insertColumnIndex,
            int metadataColumnIndex,
            Function function,
            int functionPosition,
            BindVariableService bindVariableService
    ) throws SqlException {

<span class="fc" id="L2130">        final int columnType = metadata.getColumnType(metadataColumnIndex);</span>
<span class="fc bfc" id="L2131" title="All 2 branches covered.">        if (function.isUndefined()) {</span>
<span class="fc" id="L2132">            function.assignType(columnType, bindVariableService);</span>
        }

<span class="fc bfc" id="L2135" title="All 2 branches covered.">        if (ColumnType.isAssignableFrom(function.getType(), columnType)) {</span>
<span class="fc bfc" id="L2136" title="All 2 branches covered.">            if (metadataColumnIndex == metadataTimestampIndex) {</span>
<span class="fc" id="L2137">                return;</span>
            }

<span class="fc" id="L2140">            valueFunctions.add(function);</span>
<span class="fc" id="L2141">            listColumnFilter.add(metadataColumnIndex + 1);</span>
<span class="fc" id="L2142">            return;</span>
        }

<span class="fc" id="L2145">        throw SqlException.inconvertibleTypes(</span>
                functionPosition,
<span class="fc" id="L2147">                function.getType(),</span>
<span class="fc" id="L2148">                model.getRowTupleValues(tupleIndex).getQuick(insertColumnIndex).token,</span>
<span class="fc" id="L2149">                metadata.getColumnType(metadataColumnIndex),</span>
<span class="fc" id="L2150">                metadata.getColumnName(metadataColumnIndex)</span>
        );
    }

    private ExecutionModel lightlyValidateInsertModel(InsertModel model) throws SqlException {
<span class="fc" id="L2155">        ExpressionNode tableNameExpr = model.getTableNameExpr();</span>
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">        if (tableNameExpr.type != ExpressionNode.LITERAL) {</span>
<span class="nc" id="L2157">            throw SqlException.$(tableNameExpr.position, &quot;literal expected&quot;);</span>
        }

<span class="fc" id="L2160">        int columnNameListSize = model.getColumnNameList().size();</span>

<span class="fc bfc" id="L2162" title="All 2 branches covered.">        if (columnNameListSize &gt; 0) {</span>
<span class="fc bfc" id="L2163" title="All 2 branches covered.">            for (int i = 0, n = model.getRowTupleCount(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L2164" title="All 2 branches covered.">                if (columnNameListSize != model.getRowTupleValues(i).size()) {</span>
<span class="fc" id="L2165">                    throw SqlException.$(</span>
<span class="fc" id="L2166">                                    model.getEndOfRowTupleValuesPosition(i),</span>
<span class="fc" id="L2167">                                    &quot;row value count does not match column count [expected=&quot;).put(columnNameListSize)</span>
<span class="fc" id="L2168">                            .put(&quot;, actual=&quot;).put(model.getRowTupleValues(i).size())</span>
<span class="fc" id="L2169">                            .put(&quot;, tuple=&quot;).put(i + 1)</span>
<span class="fc" id="L2170">                            .put(']');</span>
                }
            }
        }

<span class="fc" id="L2175">        return model;</span>
    }

    private RecordCursorFactory prepareForUpdate(
            TableToken tableToken,
            QueryModel selectQueryModel,
            QueryModel updateQueryModel,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L2184">        final IntList tableColumnTypes = selectQueryModel.getUpdateTableColumnTypes();</span>
<span class="fc" id="L2185">        final ObjList&lt;CharSequence&gt; tableColumnNames = selectQueryModel.getUpdateTableColumnNames();</span>

<span class="fc" id="L2187">        RecordCursorFactory updateToDataCursorFactory = codeGenerator.generate(selectQueryModel, executionContext);</span>
        try {
<span class="pc bpc" id="L2189" title="1 of 2 branches missed.">            if (!updateToDataCursorFactory.supportsUpdateRowId(tableToken)) {</span>
                // in theory this should never happen because all valid UPDATE statements should result in
                // a query plan with real row ids but better to check to prevent data corruption
<span class="nc" id="L2192">                throw SqlException.$(updateQueryModel.getModelPosition(), &quot;Unsupported SQL complexity for the UPDATE statement&quot;);</span>
            }

            // Check that updateDataFactoryMetadata match types of table to be updated exactly
<span class="fc" id="L2196">            final RecordMetadata updateDataFactoryMetadata = updateToDataCursorFactory.getMetadata();</span>
<span class="fc bfc" id="L2197" title="All 2 branches covered.">            for (int i = 0, n = updateDataFactoryMetadata.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L2198">                int virtualColumnType = updateDataFactoryMetadata.getColumnType(i);</span>
<span class="fc" id="L2199">                CharSequence updateColumnName = updateDataFactoryMetadata.getColumnName(i);</span>
<span class="fc" id="L2200">                int tableColumnIndex = tableColumnNames.indexOf(updateColumnName);</span>
<span class="fc" id="L2201">                int tableColumnType = tableColumnTypes.get(tableColumnIndex);</span>

<span class="fc bfc" id="L2203" title="All 2 branches covered.">                if (virtualColumnType != tableColumnType) {</span>
<span class="fc bfc" id="L2204" title="All 4 branches covered.">                    if (!ColumnType.isSymbol(tableColumnType) || virtualColumnType != ColumnType.STRING) {</span>
                        // get column position
<span class="fc" id="L2206">                        ExpressionNode setRhs = updateQueryModel.getNestedModel().getColumns().getQuick(i).getAst();</span>
<span class="fc" id="L2207">                        throw SqlException.inconvertibleTypes(setRhs.position, virtualColumnType, &quot;&quot;, tableColumnType, updateColumnName);</span>
                    }
                }
            }
<span class="fc" id="L2211">            return updateToDataCursorFactory;</span>
<span class="fc" id="L2212">        } catch (Throwable th) {</span>
<span class="fc" id="L2213">            updateToDataCursorFactory.close();</span>
<span class="fc" id="L2214">            throw th;</span>
        }
    }

    private CompiledQuery reindexTable(SqlExecutionContext executionContext) throws SqlException {
        CharSequence tok;
<span class="fc" id="L2220">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L2221" title="1 of 4 branches missed.">        if (tok == null || !isTableKeyword(tok)) {</span>
<span class="fc" id="L2222">            throw SqlException.$(lexer.lastTokenPosition(), &quot;TABLE expected&quot;);</span>
        }

<span class="fc" id="L2225">        tok = SqlUtil.fetchNext(lexer);</span>

<span class="pc bpc" id="L2227" title="1 of 4 branches missed.">        if (tok == null || Chars.equals(tok, ',')) {</span>
<span class="fc" id="L2228">            throw SqlException.$(lexer.getPosition(), &quot;table name expected&quot;);</span>
        }

<span class="fc bfc" id="L2231" title="All 2 branches covered.">        if (Chars.isQuoted(tok)) {</span>
<span class="fc" id="L2232">            tok = GenericLexer.unquote(tok);</span>
        }
<span class="fc" id="L2234">        TableToken tableToken = tableExistsOrFail(lexer.lastTokenPosition(), tok, executionContext);</span>
<span class="fc" id="L2235">        rebuildIndex.of(path.of(configuration.getRoot()).concat(tableToken.getDirName()), configuration);</span>

<span class="fc" id="L2237">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc" id="L2238">        CharSequence columnName = null;</span>

<span class="fc bfc" id="L2240" title="All 4 branches covered.">        if (tok != null &amp;&amp; SqlKeywords.isColumnKeyword(tok)) {</span>
<span class="fc" id="L2241">            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2242" title="All 2 branches covered.">            if (Chars.isQuoted(tok)) {</span>
<span class="fc" id="L2243">                tok = GenericLexer.unquote(tok);</span>
            }
<span class="pc bpc" id="L2245" title="2 of 4 branches missed.">            if (tok == null || TableUtils.isValidColumnName(tok, configuration.getMaxFileNameLength())) {</span>
<span class="fc" id="L2246">                columnName = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L2247">                tok = SqlUtil.fetchNext(lexer);</span>
            }
        }

<span class="fc" id="L2251">        CharSequence partition = null;</span>
<span class="fc bfc" id="L2252" title="All 4 branches covered.">        if (tok != null &amp;&amp; SqlKeywords.isPartitionKeyword(tok)) {</span>
<span class="fc" id="L2253">            tok = SqlUtil.fetchNext(lexer);</span>

<span class="fc bfc" id="L2255" title="All 2 branches covered.">            if (Chars.isQuoted(tok)) {</span>
<span class="fc" id="L2256">                tok = GenericLexer.unquote(tok);</span>
            }
<span class="fc" id="L2258">            partition = tok;</span>
<span class="fc" id="L2259">            tok = SqlUtil.fetchNext(lexer);</span>
        }

<span class="fc bfc" id="L2262" title="All 4 branches covered.">        if (tok == null || !isLockKeyword(tok)) {</span>
<span class="fc" id="L2263">            throw SqlException.$(lexer.getPosition(), &quot;LOCK EXCLUSIVE expected&quot;);</span>
        }

<span class="fc" id="L2266">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L2267" title="1 of 4 branches missed.">        if (tok == null || !isExclusiveKeyword(tok)) {</span>
<span class="fc" id="L2268">            throw SqlException.$(lexer.getPosition(), &quot;LOCK EXCLUSIVE expected&quot;);</span>
        }

<span class="fc" id="L2271">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2272" title="All 4 branches covered.">        if (tok != null &amp;&amp; !isSemicolon(tok)) {</span>
<span class="fc" id="L2273">            throw SqlException.$(lexer.getPosition(), &quot;EOF expected&quot;);</span>
        }

<span class="fc" id="L2276">        rebuildIndex.reindex(partition, columnName);</span>
<span class="fc" id="L2277">        return compiledQuery.ofRepair();</span>
    }

    private boolean removeTableDirectory(CreateTableModel model) {
        int errno;
<span class="fc" id="L2282">        TableToken tableToken = engine.getTableToken(model.getName().token);</span>
<span class="pc bpc" id="L2283" title="1 of 2 branches missed.">        if ((errno = engine.removeDirectory(path, tableToken.getDirName())) == 0) {</span>
<span class="fc" id="L2284">            return true;</span>
        }
<span class="nc" id="L2286">        LOG.error()</span>
<span class="nc" id="L2287">                .$(&quot;could not clean up after create table failure [path=&quot;).$(path)</span>
<span class="nc" id="L2288">                .$(&quot;, errno=&quot;).$(errno)</span>
<span class="nc" id="L2289">                .$(']').$();</span>
<span class="nc" id="L2290">        return false;</span>
    }

    private CompiledQuery repairTables(SqlExecutionContext executionContext) throws SqlException {
        CharSequence tok;
<span class="fc" id="L2295">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L2296" title="2 of 4 branches missed.">        if (tok == null || !isTableKeyword(tok)) {</span>
<span class="nc" id="L2297">            throw SqlException.$(lexer.lastTokenPosition(), &quot;'table' expected&quot;);</span>
        }

        do {
<span class="fc" id="L2301">            tok = SqlUtil.fetchNext(lexer);</span>

<span class="pc bpc" id="L2303" title="2 of 4 branches missed.">            if (tok == null || Chars.equals(tok, ',')) {</span>
<span class="nc" id="L2304">                throw SqlException.$(lexer.getPosition(), &quot;table name expected&quot;);</span>
            }

<span class="pc bpc" id="L2307" title="1 of 2 branches missed.">            if (Chars.isQuoted(tok)) {</span>
<span class="nc" id="L2308">                tok = GenericLexer.unquote(tok);</span>
            }
<span class="fc" id="L2310">            tableExistsOrFail(lexer.lastTokenPosition(), tok, executionContext);</span>
<span class="fc" id="L2311">            tok = SqlUtil.fetchNext(lexer);</span>

<span class="pc bpc" id="L2313" title="2 of 4 branches missed.">        } while (tok != null &amp;&amp; Chars.equals(tok, ','));</span>
<span class="fc" id="L2314">        return compiledQuery.ofRepair();</span>
    }

    private void setupTextLoaderFromModel(CopyModel model) {
<span class="nc" id="L2318">        textLoader.clear();</span>
<span class="nc" id="L2319">        textLoader.setState(TextLoader.ANALYZE_STRUCTURE);</span>
        // todo: configure the following
        //   - what happens when data row errors out, max errors may be?
        //   - we should be able to skip X rows from top, dodgy headers etc.

<span class="nc" id="L2324">        textLoader.configureDestination(model.getTarget().token, false, false,</span>
<span class="nc bnc" id="L2325" title="All 2 branches missed.">                model.getAtomicity() != -1 ? model.getAtomicity() : Atomicity.SKIP_ROW,</span>
<span class="nc bnc" id="L2326" title="All 2 branches missed.">                model.getPartitionBy() &lt; 0 ? PartitionBy.NONE : model.getPartitionBy(),</span>
<span class="nc" id="L2327">                model.getTimestampColumnName(), model.getTimestampFormat());</span>
<span class="nc" id="L2328">    }</span>

    private CompiledQuery snapshotDatabase(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2331">        executionContext.getCairoSecurityContext().checkWritePermission();</span>
<span class="fc" id="L2332">        CharSequence tok = expectToken(lexer, &quot;'prepare' or 'complete'&quot;);</span>

<span class="fc bfc" id="L2334" title="All 2 branches covered.">        if (Chars.equalsLowerCaseAscii(tok, &quot;prepare&quot;)) {</span>
<span class="pc bpc" id="L2335" title="1 of 2 branches missed.">            if (snapshotAgent == null) {</span>
<span class="nc" id="L2336">                throw SqlException.position(lexer.lastTokenPosition()).put(&quot;Snapshot agent is not configured. Try using different embedded API&quot;);</span>
            }
<span class="fc" id="L2338">            snapshotAgent.prepareSnapshot(executionContext);</span>
<span class="fc" id="L2339">            return compiledQuery.ofSnapshotPrepare();</span>
        }

<span class="fc bfc" id="L2342" title="All 2 branches covered.">        if (Chars.equalsLowerCaseAscii(tok, &quot;complete&quot;)) {</span>
<span class="pc bpc" id="L2343" title="1 of 2 branches missed.">            if (snapshotAgent == null) {</span>
<span class="nc" id="L2344">                throw SqlException.position(lexer.lastTokenPosition()).put(&quot;Snapshot agent is not configured. Try using different embedded API&quot;);</span>
            }
<span class="fc" id="L2346">            snapshotAgent.completeSnapshot();</span>
<span class="fc" id="L2347">            return compiledQuery.ofSnapshotComplete();</span>
        }

<span class="fc" id="L2350">        throw SqlException.position(lexer.lastTokenPosition()).put(&quot;'prepare' or 'complete' expected&quot;);</span>
    }

    private CompiledQuery sqlShow(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2354">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2355" title="All 2 branches covered.">        if (null != tok) {</span>
<span class="fc bfc" id="L2356" title="All 2 branches covered.">            if (isTablesKeyword(tok)) {</span>
<span class="fc" id="L2357">                return compiledQuery.of(new TableListRecordCursorFactory());</span>
            }
<span class="fc bfc" id="L2359" title="All 2 branches covered.">            if (isColumnsKeyword(tok)) {</span>
<span class="fc" id="L2360">                return sqlShowColumns(executionContext);</span>
            }

<span class="fc bfc" id="L2363" title="All 2 branches covered.">            if (isTransactionKeyword(tok)) {</span>
<span class="fc" id="L2364">                return sqlShowTransaction();</span>
            }

<span class="fc bfc" id="L2367" title="All 2 branches covered.">            if (isTransactionIsolation(tok)) {</span>
<span class="fc" id="L2368">                return compiledQuery.of(new ShowTransactionIsolationLevelCursorFactory());</span>
            }

<span class="fc bfc" id="L2371" title="All 2 branches covered.">            if (isMaxIdentifierLength(tok)) {</span>
<span class="fc" id="L2372">                return compiledQuery.of(new ShowMaxIdentifierLengthCursorFactory());</span>
            }

<span class="fc bfc" id="L2375" title="All 2 branches covered.">            if (isStandardConformingStrings(tok)) {</span>
<span class="fc" id="L2376">                return compiledQuery.of(new ShowStandardConformingStringsCursorFactory());</span>
            }

<span class="fc bfc" id="L2379" title="All 2 branches covered.">            if (isSearchPath(tok)) {</span>
<span class="fc" id="L2380">                return compiledQuery.of(new ShowSearchPathCursorFactory());</span>
            }

<span class="fc bfc" id="L2383" title="All 2 branches covered.">            if (isDateStyleKeyword(tok)) {</span>
<span class="fc" id="L2384">                return compiledQuery.of(new ShowDateStyleCursorFactory());</span>
            }

<span class="pc bpc" id="L2387" title="1 of 2 branches missed.">            if (SqlKeywords.isTimeKeyword(tok)) {</span>
<span class="fc" id="L2388">                tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L2389" title="1 of 4 branches missed.">                if (tok != null &amp;&amp; SqlKeywords.isZoneKeyword(tok)) {</span>
<span class="fc" id="L2390">                    return compiledQuery.of(new ShowTimeZoneFactory());</span>
                }
            }
        }

<span class="fc" id="L2395">        throw SqlException.position(lexer.lastTokenPosition()).put(&quot;expected 'tables', 'columns' or 'time zone'&quot;);</span>
    }

    private CompiledQuery sqlShowColumns(SqlExecutionContext executionContext) throws SqlException {
        CharSequence tok;
<span class="fc" id="L2400">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L2401" title="1 of 4 branches missed.">        if (null == tok || !isFromKeyword(tok)) {</span>
<span class="fc" id="L2402">            throw SqlException.position(lexer.getPosition()).put(&quot;expected 'from'&quot;);</span>
        }
<span class="fc" id="L2404">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L2405" title="1 of 2 branches missed.">        if (null == tok) {</span>
<span class="nc" id="L2406">            throw SqlException.position(lexer.getPosition()).put(&quot;expected a table name&quot;);</span>
        }
<span class="fc" id="L2408">        final CharSequence tableName = GenericLexer.assertNoDotsAndSlashes(GenericLexer.unquote(tok), lexer.lastTokenPosition());</span>
<span class="fc" id="L2409">        TableToken tableToken = tableExistsOrFail(lexer.lastTokenPosition(), tableName, executionContext);</span>
<span class="fc" id="L2410">        return compiledQuery.of(new ShowColumnsRecordCursorFactory(tableToken));</span>
    }

    private CompiledQuery sqlShowTransaction() throws SqlException {
<span class="fc" id="L2414">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2415" title="All 4 branches covered.">        if (tok != null &amp;&amp; isIsolationKeyword(tok)) {</span>
<span class="fc" id="L2416">            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2417" title="All 4 branches covered.">            if (tok != null &amp;&amp; isLevelKeyword(tok)) {</span>
<span class="fc" id="L2418">                return compiledQuery.of(new ShowTransactionIsolationLevelCursorFactory());</span>
            }
<span class="fc bfc" id="L2420" title="All 2 branches covered.">            throw SqlException.position(tok != null ? lexer.lastTokenPosition() : lexer.getPosition()).put(&quot;expected 'level'&quot;);</span>
        }
<span class="fc bfc" id="L2422" title="All 2 branches covered.">        throw SqlException.position(tok != null ? lexer.lastTokenPosition() : lexer.getPosition()).put(&quot;expected 'isolation'&quot;);</span>
    }

    private TableToken tableExistsOrFail(int position, CharSequence tableName, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2426">        TableToken tableToken = executionContext.getTableTokenIfExists(tableName);</span>
<span class="fc bfc" id="L2427" title="All 2 branches covered.">        if (executionContext.getStatus(path, tableToken) != TableUtils.TABLE_EXISTS) {</span>
<span class="fc" id="L2428">            throw SqlException.$(position, &quot;table does not exist [table=&quot;).put(tableName).put(']');</span>
        }
<span class="fc" id="L2430">        return tableToken;</span>
    }

    private CompiledQuery truncateTables(SqlExecutionContext executionContext) throws SqlException {
        CharSequence tok;
<span class="fc" id="L2435">        tok = SqlUtil.fetchNext(lexer);</span>

<span class="fc bfc" id="L2437" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L2438">            throw SqlException.$(lexer.getPosition(), &quot;'table' expected&quot;);</span>
        }

<span class="fc bfc" id="L2441" title="All 2 branches covered.">        if (!isTableKeyword(tok)) {</span>
<span class="fc" id="L2442">            throw SqlException.$(lexer.lastTokenPosition(), &quot;'table' expected&quot;);</span>
        }

<span class="fc" id="L2445">        tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2446" title="All 4 branches covered.">        if (tok != null &amp;&amp; isOnlyKeyword(tok)) {</span>
<span class="fc" id="L2447">            tok = SqlUtil.fetchNext(lexer);</span>
        }

<span class="fc" id="L2450">        tableWriters.clear();</span>
        try {
            try {
                do {
<span class="pc bpc" id="L2454" title="1 of 4 branches missed.">                    if (tok == null || Chars.equals(tok, ',')) {</span>
<span class="fc" id="L2455">                        throw SqlException.$(lexer.getPosition(), &quot;table name expected&quot;);</span>
                    }

<span class="fc bfc" id="L2458" title="All 2 branches covered.">                    if (Chars.isQuoted(tok)) {</span>
<span class="fc" id="L2459">                        tok = GenericLexer.unquote(tok);</span>
                    }
<span class="fc" id="L2461">                    TableToken tableToken = tableExistsOrFail(lexer.lastTokenPosition(), tok, executionContext);</span>

                    try {
<span class="fc" id="L2464">                        tableWriters.add(engine.getTableWriterAPI(executionContext.getCairoSecurityContext(), tableToken, &quot;truncateTables&quot;));</span>
<span class="fc" id="L2465">                    } catch (CairoException e) {</span>
<span class="fc" id="L2466">                        LOG.info().$(&quot;table busy [table=&quot;).$(tok).$(&quot;, e=&quot;).$((Throwable) e).$(']').$();</span>
<span class="fc" id="L2467">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;table '&quot;).put(tok).put(&quot;' could not be truncated: &quot;).put(e);</span>
<span class="fc" id="L2468">                    }</span>
<span class="fc" id="L2469">                    tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2470" title="All 4 branches covered.">                    if (tok == null || Chars.equals(tok, ';')) {</span>
<span class="fc" id="L2471">                        break;</span>
                    }
<span class="pc bpc" id="L2473" title="1 of 2 branches missed.">                    if (Chars.equalsNc(tok, ',')) {</span>
<span class="fc" id="L2474">                        tok = SqlUtil.fetchNext(lexer);</span>
                    }

<span class="fc" id="L2477">                } while (true);</span>
<span class="fc" id="L2478">            } catch (SqlException e) {</span>
<span class="fc bfc" id="L2479" title="All 2 branches covered.">                for (int i = 0, n = tableWriters.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2480">                    tableWriters.getQuick(i).close();</span>
                }
<span class="fc" id="L2482">                throw e;</span>
<span class="fc" id="L2483">            }</span>

<span class="fc bfc" id="L2485" title="All 2 branches covered.">            for (int i = 0, n = tableWriters.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2486">                try (TableWriterAPI writer = tableWriters.getQuick(i)) {</span>
                    try {
<span class="fc bfc" id="L2488" title="All 2 branches covered.">                        if (writer.getMetadata().isWalEnabled()) {</span>
<span class="fc" id="L2489">                            writer.truncate();</span>
                        } else {
<span class="fc" id="L2491">                            TableToken tableToken = writer.getTableToken();</span>
<span class="pc bpc" id="L2492" title="1 of 2 branches missed.">                            if (engine.lockReaders(tableToken)) {</span>
                                try {
<span class="fc" id="L2494">                                    writer.truncate();</span>
                                } finally {
<span class="fc" id="L2496">                                    engine.unlockReaders(tableToken);</span>
<span class="fc" id="L2497">                                }</span>
                            } else {
<span class="nc" id="L2499">                                throw SqlException.$(0, &quot;there is an active query against '&quot;).put(tableToken).put(&quot;'. Try again.&quot;);</span>
                            }
                        }
<span class="nc" id="L2502">                    } catch (CairoException | CairoError e) {</span>
<span class="nc" id="L2503">                        LOG.error().$(&quot;could not truncate [table=&quot;).$(writer.getTableToken()).$(&quot;, e=&quot;).$((Sinkable) e).$(']').$();</span>
<span class="nc" id="L2504">                        throw e;</span>
<span class="fc" id="L2505">                    }</span>
                }
            }
        } finally {
<span class="fc" id="L2509">            tableWriters.clear();</span>
        }
<span class="fc" id="L2511">        return compiledQuery.ofTruncate();</span>
    }

    private CompiledQuery vacuum(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2515">        executionContext.getCairoSecurityContext().checkWritePermission();</span>
<span class="fc" id="L2516">        CharSequence tok = expectToken(lexer, &quot;'table'&quot;);</span>
        // It used to be VACUUM PARTITIONS but become VACUUM TABLE
<span class="fc" id="L2518">        boolean partitionsKeyword = isPartitionsKeyword(tok);</span>
<span class="fc bfc" id="L2519" title="All 4 branches covered.">        if (partitionsKeyword || isTableKeyword(tok)) {</span>
<span class="fc" id="L2520">            CharSequence tableName = expectToken(lexer, &quot;table name&quot;);</span>
<span class="fc" id="L2521">            tableName = GenericLexer.assertNoDotsAndSlashes(GenericLexer.unquote(tableName), lexer.lastTokenPosition());</span>
<span class="fc" id="L2522">            int tableNamePos = lexer.lastTokenPosition();</span>
<span class="fc" id="L2523">            CharSequence eol = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2524" title="All 4 branches covered.">            if (eol == null || Chars.equals(eol, ';')) {</span>
<span class="fc" id="L2525">                executionContext.getCairoSecurityContext().checkWritePermission();</span>
<span class="fc" id="L2526">                TableToken tableToken = tableExistsOrFail(lexer.lastTokenPosition(), tableName, executionContext);</span>
<span class="fc" id="L2527">                try (TableReader rdr = executionContext.getReader(tableToken)) {</span>
<span class="fc" id="L2528">                    int partitionBy = rdr.getMetadata().getPartitionBy();</span>
<span class="fc bfc" id="L2529" title="All 2 branches covered.">                    if (PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc bfc" id="L2530" title="All 2 branches covered.">                        if (!TableUtils.schedulePurgeO3Partitions(messageBus, rdr.getTableToken(), partitionBy)) {</span>
<span class="fc" id="L2531">                            throw SqlException.$(</span>
                                    tableNamePos,
                                    &quot;cannot schedule vacuum action, queue is full, please retry &quot; +
                                            &quot;or increase Purge Discovery Queue Capacity&quot;
                            );
                        }
<span class="fc bfc" id="L2537" title="All 2 branches covered.">                    } else if (partitionsKeyword) {</span>
<span class="fc" id="L2538">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;table '&quot;).put(tableName).put(&quot;' is not partitioned&quot;);</span>
                    }
<span class="fc" id="L2540">                    vacuumColumnVersions.run(executionContext, rdr);</span>
<span class="fc" id="L2541">                    return compiledQuery.ofVacuum();</span>
                }
            }
<span class="fc" id="L2544">            throw SqlException.$(lexer.lastTokenPosition(), &quot;end of line or ';' expected&quot;);</span>
        }
<span class="fc" id="L2546">        throw SqlException.$(lexer.lastTokenPosition(), &quot;'partitions' expected&quot;);</span>
    }

    private InsertModel validateAndOptimiseInsertAsSelect(
            InsertModel model,
            SqlExecutionContext executionContext
    ) throws SqlException {
<span class="fc" id="L2553">        final QueryModel queryModel = optimiser.optimise(model.getQueryModel(), executionContext);</span>
<span class="fc" id="L2554">        int columnNameListSize = model.getColumnNameList().size();</span>
<span class="fc bfc" id="L2555" title="All 4 branches covered.">        if (columnNameListSize &gt; 0 &amp;&amp; queryModel.getBottomUpColumns().size() != columnNameListSize) {</span>
<span class="fc" id="L2556">            throw SqlException.$(model.getTableNameExpr().position, &quot;column count mismatch&quot;);</span>
        }
<span class="fc" id="L2558">        model.setQueryModel(queryModel);</span>
<span class="fc" id="L2559">        return model;</span>
    }

    private void validateTableModelAndCreateTypeCast(
            CreateTableModel model,
            RecordMetadata metadata,
            @Transient IntIntHashMap typeCast
    ) throws SqlException {
<span class="fc" id="L2567">        CharSequenceObjHashMap&lt;ColumnCastModel&gt; castModels = model.getColumnCastModels();</span>
<span class="fc" id="L2568">        ObjList&lt;CharSequence&gt; castColumnNames = castModels.keys();</span>

<span class="fc bfc" id="L2570" title="All 2 branches covered.">        for (int i = 0, n = castColumnNames.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2571">            CharSequence columnName = castColumnNames.getQuick(i);</span>
<span class="fc" id="L2572">            int index = metadata.getColumnIndexQuiet(columnName);</span>
<span class="fc" id="L2573">            ColumnCastModel ccm = castModels.get(columnName);</span>
            // the only reason why columns cannot be found at this stage is
            // concurrent table modification of table structure
<span class="fc bfc" id="L2576" title="All 2 branches covered.">            if (index == -1) {</span>
                // Cast isn't going to go away when we re-parse SQL. We must make this
                // permanent error
<span class="fc" id="L2579">                throw SqlException.invalidColumn(ccm.getColumnNamePos(), columnName);</span>
            }
<span class="fc" id="L2581">            int from = metadata.getColumnType(index);</span>
<span class="fc" id="L2582">            int to = ccm.getColumnType();</span>
<span class="fc bfc" id="L2583" title="All 2 branches covered.">            if (isCompatibleCase(from, to)) {</span>
<span class="fc" id="L2584">                int modelColumnIndex = model.getColumnIndex(columnName);</span>
<span class="fc bfc" id="L2585" title="All 4 branches covered.">                if (!ColumnType.isSymbol(to) &amp;&amp; model.isIndexed(modelColumnIndex)) {</span>
<span class="fc" id="L2586">                    throw SqlException.$(ccm.getColumnTypePos(), &quot;indexes are supported only for SYMBOL columns: &quot;).put(columnName);</span>
                }
<span class="fc" id="L2588">                typeCast.put(index, to);</span>
<span class="fc" id="L2589">            } else {</span>
<span class="fc" id="L2590">                throw SqlException.unsupportedCast(ccm.getColumnTypePos(), columnName, from, to);</span>
            }
        }

        // validate that all indexes are specified only on columns with symbol type
<span class="fc bfc" id="L2595" title="All 2 branches covered.">        for (int i = 0, n = model.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L2596">            CharSequence columnName = model.getColumnName(i);</span>
<span class="fc" id="L2597">            ColumnCastModel ccm = castModels.get(columnName);</span>
<span class="fc bfc" id="L2598" title="All 2 branches covered.">            if (ccm != null) {</span>
                // We already checked this column when validating casts.
<span class="fc" id="L2600">                continue;</span>
            }
<span class="fc" id="L2602">            int index = metadata.getColumnIndexQuiet(columnName);</span>
<span class="pc bpc" id="L2603" title="1 of 2 branches missed.">            assert index &gt; -1 : &quot;wtf? &quot; + columnName;</span>
<span class="fc bfc" id="L2604" title="All 4 branches covered.">            if (!ColumnType.isSymbol(metadata.getColumnType(index)) &amp;&amp; model.isIndexed(i)) {</span>
<span class="fc" id="L2605">                throw SqlException.$(0, &quot;indexes are supported only for SYMBOL columns: &quot;).put(columnName);</span>
            }
        }

        // validate type of timestamp column
        // no need to worry that column will not resolve
<span class="fc" id="L2611">        ExpressionNode timestamp = model.getTimestamp();</span>
<span class="fc bfc" id="L2612" title="All 4 branches covered.">        if (timestamp != null &amp;&amp; metadata.getColumnType(timestamp.token) != ColumnType.TIMESTAMP) {</span>
<span class="fc" id="L2613">            throw SqlException.position(timestamp.position).put(&quot;TIMESTAMP column expected [actual=&quot;).put(ColumnType.nameOf(metadata.getColumnType(timestamp.token))).put(']');</span>
        }

<span class="pc bpc" id="L2616" title="3 of 6 branches missed.">        if (PartitionBy.isPartitioned(model.getPartitionBy()) &amp;&amp; model.getTimestampIndex() == -1 &amp;&amp; metadata.getTimestampIndex() == -1) {</span>
<span class="nc" id="L2617">            throw SqlException.position(0).put(&quot;timestamp is not defined&quot;);</span>
        }
<span class="fc" id="L2619">    }</span>

    RecordCursorFactory generate(QueryModel queryModel, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2622">        return codeGenerator.generate(queryModel, executionContext);</span>
    }

    UpdateOperation generateUpdate(QueryModel updateQueryModel, SqlExecutionContext executionContext, TableRecordMetadata metadata) throws SqlException {
<span class="fc" id="L2626">        TableToken updateTableToken = updateQueryModel.getUpdateTableToken();</span>
<span class="fc" id="L2627">        final QueryModel selectQueryModel = updateQueryModel.getNestedModel();</span>

        // Update QueryModel structure is
        // QueryModel with SET column expressions
        // |-- QueryModel of select-virtual or select-choose of data selected for update
<span class="fc" id="L2632">        final RecordCursorFactory recordCursorFactory = prepareForUpdate(</span>
                updateTableToken,
                selectQueryModel,
                updateQueryModel,
                executionContext
        );

<span class="fc bfc" id="L2639" title="All 4 branches covered.">        if (!metadata.isWalEnabled() || executionContext.isWalApplication()) {</span>
<span class="fc" id="L2640">            return new UpdateOperation(</span>
                    updateTableToken,
<span class="fc" id="L2642">                    selectQueryModel.getTableId(),</span>
<span class="fc" id="L2643">                    selectQueryModel.getTableVersion(),</span>
<span class="fc" id="L2644">                    lexer.getPosition(),</span>
                    recordCursorFactory
            );
        } else {
<span class="fc" id="L2648">            recordCursorFactory.close();</span>

<span class="fc bfc" id="L2650" title="All 2 branches covered.">            if (selectQueryModel.containsJoin()) {</span>
<span class="fc" id="L2651">                throw SqlException.position(0).put(&quot;UPDATE statements with join are not supported yet for WAL tables&quot;);</span>
            }

<span class="fc" id="L2654">            return new UpdateOperation(</span>
                    updateTableToken,
<span class="fc" id="L2656">                    metadata.getTableId(),</span>
<span class="fc" id="L2657">                    metadata.getStructureVersion(),</span>
<span class="fc" id="L2658">                    lexer.getPosition()</span>
            );
        }
    }

    // used in tests
    void setEnableJitNullChecks(boolean value) {
<span class="nc" id="L2665">        codeGenerator.setEnableJitNullChecks(value);</span>
<span class="nc" id="L2666">    }</span>

    void setFullFatJoins(boolean value) {
<span class="fc" id="L2669">        codeGenerator.setFullFatJoins(value);</span>
<span class="fc" id="L2670">    }</span>

    @TestOnly
    ExecutionModel testCompileModel(CharSequence query, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2674">        clear();</span>
<span class="fc" id="L2675">        lexer.of(query);</span>
<span class="fc" id="L2676">        return compileExecutionModel(executionContext);</span>
    }

    // this exposed for testing only
    @TestOnly
    ExpressionNode testParseExpression(CharSequence expression, QueryModel model) throws SqlException {
<span class="fc" id="L2682">        clear();</span>
<span class="fc" id="L2683">        lexer.of(expression);</span>
<span class="fc" id="L2684">        return parser.expr(lexer, model);</span>
    }

    // test only
    @TestOnly
    void testParseExpression(CharSequence expression, ExpressionParserListener listener) throws SqlException {
<span class="fc" id="L2690">        clear();</span>
<span class="fc" id="L2691">        lexer.of(expression);</span>
<span class="fc" id="L2692">        parser.expr(lexer, listener);</span>
<span class="fc" id="L2693">    }</span>

    @FunctionalInterface
    private interface ExecutableMethod {
        CompiledQuery execute(ExecutionModel model, SqlExecutionContext sqlExecutionContext) throws SqlException;
    }

    @FunctionalInterface
    protected interface KeywordBasedExecutor {
        CompiledQuery execute(SqlExecutionContext executionContext) throws SqlException;
    }

<span class="nc" id="L2705">    public final static class PartitionAction {</span>
        public static final int ATTACH = 2;
        public static final int DETACH = 3;
        public static final int DROP = 1;
    }

    private static class TableStructureAdapter implements TableStructure {
        private RecordMetadata metadata;
        private CreateTableModel model;
        private int timestampIndex;
        private IntIntHashMap typeCast;

        @Override
        public int getColumnCount() {
<span class="fc" id="L2719">            return model.getColumnCount();</span>
        }

        @Override
        public CharSequence getColumnName(int columnIndex) {
<span class="fc" id="L2724">            return model.getColumnName(columnIndex);</span>
        }

        @Override
        public int getColumnType(int columnIndex) {
<span class="fc" id="L2729">            int castIndex = typeCast.keyIndex(columnIndex);</span>
<span class="fc bfc" id="L2730" title="All 2 branches covered.">            if (castIndex &lt; 0) {</span>
<span class="fc" id="L2731">                return typeCast.valueAt(castIndex);</span>
            }
<span class="fc" id="L2733">            return metadata.getColumnType(columnIndex);</span>
        }

        @Override
        public int getIndexBlockCapacity(int columnIndex) {
<span class="fc" id="L2738">            return model.getIndexBlockCapacity(columnIndex);</span>
        }

        @Override
        public int getMaxUncommittedRows() {
<span class="fc" id="L2743">            return model.getMaxUncommittedRows();</span>
        }

        @Override
        public long getO3MaxLag() {
<span class="fc" id="L2748">            return model.getO3MaxLag();</span>
        }

        @Override
        public int getPartitionBy() {
<span class="fc" id="L2753">            return model.getPartitionBy();</span>
        }

        @Override
        public boolean getSymbolCacheFlag(int columnIndex) {
<span class="fc" id="L2758">            final ColumnCastModel ccm = model.getColumnCastModels().get(metadata.getColumnName(columnIndex));</span>
<span class="fc bfc" id="L2759" title="All 2 branches covered.">            if (ccm != null) {</span>
<span class="fc" id="L2760">                return ccm.getSymbolCacheFlag();</span>
            }
<span class="fc" id="L2762">            return model.getSymbolCacheFlag(columnIndex);</span>
        }

        @Override
        public int getSymbolCapacity(int columnIndex) {
<span class="fc" id="L2767">            final ColumnCastModel ccm = model.getColumnCastModels().get(metadata.getColumnName(columnIndex));</span>
<span class="fc bfc" id="L2768" title="All 2 branches covered.">            if (ccm != null) {</span>
<span class="fc" id="L2769">                return ccm.getSymbolCapacity();</span>
            } else {
<span class="fc" id="L2771">                return model.getSymbolCapacity(columnIndex);</span>
            }
        }

        @Override
        public CharSequence getTableName() {
<span class="fc" id="L2777">            return model.getTableName();</span>
        }

        @Override
        public int getTimestampIndex() {
<span class="fc" id="L2782">            return timestampIndex;</span>
        }

        @Override
        public boolean isIndexed(int columnIndex) {
<span class="fc" id="L2787">            return model.isIndexed(columnIndex);</span>
        }

        @Override
        public boolean isSequential(int columnIndex) {
<span class="fc" id="L2792">            return model.isSequential(columnIndex);</span>
        }

        @Override
        public boolean isWalEnabled() {
<span class="fc" id="L2797">            return model.isWalEnabled();</span>
        }

        TableStructureAdapter of(CreateTableModel model, RecordMetadata metadata, IntIntHashMap typeCast) {
<span class="fc bfc" id="L2801" title="All 2 branches covered.">            if (model.getTimestampIndex() != -1) {</span>
<span class="fc" id="L2802">                timestampIndex = model.getTimestampIndex();</span>
            } else {
<span class="fc" id="L2804">                timestampIndex = metadata.getTimestampIndex();</span>
            }
<span class="fc" id="L2806">            this.model = model;</span>
<span class="fc" id="L2807">            this.metadata = metadata;</span>
<span class="fc" id="L2808">            this.typeCast = typeCast;</span>
<span class="fc" id="L2809">            return this;</span>
        }
    }

    private static class TimestampValueRecord implements Record {
        private long value;

        @Override
        public long getTimestamp(int col) {
<span class="fc" id="L2818">            return value;</span>
        }

        public void setTimestamp(long value) {
<span class="fc" id="L2822">            this.value = value;</span>
<span class="fc" id="L2823">        }</span>
    }

<span class="fc" id="L2826">    private class DatabaseBackupAgent implements Closeable {</span>
<span class="fc" id="L2827">        protected final Path srcPath = new Path();</span>
<span class="fc" id="L2828">        private final Path dstPath = new Path();</span>
<span class="fc" id="L2829">        private final CharSequenceObjHashMap&lt;RecordToRowCopier&gt; tableBackupRowCopiedCache = new CharSequenceObjHashMap&lt;&gt;();</span>
<span class="fc" id="L2830">        private final ObjHashSet&lt;TableToken&gt; tableNames = new ObjHashSet&lt;&gt;();</span>
<span class="fc" id="L2831">        private final ObjList&lt;TableToken&gt; tableTokenBucket = new ObjList&lt;&gt;();</span>
        private transient String cachedTmpBackupRoot;
        private transient int changeDirPrefixLen;
        private transient int currDirPrefixLen;
<span class="fc" id="L2835">        private final FindVisitor confFilesBackupOnFind = (file, type) -&gt; {</span>
<span class="fc bfc" id="L2836" title="All 2 branches covered.">            if (type == Files.DT_FILE) {</span>
<span class="fc" id="L2837">                srcPath.of(configuration.getConfRoot()).concat(file).$();</span>
<span class="fc" id="L2838">                dstPath.trimTo(currDirPrefixLen).concat(file).$();</span>
<span class="fc" id="L2839">                LOG.info().$(&quot;backup copying config file [from=&quot;).$(srcPath).$(&quot;,to=&quot;).$(dstPath).I$();</span>
<span class="pc bpc" id="L2840" title="1 of 2 branches missed.">                if (ff.copy(srcPath, dstPath) &lt; 0) {</span>
<span class="nc" id="L2841">                    throw CairoException.critical(ff.errno()).put(&quot;cannot backup conf file [to=&quot;).put(dstPath).put(']');</span>
                }
            }
<span class="fc" id="L2844">        };</span>
        private transient SqlExecutionContext currentExecutionContext;

        public void clear() {
<span class="fc" id="L2848">            srcPath.trimTo(0);</span>
<span class="fc" id="L2849">            dstPath.trimTo(0);</span>
<span class="fc" id="L2850">            cachedTmpBackupRoot = null;</span>
<span class="fc" id="L2851">            changeDirPrefixLen = 0;</span>
<span class="fc" id="L2852">            currDirPrefixLen = 0;</span>
<span class="fc" id="L2853">            tableBackupRowCopiedCache.clear();</span>
<span class="fc" id="L2854">            tableNames.clear();</span>
<span class="fc" id="L2855">        }</span>

        @Override
        public void close() {
<span class="pc bpc" id="L2859" title="1 of 2 branches missed.">            assert null == currentExecutionContext;</span>
<span class="pc bpc" id="L2860" title="1 of 2 branches missed.">            assert tableNames.isEmpty();</span>
<span class="fc" id="L2861">            tableBackupRowCopiedCache.clear();</span>
<span class="fc" id="L2862">            Misc.free(srcPath);</span>
<span class="fc" id="L2863">            Misc.free(dstPath);</span>
<span class="fc" id="L2864">        }</span>

        private void backupTabIndexFile() {
<span class="fc" id="L2867">            srcPath.of(configuration.getRoot()).concat(TableUtils.TAB_INDEX_FILE_NAME).$();</span>
<span class="fc" id="L2868">            dstPath.trimTo(currDirPrefixLen).concat(TableUtils.TAB_INDEX_FILE_NAME).$();</span>
<span class="fc" id="L2869">            LOG.info().$(&quot;backup copying file [from=&quot;).$(srcPath).$(&quot;,to=&quot;).$(dstPath).I$();</span>
<span class="pc bpc" id="L2870" title="1 of 2 branches missed.">            if (ff.copy(srcPath, dstPath) &lt; 0) {</span>
<span class="nc" id="L2871">                throw CairoException.critical(ff.errno()).put(&quot;cannot backup tab index file [to=&quot;).put(dstPath).put(']');</span>
            }
<span class="fc" id="L2873">        }</span>

        private void backupTable(@NotNull TableToken tableToken, @NotNull SqlExecutionContext executionContext) {
<span class="fc" id="L2876">            LOG.info().$(&quot;starting backup of &quot;).$(tableToken).$();</span>
<span class="fc bfc" id="L2877" title="All 2 branches covered.">            if (null == cachedTmpBackupRoot) {</span>
<span class="pc bpc" id="L2878" title="1 of 2 branches missed.">                if (null == configuration.getBackupRoot()) {</span>
<span class="nc" id="L2879">                    throw CairoException.nonCritical().put(&quot;Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]&quot;);</span>
                }
<span class="fc" id="L2881">                srcPath.of(configuration.getBackupRoot()).concat(configuration.getBackupTempDirName()).slash$();</span>
<span class="fc" id="L2882">                cachedTmpBackupRoot = Chars.toString(srcPath);</span>
            }

<span class="fc" id="L2885">            int renameRootLen = dstPath.length();</span>
<span class="fc" id="L2886">            String tableName = tableToken.getTableName();</span>
            try {
<span class="fc" id="L2888">                CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();</span>
                // todo: looks like reader should be using engine to resolve table name
<span class="fc" id="L2890">                try (TableReader reader = executionContext.getReader(tableToken)) {</span>
<span class="fc" id="L2891">                    cloneMetaData(tableName, cachedTmpBackupRoot, configuration.getBackupMkDirMode(), reader);</span>
<span class="fc" id="L2892">                    try (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableToken, cachedTmpBackupRoot)) {</span>
<span class="fc" id="L2893">                        RecordMetadata writerMetadata = backupWriter.getMetadata();</span>
<span class="fc" id="L2894">                        srcPath.of(tableName).slash().put(reader.getVersion()).$();</span>
<span class="fc" id="L2895">                        RecordToRowCopier recordToRowCopier = tableBackupRowCopiedCache.get(srcPath);</span>
<span class="pc bpc" id="L2896" title="1 of 2 branches missed.">                        if (null == recordToRowCopier) {</span>
<span class="fc" id="L2897">                            entityColumnFilter.of(writerMetadata.getColumnCount());</span>
<span class="fc" id="L2898">                            recordToRowCopier = RecordToRowCopierUtils.generateCopier(</span>
                                    asm,
<span class="fc" id="L2900">                                    reader.getMetadata(),</span>
                                    writerMetadata,
                                    entityColumnFilter
                            );
<span class="fc" id="L2904">                            tableBackupRowCopiedCache.put(srcPath.toString(), recordToRowCopier);</span>
                        }

<span class="fc" id="L2907">                        RecordCursor cursor = reader.getCursor();</span>
                        //statement/query timeout value  is most likely too small for backup operation
<span class="fc" id="L2909">                        copyTableData(cursor, reader.getMetadata(), backupWriter, writerMetadata, recordToRowCopier, SqlExecutionCircuitBreaker.NOOP_CIRCUIT_BREAKER);</span>
<span class="fc" id="L2910">                        backupWriter.commit();</span>
                    }
                }
<span class="fc" id="L2913">                srcPath.of(configuration.getBackupRoot()).concat(configuration.getBackupTempDirName()).concat(tableToken.getDirName()).$();</span>
                try {
<span class="fc" id="L2915">                    dstPath.trimTo(renameRootLen).concat(tableToken.getDirName()).$();</span>
<span class="fc" id="L2916">                    TableUtils.renameOrFail(ff, srcPath, dstPath);</span>
<span class="fc" id="L2917">                    LOG.info().$(&quot;backup complete [table=&quot;).utf8(tableName).$(&quot;, to=&quot;).$(dstPath).I$();</span>
                } finally {
<span class="fc" id="L2919">                    dstPath.trimTo(renameRootLen).$();</span>
                }
<span class="fc" id="L2921">            } catch (CairoException e) {</span>
<span class="fc" id="L2922">                LOG.info()</span>
<span class="fc" id="L2923">                        .$(&quot;could not backup [table=&quot;).utf8(tableName)</span>
<span class="fc" id="L2924">                        .$(&quot;, ex=&quot;).$(e.getFlyweightMessage())</span>
<span class="fc" id="L2925">                        .$(&quot;, errno=&quot;).$(e.getErrno())</span>
<span class="fc" id="L2926">                        .$(']').$();</span>

<span class="fc" id="L2928">                srcPath.of(cachedTmpBackupRoot).concat(tableToken.getDirName()).slash$();</span>
                int errno;
<span class="pc bpc" id="L2930" title="1 of 2 branches missed.">                if ((errno = ff.rmdir(srcPath)) != 0) {</span>
<span class="nc" id="L2931">                    LOG.error().$(&quot;could not delete directory [path=&quot;).utf8(srcPath).$(&quot;, errno=&quot;).$(errno).I$();</span>
                }
<span class="fc" id="L2933">                throw e;</span>
<span class="fc" id="L2934">            }</span>
<span class="fc" id="L2935">        }</span>

        private void cdConfRenamePath() {
<span class="fc" id="L2938">            mkdir(PropServerConfiguration.CONFIG_DIRECTORY, &quot;could not create backup [conf dir=&quot;);</span>
<span class="fc" id="L2939">        }</span>

        private void cdDbRenamePath() {
<span class="fc" id="L2942">            mkdir(configuration.getDbDirectory(), &quot;could not create backup [db dir=&quot;);</span>
<span class="fc" id="L2943">        }</span>

        private void cloneMetaData(CharSequence tableName, CharSequence backupRoot, int mkDirMode, TableReader reader) {
<span class="fc" id="L2946">            TableToken tableToken = engine.getTableToken(tableName);</span>
<span class="fc" id="L2947">            srcPath.of(backupRoot).concat(tableToken).slash$();</span>

<span class="fc bfc" id="L2949" title="All 2 branches covered.">            if (ff.exists(srcPath)) {</span>
<span class="fc" id="L2950">                throw CairoException.nonCritical().put(&quot;Backup dir for table \&quot;&quot;).put(tableName).put(&quot;\&quot; already exists [dir=&quot;).put(srcPath).put(']');</span>
            }

<span class="pc bpc" id="L2953" title="1 of 2 branches missed.">            if (ff.mkdirs(srcPath, mkDirMode) != 0) {</span>
<span class="nc" id="L2954">                throw CairoException.critical(ff.errno()).put(&quot;Could not create [dir=&quot;).put(srcPath).put(']');</span>
            }

<span class="fc" id="L2957">            int rootLen = srcPath.length();</span>

<span class="fc" id="L2959">            TableReaderMetadata sourceMetaData = reader.getMetadata();</span>
            try {
<span class="fc" id="L2961">                mem.smallFile(ff, srcPath.trimTo(rootLen).concat(TableUtils.META_FILE_NAME).$(), MemoryTag.MMAP_DEFAULT);</span>
<span class="fc" id="L2962">                sourceMetaData.dumpTo(mem);</span>

                // create symbol maps
<span class="fc" id="L2965">                srcPath.trimTo(rootLen).$();</span>
<span class="fc" id="L2966">                int symbolMapCount = 0;</span>
<span class="fc bfc" id="L2967" title="All 2 branches covered.">                for (int i = 0, sz = sourceMetaData.getColumnCount(); i &lt; sz; i++) {</span>
<span class="fc bfc" id="L2968" title="All 2 branches covered.">                    if (ColumnType.isSymbol(sourceMetaData.getColumnType(i))) {</span>
<span class="fc" id="L2969">                        SymbolMapReader mapReader = reader.getSymbolMapReader(i);</span>
<span class="fc" id="L2970">                        MapWriter.createSymbolMapFiles(ff, mem, srcPath, sourceMetaData.getColumnName(i), COLUMN_NAME_TXN_NONE, mapReader.getSymbolCapacity(), mapReader.isCached());</span>
<span class="fc" id="L2971">                        symbolMapCount++;</span>
                    }
                }
<span class="fc" id="L2974">                mem.smallFile(ff, srcPath.trimTo(rootLen).concat(TableUtils.TXN_FILE_NAME).$(), MemoryTag.MMAP_DEFAULT);</span>
<span class="fc" id="L2975">                TableUtils.createTxn(mem, symbolMapCount, 0L, 0L, TableUtils.INITIAL_TXN, 0L, sourceMetaData.getStructureVersion(), 0L, 0L);</span>

<span class="fc" id="L2977">                mem.smallFile(ff, srcPath.trimTo(rootLen).concat(TableUtils.COLUMN_VERSION_FILE_NAME).$(), MemoryTag.MMAP_DEFAULT);</span>
<span class="fc" id="L2978">                TableUtils.createColumnVersionFile(mem);</span>
<span class="fc" id="L2979">                srcPath.trimTo(rootLen).concat(TableUtils.TXN_SCOREBOARD_FILE_NAME).$();</span>
            } finally {
<span class="fc" id="L2981">                mem.close();</span>
            }
<span class="fc" id="L2983">        }</span>

        private void mkdir(CharSequence dir, String errorMessage) {
<span class="fc" id="L2986">            dstPath.trimTo(changeDirPrefixLen).concat(dir).slash$();</span>
<span class="fc" id="L2987">            currDirPrefixLen = dstPath.length();</span>
<span class="fc bfc" id="L2988" title="All 2 branches covered.">            if (ff.mkdirs(dstPath, configuration.getBackupMkDirMode()) != 0) {</span>
<span class="fc" id="L2989">                throw CairoException.critical(ff.errno()).put(errorMessage).put(dstPath).put(']');</span>
            }
<span class="fc" id="L2991">        }</span>

        private void setupBackupRenamePath() {
<span class="fc" id="L2994">            DateFormat format = configuration.getBackupDirTimestampFormat();</span>
<span class="fc" id="L2995">            long epochMicros = configuration.getMicrosecondClock().getTicks();</span>
<span class="fc" id="L2996">            int n = 0;</span>
            // There is a race here, two threads could try and create the same backupRenamePath,
            // only one will succeed the other will throw a CairoException. Maybe it should be serialised
<span class="fc" id="L2999">            dstPath.of(configuration.getBackupRoot()).slash();</span>
<span class="fc" id="L3000">            int plen = dstPath.length();</span>
            do {
<span class="fc" id="L3002">                dstPath.trimTo(plen);</span>
<span class="fc" id="L3003">                format.format(epochMicros, configuration.getDefaultDateLocale(), null, dstPath);</span>
<span class="fc bfc" id="L3004" title="All 2 branches covered.">                if (n &gt; 0) {</span>
<span class="fc" id="L3005">                    dstPath.put('.').put(n);</span>
                }
<span class="fc" id="L3007">                dstPath.slash$();</span>
<span class="fc" id="L3008">                n++;</span>
<span class="fc bfc" id="L3009" title="All 2 branches covered.">            } while (ff.exists(dstPath));</span>

<span class="pc bpc" id="L3011" title="1 of 2 branches missed.">            if (ff.mkdirs(dstPath, configuration.getBackupMkDirMode()) != 0) {</span>
<span class="nc" id="L3012">                throw CairoException.critical(ff.errno()).put(&quot;could not create backup [dir=&quot;).put(dstPath).put(']');</span>
            }
<span class="fc" id="L3014">            changeDirPrefixLen = dstPath.length();</span>
<span class="fc" id="L3015">        }</span>

        private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L3018">            executionContext.getCairoSecurityContext().checkWritePermission();</span>
<span class="fc bfc" id="L3019" title="All 2 branches covered.">            if (null == configuration.getBackupRoot()) {</span>
<span class="fc" id="L3020">                throw CairoException.nonCritical().put(&quot;Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]&quot;);</span>
            }
<span class="fc" id="L3022">            final CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="pc bpc" id="L3023" title="1 of 2 branches missed.">            if (null != tok) {</span>
<span class="fc bfc" id="L3024" title="All 2 branches covered.">                if (isTableKeyword(tok)) {</span>
<span class="fc" id="L3025">                    return sqlTableBackup(executionContext);</span>
                }
<span class="fc bfc" id="L3027" title="All 2 branches covered.">                if (isDatabaseKeyword(tok)) {</span>
<span class="fc" id="L3028">                    return sqlDatabaseBackup(executionContext);</span>
                }
            }
<span class="fc" id="L3031">            throw SqlException.position(lexer.lastTokenPosition()).put(&quot;expected 'table' or 'database'&quot;);</span>
        }

        private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) {
<span class="fc" id="L3035">            currentExecutionContext = executionContext;</span>
            try {
<span class="fc" id="L3037">                setupBackupRenamePath();</span>
<span class="fc" id="L3038">                cdDbRenamePath();</span>
<span class="fc" id="L3039">                engine.getTableTokens(tableTokenBucket, false);</span>
<span class="fc bfc" id="L3040" title="All 2 branches covered.">                for (int i = 0, n = tableTokenBucket.size(); i &lt; n; i++) {</span>
<span class="fc" id="L3041">                    backupTable(tableTokenBucket.getQuick(i), executionContext);</span>
                }
<span class="fc" id="L3043">                backupTabIndexFile();</span>
<span class="fc" id="L3044">                cdConfRenamePath();</span>
<span class="fc" id="L3045">                ff.iterateDir(srcPath.of(configuration.getConfRoot()).$(), confFilesBackupOnFind);</span>
<span class="fc" id="L3046">                return compiledQuery.ofBackupTable();</span>
            } finally {
<span class="fc" id="L3048">                currentExecutionContext = null;</span>
            }
        }

        private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L3053">            setupBackupRenamePath();</span>
<span class="fc" id="L3054">            cdDbRenamePath();</span>

            try {
<span class="fc" id="L3057">                tableNames.clear();</span>
                while (true) {
<span class="fc" id="L3059">                    CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L3060" title="All 2 branches covered.">                    if (null == tok) {</span>
<span class="fc" id="L3061">                        throw SqlException.position(lexer.getPosition()).put(&quot;expected a table name&quot;);</span>
                    }
<span class="fc" id="L3063">                    final CharSequence tableName = GenericLexer.assertNoDotsAndSlashes(GenericLexer.unquote(tok), lexer.lastTokenPosition());</span>
<span class="fc" id="L3064">                    TableToken tableToken = tableExistsOrFail(lexer.lastTokenPosition(), tableName, executionContext);</span>
<span class="fc" id="L3065">                    tableNames.add(tableToken);</span>

<span class="fc" id="L3067">                    tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L3068" title="All 4 branches covered.">                    if (null == tok || Chars.equals(tok, ';')) {</span>
<span class="fc" id="L3069">                        break;</span>
                    }
<span class="fc bfc" id="L3071" title="All 2 branches covered.">                    if (!Chars.equals(tok, ',')) {</span>
<span class="fc" id="L3072">                        throw SqlException.position(lexer.lastTokenPosition()).put(&quot;expected ','&quot;);</span>
                    }
<span class="fc" id="L3074">                }</span>

<span class="fc bfc" id="L3076" title="All 2 branches covered.">                for (int n = 0; n &lt; tableNames.size(); n++) {</span>
<span class="fc" id="L3077">                    backupTable(tableNames.get(n), executionContext);</span>
                }

<span class="fc" id="L3080">                return compiledQuery.ofBackupTable();</span>
            } finally {
<span class="fc" id="L3082">                tableNames.clear();</span>
            }
        }
    }

    static {
<span class="fc" id="L3088">        castGroups.extendAndSet(ColumnType.BOOLEAN, 2);</span>
<span class="fc" id="L3089">        castGroups.extendAndSet(ColumnType.BYTE, 1);</span>
<span class="fc" id="L3090">        castGroups.extendAndSet(ColumnType.SHORT, 1);</span>
<span class="fc" id="L3091">        castGroups.extendAndSet(ColumnType.CHAR, 1);</span>
<span class="fc" id="L3092">        castGroups.extendAndSet(ColumnType.INT, 1);</span>
<span class="fc" id="L3093">        castGroups.extendAndSet(ColumnType.LONG, 1);</span>
<span class="fc" id="L3094">        castGroups.extendAndSet(ColumnType.FLOAT, 1);</span>
<span class="fc" id="L3095">        castGroups.extendAndSet(ColumnType.DOUBLE, 1);</span>
<span class="fc" id="L3096">        castGroups.extendAndSet(ColumnType.DATE, 1);</span>
<span class="fc" id="L3097">        castGroups.extendAndSet(ColumnType.TIMESTAMP, 1);</span>
<span class="fc" id="L3098">        castGroups.extendAndSet(ColumnType.STRING, 3);</span>
<span class="fc" id="L3099">        castGroups.extendAndSet(ColumnType.SYMBOL, 3);</span>
<span class="fc" id="L3100">        castGroups.extendAndSet(ColumnType.BINARY, 4);</span>

<span class="fc" id="L3102">        sqlControlSymbols.add(&quot;(&quot;);</span>
<span class="fc" id="L3103">        sqlControlSymbols.add(&quot;;&quot;);</span>
<span class="fc" id="L3104">        sqlControlSymbols.add(&quot;)&quot;);</span>
<span class="fc" id="L3105">        sqlControlSymbols.add(&quot;,&quot;);</span>
<span class="fc" id="L3106">        sqlControlSymbols.add(&quot;/*&quot;);</span>
<span class="fc" id="L3107">        sqlControlSymbols.add(&quot;*/&quot;);</span>
<span class="fc" id="L3108">        sqlControlSymbols.add(&quot;--&quot;);</span>
<span class="fc" id="L3109">        sqlControlSymbols.add(&quot;[&quot;);</span>
<span class="fc" id="L3110">        sqlControlSymbols.add(&quot;]&quot;);</span>
<span class="fc" id="L3111">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>