<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DirectLongList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.std</a> &gt; <span class="el_source">DirectLongList.java</span></div><h1>DirectLongList.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.std;

import io.questdb.cairo.Reopenable;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.str.CharSink;

import java.io.Closeable;

public class DirectLongList implements Mutable, Closeable, Reopenable {

<span class="fc" id="L36">    private static final Log LOG = LogFactory.getLog(DirectLongList.class);</span>
    private final long initialCapacity;
    private final int memoryTag;
    private long address;
    private long capacity;
    private long limit;
    private long pos;
    private long start;

<span class="fc" id="L45">    public DirectLongList(long capacity, int memoryTag) {</span>
<span class="fc" id="L46">        this.memoryTag = memoryTag;</span>
<span class="fc" id="L47">        this.capacity = (capacity * Long.BYTES);</span>
<span class="fc" id="L48">        this.address = Unsafe.malloc(this.capacity, memoryTag);</span>
<span class="fc" id="L49">        this.start = this.pos = address;</span>
<span class="fc" id="L50">        this.limit = pos + this.capacity;</span>
<span class="fc" id="L51">        this.initialCapacity = this.capacity;</span>
<span class="fc" id="L52">    }</span>

    public void add(long x) {
<span class="fc" id="L55">        ensureCapacity();</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        assert pos &lt; limit;</span>
<span class="fc" id="L57">        Unsafe.getUnsafe().putLong(pos, x);</span>
<span class="fc" id="L58">        pos += Long.BYTES;</span>
<span class="fc" id="L59">    }</span>

    public final void add(DirectLongList that) {
<span class="fc" id="L62">        long thatSize = that.pos - that.start;</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if (limit - pos &lt; thatSize) {</span>
<span class="fc" id="L64">            setCapacityBytes(this.capacity + thatSize - (limit - pos));</span>
        }
<span class="fc" id="L66">        Vect.memcpy(this.pos, that.start, thatSize);</span>
<span class="fc" id="L67">        this.pos += thatSize;</span>
<span class="fc" id="L68">    }</span>

    public long binarySearch(long value, int scanDir) {
<span class="fc" id="L71">        final long high = (pos - start) / 8;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (high &gt; 0) {</span>
<span class="fc" id="L73">            return Vect.binarySearch64Bit(start, value, 0, high - 1, scanDir);</span>
        }
<span class="fc" id="L75">        return -1;</span>
    }

    // clear without &quot;zeroing&quot; memory
    public void clear() {
<span class="fc" id="L80">        pos = start;</span>
<span class="fc" id="L81">    }</span>

    public void clear(long b) {
<span class="fc" id="L84">        zero(b);</span>
<span class="fc" id="L85">        pos = start;</span>
<span class="fc" id="L86">    }</span>

    @Override
    public void close() {
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (address != 0) {</span>
<span class="fc" id="L91">            Unsafe.free(address, capacity, memoryTag);</span>
<span class="fc" id="L92">            address = 0;</span>
<span class="fc" id="L93">            start = 0;</span>
<span class="fc" id="L94">            limit = 0;</span>
<span class="fc" id="L95">            pos = 0;</span>
<span class="fc" id="L96">            capacity = 0;</span>
        }
<span class="fc" id="L98">    }</span>

    public long get(long p) {
<span class="fc" id="L101">        return Unsafe.getUnsafe().getLong(start + (p &lt;&lt; 3));</span>
    }

    // base address of native memory
    public long getAddress() {
<span class="fc" id="L106">        return address;</span>
    }

    // capacity in LONGs
    public long getCapacity() {
<span class="fc" id="L111">        return capacity / Long.BYTES;</span>
    }

    @Override
    public void reopen() {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (address == 0) {</span>
<span class="nc" id="L117">            resetCapacity();</span>
        }
<span class="nc" id="L119">    }</span>

    public void resetCapacity() {
<span class="fc" id="L122">        setCapacityBytes(initialCapacity);</span>
<span class="fc" id="L123">    }</span>

    public long scanSearch(long v, long low, long high) {
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        for (long i = low; i &lt; high; i++) {</span>
<span class="fc" id="L127">            long f = get(i);</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (f == v) {</span>
<span class="fc" id="L129">                return i;</span>
            }
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">            if (f &gt; v) {</span>
<span class="nc" id="L132">                return -(i + 1);</span>
            }
        }
<span class="nc" id="L135">        return -(high + 1);</span>
    }

    public void set(long p, long v) {
<span class="pc bpc" id="L139" title="2 of 4 branches missed.">        assert p &gt;= 0 &amp;&amp; p &lt;= (limit - start) &gt;&gt; 3;</span>
<span class="fc" id="L140">        Unsafe.getUnsafe().putLong(start + (p &lt;&lt; 3), v);</span>
<span class="fc" id="L141">    }</span>

    // desired capacity in LONGs (not count of bytes)
    public void setCapacity(long capacity) {
<span class="fc" id="L145">        setCapacityBytes(capacity * Long.BYTES);</span>
<span class="fc" id="L146">    }</span>

    public void setPos(long p) {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        assert p * Long.BYTES &lt;= capacity;</span>
<span class="fc" id="L150">        pos = start + p * Long.BYTES;</span>
<span class="fc" id="L151">    }</span>

    public void shrink(long newCapacity) {
        // deallocates memory but keeps reusable
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (newCapacity &lt; capacity) {</span>
<span class="fc" id="L156">            setCapacityBytes(newCapacity &lt;&lt; 3);</span>
        }
<span class="fc" id="L158">    }</span>

    public long size() {
<span class="fc" id="L161">        return (int) ((pos - start) / Long.BYTES);</span>
    }

    public void sortAsUnsigned() {
<span class="fc" id="L165">        Vect.sortULongAscInPlace(address, size());</span>
<span class="fc" id="L166">    }</span>

    @Override
    public String toString() {
<span class="fc" id="L170">        CharSink sb = Misc.getThreadLocalBuilder();</span>
<span class="fc" id="L171">        sb.put('{');</span>
<span class="fc" id="L172">        final int maxElementsToPrint = 1000; // Do not try to print too much, it can hang IntelliJ debugger.</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (int i = 0, n = (int) Math.min(maxElementsToPrint, size()); i &lt; n; i++) {</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (i &gt; 0) {</span>
<span class="fc" id="L175">                sb.put(',').put(' ');</span>
            }
<span class="fc" id="L177">            sb.put(get(i));</span>
        }
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (size() &gt; maxElementsToPrint) {</span>
<span class="fc" id="L180">            sb.put(&quot;, .. &quot;);</span>
        }
<span class="fc" id="L182">        sb.put('}');</span>
<span class="fc" id="L183">        return sb.toString();</span>
    }

    public void zero(long v) {
<span class="fc" id="L187">        Vect.memset(start, pos - start, (int) v);</span>
<span class="fc" id="L188">    }</span>

    // desired capacity in bytes (not count of LONG values)
    private void setCapacityBytes(long capacity) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (this.capacity != capacity) {</span>
<span class="fc" id="L193">            final long oldCapacity = this.capacity;</span>
<span class="fc" id="L194">            this.capacity = capacity;</span>
<span class="fc" id="L195">            long address = Unsafe.realloc(this.address, oldCapacity, capacity, memoryTag);</span>
<span class="fc" id="L196">            this.pos = address + (this.pos - this.start);</span>
<span class="fc" id="L197">            this.address = address;</span>
<span class="fc" id="L198">            this.start = address;</span>
<span class="fc" id="L199">            this.limit = address + capacity;</span>
<span class="fc" id="L200">            LOG.debug().$(&quot;resized [old=&quot;).$(oldCapacity).$(&quot;, new=&quot;).$(this.capacity).$(']').$();</span>
        }
<span class="fc" id="L202">    }</span>

    void ensureCapacity() {
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (this.pos &lt; limit) {</span>
<span class="fc" id="L206">            return;</span>
        }
<span class="fc" id="L208">        setCapacityBytes(this.capacity * 2);</span>
<span class="fc" id="L209">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>