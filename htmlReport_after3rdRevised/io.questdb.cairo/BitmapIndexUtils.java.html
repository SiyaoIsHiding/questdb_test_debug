<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BitmapIndexUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">BitmapIndexUtils.java</span></div><h1>BitmapIndexUtils.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.cairo.vm.api.MemoryR;
import io.questdb.std.str.Path;

import static io.questdb.cairo.TableUtils.COLUMN_NAME_TXN_NONE;

<span class="nc" id="L32">public final class BitmapIndexUtils {</span>
    static final int KEY_ENTRY_OFFSET_COUNT_CHECK = 24;
    static final int KEY_ENTRY_OFFSET_FIRST_VALUE_BLOCK_OFFSET = 8;
    static final int KEY_ENTRY_OFFSET_LAST_VALUE_BLOCK_OFFSET = 16;
    static final int KEY_ENTRY_OFFSET_VALUE_COUNT = 0;
    static final long KEY_ENTRY_SIZE = 32;
    /**
     * key file header offsets
     */
    static final int KEY_FILE_RESERVED = 64;
    static final int KEY_RESERVED_OFFSET_BLOCK_VALUE_COUNT = 17;
    static final int KEY_RESERVED_OFFSET_KEY_COUNT = 21;
    static final int KEY_RESERVED_OFFSET_SEQUENCE = 1;
    static final int KEY_RESERVED_OFFSET_SEQUENCE_CHECK = 29;
    static final int KEY_RESERVED_OFFSET_SIGNATURE = 0;
    static final int KEY_RESERVED_OFFSET_VALUE_MEM_SIZE = 9;
    static final byte SIGNATURE = (byte) 0xfa;
    static final int VALUE_BLOCK_FILE_RESERVED = 16;

    public static Path keyFileName(Path path, CharSequence name, long columnNameTxn) {
<span class="fc" id="L52">        path.concat(name).put(&quot;.k&quot;);</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">        if (columnNameTxn &gt; COLUMN_NAME_TXN_NONE) {</span>
<span class="fc" id="L54">            path.put('.').put(columnNameTxn);</span>
        }
<span class="fc" id="L56">        return path.$();</span>
    }

    public static Path valueFileName(Path path, CharSequence name, long columnNameTxn) {
<span class="fc" id="L60">        path.concat(name).put(&quot;.v&quot;);</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (columnNameTxn &gt; COLUMN_NAME_TXN_NONE) {</span>
<span class="fc" id="L62">            path.put('.').put(columnNameTxn);</span>
        }
<span class="fc" id="L64">        return path.$();</span>
    }

    static long getKeyEntryOffset(int key) {
<span class="fc" id="L68">        return key * KEY_ENTRY_SIZE + KEY_FILE_RESERVED;</span>
    }

    /**
     * Searches ordered list of long values. Return value is either index behind matching value in the list or
     * index of where values would be inserted in order to maintain ascending order of the list. When list
     * contains duplicate values the index would be behind group of duplicate values. In this example list:
     * &lt;p&gt;
     * 1,1,2,2,2,2,5,5,5
     * &lt;p&gt;
     * when we search for 2, the index would be here:
     * &lt;p&gt;
     * 1,1,2,2,2,2,5,5,5
     * ^
     * &lt;p&gt;
     * Same index will be returned when we search for value of 3.
     * &lt;p&gt;
     * This method is meant to search for the position of a rowid (value), 100% guaranteed to exist, otherwise
     * it means the index is corrupt.
     *
     * @param memory    virtual memory instance
     * @param offset    offset in virtual memory
     * @param cellCount length of the available memory measured in 64-bit cells
     * @param value     value we search of
     * @return index directly behind the searched value or group of values if list contains duplicate values
     * @throws CairoException when the index is corrupted
     */
    static long searchValueBlock(MemoryR memory, long offset, long cellCount, long value) {
        // when block is &quot;small&quot;, we just scan it linearly
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (cellCount &lt; 64) {</span>
            // this will definitely exit because we had checked that at least the last value is greater than value
<span class="fc bfc" id="L99" title="All 2 branches covered.">            for (long i = offset, limit = memory.size(); i &lt; limit; i += 8) {</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">                if (memory.getLong(i) &gt; value) {</span>
<span class="fc" id="L101">                    return (i - offset) / 8;</span>
                }
            }
        } else {
            // use binary search on larger block
<span class="fc" id="L106">            long low = 0;</span>
<span class="fc" id="L107">            long high = cellCount - 1;</span>
            long half;
            long pivot;
            do {
<span class="fc" id="L111">                half = (high - low) / 2;</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">                if (half == 0) {</span>
<span class="fc" id="L113">                    break;</span>
                }
<span class="fc" id="L115">                pivot = memory.getLong(offset + (low + half) * 8);</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">                if (pivot &lt;= value) {</span>
<span class="fc" id="L117">                    low += half;</span>
                } else {
<span class="fc" id="L119">                    high = low + half;</span>
                }
<span class="fc" id="L121">            } while (true);</span>

<span class="fc" id="L123">            return low + 1;</span>
        }
<span class="fc" id="L125">        throw CairoException.critical(0)</span>
<span class="fc" id="L126">                .put(&quot;index is corrupt, rowid not found [offset=&quot;).put(offset)</span>
<span class="fc" id="L127">                .put(&quot;, cellCount=&quot;).put(cellCount)</span>
<span class="fc" id="L128">                .put(&quot;, value=&quot;).put(value)</span>
<span class="fc" id="L129">                .put(']');</span>
    }

    /**
     * Seeks first block that contains first value, which is greater or equal to minValue.
     * It starts from first block in the list and proceeds moving right until it finds
     * block with low and high values surrounding minValue.
     * &lt;p&gt;
     * The found block is then binary searched to count values that are all greater or
     * equal than minValue.
     * &lt;p&gt;
     * Unlike seekValueBlockRTL, this method does a boundary check over the valueMem size.
     *
     * @param totalCount            total count of values in all blocks;
     *                              *important note*: initialCount may include blocks that exceed the file boundary
     * @param firstValueBlockOffset offset of first block in linked list
     * @param valueMem              value block memory
     * @param minValue              lower limit for values
     * @param blockValueCountMod    number of values in single block - 1
     * @param seeker                interface that collects results of the search
     */
    static void seekValueBlockLTR(
            long totalCount,
            long firstValueBlockOffset,
            MemoryR valueMem,
            long minValue,
            long blockValueCountMod,
            ValueBlockSeeker seeker
    ) {
<span class="fc" id="L158">        long valueCount = totalCount;</span>
<span class="fc" id="L159">        long valueBlockOffset = firstValueBlockOffset;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (firstValueBlockOffset &gt;= valueMem.size()) {</span>
            // The very first block is beyond the memory boundary. Report that we didn't find the value by
            // using the total count of values in the seeker call.
<span class="fc" id="L163">            seeker.seek(totalCount, firstValueBlockOffset);</span>
<span class="fc" id="L164">            return;</span>
        }
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (valueCount &gt; 0) {</span>
            long cellCount;
            do {
                // check block range by peeking at first and last value
<span class="fc bfc" id="L170" title="All 2 branches covered.">                if (valueCount &gt; blockValueCountMod) {</span>
<span class="fc" id="L171">                    cellCount = blockValueCountMod + 1;</span>
                } else {
<span class="fc" id="L173">                    cellCount = valueCount;</span>
                }
<span class="fc" id="L175">                final long hi = valueMem.getLong(valueBlockOffset + (cellCount - 1) * 8);</span>

                // can we skip this block?
<span class="fc bfc" id="L178" title="All 2 branches covered.">                if (hi &lt; minValue) {</span>
<span class="fc" id="L179">                    valueCount -= cellCount;</span>
                    // do we have next block?
<span class="fc bfc" id="L181" title="All 2 branches covered.">                    if (valueCount &gt; 0) {</span>
<span class="fc" id="L182">                        final long nextBlockOffset = (blockValueCountMod + 1) * 8 + 8;</span>
<span class="fc" id="L183">                        valueBlockOffset = valueMem.getLong(valueBlockOffset + nextBlockOffset);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                        if (valueBlockOffset &gt;= valueMem.size()) {</span>
                            // We've reached the memory boundary. Report that we didn't find the value by
                            // using the total count of values in the seeker call.
<span class="fc" id="L187">                            seeker.seek(totalCount, valueBlockOffset);</span>
<span class="fc" id="L188">                            return;</span>
                        }
                        continue;
                    }
                }
                break;
            } while (true);

<span class="fc bfc" id="L196" title="All 2 branches covered.">            if (valueCount &gt; 0) {</span>
                // do we need to search this block?
<span class="fc" id="L198">                final long lo = valueMem.getLong(valueBlockOffset);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">                if (minValue &gt; lo) {</span>
                    // yes, we do
<span class="fc" id="L201">                    valueCount -= searchValueBlock(valueMem, valueBlockOffset, cellCount, minValue - 1);</span>
                }
            }
        }
<span class="fc" id="L205">        seeker.seek(totalCount - valueCount, valueBlockOffset);</span>
<span class="fc" id="L206">    }</span>

    /**
     * Seeks index value block for rows &lt;= maxValue. It starts from append block, which is the last block in
     * the list, and proceeds moving left until it finds block with low and high values surrounding maxValue.
     * This block is then binary searched to count values that are less or equal than maxValue.
     * &lt;p&gt;
     * List of value blocks is assumed to be ordered by value in ascending order.
     *
     * @param valueCount         total count of values in all blocks
     * @param blockOffset        offset of last value block in chain of blocks
     * @param valueMem           value block memory
     * @param maxValue           upper limit for block values
     * @param blockValueCountMod number of values in single block - 1
     * @param seeker             interface that collects results of the search
     */
    static void seekValueBlockRTL(
            long valueCount,
            long blockOffset,
            MemoryR valueMem,
            long maxValue,
            long blockValueCountMod,
            ValueBlockSeeker seeker
    ) {
<span class="fc" id="L230">        long valueBlockOffset = blockOffset;</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (valueCount &gt; 0) {</span>
<span class="fc" id="L232">            long prevBlockOffset = (blockValueCountMod + 1) * 8;</span>
            long cellCount;
            do {
                // check block range by peeking at first and last value
<span class="fc" id="L236">                long lo = valueMem.getLong(valueBlockOffset);</span>
<span class="fc" id="L237">                cellCount = (valueCount - 1 &amp; blockValueCountMod) + 1;</span>

                // can we skip this block?
<span class="fc bfc" id="L240" title="All 2 branches covered.">                if (lo &gt; maxValue) {</span>
<span class="fc" id="L241">                    valueCount -= cellCount;</span>
                    // do we have previous block?
<span class="fc bfc" id="L243" title="All 2 branches covered.">                    if (valueCount &gt; 0) {</span>
<span class="fc" id="L244">                        valueBlockOffset = valueMem.getLong(valueBlockOffset + prevBlockOffset);</span>
<span class="fc" id="L245">                        continue;</span>
                    }
                }
                break;
            } while (true);

<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (valueCount &gt; 0) {</span>
                // do we need to search this block?
<span class="fc" id="L253">                long hi = valueMem.getLong(valueBlockOffset + (cellCount - 1) * 8);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">                if (maxValue &lt; hi) {</span>
                    // yes, we do
<span class="fc" id="L256">                    valueCount -= cellCount - searchValueBlock(valueMem, valueBlockOffset, cellCount, maxValue);</span>
                }
            }
        }
<span class="fc" id="L260">        seeker.seek(valueCount, valueBlockOffset);</span>
<span class="fc" id="L261">    }</span>

    @FunctionalInterface
    interface ValueBlockSeeker {
        void seek(long count, long offset);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>