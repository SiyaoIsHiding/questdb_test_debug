<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableReaderMetadata.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">TableReaderMetadata.java</span></div><h1>TableReaderMetadata.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.cairo.sql.TableRecordMetadata;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryMA;
import io.questdb.cairo.vm.api.MemoryMR;
import io.questdb.std.*;
import io.questdb.std.datetime.millitime.MillisecondClock;
import io.questdb.std.str.Path;

<span class="fc" id="L35">public class TableReaderMetadata extends AbstractRecordMetadata implements TableRecordMetadata, Mutable {</span>
    private final CairoConfiguration configuration;
    private final FilesFacade ff;
<span class="fc" id="L38">    private final LowerCaseCharSequenceIntHashMap tmpValidationMap = new LowerCaseCharSequenceIntHashMap();</span>
    private int maxUncommittedRows;
    private MemoryMR metaMem;
    private long o3MaxLag;
    private int partitionBy;
    private Path path;
    private int plen;
    private long structureVersion;
    private int tableId;
    private TableToken tableToken;
    private MemoryMR transitionMeta;
    private boolean walEnabled;

<span class="fc" id="L51">    public TableReaderMetadata(CairoConfiguration configuration, TableToken tableToken) {</span>
<span class="fc" id="L52">        this.configuration = configuration;</span>
<span class="fc" id="L53">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L54">        this.tableToken = tableToken;</span>
<span class="fc" id="L55">        this.path = new Path().of(configuration.getRoot()).concat(tableToken.getDirName());</span>
<span class="fc" id="L56">        this.plen = path.length();</span>
<span class="fc" id="L57">        this.metaMem = Vm.getMRInstance();</span>
<span class="fc" id="L58">    }</span>

    // constructor used to read random metadata files
<span class="fc" id="L61">    public TableReaderMetadata(CairoConfiguration configuration) {</span>
<span class="fc" id="L62">        this.configuration = configuration;</span>
<span class="fc" id="L63">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L64">        this.tableToken = null;</span>
<span class="fc" id="L65">        this.metaMem = Vm.getMRInstance();</span>
<span class="fc" id="L66">    }</span>

    public void applyTransitionIndex() {
        // swap meta and transitionMeta
<span class="fc" id="L70">        MemoryMR temp = this.metaMem;</span>
<span class="fc" id="L71">        this.metaMem = this.transitionMeta;</span>
<span class="fc" id="L72">        transitionMeta = temp;</span>
<span class="fc" id="L73">        transitionMeta.close(); // Memory is safe to double close, do not assign null to transitionMeta</span>
<span class="fc" id="L74">        this.columnNameIndexMap.clear();</span>
<span class="fc" id="L75">        int existingColumnCount = this.columnCount;</span>

<span class="fc" id="L77">        int columnCount = metaMem.getInt(TableUtils.META_OFFSET_COUNT);</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        assert columnCount &gt;= existingColumnCount;</span>
<span class="fc" id="L79">        columnMetadata.setPos(columnCount);</span>
<span class="fc" id="L80">        int timestampIndex = metaMem.getInt(TableUtils.META_OFFSET_TIMESTAMP_INDEX);</span>
<span class="fc" id="L81">        this.tableId = metaMem.getInt(TableUtils.META_OFFSET_TABLE_ID);</span>
<span class="fc" id="L82">        this.structureVersion = metaMem.getLong(TableUtils.META_OFFSET_STRUCTURE_VERSION);</span>
<span class="fc" id="L83">        this.maxUncommittedRows = metaMem.getInt(TableUtils.META_OFFSET_MAX_UNCOMMITTED_ROWS);</span>
<span class="fc" id="L84">        this.o3MaxLag = metaMem.getLong(TableUtils.META_OFFSET_O3_MAX_LAG);</span>
<span class="fc" id="L85">        this.walEnabled = metaMem.getBool(TableUtils.META_OFFSET_WAL_ENABLED);</span>
<span class="fc" id="L86">        long offset = TableUtils.getColumnNameOffset(columnCount);</span>

<span class="fc" id="L88">        int shiftLeft = 0, existingIndex = 0;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        for (int metaIndex = 0; metaIndex &lt; columnCount; metaIndex++) {</span>
<span class="fc" id="L90">            CharSequence name = metaMem.getStr(offset);</span>
<span class="fc" id="L91">            offset += Vm.getStorageLength(name);</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">            assert name != null;</span>
<span class="fc" id="L93">            int columnType = TableUtils.getColumnType(metaMem, metaIndex);</span>
<span class="fc" id="L94">            boolean isIndexed = TableUtils.isColumnIndexed(metaMem, metaIndex);</span>
<span class="fc" id="L95">            int indexBlockCapacity = TableUtils.getIndexBlockCapacity(metaMem, metaIndex);</span>
<span class="fc" id="L96">            TableColumnMetadata existing = null;</span>
            String newName;

<span class="fc bfc" id="L99" title="All 2 branches covered.">            if (existingIndex &lt; existingColumnCount) {</span>
<span class="fc" id="L100">                existing = columnMetadata.getQuick(existingIndex);</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">                if (existing.getWriterIndex() &gt; metaIndex) {</span>
                    // This column must be deleted so existing dense columns do not contain it
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">                    assert columnType &lt; 0;</span>
                    continue;
                }
            }
<span class="pc bpc" id="L108" title="1 of 4 branches missed.">            assert existing == null || existing.getWriterIndex() == metaIndex; // Same column</span>

            // exiting column
<span class="fc bfc" id="L111" title="All 2 branches covered.">            if (columnType &lt; 0) {</span>
<span class="fc" id="L112">                shiftLeft++;</span>
            } else {
<span class="fc bfc" id="L114" title="All 4 branches covered.">                boolean rename = existing != null &amp;&amp; !Chars.equals(existing.getName(), name);</span>
<span class="fc bfc" id="L115" title="All 4 branches covered.">                newName = rename || existing == null ? Chars.toString(name) : existing.getName();</span>
<span class="fc bfc" id="L116" title="All 4 branches covered.">                if (rename</span>
                        || existing == null
<span class="fc bfc" id="L118" title="All 2 branches covered.">                        || existing.isIndexed() != isIndexed</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">                        || existing.getIndexValueBlockCapacity() != indexBlockCapacity</span>
                ) {
<span class="fc" id="L121">                    columnMetadata.setQuick(existingIndex - shiftLeft,</span>
                            new TableColumnMetadata(
                                    newName,
                                    columnType,
                                    isIndexed,
                                    indexBlockCapacity,
                                    true,
                                    null,
                                    metaIndex
                            )
                    );
<span class="fc bfc" id="L132" title="All 2 branches covered.">                } else if (shiftLeft &gt; 0) {</span>
<span class="fc" id="L133">                    columnMetadata.setQuick(existingIndex - shiftLeft, existing);</span>
                }
<span class="fc" id="L135">                this.columnNameIndexMap.put(newName, existingIndex - shiftLeft);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">                if (timestampIndex == metaIndex) {</span>
<span class="fc" id="L137">                    this.timestampIndex = existingIndex - shiftLeft;</span>
                }
            }
<span class="fc" id="L140">            existingIndex++;</span>
        }
<span class="fc" id="L142">        columnMetadata.setPos(existingIndex - shiftLeft);</span>
<span class="fc" id="L143">        this.columnCount = columnMetadata.size();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (timestampIndex &lt; 0) {</span>
<span class="fc" id="L145">            this.timestampIndex = timestampIndex;</span>
        }
<span class="fc" id="L147">    }</span>

    @Override
    public void clear() {
<span class="fc" id="L151">        super.clear();</span>
<span class="fc" id="L152">        Misc.free(metaMem);</span>
<span class="fc" id="L153">        Misc.free(transitionMeta);</span>
<span class="fc" id="L154">    }</span>

    @Override
    public void close() {
<span class="fc" id="L158">        metaMem = Misc.free(metaMem);</span>
<span class="fc" id="L159">        path = Misc.free(path);</span>
<span class="fc" id="L160">        transitionMeta = Misc.free(transitionMeta);</span>
<span class="fc" id="L161">    }</span>

    public void copy(TableReaderMetadata metadata) {
<span class="nc" id="L164">        partitionBy = metadata.partitionBy;</span>
<span class="nc" id="L165">        tableId = metadata.tableId;</span>
<span class="nc" id="L166">        maxUncommittedRows = metadata.maxUncommittedRows;</span>
<span class="nc" id="L167">        o3MaxLag = metadata.o3MaxLag;</span>
<span class="nc" id="L168">        structureVersion = metadata.structureVersion;</span>
<span class="nc" id="L169">        walEnabled = metadata.walEnabled;</span>
<span class="nc" id="L170">        path.of(metadata.path);</span>
<span class="nc" id="L171">        timestampIndex = metadata.timestampIndex;</span>
<span class="nc" id="L172">        columnCount = metadata.columnCount;</span>
<span class="nc" id="L173">        columnMetadata.setPos(columnCount);</span>
<span class="nc" id="L174">        columnNameIndexMap.clear();</span>

<span class="nc bnc" id="L176" title="All 2 branches missed.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="nc" id="L177">            TableColumnMetadata columnMetadata = metadata.columnMetadata.getQuick(i);</span>
<span class="nc" id="L178">            this.columnMetadata.setQuick(i, new TableColumnMetadata(</span>
<span class="nc" id="L179">                    columnMetadata.getName(),</span>
<span class="nc" id="L180">                    columnMetadata.getType(),</span>
<span class="nc" id="L181">                    columnMetadata.isIndexed(),</span>
<span class="nc" id="L182">                    columnMetadata.getIndexValueBlockCapacity(),</span>
<span class="nc" id="L183">                    columnMetadata.isSymbolTableStatic(),</span>
<span class="nc" id="L184">                    columnMetadata.getMetadata(),</span>
<span class="nc" id="L185">                    columnMetadata.getWriterIndex()</span>
            ));
<span class="nc" id="L187">            columnNameIndexMap.put(columnMetadata.getName(), i);</span>
        }
<span class="nc" id="L189">    }</span>

    public long createTransitionIndex(long txnStructureVersion) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (transitionMeta == null) {</span>
<span class="fc" id="L193">            transitionMeta = Vm.getMRInstance();</span>
        }

<span class="fc" id="L196">        transitionMeta.smallFile(ff, path, MemoryTag.NATIVE_TABLE_READER);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (transitionMeta.size() &gt;= TableUtils.META_OFFSET_STRUCTURE_VERSION + 8</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">                &amp;&amp; txnStructureVersion != transitionMeta.getLong(TableUtils.META_OFFSET_STRUCTURE_VERSION)) {</span>
            // No match
<span class="fc" id="L200">            return -1;</span>
        }

<span class="fc" id="L203">        tmpValidationMap.clear();</span>
<span class="fc" id="L204">        TableUtils.validateMeta(transitionMeta, tmpValidationMap, ColumnType.VERSION);</span>
<span class="fc" id="L205">        return TableUtils.createTransitionIndex(transitionMeta, this);</span>
    }

    public void dumpTo(MemoryMA mem) {
        // Since _meta files are immutable and get updated with a single atomic rename
        // operation replacing the old file with the new one, it's ok to clone the metadata
        // by copying metaMem's contents. Even if _meta file was already replaced, the file
        // should be still kept on disk until inode's ref counter is above zero.
<span class="fc" id="L213">        long len = metaMem.size();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        for (long p = 0; p &lt; len; p++) {</span>
<span class="fc" id="L215">            mem.putByte(metaMem.getByte(p));</span>
        }
<span class="fc" id="L217">    }</span>

    @Override
    public int getColumnCount() {
<span class="fc" id="L221">        return columnCount;</span>
    }

    @Override
    public int getMaxUncommittedRows() {
<span class="fc" id="L226">        return maxUncommittedRows;</span>
    }

    @Override
    public long getO3MaxLag() {
<span class="fc" id="L231">        return o3MaxLag;</span>
    }

    public int getPartitionBy() {
<span class="fc" id="L235">        return partitionBy;</span>
    }

    @Override
    public long getStructureVersion() {
<span class="fc" id="L240">        return structureVersion;</span>
    }

    @Override
    public int getTableId() {
<span class="fc" id="L245">        return tableId;</span>
    }

    @Override
    public TableToken getTableToken() {
<span class="fc" id="L250">        return tableToken;</span>
    }

    public boolean isWalEnabled() {
<span class="fc" id="L254">        return walEnabled;</span>
    }

    public void load() {
<span class="fc" id="L258">        final long timeout = configuration.getSpinLockTimeout();</span>
<span class="fc" id="L259">        final MillisecondClock millisecondClock = configuration.getMillisecondClock();</span>
<span class="fc" id="L260">        long deadline = configuration.getMillisecondClock().getTicks() + timeout;</span>
<span class="fc" id="L261">        this.path.trimTo(plen).concat(TableUtils.META_FILE_NAME).$();</span>
<span class="fc" id="L262">        boolean existenceChecked = false;</span>
        while (true) {
            try {
<span class="fc" id="L265">                load(path);</span>
<span class="fc" id="L266">                return;</span>
<span class="fc" id="L267">            } catch (CairoException ex) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">                if (!existenceChecked) {</span>
<span class="fc" id="L269">                    path.trimTo(plen).slash$();</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">                    if (!ff.exists(path)) {</span>
<span class="nc" id="L271">                        throw CairoException.tableDoesNotExist(tableToken.getTableName());</span>
                    }
<span class="fc" id="L273">                    path.trimTo(plen).concat(TableUtils.META_FILE_NAME).$();</span>
                }
<span class="fc" id="L275">                existenceChecked = true;</span>
<span class="fc" id="L276">                TableUtils.handleMetadataLoadException(tableToken.getTableName(), deadline, ex, millisecondClock, timeout);</span>
<span class="fc" id="L277">            }</span>
        }
    }

    public void load(Path path) {
        try {
<span class="fc" id="L283">            this.metaMem.smallFile(ff, path, MemoryTag.NATIVE_TABLE_READER);</span>
<span class="fc" id="L284">            this.columnNameIndexMap.clear();</span>
<span class="fc" id="L285">            TableUtils.validateMeta(metaMem, this.columnNameIndexMap, ColumnType.VERSION);</span>
<span class="fc" id="L286">            int columnCount = metaMem.getInt(TableUtils.META_OFFSET_COUNT);</span>
<span class="fc" id="L287">            int timestampIndex = metaMem.getInt(TableUtils.META_OFFSET_TIMESTAMP_INDEX);</span>
<span class="fc" id="L288">            this.partitionBy = metaMem.getInt(TableUtils.META_OFFSET_PARTITION_BY);</span>
<span class="fc" id="L289">            this.tableId = metaMem.getInt(TableUtils.META_OFFSET_TABLE_ID);</span>
<span class="fc" id="L290">            this.maxUncommittedRows = metaMem.getInt(TableUtils.META_OFFSET_MAX_UNCOMMITTED_ROWS);</span>
<span class="fc" id="L291">            this.o3MaxLag = metaMem.getLong(TableUtils.META_OFFSET_O3_MAX_LAG);</span>
<span class="fc" id="L292">            this.structureVersion = metaMem.getLong(TableUtils.META_OFFSET_STRUCTURE_VERSION);</span>
<span class="fc" id="L293">            this.walEnabled = metaMem.getBool(TableUtils.META_OFFSET_WAL_ENABLED);</span>
<span class="fc" id="L294">            this.columnMetadata.clear();</span>
<span class="fc" id="L295">            long offset = TableUtils.getColumnNameOffset(columnCount);</span>
<span class="fc" id="L296">            this.timestampIndex = -1;</span>

            // don't create strings in this loop, we already have them in columnNameIndexMap
<span class="fc bfc" id="L299" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L300">                CharSequence name = metaMem.getStr(offset);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">                assert name != null;</span>
<span class="fc" id="L302">                int columnType = TableUtils.getColumnType(metaMem, i);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                if (columnType &gt; -1) {</span>
<span class="fc" id="L304">                    columnMetadata.add(</span>
                            new TableColumnMetadata(
<span class="fc" id="L306">                                    Chars.toString(name),</span>
                                    columnType,
<span class="fc" id="L308">                                    TableUtils.isColumnIndexed(metaMem, i),</span>
<span class="fc" id="L309">                                    TableUtils.getIndexBlockCapacity(metaMem, i),</span>
                                    true,
                                    null,
                                    i
                            )
                    );
<span class="fc bfc" id="L315" title="All 2 branches covered.">                    if (i == timestampIndex) {</span>
<span class="fc" id="L316">                        this.timestampIndex = columnMetadata.size() - 1;</span>
                    }
                }
<span class="fc" id="L319">                offset += Vm.getStorageLength(name);</span>
            }
<span class="fc" id="L321">            this.columnCount = columnMetadata.size();</span>
<span class="fc" id="L322">        } catch (Throwable e) {</span>
<span class="fc" id="L323">            clear();</span>
<span class="fc" id="L324">            throw e;</span>
<span class="fc" id="L325">        }</span>
<span class="fc" id="L326">    }</span>

    public void updateTableToken(TableToken tableToken) {
<span class="fc" id="L329">        this.tableToken = tableToken;</span>
<span class="fc" id="L330">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>