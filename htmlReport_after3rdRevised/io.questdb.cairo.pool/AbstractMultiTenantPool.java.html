<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractMultiTenantPool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo.pool</a> &gt; <span class="el_source">AbstractMultiTenantPool.java</span></div><h1>AbstractMultiTenantPool.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo.pool;

import io.questdb.cairo.CairoConfiguration;
import io.questdb.cairo.CairoException;
import io.questdb.cairo.EntryUnavailableException;
import io.questdb.cairo.TableToken;
import io.questdb.cairo.pool.ex.EntryLockedException;
import io.questdb.cairo.pool.ex.PoolClosedException;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.ConcurrentHashMap;
import io.questdb.std.Os;
import io.questdb.std.Unsafe;

import java.util.Arrays;
import java.util.Map;

public abstract class AbstractMultiTenantPool&lt;T extends PoolTenant&gt; extends AbstractPool implements ResourcePool&lt;T&gt; {
    public static final int ENTRY_SIZE = 32;
<span class="fc" id="L44">    private static final long LOCK_OWNER = Unsafe.getFieldOffset(Entry.class, &quot;lockOwner&quot;);</span>
    private static final int NEXT_ALLOCATED = 1;
    private static final int NEXT_LOCKED = 2;
    private static final int NEXT_OPEN = 0;
<span class="fc" id="L48">    private static final long NEXT_STATUS = Unsafe.getFieldOffset(Entry.class, &quot;nextStatus&quot;);</span>
    private static final long UNLOCKED = -1L;
<span class="fc" id="L50">    private final Log LOG = LogFactory.getLog(this.getClass());</span>
<span class="fc" id="L51">    private final ConcurrentHashMap&lt;Entry&lt;T&gt;&gt; entries = new ConcurrentHashMap&lt;&gt;();</span>
    private final int maxEntries;
    private final int maxSegments;

    public AbstractMultiTenantPool(CairoConfiguration configuration) {
<span class="fc" id="L56">        super(configuration, configuration.getInactiveReaderTTL());</span>
<span class="fc" id="L57">        this.maxSegments = configuration.getReaderPoolMaxSegments();</span>
<span class="fc" id="L58">        this.maxEntries = maxSegments * ENTRY_SIZE;</span>
<span class="fc" id="L59">    }</span>

    public Map&lt;CharSequence, Entry&lt;T&gt;&gt; entries() {
<span class="fc" id="L62">        return entries;</span>
    }

    @Override
    public T get(TableToken tableToken) {

<span class="fc" id="L68">        Entry&lt;T&gt; e = getEntry(tableToken);</span>

<span class="fc" id="L70">        long lockOwner = e.lockOwner;</span>
<span class="fc" id="L71">        long thread = Thread.currentThread().getId();</span>

<span class="fc bfc" id="L73" title="All 2 branches covered.">        if (lockOwner != UNLOCKED) {</span>
<span class="fc" id="L74">            LOG.info().$('\'').utf8(tableToken.getDirName()).$(&quot;' is locked [owner=&quot;).$(lockOwner).$(']').$();</span>
<span class="fc" id="L75">            throw EntryLockedException.instance(&quot;unknown&quot;);</span>
        }

        do {
<span class="fc bfc" id="L79" title="All 2 branches covered.">            for (int i = 0; i &lt; ENTRY_SIZE; i++) {</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">                if (Unsafe.cas(e.allocations, i, UNALLOCATED, thread)) {</span>
<span class="fc" id="L81">                    Unsafe.arrayPutOrdered(e.releaseOrAcquireTimes, i, clock.getTicks());</span>
                    // got lock, allocate if needed
<span class="fc" id="L83">                    T tenant = e.getTenant(i);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">                    if (tenant == null) {</span>
                        try {
<span class="fc" id="L86">                            LOG.info()</span>
<span class="fc" id="L87">                                    .$(&quot;open '&quot;).utf8(tableToken.getDirName())</span>
<span class="fc" id="L88">                                    .$(&quot;' [at=&quot;).$(e.index).$(':').$(i)</span>
<span class="fc" id="L89">                                    .I$();</span>
<span class="fc" id="L90">                            tenant = newTenant(tableToken, e, i);</span>
<span class="fc" id="L91">                        } catch (CairoException ex) {</span>
<span class="fc" id="L92">                            Unsafe.arrayPutOrdered(e.allocations, i, UNALLOCATED);</span>
<span class="fc" id="L93">                            throw ex;</span>
<span class="fc" id="L94">                        }</span>

<span class="fc" id="L96">                        e.assignTenant(i, tenant);</span>
<span class="fc" id="L97">                        notifyListener(thread, tableToken, PoolListener.EV_CREATE, e.index, i);</span>
                    } else {
<span class="fc" id="L99">                        tenant.refresh();</span>
<span class="fc" id="L100">                        notifyListener(thread, tableToken, PoolListener.EV_GET, e.index, i);</span>
                    }

<span class="fc bfc" id="L103" title="All 2 branches covered.">                    if (isClosed()) {</span>
<span class="fc" id="L104">                        e.assignTenant(i, null);</span>
<span class="fc" id="L105">                        tenant.goodbye();</span>
<span class="fc" id="L106">                        LOG.info().$('\'').utf8(tableToken.getDirName()).$(&quot;' born free&quot;).$();</span>
<span class="fc" id="L107">                        tenant.updateTableToken(tableToken);</span>
<span class="fc" id="L108">                        return tenant;</span>
                    }
<span class="fc" id="L110">                    LOG.debug().$('\'').utf8(tableToken.getDirName()).$(&quot;' is assigned [at=&quot;).$(e.index).$(':').$(i).$(&quot;, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L111">                    tenant.updateTableToken(tableToken);</span>
<span class="fc" id="L112">                    return tenant;</span>
                }
            }

<span class="fc" id="L116">            LOG.debug().$(&quot;Thread &quot;).$(thread).$(&quot; is moving to entry &quot;).$(e.index + 1).$();</span>

            // all allocated, create next entry if possible
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (Unsafe.getUnsafe().compareAndSwapInt(e, NEXT_STATUS, NEXT_OPEN, NEXT_ALLOCATED)) {</span>
<span class="fc" id="L120">                LOG.debug().$(&quot;Thread &quot;).$(thread).$(&quot; allocated entry &quot;).$(e.index + 1).$();</span>
<span class="fc" id="L121">                e.next = new Entry&lt;T&gt;(e.index + 1, clock.getTicks());</span>
            }
<span class="fc" id="L123">            e = e.next;</span>
<span class="pc bpc" id="L124" title="1 of 4 branches missed.">        } while (e != null &amp;&amp; e.index &lt; maxSegments);</span>

        // max entries exceeded
<span class="fc" id="L127">        notifyListener(thread, tableToken, PoolListener.EV_FULL, -1, -1);</span>
<span class="fc" id="L128">        LOG.info().$(&quot;could not get, busy [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, thread=&quot;).$(thread).$(&quot;, retries=&quot;).$(this.maxSegments).$(']').$();</span>
<span class="fc" id="L129">        throw EntryUnavailableException.instance(&quot;unknown&quot;);</span>
    }

    public int getBusyCount() {
<span class="fc" id="L133">        int count = 0;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (Map.Entry&lt;CharSequence, Entry&lt;T&gt;&gt; me : entries.entrySet()) {</span>
<span class="fc" id="L135">            Entry&lt;T&gt; e = me.getValue();</span>
            do {
<span class="fc bfc" id="L137" title="All 2 branches covered.">                for (int i = 0; i &lt; ENTRY_SIZE; i++) {</span>
<span class="fc bfc" id="L138" title="All 4 branches covered.">                    if (Unsafe.arrayGetVolatile(e.allocations, i) != UNALLOCATED &amp;&amp; e.getTenant(i) != null) {</span>
<span class="fc" id="L139">                        count++;</span>
                    }
                }
<span class="fc" id="L142">                e = e.next;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            } while (e != null);</span>
<span class="fc" id="L144">        }</span>
<span class="fc" id="L145">        return count;</span>
    }

    public int getMaxEntries() {
<span class="fc" id="L149">        return maxEntries;</span>
    }

    public boolean lock(TableToken tableToken) {
<span class="fc" id="L153">        Entry&lt;T&gt; e = getEntry(tableToken);</span>
<span class="fc" id="L154">        final long thread = Thread.currentThread().getId();</span>
<span class="fc bfc" id="L155" title="All 4 branches covered.">        if (Unsafe.cas(e, LOCK_OWNER, UNLOCKED, thread) || e.lockOwner == thread) {</span>
            do {
<span class="fc bfc" id="L157" title="All 2 branches covered.">                for (int i = 0; i &lt; ENTRY_SIZE; i++) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                    if (Unsafe.cas(e.allocations, i, UNALLOCATED, thread)) {</span>
<span class="fc" id="L159">                        closeTenant(thread, e, i, PoolListener.EV_LOCK_CLOSE, PoolConstants.CR_NAME_LOCK);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">                    } else if (Unsafe.arrayGetVolatile(e.allocations, i) == thread) {</span>
                        // same thread, don't need to order reads
<span class="fc bfc" id="L162" title="All 2 branches covered.">                        if (e.getTenant(i) != null) {</span>
                            // this thread has busy reader, it should close first
<span class="fc" id="L164">                            e.lockOwner = -1L;</span>
<span class="fc" id="L165">                            return false;</span>
                        }
                    } else {
<span class="fc" id="L168">                        LOG.info().$(&quot;could not lock, busy [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, at=&quot;).$(e.index).$(':').$(i).$(&quot;, owner=&quot;).$(e.allocations[i]).$(&quot;, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L169">                        e.lockOwner = -1L;</span>
<span class="fc" id="L170">                        return false;</span>
                    }
                }

                // try to prevent new entries from being created
<span class="fc bfc" id="L175" title="All 2 branches covered.">                if (e.next == null) {</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                    if (Unsafe.getUnsafe().compareAndSwapInt(e, NEXT_STATUS, NEXT_OPEN, NEXT_LOCKED)) {</span>
<span class="fc" id="L177">                        break;</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                    } else if (e.nextStatus == NEXT_ALLOCATED) {</span>
                        // now we must wait until another thread that executes a get() call
                        // assigns the newly created next entry
<span class="nc bnc" id="L181" title="All 2 branches missed.">                        while (e.next == null) {</span>
<span class="nc" id="L182">                            Os.pause();</span>
                        }
                    }
                }

<span class="fc" id="L187">                e = e.next;</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">            } while (e != null);</span>
        } else {
<span class="fc" id="L190">            LOG.error().$(&quot;' already locked [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, owner=&quot;).$(e.lockOwner).$(']').$();</span>
<span class="fc" id="L191">            notifyListener(thread, tableToken, PoolListener.EV_LOCK_BUSY, -1, -1);</span>
<span class="fc" id="L192">            return false;</span>
        }
<span class="fc" id="L194">        notifyListener(thread, tableToken, PoolListener.EV_LOCK_SUCCESS, -1, -1);</span>
<span class="fc" id="L195">        LOG.debug().$(&quot;locked [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L196">        return true;</span>
    }

    public void unlock(TableToken tableToken) {
<span class="fc" id="L200">        Entry&lt;T&gt; e = entries.get(tableToken.getDirName());</span>
<span class="fc" id="L201">        long thread = Thread.currentThread().getId();</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (e == null) {</span>
<span class="fc" id="L203">            LOG.info().$(&quot;not found, cannot unlock [table=`&quot;).$(tableToken).$(&quot;`]&quot;).$();</span>
<span class="fc" id="L204">            notifyListener(thread, tableToken, PoolListener.EV_NOT_LOCKED, -1, -1);</span>
<span class="fc" id="L205">            return;</span>
        }

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (e.lockOwner == thread) {</span>
<span class="fc" id="L209">            entries.remove(tableToken.getDirName());</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            while (e != null) {</span>
<span class="fc" id="L211">                e = e.next;</span>
            }
        } else {
<span class="fc" id="L214">            notifyListener(thread, tableToken, PoolListener.EV_NOT_LOCK_OWNER);</span>
<span class="fc" id="L215">            throw CairoException.nonCritical().put(&quot;Not the lock owner of &quot;).put(tableToken.getDirName());</span>
        }

<span class="fc" id="L218">        notifyListener(thread, tableToken, PoolListener.EV_UNLOCKED, -1, -1);</span>
<span class="fc" id="L219">        LOG.debug().$(&quot;unlocked [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`]&quot;).$();</span>
<span class="fc" id="L220">    }</span>

    private void checkClosed() {
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (isClosed()) {</span>
<span class="fc" id="L224">            LOG.info().$(&quot;is closed&quot;).$();</span>
<span class="fc" id="L225">            throw PoolClosedException.INSTANCE;</span>
        }
<span class="fc" id="L227">    }</span>

    private void closeTenant(long thread, Entry&lt;T&gt; entry, int index, short ev, int reason) {
<span class="fc" id="L230">        T tenant = entry.getTenant(index);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (tenant != null) {</span>
<span class="fc" id="L232">            tenant.goodbye();</span>
<span class="fc" id="L233">            tenant.close();</span>
<span class="fc" id="L234">            LOG.info().$(&quot;closed '&quot;).utf8(tenant.getTableToken().getDirName())</span>
<span class="fc" id="L235">                    .$(&quot;' [at=&quot;).$(entry.index).$(':').$(index)</span>
<span class="fc" id="L236">                    .$(&quot;, reason=&quot;).$(PoolConstants.closeReasonText(reason))</span>
<span class="fc" id="L237">                    .I$();</span>
<span class="fc" id="L238">            notifyListener(thread, tenant.getTableToken(), ev, entry.index, index);</span>
<span class="fc" id="L239">            entry.assignTenant(index, null);</span>
        }
<span class="fc" id="L241">    }</span>

    private Entry&lt;T&gt; getEntry(TableToken name) {
<span class="fc" id="L244">        checkClosed();</span>

<span class="fc" id="L246">        Entry&lt;T&gt; e = entries.get(name.getDirName());</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (e == null) {</span>
<span class="fc" id="L248">            e = new Entry&lt;T&gt;(0, clock.getTicks());</span>
<span class="fc" id="L249">            Entry&lt;T&gt; other = entries.putIfAbsent(name.getDirName(), e);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (other != null) {</span>
<span class="fc" id="L251">                e = other;</span>
            }
        }
<span class="fc" id="L254">        return e;</span>
    }

    private void notifyListener(long thread, TableToken name, short event, int segment, int position) {
<span class="fc" id="L258">        PoolListener listener = getPoolListener();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L260">            listener.onEvent(getListenerSrc(), thread, name, event, (short) segment, (short) position);</span>
        }
<span class="fc" id="L262">    }</span>

    @Override
    protected void closePool() {
<span class="fc" id="L266">        super.closePool();</span>
<span class="fc" id="L267">        LOG.info().$(&quot;closed&quot;).$();</span>
<span class="fc" id="L268">    }</span>

    protected void expelFromPool(T tenant) {
<span class="fc" id="L271">        final Entry&lt;T&gt; e = tenant.getEntry();</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (e == null) {</span>
<span class="nc" id="L273">            return;</span>
        }

<span class="fc" id="L276">        final TableToken tableToken = tenant.getTableToken();</span>
<span class="fc" id="L277">        final long thread = Thread.currentThread().getId();</span>
<span class="fc" id="L278">        final int index = tenant.getIndex();</span>
<span class="fc" id="L279">        final long owner = Unsafe.arrayGetVolatile(e.allocations, index);</span>

<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (owner != UNALLOCATED) {</span>
<span class="fc" id="L282">            LOG.debug().$('\'').utf8(tableToken.getDirName()).$(&quot;' is expelled [at=&quot;).$(e.index).$(':').$(index).$(&quot;, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L283">            notifyListener(thread, tableToken, PoolListener.EV_OUT_OF_POOL_CLOSE, e.index, index);</span>
<span class="fc" id="L284">            e.assignTenant(index, null);</span>
<span class="fc" id="L285">            Unsafe.cas(e.allocations, index, owner, UNALLOCATED);</span>
        }
<span class="fc" id="L287">    }</span>

    protected abstract byte getListenerSrc();

    protected abstract T newTenant(TableToken tableName, Entry&lt;T&gt; entry, int index);

    @Override
    protected boolean releaseAll(long deadline) {
<span class="fc" id="L295">        long thread = Thread.currentThread().getId();</span>
<span class="fc" id="L296">        boolean removed = false;</span>
<span class="fc" id="L297">        int casFailures = 0;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        int closeReason = deadline &lt; Long.MAX_VALUE ? PoolConstants.CR_IDLE : PoolConstants.CR_POOL_CLOSE;</span>

<span class="fc" id="L300">        TableToken leftBehind = null;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        for (Entry&lt;T&gt; e : entries.values()) {</span>
            do {
<span class="fc bfc" id="L303" title="All 2 branches covered.">                for (int i = 0; i &lt; ENTRY_SIZE; i++) {</span>
                    T r;
<span class="fc bfc" id="L305" title="All 4 branches covered.">                    if (deadline &gt; Unsafe.arrayGetVolatile(e.releaseOrAcquireTimes, i) &amp;&amp; (r = e.getTenant(i)) != null) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                        if (Unsafe.cas(e.allocations, i, UNALLOCATED, thread)) {</span>
                            // check if deadline violation still holds
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">                            if (deadline &gt; e.releaseOrAcquireTimes[i]) {</span>
<span class="fc" id="L309">                                removed = true;</span>
<span class="fc" id="L310">                                closeTenant(thread, e, i, PoolListener.EV_EXPIRE, closeReason);</span>
                            }
<span class="fc" id="L312">                            Unsafe.arrayPutOrdered(e.allocations, i, UNALLOCATED);</span>
                        } else {
<span class="fc" id="L314">                            casFailures++;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">                            if (deadline == Long.MAX_VALUE) {</span>
<span class="fc" id="L316">                                r.goodbye();</span>
<span class="fc" id="L317">                                Unsafe.arrayPutOrdered(e.allocations, i, UNALLOCATED);</span>
<span class="fc" id="L318">                                LOG.info().$(&quot;shutting down. '&quot;).utf8(r.getTableToken().getDirName()).$(&quot;' is left behind&quot;).$();</span>
<span class="fc" id="L319">                                leftBehind = r.getTableToken();</span>
                            }
                        }
                    }
                }
                // this does not release the next
<span class="fc" id="L325">                e = e.next;</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">            } while (e != null);</span>
<span class="fc" id="L327">        }</span>

<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (leftBehind != null) {</span>
            // This code branch should be in tests only.
            // Release the item, to not block the pool, but throw an exception to fail the test
<span class="fc" id="L332">            throw CairoException.nonCritical().put('\'').put(leftBehind.getDirName()).put(&quot;' is left behind on pool shutdown&quot;);</span>
        }

        // when we are timing out entries the result is &quot;true&quot; if there was any work done
        // when we're closing pool, the result is true when pool is empty
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (closeReason == PoolConstants.CR_IDLE) {</span>
<span class="fc" id="L338">            return removed;</span>
        } else {
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            return casFailures == 0;</span>
        }
    }

    protected boolean returnToPool(T tenant) {
<span class="fc" id="L345">        final Entry&lt;T&gt; e = tenant.getEntry();</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (e == null) {</span>
<span class="nc" id="L347">            return false;</span>
        }

<span class="fc" id="L350">        final TableToken tableToken = tenant.getTableToken();</span>
<span class="fc" id="L351">        final long thread = Thread.currentThread().getId();</span>
<span class="fc" id="L352">        final int index = tenant.getIndex();</span>
<span class="fc" id="L353">        final long owner = Unsafe.arrayGetVolatile(e.allocations, index);</span>

<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (owner != UNALLOCATED) {</span>
<span class="fc" id="L356">            LOG.debug().$('\'').utf8(tableToken.getDirName()).$(&quot;' is back [at=&quot;).$(e.index).$(':').$(index).$(&quot;, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L357">            notifyListener(thread, tableToken, PoolListener.EV_RETURN, e.index, index);</span>

            // release the entry for anyone to pick up
<span class="fc" id="L360">            e.releaseOrAcquireTimes[index] = clock.getTicks();</span>
<span class="fc" id="L361">            Unsafe.arrayPutOrdered(e.allocations, index, UNALLOCATED);</span>
<span class="fc" id="L362">            final boolean closed = isClosed();</span>

            // When pool is closed we will race against release thread
            // to release our entry. No need to bother releasing map entry, pool is going down.
<span class="pc bpc" id="L366" title="3 of 4 branches missed.">            return !closed || !Unsafe.cas(e.allocations, index, UNALLOCATED, owner);</span>
        }

<span class="fc" id="L369">        throw CairoException.critical(0).put(&quot;double close [table=&quot;).put(tableToken.getDirName()).put(&quot;, index=&quot;).put(index).put(']');</span>
    }

    public static final class Entry&lt;T&gt; {
<span class="fc" id="L373">        private final long[] allocations = new long[ENTRY_SIZE];</span>
        private final int index;
<span class="fc" id="L375">        private final long[] releaseOrAcquireTimes = new long[ENTRY_SIZE];</span>
<span class="fc" id="L376">        @SuppressWarnings(&quot;unchecked&quot;)</span>
        private final T[] tenants = (T[]) new Object[ENTRY_SIZE];
<span class="fc" id="L378">        int nextStatus = NEXT_OPEN;</span>
<span class="fc" id="L379">        private volatile long lockOwner = -1L;</span>
        private volatile Entry&lt;T&gt; next;

<span class="fc" id="L382">        public Entry(int index, long currentMicros) {</span>
<span class="fc" id="L383">            this.index = index;</span>
<span class="fc" id="L384">            Arrays.fill(allocations, UNALLOCATED);</span>
<span class="fc" id="L385">            Arrays.fill(releaseOrAcquireTimes, currentMicros);</span>
<span class="fc" id="L386">        }</span>

        public void assignTenant(int pos, T tenant) {
<span class="fc" id="L389">            tenants[pos] = tenant;</span>
<span class="fc" id="L390">        }</span>

        public Entry&lt;T&gt; getNext() {
<span class="fc" id="L393">            return next;</span>
        }

        public long getOwnerVolatile(int pos) {
<span class="fc" id="L397">            return Unsafe.arrayGetVolatile(allocations, pos);</span>
        }

        public long getReleaseOrAcquireTime(int pos) {
<span class="fc" id="L401">            return releaseOrAcquireTimes[pos];</span>
        }

        public T getTenant(int pos) {
<span class="fc" id="L405">            return tenants[pos];</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>