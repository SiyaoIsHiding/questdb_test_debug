<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Mig607.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo.mig</a> &gt; <span class="el_source">Mig607.java</span></div><h1>Mig607.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo.mig;

import io.questdb.cairo.*;
import io.questdb.cairo.vm.MemoryCMARWImpl;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryMARW;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.FilesFacade;
import io.questdb.std.MemoryTag;
import io.questdb.std.Os;
import io.questdb.std.str.CharSink;
import io.questdb.std.str.LPSZ;
import io.questdb.std.str.Path;

import static io.questdb.cairo.TableUtils.*;

<span class="nc" id="L42">final class Mig607 {</span>
    private static final String DEFAULT_PARTITION_NAME = &quot;default&quot;;
<span class="fc" id="L44">    private static final Log LOG = LogFactory.getLog(Mig607.class);</span>
    private static final int LONGS_PER_TX_ATTACHED_PARTITION = 4;
    private static final String META_FILE_NAME = &quot;_meta&quot;;
    private static final String TXN_FILE_NAME = &quot;_txn&quot;;
    private static final long TX_OFFSET_TRANSIENT_ROW_COUNT = 8;

    public static void migrate(
            FilesFacade ff,
            Path path,
            MigrationContext migrationContext,
            MemoryMARW metaMem,
            int columnCount,
            long rowCount,
            long columnNameOffset
    ) {
<span class="fc" id="L59">        final int plen2 = path.length();</span>
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (rowCount &gt; 0) {</span>
<span class="fc" id="L61">            long mem = migrationContext.getTempMemory();</span>
<span class="fc" id="L62">            long currentColumnNameOffset = columnNameOffset;</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L64">                final int columnType = ColumnType.tagOf(</span>
<span class="fc" id="L65">                        metaMem.getInt(</span>
<span class="fc" id="L66">                                MigrationActions.prefixedBlockOffset(MigrationActions.META_OFFSET_COLUMN_TYPES_606, i, MigrationActions.META_COLUMN_DATA_SIZE_606)</span>
                        )
                );
<span class="fc" id="L69">                final CharSequence columnName = metaMem.getStr(currentColumnNameOffset);</span>
<span class="fc" id="L70">                currentColumnNameOffset += Vm.getStorageLength(columnName);</span>
<span class="fc bfc" id="L71" title="All 4 branches covered.">                if (columnType == ColumnType.STRING || columnType == ColumnType.BINARY) {</span>
<span class="fc" id="L72">                    final long columnTop = readColumnTop(</span>
                            ff,
<span class="fc" id="L74">                            path.trimTo(plen2),</span>
                            columnName,
                            plen2,
                            false
                    );
<span class="fc" id="L79">                    final long columnRowCount = rowCount - columnTop;</span>
<span class="fc" id="L80">                    long offset = columnRowCount * 8L;</span>
<span class="fc" id="L81">                    iFile(path.trimTo(plen2), columnName);</span>
<span class="fc" id="L82">                    int fd = TableUtils.openRW(ff, path, MigrationActions.LOG, migrationContext.getConfiguration().getWriterFileOpenOpts());</span>
                    try {
<span class="fc" id="L84">                        long fileLen = ff.length(fd);</span>

<span class="pc bpc" id="L86" title="1 of 2 branches missed.">                        if (fileLen &lt; offset) {</span>
<span class="nc" id="L87">                            throw CairoException.critical(0).put(&quot;file is too short [path=&quot;).put(path).put(&quot;]&quot;);</span>
                        }

<span class="fc" id="L90">                        TableUtils.allocateDiskSpace(ff, fd, offset + 8);</span>
<span class="fc" id="L91">                        long dataOffset = TableUtils.readLongOrFail(ff, fd, offset - 8L, mem, path);</span>
<span class="fc" id="L92">                        dFile(path.trimTo(plen2), columnName);</span>
<span class="fc" id="L93">                        final int fd2 = TableUtils.openRO(ff, path, MigrationActions.LOG);</span>
                        try {
<span class="fc bfc" id="L95" title="All 2 branches covered.">                            if (columnType == ColumnType.BINARY) {</span>
<span class="fc" id="L96">                                long len = TableUtils.readLongOrFail(ff, fd2, dataOffset, mem, path);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">                                if (len == -1) {</span>
<span class="fc" id="L98">                                    dataOffset += 8;</span>
                                } else {
<span class="fc" id="L100">                                    dataOffset += 8 + len;</span>
                                }
<span class="fc" id="L102">                            } else {</span>
<span class="fc" id="L103">                                long len = TableUtils.readIntOrFail(ff, fd2, dataOffset, mem, path);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">                                if (len == -1) {</span>
<span class="fc" id="L105">                                    dataOffset += 4;</span>
                                } else {
<span class="fc" id="L107">                                    dataOffset += MigrationActions.prefixedBlockOffset(4, 2, len);</span>
                                }

                            }
                        } finally {
<span class="fc" id="L112">                            ff.close(fd2);</span>
                        }
<span class="fc" id="L114">                        TableUtils.writeLongOrFail(ff, fd, offset, dataOffset, mem, path);</span>
                    } finally {
<span class="fc" id="L116">                        Vm.bestEffortClose(ff, MigrationActions.LOG, fd, offset + 8);</span>
                    }
                }
            }
        }
<span class="fc" id="L121">    }</span>

    /**
     * Reads 8 bytes from &quot;top&quot; file. Moved from TableUtils when refactored column tops into column version file
     *
     * @param ff                 files facade, - intermediary to intercept OS file system calls.
     * @param path               path has to be set to location of &quot;top&quot; file, excluding file name. Zero terminated string.
     * @param name               name of top file
     * @param plen               path length to truncate &quot;path&quot; back to, path is reusable.
     * @param failIfCouldNotRead if true the method will throw exception if top file cannot be read. Otherwise, 0.
     * @return number of rows column doesn't have when column was added to table that already had data.
     */
    public static long readColumnTop(FilesFacade ff, Path path, CharSequence name, int plen, boolean failIfCouldNotRead) {
        try {
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            if (ff.exists(topFile(path, name))) {</span>
<span class="nc" id="L136">                final int fd = TableUtils.openRO(ff, path, LOG);</span>
                try {
                    long n;
<span class="nc bnc" id="L139" title="All 2 branches missed.">                    if ((n = ff.readNonNegativeLong(fd, 0)) &lt; 0) {</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                        if (failIfCouldNotRead) {</span>
<span class="nc" id="L141">                            throw CairoException.critical(Os.errno())</span>
<span class="nc" id="L142">                                    .put(&quot;could not read top of column [file=&quot;).put(path)</span>
<span class="nc" id="L143">                                    .put(&quot;, read=&quot;).put(n).put(']');</span>
                        } else {
<span class="nc" id="L145">                            LOG.error().$(&quot;could not read top of column [file=&quot;).$(path)</span>
<span class="nc" id="L146">                                    .$(&quot;, read=&quot;).$(n)</span>
<span class="nc" id="L147">                                    .$(&quot;, errno=&quot;).$(ff.errno())</span>
<span class="nc" id="L148">                                    .I$();</span>
<span class="nc" id="L149">                            return 0L;</span>
                        }
                    }
<span class="nc" id="L152">                    return n;</span>
                } finally {
<span class="nc" id="L154">                    ff.close(fd);</span>
                }
            }
<span class="fc" id="L157">            return 0L;</span>
        } finally {
<span class="fc" id="L159">            path.trimTo(plen);</span>
        }
    }

    public static void txnPartition(CharSink path, long txn) {
<span class="fc" id="L164">        path.put('.').put(txn);</span>
<span class="fc" id="L165">    }</span>

    private static void charFileName(Path path, CharSequence columnName) {
<span class="fc" id="L168">        path.concat(columnName).put(&quot;.c&quot;).$();</span>
<span class="fc" id="L169">    }</span>

    private static void dFile(Path path, CharSequence columnName) {
<span class="fc" id="L172">        path.concat(columnName).put(FILE_SUFFIX_D);</span>
<span class="fc" id="L173">        path.$();</span>
<span class="fc" id="L174">    }</span>

    private static void iFile(Path path, CharSequence columnName) {
<span class="fc" id="L177">        path.concat(columnName).put(FILE_SUFFIX_I).$();</span>
<span class="fc" id="L178">    }</span>

    private static void offsetFileName(Path path, CharSequence columnName) {
<span class="fc" id="L181">        path.concat(columnName).put(&quot;.o&quot;).$();</span>
<span class="fc" id="L182">    }</span>

    private static void trimFile(FilesFacade ff, Path path, long size, long opts) {
<span class="fc" id="L185">        final int fd = TableUtils.openFileRWOrFail(ff, path, opts);</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (!ff.truncate(fd, size)) {</span>
            // This should never happen on migration but better to be on safe side anyway
<span class="nc" id="L188">            throw CairoException.critical(ff.errno()).put(&quot;Cannot trim to size [file=&quot;).put(path).put(']');</span>
        }
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (!ff.close(fd)) {</span>
            // This should never happen on migration but better to be on safe side anyway
<span class="nc" id="L192">            throw CairoException.critical(ff.errno()).put(&quot;Cannot close [file=&quot;).put(path).put(']');</span>
        }
<span class="fc" id="L194">    }</span>

    static void migrate(MigrationContext migrationContext) {
<span class="fc" id="L197">        final FilesFacade ff = migrationContext.getFf();</span>
<span class="fc" id="L198">        Path path = migrationContext.getTablePath();</span>
<span class="fc" id="L199">        int plen = path.length();</span>


<span class="fc" id="L202">        path.trimTo(plen).concat(META_FILE_NAME).$();</span>
        long metaFileSize;
        long txFileSize;
<span class="fc" id="L205">        try (MemoryMARW metaMem = migrationContext.getRwMemory()) {</span>
<span class="fc" id="L206">            metaMem.of(ff, path, ff.getPageSize(), ff.length(path), MemoryTag.NATIVE_MIG_MMAP);</span>
<span class="fc" id="L207">            final int columnCount = metaMem.getInt(0);</span>
<span class="fc" id="L208">            final int partitionBy = metaMem.getInt(4);</span>
<span class="fc" id="L209">            final long columnNameOffset = MigrationActions.prefixedBlockOffset(</span>
                    MigrationActions.META_OFFSET_COLUMN_TYPES_606,
                    columnCount,
                    MigrationActions.META_COLUMN_DATA_SIZE_606
            );

<span class="fc" id="L215">            try (MemoryMARW txMem = new MemoryCMARWImpl(</span>
                    ff,
<span class="fc" id="L217">                    path.trimTo(plen).concat(TXN_FILE_NAME).$(),</span>
<span class="fc" id="L218">                    ff.getPageSize(),</span>
<span class="fc" id="L219">                    ff.length(path),</span>
                    MemoryTag.NATIVE_MIG_MMAP,
<span class="fc" id="L221">                    migrationContext.getConfiguration().getWriterFileOpenOpts()</span>
            )
            ) {
                // this is a variable length file; we need to count of symbol maps before we get to the partition
                // table data
<span class="fc" id="L226">                final int symbolMapCount = txMem.getInt(MigrationActions.TX_OFFSET_MAP_WRITER_COUNT_505);</span>
<span class="fc" id="L227">                final long partitionCountOffset = MigrationActions.TX_OFFSET_MAP_WRITER_COUNT_505 + 4 + symbolMapCount * 8L;</span>
<span class="fc" id="L228">                int partitionCount = txMem.getInt(partitionCountOffset) / Long.BYTES / LONGS_PER_TX_ATTACHED_PARTITION;</span>
<span class="fc" id="L229">                final long transientRowCount = txMem.getLong(TX_OFFSET_TRANSIENT_ROW_COUNT);</span>


<span class="fc bfc" id="L232" title="All 2 branches covered.">                if (PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                    for (int partitionIndex = 0; partitionIndex &lt; partitionCount; partitionIndex++) {</span>
<span class="fc" id="L234">                        final long partitionDataOffset = partitionCountOffset + Integer.BYTES + partitionIndex * 8L * LONGS_PER_TX_ATTACHED_PARTITION;</span>

<span class="fc" id="L236">                        setPathForPartition(</span>
<span class="fc" id="L237">                                path.trimTo(plen),</span>
                                partitionBy,
<span class="fc" id="L239">                                txMem.getLong(partitionDataOffset),</span>
                                false
                        );
                        // the row count may not be stored in _txn file for the last partition
                        // we need to use transient row count instead
<span class="fc bfc" id="L244" title="All 2 branches covered.">                        long rowCount = partitionIndex &lt; partitionCount - 1 ? txMem.getLong(partitionDataOffset + Long.BYTES) : transientRowCount;</span>
<span class="fc" id="L245">                        long txSuffix = txMem.getLong(MigrationActions.prefixedBlockOffset(partitionDataOffset, 2, Long.BYTES));</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">                        if (txSuffix &gt; -1) {</span>
<span class="fc" id="L247">                            txnPartition(path, txSuffix);</span>
                        }
<span class="fc" id="L249">                        migrate(ff, path, migrationContext, metaMem, columnCount, rowCount, columnNameOffset);</span>
                    }
                } else {
<span class="fc" id="L252">                    path.trimTo(plen).concat(DEFAULT_PARTITION_NAME);</span>
<span class="fc" id="L253">                    migrate(ff, path, migrationContext, metaMem, columnCount, transientRowCount, columnNameOffset);</span>
                }

                // update symbol maps
<span class="fc" id="L257">                long tmpMem = migrationContext.getTempMemory();</span>
<span class="fc" id="L258">                int denseSymbolCount = 0;</span>
<span class="fc" id="L259">                long currentColumnNameOffset = columnNameOffset;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">                for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L261">                    final CharSequence columnName = metaMem.getStr(currentColumnNameOffset);</span>
<span class="fc" id="L262">                    currentColumnNameOffset += Vm.getStorageLength(columnName.length());</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">                    if (ColumnType.tagOf(</span>
<span class="fc" id="L265">                            metaMem.getInt(</span>
<span class="fc" id="L266">                                    MigrationActions.prefixedBlockOffset(</span>
                                            MigrationActions.META_OFFSET_COLUMN_TYPES_606,
                                            i,
                                            MigrationActions.META_COLUMN_DATA_SIZE_606
                                    )
                            )) == ColumnType.SYMBOL
                    ) {
<span class="fc" id="L273">                        final int symbolCount = txMem.getInt(MigrationActions.TX_OFFSET_MAP_WRITER_COUNT_505 + 8 + denseSymbolCount * 8L);</span>
<span class="fc" id="L274">                        final long offset = MigrationActions.prefixedBlockOffset(SymbolMapWriter.HEADER_SIZE, symbolCount, 8L);</span>

<span class="fc" id="L276">                        offsetFileName(path.trimTo(plen), columnName);</span>
<span class="fc" id="L277">                        final int fd = TableUtils.openRW(ff, path, MigrationActions.LOG, migrationContext.getConfiguration().getWriterFileOpenOpts());</span>
                        try {
<span class="fc" id="L279">                            long fileLen = ff.length(fd);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                            if (symbolCount &gt; 0) {</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">                                if (fileLen &lt; offset) {</span>
<span class="nc" id="L282">                                    MigrationActions.LOG.error().$(&quot;file is too short [path=&quot;).$(path).I$();</span>
                                } else {
<span class="fc" id="L284">                                    TableUtils.allocateDiskSpace(ff, fd, offset + 8);</span>
<span class="fc" id="L285">                                    long dataOffset = TableUtils.readLongOrFail(ff, fd, offset - 8L, tmpMem, path);</span>
                                    // string length
<span class="fc" id="L287">                                    charFileName(path.trimTo(plen), columnName);</span>
<span class="fc" id="L288">                                    final int fd2 = TableUtils.openRO(ff, path, MigrationActions.LOG);</span>
                                    try {
<span class="fc" id="L290">                                        long len = TableUtils.readIntOrFail(ff, fd2, dataOffset, tmpMem, path);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                                        if (len == -1) {</span>
<span class="nc" id="L292">                                            dataOffset += 4;</span>
                                        } else {
<span class="fc" id="L294">                                            dataOffset += 4 + len * 2L;</span>
                                        }
<span class="fc" id="L296">                                        TableUtils.writeLongOrFail(ff, fd, offset, dataOffset, tmpMem, path);</span>
                                    } finally {
<span class="fc" id="L298">                                        ff.close(fd2);</span>
                                    }
                                }
                            }
                        } finally {
<span class="fc" id="L303">                            Vm.bestEffortClose(ff, MigrationActions.LOG, fd, offset + 8);</span>
                        }
<span class="fc" id="L305">                        denseSymbolCount++;</span>
                    }
                }
<span class="fc" id="L308">                txFileSize = txMem.getAppendOffset();</span>
            }
<span class="fc" id="L310">            metaFileSize = metaMem.getAppendOffset();</span>
        }

        // This migration when written originally used implementation of MemoryMARW which truncated files to size on close
        // MemoryMARW now truncate to page size. To test old migrations here we simulate the migration as it is originally released
        // So trim TX and META files to their sizes
<span class="fc" id="L316">        path.trimTo(plen).concat(META_FILE_NAME).$();</span>
<span class="fc" id="L317">        trimFile(ff, path, metaFileSize, migrationContext.getConfiguration().getWriterFileOpenOpts());</span>

<span class="fc" id="L319">        path.trimTo(plen).concat(TXN_FILE_NAME).$();</span>
<span class="fc" id="L320">        trimFile(ff, path, txFileSize, migrationContext.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L321">    }</span>

    static LPSZ topFile(Path path, CharSequence columnName) {
<span class="fc" id="L324">        return path.concat(columnName).put(&quot;.top&quot;).$();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>