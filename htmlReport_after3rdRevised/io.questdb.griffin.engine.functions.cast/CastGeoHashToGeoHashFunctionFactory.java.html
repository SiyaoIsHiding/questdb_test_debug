<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CastGeoHashToGeoHashFunctionFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.engine.functions.cast</a> &gt; <span class="el_source">CastGeoHashToGeoHashFunctionFactory.java</span></div><h1>CastGeoHashToGeoHashFunctionFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.engine.functions.cast;

import io.questdb.cairo.CairoConfiguration;
import io.questdb.cairo.ColumnType;
import io.questdb.cairo.GeoHashes;
import io.questdb.cairo.sql.Function;
import io.questdb.cairo.sql.Record;
import io.questdb.griffin.FunctionFactory;
import io.questdb.griffin.SqlException;
import io.questdb.griffin.SqlExecutionContext;
import io.questdb.griffin.engine.functions.*;
import io.questdb.griffin.engine.functions.constants.Constants;
import io.questdb.std.IntList;
import io.questdb.std.ObjList;
import io.questdb.std.str.CharSink;
import io.questdb.std.str.StringSink;
import org.jetbrains.annotations.NotNull;

<span class="fc" id="L43">public class CastGeoHashToGeoHashFunctionFactory implements FunctionFactory {</span>
    @NotNull
    public static Function getGeoByteToStrCastFunction(Function value, int srcBitsPrecision) {
<span class="fc bfc" id="L46" title="All 2 branches covered.">        if (srcBitsPrecision % 5 == 0) {</span>
<span class="fc" id="L47">            return new CastGeoByteToStrCharsFunc(value, srcBitsPrecision / 5);</span>
        }
<span class="fc" id="L49">        return new CastGeoByteToStrBitsFunc(value, srcBitsPrecision);</span>
    }

    @NotNull
    public static Function getGeoIntToStrCastFunction(Function value, int srcBitsPrecision) {
<span class="fc bfc" id="L54" title="All 2 branches covered.">        if (srcBitsPrecision % 5 == 0) {</span>
<span class="fc" id="L55">            return new CastGeoIntToStrCharsFunc(value, srcBitsPrecision / 5);</span>
        }
<span class="fc" id="L57">        return new CastGeoIntToStrBitsFunc(value, srcBitsPrecision);</span>
    }

    @NotNull
    public static Function getGeoLongToStrCastFunction(Function value, int srcBitsPrecision) {
<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (srcBitsPrecision % 5 == 0) {</span>
<span class="fc" id="L63">            return new CastGeoLongToStrCharsFunc(value, srcBitsPrecision / 5);</span>
        }
<span class="fc" id="L65">        return new CastGeoLongToStrBitsFunc(value, srcBitsPrecision);</span>
    }

    @NotNull
    public static Function getGeoShortToStrCastFunction(Function value, int srcBitsPrecision) {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (srcBitsPrecision % 5 == 0) {</span>
<span class="fc" id="L71">            return new CastGeoShortToStrCharsFunc(value, srcBitsPrecision / 5);</span>
        }
<span class="fc" id="L73">        return new CastGeoShortToStrBitsFunc(value, srcBitsPrecision);</span>
    }

    public static Function newInstance(int position, Function value, int toType, int fromType) throws SqlException {
<span class="fc" id="L77">        int fromBits = ColumnType.getGeoHashBits(fromType);</span>
<span class="fc" id="L78">        int toBits = ColumnType.getGeoHashBits(toType);</span>
<span class="fc" id="L79">        int shift = fromBits - toBits;</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (shift &gt; 0) {</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">            if (value.isConstant()) {</span>
<span class="fc" id="L82">                long val = GeoHashes.getGeoLong(fromType, value, null);</span>
                // &gt;&gt; shift will take care of NULL value -1
<span class="fc" id="L84">                return Constants.getGeoHashConstantWithType(val &gt;&gt; shift, toType);</span>
            }

<span class="fc" id="L87">            final Function result = getCastGeoHashToGeoHashFunction(value, toType, fromType, shift);</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">            if (result != null) {</span>
<span class="fc" id="L89">                return result;</span>
            }
<span class="pc bfc" id="L91" title="All 2 branches covered.">        } else if (shift == 0) {</span>
<span class="fc" id="L92">            return value;</span>
        }

        // check if this is a null of different bit count
<span class="pc bpc" id="L96" title="2 of 4 branches missed.">        if (value.isConstant() &amp;&amp; GeoHashes.getGeoLong(value.getType(), value, null) == GeoHashes.NULL) {</span>
<span class="nc" id="L97">            return Constants.getNullConstant(toType);</span>
        }

<span class="pc bpc" id="L100" title="2 of 3 branches missed.">        switch (ColumnType.tagOf(toType)) {</span>
            case ColumnType.GEOBYTE:
            case ColumnType.GEOSHORT:
            case ColumnType.GEOINT:
            case ColumnType.GEOLONG:
<span class="fc" id="L105">                throw SqlException.position(position)</span>
<span class="fc" id="L106">                        .put(&quot;CAST cannot narrow values from GEOHASH(&quot;)</span>
<span class="fc" id="L107">                        .put(fromBits)</span>
<span class="fc" id="L108">                        .put(&quot;b) to GEOHASH(&quot;)</span>
<span class="fc" id="L109">                        .put(toBits)</span>
<span class="fc" id="L110">                        .put(&quot;b)&quot;);</span>
            case ColumnType.STRING:
<span class="nc bnc" id="L112" title="All 3 branches missed.">                switch (ColumnType.tagOf(fromType)) {</span>
                    case ColumnType.GEOBYTE:
<span class="nc" id="L114">                        return getGeoByteToStrCastFunction(value, fromBits);</span>
                    case ColumnType.GEOSHORT:
<span class="nc" id="L116">                        return getGeoShortToStrCastFunction(value, fromBits);</span>
                }
            default:
<span class="nc" id="L119">                throw SqlException.position(position)</span>
<span class="nc" id="L120">                        .put(&quot;cannot cast GEOHASH(&quot;)</span>
<span class="nc" id="L121">                        .put(fromBits)</span>
<span class="nc" id="L122">                        .put(&quot;b) to &quot;)</span>
<span class="nc" id="L123">                        .put(ColumnType.nameOf(toType));</span>
        }
    }

    @Override
    public String getSignature() {
        // GeoHashes are of different lengths
        // and can be cast to lower precision
        // for example cast(cast('questdb' as geohash(6c)) as geohash(5c))
<span class="fc" id="L132">        return &quot;cast(Gg)&quot;;</span>
    }

    @Override
    public Function newInstance(int position,
                                ObjList&lt;Function&gt; args,
                                IntList argPositions,
                                CairoConfiguration configuration,
                                SqlExecutionContext sqlExecutionContext
    ) throws SqlException {
<span class="fc" id="L142">        final Function value = args.getQuick(0);</span>
<span class="fc" id="L143">        int srcType = value.getType();</span>
<span class="fc" id="L144">        int targetType = args.getQuick(1).getType();</span>
<span class="fc" id="L145">        return newInstance(position, value, targetType, srcType);</span>
    }

    private static Function getCastGeoHashToGeoHashFunction(Function value, int toType, int fromType, int shift) {
<span class="fc bfc" id="L149" title="All 4 branches covered.">        switch (ColumnType.tagOf(fromType)) {</span>
            case ColumnType.GEOBYTE:
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">                if (ColumnType.tagOf(toType) == ColumnType.GEOBYTE) {</span>
<span class="fc" id="L152">                    return new CastByteFunc(shift, toType, value);</span>
                }
                break;
            case ColumnType.GEOSHORT:
<span class="pc bpc" id="L156" title="2 of 3 branches missed.">                switch (ColumnType.tagOf(toType)) {</span>
                    case ColumnType.GEOBYTE:
<span class="fc" id="L158">                        return new CastShortToByteFunc(shift, toType, value);</span>
                    case ColumnType.GEOSHORT:
<span class="nc" id="L160">                        return new CastGeoShortFunction(shift, toType, value);</span>
                }
<span class="nc" id="L162">                break;</span>
            case ColumnType.GEOINT:
<span class="pc bpc" id="L164" title="2 of 4 branches missed.">                switch (ColumnType.tagOf(toType)) {</span>
                    case ColumnType.GEOBYTE:
<span class="fc" id="L166">                        return new CastIntToByteFunc(shift, toType, value);</span>
                    case ColumnType.GEOSHORT:
<span class="fc" id="L168">                        return new CastGeoIntToGeoShortFunction(shift, toType, value);</span>
                    case ColumnType.GEOINT:
<span class="nc" id="L170">                        return new CastIntFunc(shift, toType, value);</span>
                }
<span class="nc" id="L172">                break;</span>
            default:
<span class="pc bpc" id="L174" title="2 of 5 branches missed.">                switch (ColumnType.tagOf(toType)) {</span>
                    case ColumnType.GEOBYTE:
<span class="fc" id="L176">                        return new CastLongToByteFunc(shift, toType, value);</span>
                    case ColumnType.GEOSHORT:
<span class="fc" id="L178">                        return new CastGeoLongToGeoShortFunction(shift, toType, value);</span>
                    case ColumnType.GEOINT:
<span class="fc" id="L180">                        return new CastLongToIntFunc(shift, toType, value);</span>
                    case ColumnType.GEOLONG:
<span class="nc" id="L182">                        return new CastLongFunc(shift, toType, value);</span>
                }
        }
<span class="nc" id="L185">        return null;</span>
    }

    private static abstract class AbstractCastGeoByteToStrFunction extends StrFunction implements UnaryFunction {
        protected final int bits;
        protected final Function value;
<span class="fc" id="L191">        private final StringSink sinkA = new StringSink();</span>
<span class="fc" id="L192">        private final StringSink sinkB = new StringSink();</span>

<span class="fc" id="L194">        public AbstractCastGeoByteToStrFunction(Function value, int bits) {</span>
<span class="fc" id="L195">            this.value = value;</span>
<span class="fc" id="L196">            this.bits = bits;</span>
<span class="fc" id="L197">        }</span>

        @Override
        public final Function getArg() {
<span class="fc" id="L201">            return value;</span>
        }

        @Override
        public final CharSequence getStr(Record rec) {
<span class="fc" id="L206">            return toSink(getValue(rec), sinkA);</span>
        }

        @Override
        public final CharSequence getStrB(Record rec) {
<span class="fc" id="L211">            return toSink(getValue(rec), sinkB);</span>
        }

        private StringSink toSink(long value, StringSink sink) {
<span class="fc" id="L215">            sink.clear();</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (value == GeoHashes.NULL) {</span>
<span class="nc" id="L217">                sink.put(&quot;null&quot;);</span>
            } else {
<span class="fc" id="L219">                print(value, sink);</span>
            }
<span class="fc" id="L221">            return sink;</span>
        }

        protected abstract long getValue(Record rec);

        protected abstract void print(long value, CharSink sink);
    }

    private static class CastByteFunc extends GeoByteFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastByteFunc(int shift, int targetType, Function value) {
<span class="fc" id="L234">            super(targetType);</span>
<span class="fc" id="L235">            this.value = value;</span>
<span class="fc" id="L236">            this.shift = shift;</span>
<span class="fc" id="L237">        }</span>

        @Override
        public Function getArg() {
<span class="fc" id="L241">            return value;</span>
        }

        @Override
        public byte getGeoByte(Record rec) {
<span class="fc" id="L246">            return (byte) (value.getGeoByte(rec) &gt;&gt; shift);</span>
        }
    }

    private static class CastGeoByteToStrBitsFunc extends AbstractCastGeoByteToStrFunction implements UnaryFunction {

        public CastGeoByteToStrBitsFunc(Function value, int bits) {
<span class="fc" id="L253">            super(value, bits);</span>
<span class="fc" id="L254">        }</span>

        @Override
        protected long getValue(Record rec) {
<span class="fc" id="L258">            return this.value.getGeoByte(rec);</span>
        }

        @Override
        protected void print(long value, CharSink sink) {
<span class="fc" id="L263">            GeoHashes.appendBinaryStringUnsafe(value, bits, sink);</span>
<span class="fc" id="L264">        }</span>
    }

    private static class CastGeoByteToStrCharsFunc extends AbstractCastGeoByteToStrFunction implements UnaryFunction {

        public CastGeoByteToStrCharsFunc(Function value, int bits) {
<span class="fc" id="L270">            super(value, bits);</span>
<span class="fc" id="L271">        }</span>

        @Override
        protected long getValue(Record rec) {
<span class="fc" id="L275">            return this.value.getGeoByte(rec);</span>
        }

        @Override
        protected void print(long value, CharSink sink) {
<span class="fc" id="L280">            GeoHashes.appendCharsUnsafe(value, bits, sink);</span>
<span class="fc" id="L281">        }</span>
    }

    public static class CastGeoIntToGeoShortFunction extends GeoShortFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastGeoIntToGeoShortFunction(int shift, int targetType, Function value) {
<span class="fc" id="L289">            super(targetType);</span>
<span class="fc" id="L290">            this.value = value;</span>
<span class="fc" id="L291">            this.shift = shift;</span>
<span class="fc" id="L292">        }</span>

        @Override
        public Function getArg() {
<span class="fc" id="L296">            return value;</span>
        }

        @Override
        public short getGeoShort(Record rec) {
<span class="fc" id="L301">            return (short) (value.getGeoInt(rec) &gt;&gt; shift);</span>
        }
    }

    private static class CastGeoIntToStrBitsFunc extends AbstractCastGeoByteToStrFunction implements UnaryFunction {

        public CastGeoIntToStrBitsFunc(Function value, int bits) {
<span class="fc" id="L308">            super(value, bits);</span>
<span class="fc" id="L309">        }</span>

        @Override
        protected long getValue(Record rec) {
<span class="fc" id="L313">            return this.value.getGeoInt(rec);</span>
        }

        @Override
        protected void print(long value, CharSink sink) {
<span class="fc" id="L318">            GeoHashes.appendBinaryStringUnsafe(value, bits, sink);</span>
<span class="fc" id="L319">        }</span>
    }

    private static class CastGeoIntToStrCharsFunc extends AbstractCastGeoByteToStrFunction implements UnaryFunction {

        public CastGeoIntToStrCharsFunc(Function value, int bits) {
<span class="fc" id="L325">            super(value, bits);</span>
<span class="fc" id="L326">        }</span>

        @Override
        protected long getValue(Record rec) {
<span class="fc" id="L330">            return this.value.getGeoInt(rec);</span>
        }

        @Override
        protected void print(long value, CharSink sink) {
<span class="fc" id="L335">            GeoHashes.appendCharsUnsafe(value, bits, sink);</span>
<span class="fc" id="L336">        }</span>
    }

    public static class CastGeoLongToGeoShortFunction extends GeoShortFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastGeoLongToGeoShortFunction(int shift, int targetType, Function value) {
<span class="fc" id="L344">            super(targetType);</span>
<span class="fc" id="L345">            this.value = value;</span>
<span class="fc" id="L346">            this.shift = shift;</span>
<span class="fc" id="L347">        }</span>

        @Override
        public Function getArg() {
<span class="fc" id="L351">            return value;</span>
        }

        @Override
        public short getGeoShort(Record rec) {
<span class="fc" id="L356">            return (short) (value.getGeoLong(rec) &gt;&gt; shift);</span>
        }
    }

    private static class CastGeoLongToStrBitsFunc extends AbstractCastGeoByteToStrFunction implements UnaryFunction {

        public CastGeoLongToStrBitsFunc(Function value, int bits) {
<span class="fc" id="L363">            super(value, bits);</span>
<span class="fc" id="L364">        }</span>

        @Override
        protected long getValue(Record rec) {
<span class="fc" id="L368">            return this.value.getGeoLong(rec);</span>
        }

        @Override
        protected void print(long value, CharSink sink) {
<span class="fc" id="L373">            GeoHashes.appendBinaryStringUnsafe(value, bits, sink);</span>
<span class="fc" id="L374">        }</span>
    }

    private static class CastGeoLongToStrCharsFunc extends AbstractCastGeoByteToStrFunction implements UnaryFunction {

        public CastGeoLongToStrCharsFunc(Function value, int bits) {
<span class="fc" id="L380">            super(value, bits);</span>
<span class="fc" id="L381">        }</span>

        @Override
        protected long getValue(Record rec) {
<span class="fc" id="L385">            return this.value.getGeoLong(rec);</span>
        }

        @Override
        protected void print(long value, CharSink sink) {
<span class="fc" id="L390">            GeoHashes.appendCharsUnsafe(value, bits, sink);</span>
<span class="fc" id="L391">        }</span>
    }

    public static class CastGeoShortFunction extends GeoShortFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastGeoShortFunction(int shift, int targetType, Function value) {
<span class="nc" id="L399">            super(targetType);</span>
<span class="nc" id="L400">            this.value = value;</span>
<span class="nc" id="L401">            this.shift = shift;</span>
<span class="nc" id="L402">        }</span>

        @Override
        public Function getArg() {
<span class="nc" id="L406">            return value;</span>
        }

        @Override
        public short getGeoShort(Record rec) {
<span class="nc" id="L411">            return (short) (value.getGeoShort(rec) &gt;&gt; shift);</span>
        }
    }

    private static class CastGeoShortToStrBitsFunc extends AbstractCastGeoByteToStrFunction implements UnaryFunction {

        public CastGeoShortToStrBitsFunc(Function value, int bits) {
<span class="fc" id="L418">            super(value, bits);</span>
<span class="fc" id="L419">        }</span>

        @Override
        protected long getValue(Record rec) {
<span class="fc" id="L423">            return this.value.getGeoShort(rec);</span>
        }

        @Override
        protected void print(long value, CharSink sink) {
<span class="fc" id="L428">            GeoHashes.appendBinaryStringUnsafe(value, bits, sink);</span>
<span class="fc" id="L429">        }</span>
    }

    private static class CastGeoShortToStrCharsFunc extends AbstractCastGeoByteToStrFunction implements UnaryFunction {

        public CastGeoShortToStrCharsFunc(Function value, int bits) {
<span class="fc" id="L435">            super(value, bits);</span>
<span class="fc" id="L436">        }</span>

        @Override
        protected long getValue(Record rec) {
<span class="fc" id="L440">            return this.value.getGeoShort(rec);</span>
        }

        @Override
        protected void print(long value, CharSink sink) {
<span class="fc" id="L445">            GeoHashes.appendCharsUnsafe(value, bits, sink);</span>
<span class="fc" id="L446">        }</span>
    }

    private static class CastIntFunc extends GeoIntFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastIntFunc(int shift, int targetType, Function value) {
<span class="nc" id="L454">            super(targetType);</span>
<span class="nc" id="L455">            this.value = value;</span>
<span class="nc" id="L456">            this.shift = shift;</span>
<span class="nc" id="L457">        }</span>

        @Override
        public Function getArg() {
<span class="nc" id="L461">            return value;</span>
        }


        @Override
        public int getGeoInt(Record rec) {
<span class="nc" id="L467">            return value.getGeoInt(rec) &gt;&gt; shift;</span>
        }
    }

    private static class CastIntToByteFunc extends GeoByteFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastIntToByteFunc(int shift, int targetType, Function value) {
<span class="fc" id="L476">            super(targetType);</span>
<span class="fc" id="L477">            this.value = value;</span>
<span class="fc" id="L478">            this.shift = shift;</span>
<span class="fc" id="L479">        }</span>

        @Override
        public Function getArg() {
<span class="fc" id="L483">            return value;</span>
        }

        @Override
        public byte getGeoByte(Record rec) {
<span class="fc" id="L488">            return (byte) (value.getGeoInt(rec) &gt;&gt; shift);</span>
        }
    }

    private static class CastLongFunc extends GeoLongFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastLongFunc(int shift, int targetType, Function value) {
<span class="nc" id="L497">            super(targetType);</span>
<span class="nc" id="L498">            this.value = value;</span>
<span class="nc" id="L499">            this.shift = shift;</span>
<span class="nc" id="L500">        }</span>

        @Override
        public Function getArg() {
<span class="nc" id="L504">            return value;</span>
        }

        @Override
        public long getGeoLong(Record rec) {
<span class="nc" id="L509">            return value.getGeoLong(rec) &gt;&gt; shift;</span>
        }
    }

    private static class CastLongToByteFunc extends GeoByteFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastLongToByteFunc(int shift, int targetType, Function value) {
<span class="fc" id="L518">            super(targetType);</span>
<span class="fc" id="L519">            this.value = value;</span>
<span class="fc" id="L520">            this.shift = shift;</span>
<span class="fc" id="L521">        }</span>

        @Override
        public Function getArg() {
<span class="fc" id="L525">            return value;</span>
        }

        @Override
        public byte getGeoByte(Record rec) {
<span class="fc" id="L530">            return (byte) (value.getGeoLong(rec) &gt;&gt; shift);</span>
        }
    }

    private static class CastLongToIntFunc extends GeoIntFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastLongToIntFunc(int shift, int targetType, Function value) {
<span class="fc" id="L539">            super(targetType);</span>
<span class="fc" id="L540">            this.value = value;</span>
<span class="fc" id="L541">            this.shift = shift;</span>
<span class="fc" id="L542">        }</span>

        @Override
        public Function getArg() {
<span class="fc" id="L546">            return value;</span>
        }

        @Override
        public int getGeoInt(Record rec) {
<span class="fc" id="L551">            return (int) (value.getGeoLong(rec) &gt;&gt; shift);</span>
        }
    }

    private static class CastShortToByteFunc extends GeoByteFunction implements UnaryFunction {
        private final int shift;
        private final Function value;

        public CastShortToByteFunc(int shift, int targetType, Function value) {
<span class="fc" id="L560">            super(targetType);</span>
<span class="fc" id="L561">            this.value = value;</span>
<span class="fc" id="L562">            this.shift = shift;</span>
<span class="fc" id="L563">        }</span>

        @Override
        public Function getArg() {
<span class="fc" id="L567">            return value;</span>
        }

        @Override
        public byte getGeoByte(Record rec) {
<span class="fc" id="L572">            return (byte) (value.getGeoShort(rec) &gt;&gt; shift);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>