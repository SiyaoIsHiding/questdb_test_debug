<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AuthDb.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.line.tcp</a> &gt; <span class="el_source">AuthDb.java</span></div><h1>AuthDb.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.line.tcp;

import io.questdb.std.CharSequenceObjHashMap;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.security.*;
import java.security.interfaces.ECKey;
import java.security.spec.*;
import java.util.Base64;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class AuthDb {
    public static final String EC_ALGORITHM = &quot;EC&quot;;
    public static final String EC_CURVE = &quot;secp256r1&quot;;
    public static final String SIGNATURE_TYPE_DER = &quot;SHA256withECDSA&quot;;
    public static final String SIGNATURE_TYPE_P1363 = &quot;SHA256withECDSAinP1363Format&quot;;
<span class="fc" id="L46">    private static final Pattern TOKEN_PATTERN = Pattern.compile(&quot;\\s*(\\S+)(.*)&quot;);</span>
<span class="fc" id="L47">    private final CharSequenceObjHashMap&lt;PublicKey&gt; publicKeyByKeyId = new CharSequenceObjHashMap&lt;&gt;();</span>

<span class="fc" id="L49">    AuthDb(LineTcpReceiverConfiguration configuration) {</span>
<span class="fc" id="L50">        int nLine = 0;</span>
<span class="fc" id="L51">        String[] tokens = new String[4];</span>
<span class="fc" id="L52">        try (BufferedReader r = new BufferedReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(configuration.getAuthDbPath()))))) {</span>
            String line;
            do {
<span class="fc" id="L55">                int nTokens = 0;</span>
<span class="fc" id="L56">                line = r.readLine();</span>
<span class="fc" id="L57">                nLine++;</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">                while (null != line) {</span>
<span class="fc" id="L59">                    Matcher m = TOKEN_PATTERN.matcher(line);</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">                    if (!m.matches()) {</span>
<span class="fc" id="L61">                        break;</span>
                    }
<span class="fc" id="L63">                    String token = m.group(1);</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">                    if (token.startsWith(&quot;#&quot;)) {</span>
<span class="fc" id="L65">                        break;</span>
                    }
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">                    if (nTokens == tokens.length) {</span>
<span class="nc" id="L68">                        throw new IllegalArgumentException(&quot;Too many tokens&quot;);</span>
                    }
<span class="fc" id="L70">                    tokens[nTokens] = m.group(1);</span>
<span class="fc" id="L71">                    nTokens++;</span>
<span class="fc" id="L72">                    line = m.group(2);</span>
<span class="fc" id="L73">                }</span>

<span class="fc bfc" id="L75" title="All 2 branches covered.">                if (nTokens == 0) {</span>
<span class="fc" id="L76">                    continue;</span>
                }

<span class="pc bpc" id="L79" title="1 of 2 branches missed.">                if (nTokens != 4) {</span>
<span class="nc" id="L80">                    throw new IllegalArgumentException(&quot;Was expecting 4 tokens&quot;);</span>
                }

<span class="pc bpc" id="L83" title="1 of 2 branches missed.">                if (!&quot;ec-p-256-sha256&quot;.equals(tokens[1])) {</span>
<span class="nc" id="L84">                    throw new IllegalArgumentException(&quot;Unrecognized type &quot; + tokens[1]);</span>
                }

<span class="fc" id="L87">                CharSequence keyId = tokens[0];</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">                if (!publicKeyByKeyId.excludes(keyId)) {</span>
<span class="nc" id="L89">                    throw new IllegalArgumentException(&quot;Duplicate keyId &quot; + keyId);</span>
                }

<span class="fc" id="L92">                PublicKey publicKey = importPublicKey(tokens[2], tokens[3]);</span>
<span class="fc" id="L93">                publicKeyByKeyId.put(keyId, publicKey);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">            } while (null != line);</span>
<span class="nc" id="L95">        } catch (Exception ex) {</span>
<span class="nc" id="L96">            throw new IllegalArgumentException(&quot;IO error, failed to read auth db file &quot; + configuration.getAuthDbPath() + &quot; at line &quot; + nLine, ex);</span>
<span class="fc" id="L97">        }</span>
<span class="fc" id="L98">    }</span>

    public static PrivateKey importPrivateKey(String encodedPrivateKey) {
<span class="fc" id="L101">        byte[] dBytes = Base64.getUrlDecoder().decode(encodedPrivateKey);</span>

        try {
<span class="fc" id="L104">            BigInteger privateKeyInt = new BigInteger(1, dBytes);</span>
<span class="fc" id="L105">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(EC_ALGORITHM);</span>
<span class="fc" id="L106">            AlgorithmParameterSpec prime256v1ParamSpec = new ECGenParameterSpec(EC_CURVE);</span>
<span class="fc" id="L107">            keyPairGenerator.initialize(prime256v1ParamSpec);</span>
<span class="fc" id="L108">            ECParameterSpec parameterSpec = ((ECKey) keyPairGenerator.generateKeyPair().getPrivate()).getParams();</span>
<span class="fc" id="L109">            ECPrivateKeySpec privateKeySpec = new ECPrivateKeySpec(privateKeyInt, parameterSpec);</span>
<span class="fc" id="L110">            return KeyFactory.getInstance(EC_ALGORITHM).generatePrivate(privateKeySpec);</span>
<span class="nc" id="L111">        } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException | InvalidKeySpecException ex) {</span>
<span class="nc" id="L112">            throw new IllegalArgumentException(&quot;Failed to decode &quot; + encodedPrivateKey, ex);</span>
        }
    }

    public static PublicKey importPublicKey(String encodedX, String encodedY) {
<span class="fc" id="L117">        byte[] xBytes = Base64.getUrlDecoder().decode(encodedX);</span>
<span class="fc" id="L118">        byte[] yBytes = Base64.getUrlDecoder().decode(encodedY);</span>
        try {
<span class="fc" id="L120">            BigInteger x = new BigInteger(1, xBytes);</span>
<span class="fc" id="L121">            BigInteger y = new BigInteger(1, yBytes);</span>
<span class="fc" id="L122">            ECPoint point = new ECPoint(x, y);</span>

<span class="fc" id="L124">            AlgorithmParameters parameters = AlgorithmParameters.getInstance(EC_ALGORITHM);</span>
<span class="fc" id="L125">            parameters.init(new ECGenParameterSpec(EC_CURVE));</span>
<span class="fc" id="L126">            ECParameterSpec ecParameters = parameters.getParameterSpec(ECParameterSpec.class);</span>
<span class="fc" id="L127">            ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(point, ecParameters);</span>
<span class="fc" id="L128">            return KeyFactory.getInstance(EC_ALGORITHM).generatePublic(pubKeySpec);</span>
<span class="nc" id="L129">        } catch (NoSuchAlgorithmException | InvalidKeySpecException | InvalidParameterSpecException ex) {</span>
<span class="nc" id="L130">            throw new IllegalArgumentException(&quot;Failed to decode &quot; + encodedX + &quot;,&quot; + encodedY, ex);</span>
        }
    }

    public PublicKey getPublicKey(CharSequence keyId) {
<span class="fc" id="L135">        return publicKeyByKeyId.get(keyId);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>