<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LineTcpEventBuffer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.line.tcp</a> &gt; <span class="el_source">LineTcpEventBuffer.java</span></div><h1>LineTcpEventBuffer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.line.tcp;

import io.questdb.cairo.CairoException;
import io.questdb.cairo.ColumnType;
import io.questdb.cairo.GeoHashes;
import io.questdb.cairo.sql.SymbolTable;
import io.questdb.std.*;
import io.questdb.std.str.DirectByteCharSequence;
import io.questdb.std.str.FloatingDirectCharSink;

import static io.questdb.cutlass.line.tcp.LineTcpParser.ENTITY_TYPE_NULL;
import static io.questdb.std.Chars.utf8ToUtf16;
import static io.questdb.std.Chars.utf8ToUtf16Unchecked;

public class LineTcpEventBuffer {
    private final long bufLo;
    private final long bufSize;
<span class="fc" id="L42">    private final FloatingDirectCharSink tempSink = new FloatingDirectCharSink();</span>

<span class="fc" id="L44">    public LineTcpEventBuffer(long bufLo, long bufSize) {</span>
<span class="fc" id="L45">        this.bufLo = bufLo;</span>
<span class="fc" id="L46">        this.bufSize = bufLo + bufSize;</span>
<span class="fc" id="L47">    }</span>

    public long addBoolean(long address, byte value) {
<span class="fc" id="L50">        checkCapacity(address, Byte.BYTES + Byte.BYTES);</span>
<span class="fc" id="L51">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_BOOLEAN);</span>
<span class="fc" id="L52">        Unsafe.getUnsafe().putByte(address + Byte.BYTES, value);</span>
<span class="fc" id="L53">        return address + Byte.BYTES + Byte.BYTES;</span>
    }

    public long addByte(long address, byte value) {
<span class="fc" id="L57">        checkCapacity(address, Byte.BYTES + Byte.BYTES);</span>
<span class="fc" id="L58">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_BYTE);</span>
<span class="fc" id="L59">        Unsafe.getUnsafe().putByte(address + Byte.BYTES, value);</span>
<span class="fc" id="L60">        return address + Byte.BYTES + Byte.BYTES;</span>
    }

    public long addChar(long address, char value) {
<span class="fc" id="L64">        checkCapacity(address, Character.BYTES + Byte.BYTES);</span>
<span class="fc" id="L65">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_CHAR);</span>
<span class="fc" id="L66">        Unsafe.getUnsafe().putChar(address + Byte.BYTES, value);</span>
<span class="fc" id="L67">        return address + Character.BYTES + Byte.BYTES;</span>
    }

    public long addColumnIndex(long address, int colIndex) {
<span class="fc" id="L71">        checkCapacity(address, Integer.BYTES);</span>
<span class="fc" id="L72">        Unsafe.getUnsafe().putInt(address, colIndex);</span>
<span class="fc" id="L73">        return address + Integer.BYTES;</span>
    }

    public long addColumnName(long address, CharSequence colName) {
<span class="fc" id="L77">        int length = colName.length();</span>
<span class="fc" id="L78">        int capacity = Integer.BYTES + 2 * length;</span>
<span class="fc" id="L79">        checkCapacity(address, capacity);</span>

        // Negative length indicates to the writer thread that column is passed by
        // name rather than by index. When value is positive (on the else branch)
        // the value is treated as column index.
<span class="fc" id="L84">        Unsafe.getUnsafe().putInt(address, -1 * length);</span>

<span class="fc" id="L86">        Chars.copyStrChars(colName, 0, length, address + Integer.BYTES);</span>
<span class="fc" id="L87">        return address + capacity;</span>
    }

    public long addDate(long address, long value) {
<span class="fc" id="L91">        checkCapacity(address, Long.BYTES + Byte.BYTES);</span>
<span class="fc" id="L92">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_DATE);</span>
<span class="fc" id="L93">        Unsafe.getUnsafe().putLong(address + Byte.BYTES, value);</span>
<span class="fc" id="L94">        return address + Long.BYTES + Byte.BYTES;</span>
    }

    public void addDesignatedTimestamp(long address, long timestamp) {
<span class="fc" id="L98">        checkCapacity(address, Long.BYTES);</span>
<span class="fc" id="L99">        Unsafe.getUnsafe().putLong(address, timestamp);</span>
<span class="fc" id="L100">    }</span>

    public long addDouble(long address, double value) {
<span class="fc" id="L103">        checkCapacity(address, Double.BYTES + Byte.BYTES);</span>
<span class="fc" id="L104">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_DOUBLE);</span>
<span class="fc" id="L105">        Unsafe.getUnsafe().putDouble(address + Byte.BYTES, value);</span>
<span class="fc" id="L106">        return address + Double.BYTES + Byte.BYTES;</span>
    }

    public long addFloat(long address, float value) {
<span class="fc" id="L110">        checkCapacity(address, Float.BYTES + Byte.BYTES);</span>
<span class="fc" id="L111">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_FLOAT);</span>
<span class="fc" id="L112">        Unsafe.getUnsafe().putFloat(address + Byte.BYTES, value);</span>
<span class="fc" id="L113">        return address + Float.BYTES + Byte.BYTES;</span>
    }

    public long addGeoHash(long address, DirectByteCharSequence value, int colTypeMeta) {
        long geohash;
        try {
<span class="fc" id="L119">            geohash = GeoHashes.fromStringTruncatingNl(value.getLo(), value.getHi(), Numbers.decodeLowShort(colTypeMeta));</span>
<span class="fc" id="L120">        } catch (NumericException e) {</span>
<span class="fc" id="L121">            geohash = GeoHashes.NULL;</span>
<span class="fc" id="L122">        }</span>
<span class="fc bfc" id="L123" title="All 4 branches covered.">        switch (Numbers.decodeHighShort(colTypeMeta)) {</span>
            default:
<span class="fc" id="L125">                checkCapacity(address, Long.BYTES + Byte.BYTES);</span>
<span class="fc" id="L126">                Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_GEOLONG);</span>
<span class="fc" id="L127">                Unsafe.getUnsafe().putLong(address + Byte.BYTES, geohash);</span>
<span class="fc" id="L128">                return address + Long.BYTES + Byte.BYTES;</span>
            case ColumnType.GEOINT:
<span class="fc" id="L130">                checkCapacity(address, Integer.BYTES + Byte.BYTES);</span>
<span class="fc" id="L131">                Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_GEOINT);</span>
<span class="fc" id="L132">                Unsafe.getUnsafe().putInt(address + Byte.BYTES, (int) geohash);</span>
<span class="fc" id="L133">                return address + Integer.BYTES + Byte.BYTES;</span>
            case ColumnType.GEOSHORT:
<span class="fc" id="L135">                checkCapacity(address, Short.BYTES + Byte.BYTES);</span>
<span class="fc" id="L136">                Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_GEOSHORT);</span>
<span class="fc" id="L137">                Unsafe.getUnsafe().putShort(address + Byte.BYTES, (short) geohash);</span>
<span class="fc" id="L138">                return address + Short.BYTES + Byte.BYTES;</span>
            case ColumnType.GEOBYTE:
<span class="fc" id="L140">                checkCapacity(address, Byte.BYTES + Byte.BYTES);</span>
<span class="fc" id="L141">                Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_GEOBYTE);</span>
<span class="fc" id="L142">                Unsafe.getUnsafe().putByte(address + Byte.BYTES, (byte) geohash);</span>
<span class="fc" id="L143">                return address + Byte.BYTES + Byte.BYTES;</span>
        }
    }

    public long addInt(long address, int value) {
<span class="fc" id="L148">        checkCapacity(address, Integer.BYTES + Byte.BYTES);</span>
<span class="fc" id="L149">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_INTEGER);</span>
<span class="fc" id="L150">        Unsafe.getUnsafe().putInt(address + Byte.BYTES, value);</span>
<span class="fc" id="L151">        return address + Integer.BYTES + Byte.BYTES;</span>
    }

    public long addLong(long address, long value) {
<span class="fc" id="L155">        checkCapacity(address, Long.BYTES + Byte.BYTES);</span>
<span class="fc" id="L156">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_LONG);</span>
<span class="fc" id="L157">        Unsafe.getUnsafe().putLong(address + Byte.BYTES, value);</span>
<span class="fc" id="L158">        return address + Long.BYTES + Byte.BYTES;</span>
    }

    public long addLong256(long address, DirectByteCharSequence value, boolean hasNonAsciiChars) {
<span class="fc" id="L162">        return addString(address, value, hasNonAsciiChars, LineTcpParser.ENTITY_TYPE_LONG256);</span>
    }

    public long addNull(long address) {
<span class="fc" id="L166">        checkCapacity(address, Byte.BYTES);</span>
<span class="fc" id="L167">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_NULL);</span>
<span class="fc" id="L168">        return address + Byte.BYTES;</span>
    }

    public void addNumOfColumns(long address, int numOfColumns) {
<span class="fc" id="L172">        checkCapacity(address, Integer.BYTES);</span>
<span class="fc" id="L173">        Unsafe.getUnsafe().putInt(address, numOfColumns);</span>
<span class="fc" id="L174">    }</span>

    public long addShort(long address, short value) {
<span class="fc" id="L177">        checkCapacity(address, Short.BYTES + Byte.BYTES);</span>
<span class="fc" id="L178">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_SHORT);</span>
<span class="fc" id="L179">        Unsafe.getUnsafe().putShort(address + Byte.BYTES, value);</span>
<span class="fc" id="L180">        return address + Short.BYTES + Byte.BYTES;</span>
    }

    public long addString(long address, DirectByteCharSequence value, boolean hasNonAsciiChars) {
<span class="fc" id="L184">        return addString(address, value, hasNonAsciiChars, LineTcpParser.ENTITY_TYPE_STRING);</span>
    }

    public void addStructureVersion(long address, long structureVersion) {
<span class="fc" id="L188">        checkCapacity(address, Long.BYTES);</span>
<span class="fc" id="L189">        Unsafe.getUnsafe().putLong(address, structureVersion);</span>
<span class="fc" id="L190">    }</span>

    public long addSymbol(long address, DirectByteCharSequence value, boolean hasNonAsciiChars, DirectByteSymbolLookup symbolLookup) {
<span class="fc" id="L193">        final int maxLen = 2 * value.length();</span>
<span class="fc" id="L194">        checkCapacity(address, Byte.BYTES + Integer.BYTES + maxLen);</span>
<span class="fc" id="L195">        final long strPos = address + Byte.BYTES + Integer.BYTES; // skip field type and string length</span>

        // via temp string the utf8 decoder will be writing directly to our buffer
<span class="fc" id="L198">        tempSink.of(strPos, strPos + maxLen);</span>

<span class="fc" id="L200">        final int symIndex = symbolLookup.keyOf(value);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (symIndex != SymbolTable.VALUE_NOT_FOUND) {</span>
            // We know the symbol int value
            // Encode the int
<span class="fc" id="L204">            Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_CACHED_TAG);</span>
<span class="fc" id="L205">            Unsafe.getUnsafe().putInt(address + Byte.BYTES, symIndex);</span>
<span class="fc" id="L206">            return address + Integer.BYTES + Byte.BYTES;</span>
        } else {
            // Symbol value cannot be resolved at this point
            // Encode whole string value into the message
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (!hasNonAsciiChars) {</span>
<span class="fc" id="L211">                tempSink.put(value);</span>
            } else {
<span class="fc" id="L213">                utf8ToUtf16(value, tempSink, true);</span>
            }
<span class="fc" id="L215">            final int length = tempSink.length();</span>
<span class="fc" id="L216">            Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_TAG);</span>
<span class="fc" id="L217">            Unsafe.getUnsafe().putInt(address + Byte.BYTES, length);</span>
<span class="fc" id="L218">            return address + length * 2L + Integer.BYTES + Byte.BYTES;</span>
        }
    }

    public long addTimestamp(long address, long value) {
<span class="fc" id="L223">        checkCapacity(address, Long.BYTES + Byte.BYTES);</span>
<span class="fc" id="L224">        Unsafe.getUnsafe().putByte(address, LineTcpParser.ENTITY_TYPE_TIMESTAMP);</span>
<span class="fc" id="L225">        Unsafe.getUnsafe().putLong(address + Byte.BYTES, value);</span>
<span class="fc" id="L226">        return address + Long.BYTES + Byte.BYTES;</span>
    }

    /**
     * Add UUID encoded as a string to the buffer.
     * &lt;p&gt;
     * Technically, DirectByteCharSequence is UTF-8 encoded, but any non-ASCII character will cause the UUID
     * to be rejected by the parser. Hence, we do not have to bother with UTF-8 decoding.
     *
     * @param offset offset in the buffer to write to
     * @param value  value to write
     * @return new offset
     * @throws NumericException if the value is not a valid UUID string
     */
    public long addUuid(long offset, DirectByteCharSequence value) throws NumericException {
<span class="fc" id="L241">        checkCapacity(offset, Byte.BYTES + 2 * Long.BYTES);</span>
<span class="fc" id="L242">        Uuid.checkDashesAndLength(value);</span>
<span class="fc" id="L243">        long hi = Uuid.parseHi(value);</span>
<span class="fc" id="L244">        long lo = Uuid.parseLo(value);</span>
<span class="fc" id="L245">        Unsafe.getUnsafe().putByte(offset, LineTcpParser.ENTITY_TYPE_UUID);</span>
<span class="fc" id="L246">        offset += Byte.BYTES;</span>
<span class="fc" id="L247">        Unsafe.getUnsafe().putLong(offset, lo);</span>
<span class="fc" id="L248">        offset += Long.BYTES;</span>
<span class="fc" id="L249">        Unsafe.getUnsafe().putLong(offset, hi);</span>
<span class="fc" id="L250">        return offset + Long.BYTES;</span>
    }

    public long columnValueLength(byte entityType, long offset) {
        CharSequence cs;
<span class="nc bnc" id="L255" title="All 11 branches missed.">        switch (entityType) {</span>
            case LineTcpParser.ENTITY_TYPE_TAG:
            case LineTcpParser.ENTITY_TYPE_STRING:
            case LineTcpParser.ENTITY_TYPE_LONG256:
<span class="nc" id="L259">                cs = readUtf16Chars(offset);</span>
<span class="nc" id="L260">                return cs.length() * 2L + Integer.BYTES;</span>
            case LineTcpParser.ENTITY_TYPE_BYTE:
            case LineTcpParser.ENTITY_TYPE_GEOBYTE:
            case LineTcpParser.ENTITY_TYPE_BOOLEAN:
<span class="nc" id="L264">                return Byte.BYTES;</span>
            case LineTcpParser.ENTITY_TYPE_SHORT:
            case LineTcpParser.ENTITY_TYPE_GEOSHORT:
<span class="nc" id="L267">                return Short.BYTES;</span>
            case LineTcpParser.ENTITY_TYPE_CHAR:
<span class="nc" id="L269">                return Character.BYTES;</span>
            case LineTcpParser.ENTITY_TYPE_CACHED_TAG:
            case LineTcpParser.ENTITY_TYPE_INTEGER:
            case LineTcpParser.ENTITY_TYPE_GEOINT:
<span class="nc" id="L273">                return Integer.BYTES;</span>
            case LineTcpParser.ENTITY_TYPE_LONG:
            case LineTcpParser.ENTITY_TYPE_GEOLONG:
            case LineTcpParser.ENTITY_TYPE_DATE:
            case LineTcpParser.ENTITY_TYPE_TIMESTAMP:
<span class="nc" id="L278">                return Long.BYTES;</span>
            case LineTcpParser.ENTITY_TYPE_FLOAT:
<span class="nc" id="L280">                return Float.BYTES;</span>
            case LineTcpParser.ENTITY_TYPE_DOUBLE:
<span class="nc" id="L282">                return Double.BYTES;</span>
            case LineTcpParser.ENTITY_TYPE_UUID:
<span class="nc" id="L284">                return Long128.BYTES;</span>
            case ENTITY_TYPE_NULL:
<span class="nc" id="L286">                return 0;</span>
            default:
<span class="nc" id="L288">                throw new UnsupportedOperationException(&quot;entityType &quot; + entityType + &quot; is not implemented!&quot;);</span>
        }
    }

    public long getAddress() {
<span class="fc" id="L293">        return bufLo;</span>
    }

    public long getAddressAfterHeader() {
        // The header contains structure version (long), timestamp (long) and number of columns (int).
<span class="fc" id="L298">        return bufLo + 2 * Long.BYTES + Integer.BYTES;</span>
    }

    public byte readByte(long address) {
<span class="fc" id="L302">        return Unsafe.getUnsafe().getByte(address);</span>
    }

    public char readChar(long address) {
<span class="fc" id="L306">        return Unsafe.getUnsafe().getChar(address);</span>
    }

    public double readDouble(long address) {
<span class="fc" id="L310">        return Unsafe.getUnsafe().getDouble(address);</span>
    }

    public float readFloat(long address) {
<span class="fc" id="L314">        return Unsafe.getUnsafe().getFloat(address);</span>
    }

    public int readInt(long address) {
<span class="fc" id="L318">        return Unsafe.getUnsafe().getInt(address);</span>
    }

    public long readLong(long address) {
<span class="fc" id="L322">        return Unsafe.getUnsafe().getLong(address);</span>
    }

    public short readShort(long address) {
<span class="fc" id="L326">        return Unsafe.getUnsafe().getShort(address);</span>
    }

    public CharSequence readUtf16Chars(long address) {
<span class="fc" id="L330">        int len = readInt(address);</span>
<span class="fc" id="L331">        return readUtf16Chars(address + Integer.BYTES, len);</span>
    }

    public CharSequence readUtf16Chars(long address, int length) {
<span class="fc" id="L335">        return tempSink.asCharSequence(address, address + length * 2L);</span>
    }

    private long addString(long address, DirectByteCharSequence value, boolean hasNonAsciiChars, byte entityTypeString) {
<span class="fc" id="L339">        int maxLen = 2 * value.length();</span>
<span class="fc" id="L340">        checkCapacity(address, Byte.BYTES + Integer.BYTES + maxLen);</span>
<span class="fc" id="L341">        long strPos = address + Byte.BYTES + Integer.BYTES; // skip field type and string length</span>
<span class="fc" id="L342">        tempSink.of(strPos, strPos + maxLen);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (hasNonAsciiChars) {</span>
<span class="fc" id="L344">            utf8ToUtf16Unchecked(value, tempSink);</span>
        } else {
<span class="fc" id="L346">            tempSink.put(value);</span>
        }
<span class="fc" id="L348">        final int length = tempSink.length();</span>
<span class="fc" id="L349">        Unsafe.getUnsafe().putByte(address, entityTypeString);</span>
<span class="fc" id="L350">        Unsafe.getUnsafe().putInt(address + Byte.BYTES, length);</span>
<span class="fc" id="L351">        return address + length * 2L + Integer.BYTES + Byte.BYTES;</span>
    }

    private void checkCapacity(long address, int length) {
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (address + length &gt; bufSize) {</span>
<span class="fc" id="L356">            throw CairoException.critical(0).put(&quot;queue buffer overflow&quot;);</span>
        }
<span class="fc" id="L358">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>