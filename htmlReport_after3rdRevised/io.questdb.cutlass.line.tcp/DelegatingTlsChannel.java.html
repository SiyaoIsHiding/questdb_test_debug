<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DelegatingTlsChannel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.line.tcp</a> &gt; <span class="el_source">DelegatingTlsChannel.java</span></div><h1>DelegatingTlsChannel.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.line.tcp;

import io.questdb.client.Sender;
import io.questdb.cutlass.line.LineChannel;
import io.questdb.cutlass.line.LineSenderException;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.MemoryTag;
import io.questdb.std.Misc;
import io.questdb.std.Unsafe;
import io.questdb.std.Vect;

import javax.net.ssl.*;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

public final class DelegatingTlsChannel implements LineChannel {
    private static final long ADDRESS_FIELD_OFFSET;
    private static final int AFTER_HANDSHAKE = 1;
<span class="fc" id="L51">    private static final TrustManager[] BLIND_TRUST_MANAGERS = new TrustManager[]{new X509TrustManager() {</span>
        public void checkClientTrusted(X509Certificate[] certs, String t) {
<span class="nc" id="L53">        }</span>

        public void checkServerTrusted(X509Certificate[] certs, String t) {
<span class="fc" id="L56">        }</span>

        public X509Certificate[] getAcceptedIssuers() {
<span class="fc" id="L59">            return null;</span>
        }
    }};
    private static final long CAPACITY_FIELD_OFFSET;
    private static final int CLOSED = 3;
    private static final int CLOSING = 2;
    private static final int INITIAL_BUFFER_CAPACITY = 64 * 1024;
    private static final int INITIAL_STATE = 0;
    private static final long LIMIT_FIELD_OFFSET;
<span class="fc" id="L68">    private static final Log LOG = LogFactory.getLog(DelegatingTlsChannel.class);</span>
    private final ByteBuffer dummyBuffer;
    private final SSLEngine sslEngine;

    private final ByteBuffer wrapInputBuffer;
    private LineChannel delegate;
<span class="fc" id="L74">    private int state = INITIAL_STATE;</span>
    private ByteBuffer unwrapInputBuffer;
    private long unwrapInputBufferPtr;
    private ByteBuffer unwrapOutputBuffer;
    private long unwrapOutputBufferPtr;
    private ByteBuffer wrapOutputBuffer;
    private long wrapOutputBufferPtr;

    public DelegatingTlsChannel(LineChannel delegate, String trustStorePath, char[] password,
<span class="fc" id="L83">                                Sender.TlsValidationMode validationMode, String peerHost) {</span>
<span class="fc" id="L84">        this.delegate = delegate;</span>
<span class="fc" id="L85">        this.sslEngine = createSslEngine(trustStorePath, password, validationMode, peerHost);</span>

        // wrapInputBuffer is just a placeholder, we set the internal address, capacity and limit in send()
<span class="fc" id="L88">        this.wrapInputBuffer = ByteBuffer.allocateDirect(0);</span>

        // allows to override in tests, but we don't necessary want to expose this to users.
<span class="fc" id="L91">        int initialCapacity = Integer.getInteger(&quot;questdb.experimental.tls.buffersize&quot;, INITIAL_BUFFER_CAPACITY);</span>

        // we want to track allocated memory hence we just create dummy direct byte buffers
        // and later reset it to manually allocated memory
<span class="fc" id="L95">        this.wrapOutputBuffer = ByteBuffer.allocateDirect(0);</span>
<span class="fc" id="L96">        this.unwrapInputBuffer = ByteBuffer.allocateDirect(0);</span>
<span class="fc" id="L97">        this.unwrapOutputBuffer = ByteBuffer.allocateDirect(0);</span>

<span class="fc" id="L99">        this.wrapOutputBufferPtr = allocateMemoryAndResetBuffer(wrapOutputBuffer, initialCapacity);</span>
<span class="fc" id="L100">        this.unwrapInputBufferPtr = allocateMemoryAndResetBuffer(unwrapInputBuffer, initialCapacity);</span>
<span class="fc" id="L101">        this.unwrapOutputBufferPtr = allocateMemoryAndResetBuffer(unwrapOutputBuffer, initialCapacity);</span>

<span class="fc" id="L103">        this.dummyBuffer = ByteBuffer.allocate(0);</span>

        try {
<span class="fc" id="L106">            handshakeLoop();</span>
<span class="fc" id="L107">        } catch (Throwable e) {</span>
            // do not close the delegate - we don't own it when our own constructors fails
<span class="fc" id="L109">            close0(false);</span>
<span class="fc" id="L110">            throw new LineSenderException(&quot;could not perform TLS handshake&quot;, e);</span>
<span class="fc" id="L111">        }</span>
<span class="fc" id="L112">    }</span>

    @Override
    public void close() {
<span class="fc" id="L116">        close0(true);</span>
<span class="fc" id="L117">    }</span>

    public void close0(boolean closeDelegate) {
<span class="fc" id="L120">        int prevState = state;</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (prevState == CLOSED) {</span>
<span class="nc" id="L122">            return;</span>
        }
<span class="fc" id="L124">        state = CLOSING;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (prevState == AFTER_HANDSHAKE) {</span>
            try {
<span class="fc" id="L127">                sslEngine.closeOutbound();</span>
<span class="fc" id="L128">                wrapLoop(dummyBuffer);</span>
<span class="fc" id="L129">                writeToUpstreamAndClear();</span>
<span class="nc" id="L130">            } catch (Throwable e) {</span>
<span class="nc" id="L131">                LOG.error().$(&quot;could not send TLS close_notify alert&quot;).$(e).$();</span>
<span class="fc" id="L132">            }</span>
        }
<span class="fc" id="L134">        state = CLOSED;</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (closeDelegate) {</span>
<span class="fc" id="L137">            delegate = Misc.free(delegate);</span>
        }

        // a bit of ceremony to make sure there is no point that a buffer or a pointer is referencing unallocated memory
<span class="fc" id="L141">        int capacity = wrapOutputBuffer.capacity();</span>
<span class="fc" id="L142">        long ptrToFree = wrapOutputBufferPtr;</span>
<span class="fc" id="L143">        wrapOutputBuffer = null; // if there is an attempt to use a buffer after close() then it's better to throw NPE than segfaulting</span>
<span class="fc" id="L144">        wrapOutputBufferPtr = 0;</span>
<span class="fc" id="L145">        Unsafe.free(ptrToFree, capacity, MemoryTag.NATIVE_TLS_RSS);</span>

<span class="fc" id="L147">        capacity = unwrapInputBuffer.capacity();</span>
<span class="fc" id="L148">        ptrToFree = unwrapInputBufferPtr;</span>
<span class="fc" id="L149">        unwrapInputBuffer = null;</span>
<span class="fc" id="L150">        unwrapInputBufferPtr = 0;</span>
<span class="fc" id="L151">        Unsafe.free(ptrToFree, capacity, MemoryTag.NATIVE_TLS_RSS);</span>

<span class="fc" id="L153">        capacity = unwrapOutputBuffer.capacity();</span>
<span class="fc" id="L154">        ptrToFree = unwrapOutputBufferPtr;</span>
<span class="fc" id="L155">        unwrapOutputBuffer = null;</span>
<span class="fc" id="L156">        unwrapOutputBufferPtr = 0;</span>
<span class="fc" id="L157">        Unsafe.free(ptrToFree, capacity, MemoryTag.NATIVE_TLS_RSS);</span>
<span class="fc" id="L158">    }</span>

    @Override
    public int errno() {
<span class="nc" id="L162">        return delegate.errno();</span>
    }

    @Override
    public int receive(long ptr, int len) {
        try {
<span class="fc" id="L168">            unwrapLoop();</span>
<span class="fc" id="L169">            unwrapOutputBuffer.flip();</span>
<span class="fc" id="L170">            int i = unwrapOutputBufferToPtr(ptr, len);</span>
<span class="fc" id="L171">            unwrapOutputBuffer.compact();</span>
<span class="fc" id="L172">            return i;</span>
<span class="nc" id="L173">        } catch (SSLException e) {</span>
<span class="nc" id="L174">            throw new LineSenderException(&quot;could not unwrap SSL packet&quot;, e);</span>
        }
    }

    @Override
    public void send(long ptr, int len) {
        try {
<span class="fc" id="L181">            resetBufferToPointer(wrapInputBuffer, ptr, len);</span>
<span class="fc" id="L182">            wrapInputBuffer.position(0);</span>
<span class="fc" id="L183">            wrapLoop(wrapInputBuffer);</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">            assert !wrapInputBuffer.hasRemaining();</span>
<span class="nc" id="L185">        } catch (SSLException e) {</span>
<span class="nc" id="L186">            throw new LineSenderException(&quot;error while sending data to questdb server&quot;, e);</span>
<span class="fc" id="L187">        }</span>
<span class="fc" id="L188">    }</span>

    private static long allocateMemoryAndResetBuffer(ByteBuffer buffer, int capacity) {
<span class="fc" id="L191">        long newAddress = Unsafe.malloc(capacity, MemoryTag.NATIVE_TLS_RSS);</span>
<span class="fc" id="L192">        resetBufferToPointer(buffer, newAddress, capacity);</span>
<span class="fc" id="L193">        return newAddress;</span>
    }

    private static SSLEngine createSslEngine(String trustStorePath, char[] trustStorePassword, Sender.TlsValidationMode validationMode, String peerHost) {
<span class="pc bpc" id="L197" title="1 of 4 branches missed.">        assert trustStorePath == null || validationMode == Sender.TlsValidationMode.DEFAULT;</span>
        try {
            SSLContext sslContext;
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (trustStorePath != null) {</span>
<span class="fc" id="L201">                sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="fc" id="L202">                TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="fc" id="L203">                KeyStore jks = KeyStore.getInstance(&quot;JKS&quot;);</span>
<span class="fc" id="L204">                try (InputStream trustStoreStream = openTruststoreStream(trustStorePath)) {</span>
<span class="fc" id="L205">                    jks.load(trustStoreStream, trustStorePassword);</span>
                }
<span class="fc" id="L207">                tmf.init(jks);</span>
<span class="fc" id="L208">                TrustManager[] trustManagers = tmf.getTrustManagers();</span>
<span class="fc" id="L209">                sslContext.init(null, trustManagers, new SecureRandom());</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            } else if (validationMode == Sender.TlsValidationMode.INSECURE) {</span>
<span class="fc" id="L211">                sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="fc" id="L212">                sslContext.init(null, BLIND_TRUST_MANAGERS, new SecureRandom());</span>
            } else {
<span class="fc" id="L214">                sslContext = SSLContext.getDefault();</span>
            }

            // SSLEngine needs to know hostname during TLS handshake to validate a server certificate was issued
            // for the server we are connecting to. For details see the comment below.
            // Hostname validation does not use port at all hence we can get away with a dummy value -1
<span class="fc" id="L220">            SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, -1);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">            if (validationMode != Sender.TlsValidationMode.INSECURE) {</span>
<span class="fc" id="L222">                SSLParameters sslParameters = sslEngine.getSSLParameters();</span>
                // The https validation algorithm? That looks confusing! After all we are not using any
                // https here at so what does it mean?
                // It's actually simple: It just instructs the SSLEngine to perform the same hostname validation
                // as it does during HTTPS connections. SSLEngine does not do hostname validation by default. Without
                // this option SSLEngine would happily accept any certificate as long as it's signed by a trusted CA.
                // This option will make sure certificates are accepted only if they were issued for the
                // server we are connecting to.
<span class="fc" id="L230">                sslParameters.setEndpointIdentificationAlgorithm(&quot;https&quot;);</span>
<span class="fc" id="L231">                sslEngine.setSSLParameters(sslParameters);</span>
            }
<span class="fc" id="L233">            sslEngine.setUseClientMode(true);</span>
<span class="fc" id="L234">            return sslEngine;</span>
<span class="fc" id="L235">        } catch (Throwable t) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (t instanceof LineSenderException) {</span>
<span class="fc" id="L237">                throw (LineSenderException) t;</span>
            }
<span class="fc" id="L239">            throw new LineSenderException(&quot;could not create SSL engine&quot;, t);</span>
        }
    }

    private static long expandBuffer(ByteBuffer buffer, long oldAddress) {
<span class="fc" id="L244">        int oldCapacity = buffer.capacity();</span>
<span class="fc" id="L245">        int newCapacity = oldCapacity * 2;</span>
<span class="fc" id="L246">        long newAddress = Unsafe.realloc(oldAddress, oldCapacity, newCapacity, MemoryTag.NATIVE_TLS_RSS);</span>
<span class="fc" id="L247">        resetBufferToPointer(buffer, newAddress, newCapacity);</span>
<span class="fc" id="L248">        return newAddress;</span>
    }

    private static InputStream openTruststoreStream(String trustStorePath) throws FileNotFoundException {
        InputStream trustStoreStream;
<span class="fc bfc" id="L253" title="All 2 branches covered.">        if (trustStorePath.startsWith(&quot;classpath:&quot;)) {</span>
<span class="fc" id="L254">            String adjustedPath = trustStorePath.substring(&quot;classpath:&quot;.length());</span>
<span class="fc" id="L255">            trustStoreStream = DelegatingTlsChannel.class.getResourceAsStream(adjustedPath);</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if (trustStoreStream == null) {</span>
<span class="fc" id="L257">                throw new LineSenderException(&quot;configured trust store is unavailable &quot;)</span>
<span class="fc" id="L258">                        .put(&quot;[path=&quot;).put(trustStorePath).put(&quot;]&quot;);</span>
            }
<span class="fc" id="L260">            return trustStoreStream;</span>
        }
<span class="fc" id="L262">        return new FileInputStream(trustStorePath);</span>
    }

    private static void resetBufferToPointer(ByteBuffer buffer, long ptr, int len) {
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        assert buffer.isDirect();</span>
<span class="fc" id="L267">        Unsafe.getUnsafe().putLong(buffer, ADDRESS_FIELD_OFFSET, ptr);</span>
<span class="fc" id="L268">        Unsafe.getUnsafe().putLong(buffer, LIMIT_FIELD_OFFSET, len);</span>
<span class="fc" id="L269">        Unsafe.getUnsafe().putLong(buffer, CAPACITY_FIELD_OFFSET, len);</span>
<span class="fc" id="L270">    }</span>

    private void growUnwrapInputBuffer() {
<span class="fc" id="L273">        unwrapInputBufferPtr = expandBuffer(unwrapInputBuffer, unwrapInputBufferPtr);</span>
<span class="fc" id="L274">    }</span>

    private void growUnwrapOutputBuffer() {
<span class="fc" id="L277">        unwrapOutputBufferPtr = expandBuffer(unwrapOutputBuffer, unwrapOutputBufferPtr);</span>
<span class="fc" id="L278">    }</span>

    private void growWrapOutputBuffer() {
<span class="fc" id="L281">        wrapOutputBufferPtr = expandBuffer(wrapOutputBuffer, wrapOutputBufferPtr);</span>
<span class="fc" id="L282">    }</span>

    private void handshakeLoop() throws SSLException {
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (state != INITIAL_STATE) {</span>
<span class="nc" id="L286">            return;</span>
        }

        // trigger handshaking - otherwise the initial state is NOT_HANDSHAKING
<span class="fc" id="L290">        sslEngine.beginHandshake();</span>
        for (; ; ) {
<span class="fc" id="L292">            SSLEngineResult.HandshakeStatus status = sslEngine.getHandshakeStatus();</span>
<span class="pc bpc" id="L293" title="2 of 6 branches missed.">            switch (status) {</span>
                case NOT_HANDSHAKING:
<span class="fc" id="L295">                    state = AFTER_HANDSHAKE;</span>
<span class="fc" id="L296">                    return;</span>
                case NEED_TASK:
<span class="fc" id="L298">                    sslEngine.getDelegatedTask().run();</span>
<span class="fc" id="L299">                    break;</span>
                case NEED_WRAP:
<span class="fc" id="L301">                    wrapLoop(dummyBuffer);</span>
<span class="fc" id="L302">                    break;</span>
                case NEED_UNWRAP:
<span class="fc" id="L304">                    unwrapLoop();</span>
<span class="fc" id="L305">                    break;</span>
                case FINISHED:
<span class="nc" id="L307">                    throw new LineSenderException(&quot;getHandshakeStatus() returned FINISHED. It should not have been possible.&quot;);</span>
                default:
<span class="nc" id="L309">                    throw new LineSenderException(status + &quot;not supported&quot;);</span>
            }
<span class="fc" id="L311">        }</span>
    }

    private void readFromUpstream(boolean force) {
<span class="fc bfc" id="L315" title="All 4 branches covered.">        if (unwrapInputBuffer.position() != 0 &amp;&amp; !force) {</span>
            // we don't want to block on receive() if there are still data to be processed
            // unless we are forced to do so
<span class="fc" id="L318">            return;</span>
        }

<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        assert unwrapInputBuffer.limit() == unwrapInputBuffer.capacity();</span>
<span class="fc" id="L322">        int remainingLen = unwrapInputBuffer.remaining();</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (remainingLen == 0) {</span>
<span class="fc" id="L324">            growUnwrapInputBuffer();</span>
<span class="fc" id="L325">            remainingLen = unwrapInputBuffer.remaining();</span>
        }
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        assert Unsafe.getUnsafe().getLong(unwrapInputBuffer, ADDRESS_FIELD_OFFSET) == unwrapInputBufferPtr;</span>
<span class="fc" id="L328">        long adjustedPtr = unwrapInputBufferPtr + unwrapInputBuffer.position();</span>

<span class="fc" id="L330">        int receive = delegate.receive(adjustedPtr, remainingLen);</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (receive &lt; 0) {</span>
<span class="nc" id="L332">            throw new LineSenderException(&quot;connection closed&quot;);</span>
        }
<span class="fc" id="L334">        unwrapInputBuffer.position(unwrapInputBuffer.position() + receive);</span>
<span class="fc" id="L335">    }</span>

    private void unwrapLoop() throws SSLException {
        // we want the loop to return as soon as we have some unwrapped data in the output buffer
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        while (unwrapOutputBuffer.position() == 0) {</span>
<span class="fc" id="L340">            readFromUpstream(false);</span>
<span class="fc" id="L341">            unwrapInputBuffer.flip();</span>
<span class="fc" id="L342">            SSLEngineResult result = sslEngine.unwrap(unwrapInputBuffer, unwrapOutputBuffer);</span>
<span class="fc" id="L343">            unwrapInputBuffer.compact();</span>
<span class="pc bpc" id="L344" title="2 of 5 branches missed.">            switch (result.getStatus()) {</span>
                case BUFFER_UNDERFLOW:
                    // we need more input no matter what. so let's force reading from the upstream channel
<span class="fc" id="L347">                    readFromUpstream(true);</span>
<span class="fc" id="L348">                    break;</span>
                case BUFFER_OVERFLOW:
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                    if (unwrapOutputBuffer.position() != 0) {</span>
                        // we have at least something, that's enough
                        // if it's not enough then it's up to the caller to call us again
<span class="nc" id="L353">                        return;</span>
                    }

                    // there was overflow, and we have nothing
                    // apparently the output buffer cannot fit even a single TLS record. let's grow it!
<span class="fc" id="L358">                    growUnwrapOutputBuffer();</span>
<span class="fc" id="L359">                    break;</span>
                case OK:
<span class="fc" id="L361">                    return;</span>
                case CLOSED:
<span class="nc" id="L363">                    throw new LineSenderException(&quot;server closed connection unexpectedly&quot;);</span>
            }
<span class="fc" id="L365">        }</span>
<span class="nc" id="L366">    }</span>

    private int unwrapOutputBufferToPtr(long dstPtr, int dstLen) {
<span class="fc" id="L369">        int oldPosition = unwrapOutputBuffer.position();</span>

<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        assert Unsafe.getUnsafe().getLong(unwrapOutputBufferPtr, ADDRESS_FIELD_OFFSET) == unwrapOutputBufferPtr;</span>
<span class="fc" id="L372">        long srcPtr = unwrapOutputBufferPtr + oldPosition;</span>
<span class="fc" id="L373">        int srcLen = unwrapOutputBuffer.remaining();</span>
<span class="fc" id="L374">        int len = Math.min(dstLen, srcLen);</span>
<span class="fc" id="L375">        Vect.memcpy(dstPtr, srcPtr, len);</span>
<span class="fc" id="L376">        unwrapOutputBuffer.position(oldPosition + len);</span>
<span class="fc" id="L377">        return len;</span>
    }

    private void wrapLoop(ByteBuffer src) throws SSLException {
        do {
<span class="fc" id="L382">            SSLEngineResult result = sslEngine.wrap(src, wrapOutputBuffer);</span>
<span class="pc bpc" id="L383" title="2 of 5 branches missed.">            switch (result.getStatus()) {</span>
                case BUFFER_UNDERFLOW:
<span class="nc" id="L385">                    throw new LineSenderException(&quot;should not happen&quot;);</span>
                case BUFFER_OVERFLOW:
<span class="fc" id="L387">                    growWrapOutputBuffer();</span>
<span class="fc" id="L388">                    break;</span>
                case OK:
<span class="fc" id="L390">                    writeToUpstreamAndClear();</span>
<span class="fc" id="L391">                    break;</span>
                case CLOSED:
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                    if (state != CLOSING) {</span>
<span class="nc" id="L394">                        throw new LineSenderException(&quot;server closed connection unexpectedly&quot;);</span>
                    }
<span class="fc" id="L396">                    return;</span>
            }
<span class="fc bfc" id="L398" title="All 2 branches covered.">        } while (src.hasRemaining());</span>
<span class="fc" id="L399">    }</span>

    private void writeToUpstreamAndClear() {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        assert wrapOutputBuffer.limit() == wrapOutputBuffer.capacity();</span>

        // we don't flip the wrapOutputBuffer before reading from it
        // hence the writer position is the actual length to be sent to the upstream channel
<span class="fc" id="L406">        int len = wrapOutputBuffer.position();</span>

<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        assert Unsafe.getUnsafe().getLong(wrapOutputBuffer, ADDRESS_FIELD_OFFSET) == wrapOutputBufferPtr;</span>
<span class="fc" id="L409">        delegate.send(wrapOutputBufferPtr, len);</span>

        // we know limit == capacity
        // thus setting the position to 0 is equivalent to clearing
<span class="fc" id="L413">        wrapOutputBuffer.position(0);</span>
<span class="fc" id="L414">    }</span>

    static {
        Field addressField;
        Field limitField;
        Field capacityField;
        try {
<span class="fc" id="L421">            addressField = Buffer.class.getDeclaredField(&quot;address&quot;);</span>
<span class="fc" id="L422">            limitField = Buffer.class.getDeclaredField(&quot;limit&quot;);</span>
<span class="fc" id="L423">            capacityField = Buffer.class.getDeclaredField(&quot;capacity&quot;);</span>
<span class="nc" id="L424">        } catch (NoSuchFieldException e) {</span>
            // possible improvement: implement a fallback strategy when reflection is unavailable for any reason.
<span class="nc" id="L426">            throw new ExceptionInInitializerError(e);</span>
<span class="fc" id="L427">        }</span>
<span class="fc" id="L428">        ADDRESS_FIELD_OFFSET = Unsafe.getUnsafe().objectFieldOffset(addressField);</span>
<span class="fc" id="L429">        LIMIT_FIELD_OFFSET = Unsafe.getUnsafe().objectFieldOffset(limitField);</span>
<span class="fc" id="L430">        CAPACITY_FIELD_OFFSET = Unsafe.getUnsafe().objectFieldOffset(capacityField);</span>
<span class="fc" id="L431">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>