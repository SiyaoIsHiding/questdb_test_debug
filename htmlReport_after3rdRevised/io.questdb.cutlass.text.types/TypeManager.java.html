<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.text.types</a> &gt; <span class="el_source">TypeManager.java</span></div><h1>TypeManager.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.text.types;

import io.questdb.cairo.CairoException;
import io.questdb.cairo.ColumnType;
import io.questdb.cutlass.text.TextConfiguration;
import io.questdb.std.IntList;
import io.questdb.std.Mutable;
import io.questdb.std.ObjList;
import io.questdb.std.ObjectPool;
import io.questdb.std.datetime.DateFormat;
import io.questdb.std.datetime.DateLocale;
import io.questdb.std.str.DirectCharSink;

public class TypeManager implements Mutable {
    private final ObjectPool&lt;DateUtf8Adapter&gt; dateAdapterPool;
    private final SymbolAdapter indexedSymbolAdapter;
    private final InputFormatConfiguration inputFormatConfiguration;
    private final SymbolAdapter notIndexedSymbolAdapter;
    private final int probeCount;
<span class="fc" id="L44">    private final ObjList&lt;TypeAdapter&gt; probes = new ObjList&lt;&gt;();</span>
    private final StringAdapter stringAdapter;
    private final ObjectPool&lt;TimestampAdapter&gt; timestampAdapterPool;
    private final ObjectPool&lt;TimestampUtf8Adapter&gt; timestampUtf8AdapterPool;

    public TypeManager(
            TextConfiguration configuration,
            DirectCharSink utf8Sink
<span class="fc" id="L52">    ) {</span>
<span class="fc" id="L53">        this.dateAdapterPool = new ObjectPool&lt;&gt;(() -&gt; new DateUtf8Adapter(utf8Sink), configuration.getDateAdapterPoolCapacity());</span>
<span class="fc" id="L54">        this.timestampUtf8AdapterPool = new ObjectPool&lt;&gt;(() -&gt; new TimestampUtf8Adapter(utf8Sink), configuration.getTimestampAdapterPoolCapacity());</span>
<span class="fc" id="L55">        this.timestampAdapterPool = new ObjectPool&lt;&gt;(TimestampAdapter::new, configuration.getTimestampAdapterPoolCapacity());</span>
<span class="fc" id="L56">        this.inputFormatConfiguration = configuration.getInputFormatConfiguration();</span>
<span class="fc" id="L57">        this.stringAdapter = new StringAdapter(utf8Sink);</span>
<span class="fc" id="L58">        this.indexedSymbolAdapter = new SymbolAdapter(utf8Sink, true);</span>
<span class="fc" id="L59">        this.notIndexedSymbolAdapter = new SymbolAdapter(utf8Sink, false);</span>
<span class="fc" id="L60">        addDefaultProbes();</span>

<span class="fc" id="L62">        final ObjList&lt;DateFormat&gt; dateFormats = inputFormatConfiguration.getDateFormats();</span>
<span class="fc" id="L63">        final ObjList&lt;DateLocale&gt; dateLocales = inputFormatConfiguration.getDateLocales();</span>
<span class="fc" id="L64">        final IntList dateUtf8Flags = inputFormatConfiguration.getDateUtf8Flags();</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        for (int i = 0, n = dateFormats.size(); i &lt; n; i++) {</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">            if (dateUtf8Flags.getQuick(i) == 1) {</span>
<span class="nc" id="L67">                probes.add(new DateUtf8Adapter(utf8Sink).of(dateFormats.getQuick(i), dateLocales.getQuick(i)));</span>
            } else {
<span class="fc" id="L69">                probes.add(new DateAdapter().of(dateFormats.getQuick(i), dateLocales.getQuick(i)));</span>
            }
        }

<span class="fc" id="L73">        final ObjList&lt;DateFormat&gt; timestampFormats = inputFormatConfiguration.getTimestampFormats();</span>
<span class="fc" id="L74">        final ObjList&lt;DateLocale&gt; timestampLocales = inputFormatConfiguration.getTimestampLocales();</span>
<span class="fc" id="L75">        final IntList timestampUtf8Flags = inputFormatConfiguration.getTimestampUtf8Flags();</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        for (int i = 0, n = timestampFormats.size(); i &lt; n; i++) {</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">            if (timestampUtf8Flags.getQuick(i) == 1) {</span>
<span class="nc" id="L78">                probes.add(new TimestampUtf8Adapter(utf8Sink).of(timestampFormats.getQuick(i), timestampLocales.getQuick(i)));</span>
            } else {
<span class="fc" id="L80">                probes.add(new TimestampAdapter().of(timestampFormats.getQuick(i), timestampLocales.getQuick(i)));</span>
            }
        }
<span class="fc" id="L83">        this.probeCount = probes.size();</span>
<span class="fc" id="L84">    }</span>

    @Override
    public void clear() {
<span class="fc" id="L88">        dateAdapterPool.clear();</span>
<span class="fc" id="L89">        timestampUtf8AdapterPool.clear();</span>
<span class="fc" id="L90">        timestampAdapterPool.clear();</span>
<span class="fc" id="L91">    }</span>

    public InputFormatConfiguration getInputFormatConfiguration() {
<span class="fc" id="L94">        return inputFormatConfiguration;</span>
    }

    public TypeAdapter getProbe(int index) {
<span class="fc" id="L98">        return probes.getQuick(index);</span>
    }

    public int getProbeCount() {
<span class="fc" id="L102">        return probeCount;</span>
    }

    public TypeAdapter getTypeAdapter(int columnType) {
<span class="fc bfc" id="L106" title="All 14 branches covered.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.BYTE:
<span class="fc" id="L108">                return ByteAdapter.INSTANCE;</span>
            case ColumnType.SHORT:
<span class="fc" id="L110">                return ShortAdapter.INSTANCE;</span>
            case ColumnType.CHAR:
<span class="fc" id="L112">                return CharAdapter.INSTANCE;</span>
            case ColumnType.INT:
<span class="fc" id="L114">                return IntAdapter.INSTANCE;</span>
            case ColumnType.LONG:
<span class="fc" id="L116">                return LongAdapter.INSTANCE;</span>
            case ColumnType.BOOLEAN:
<span class="fc" id="L118">                return BooleanAdapter.INSTANCE;</span>
            case ColumnType.FLOAT:
<span class="fc" id="L120">                return FloatAdapter.INSTANCE;</span>
            case ColumnType.DOUBLE:
<span class="fc" id="L122">                return DoubleAdapter.INSTANCE;</span>
            case ColumnType.STRING:
<span class="fc" id="L124">                return stringAdapter;</span>
            case ColumnType.SYMBOL:
<span class="fc" id="L126">                return nextSymbolAdapter(false);</span>
            case ColumnType.LONG256:
<span class="fc" id="L128">                return Long256Adapter.INSTANCE;</span>
            case ColumnType.GEOBYTE:
            case ColumnType.GEOSHORT:
            case ColumnType.GEOINT:
            case ColumnType.GEOLONG:
<span class="fc" id="L133">                GeoHashAdapter adapter = GeoHashAdapter.getInstance(columnType);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                if (adapter != null) {</span>
<span class="fc" id="L135">                    return adapter;</span>
                }
            case ColumnType.UUID:
<span class="fc" id="L138">                return UuidAdapter.INSTANCE;</span>
            default:
<span class="fc" id="L140">                throw CairoException.nonCritical().put(&quot;no adapter for type [id=&quot;).put(columnType).put(&quot;, name=&quot;).put(ColumnType.nameOf(columnType)).put(']');</span>
        }
    }

    public DateUtf8Adapter nextDateAdapter() {
<span class="fc" id="L145">        return dateAdapterPool.next();</span>
    }

    public TypeAdapter nextSymbolAdapter(boolean indexed) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        return indexed ? indexedSymbolAdapter : notIndexedSymbolAdapter;</span>
    }

    public TypeAdapter nextTimestampAdapter(boolean decodeUtf8, DateFormat format, DateLocale locale) {
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (decodeUtf8) {</span>
<span class="fc" id="L154">            TimestampUtf8Adapter adapter = timestampUtf8AdapterPool.next();</span>
<span class="fc" id="L155">            adapter.of(format, locale);</span>
<span class="fc" id="L156">            return adapter;</span>
        }

<span class="fc" id="L159">        TimestampAdapter adapter = timestampAdapterPool.next();</span>
<span class="fc" id="L160">        adapter.of(format, locale);</span>
<span class="fc" id="L161">        return adapter;</span>
    }

    private void addDefaultProbes() {
<span class="fc" id="L165">        probes.add(getTypeAdapter(ColumnType.CHAR));</span>
<span class="fc" id="L166">        probes.add(getTypeAdapter(ColumnType.INT));</span>
<span class="fc" id="L167">        probes.add(getTypeAdapter(ColumnType.LONG));</span>
<span class="fc" id="L168">        probes.add(getTypeAdapter(ColumnType.DOUBLE));</span>
<span class="fc" id="L169">        probes.add(getTypeAdapter(ColumnType.BOOLEAN));</span>
<span class="fc" id="L170">        probes.add(getTypeAdapter(ColumnType.LONG256));</span>
<span class="fc" id="L171">        probes.add(getTypeAdapter(ColumnType.UUID));</span>
<span class="fc" id="L172">    }</span>

    ObjList&lt;TypeAdapter&gt; getAllAdapters() {
<span class="fc" id="L175">        return probes;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>