<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WalWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo.wal</a> &gt; <span class="el_source">WalWriter.java</span></div><h1>WalWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo.wal;

import io.questdb.Metrics;
import io.questdb.cairo.*;
import io.questdb.cairo.sql.SymbolTable;
import io.questdb.cairo.sql.TableRecordMetadata;
import io.questdb.cairo.sql.TableReferenceOutOfDateException;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryA;
import io.questdb.cairo.vm.api.MemoryMA;
import io.questdb.cairo.vm.api.MemoryMAR;
import io.questdb.cairo.vm.api.NullMemory;
import io.questdb.cairo.wal.seq.MetadataServiceStub;
import io.questdb.cairo.wal.seq.TableMetadataChange;
import io.questdb.cairo.wal.seq.TableMetadataChangeLog;
import io.questdb.cairo.wal.seq.TableSequencerAPI;
import io.questdb.griffin.SqlUtil;
import io.questdb.griffin.engine.ops.AbstractOperation;
import io.questdb.griffin.engine.ops.AlterOperation;
import io.questdb.griffin.engine.ops.UpdateOperation;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.*;
import io.questdb.std.datetime.microtime.Timestamps;
import io.questdb.std.datetime.millitime.MillisecondClock;
import io.questdb.std.str.*;
import org.jetbrains.annotations.NotNull;

import static io.questdb.cairo.TableUtils.*;
import static io.questdb.cairo.wal.WalUtils.WAL_NAME_BASE;
import static io.questdb.cairo.wal.seq.TableSequencer.NO_TXN;
import static io.questdb.std.Chars.utf8ToUtf16;

public class WalWriter implements TableWriterAPI {
    public static final int NEW_COL_RECORD_SIZE = 6;
    private static final long COLUMN_DELETED_NULL_FLAG = Long.MAX_VALUE;
<span class="fc" id="L61">    private static final Log LOG = LogFactory.getLog(WalWriter.class);</span>
    private static final int MEM_TAG = MemoryTag.MMAP_TABLE_WAL_WRITER;
<span class="fc" id="L63">    private static final Runnable NOOP = () -&gt; {</span>
<span class="nc" id="L64">    };</span>
<span class="fc" id="L65">    private final AlterOperation alterOp = new AlterOperation();</span>
    private final ObjList&lt;MemoryMA&gt; columns;
    private final CairoConfiguration configuration;
    private final WalWriterEvents events;
    private final FilesFacade ff;
    private final AtomicIntList initialSymbolCounts;
    private final IntList localSymbolIds;
<span class="fc" id="L72">    private final MetadataValidatorService metaValidatorSvc = new MetadataValidatorService();</span>
<span class="fc" id="L73">    private final MetadataService metaWriterSvc = new MetadataWriterService();</span>
    private final WalWriterMetadata metadata;
    private final Metrics metrics;
    private final int mkDirMode;
    private final ObjList&lt;Runnable&gt; nullSetters;
    private final Path path;
    private final int rootLen;
<span class="fc" id="L80">    private final RowImpl row = new RowImpl();</span>
<span class="fc" id="L81">    private final LongList rowValueIsNotNull = new LongList();</span>
    private final TableSequencerAPI sequencer;
<span class="fc" id="L83">    private final MemoryMAR symbolMapMem = Vm.getMARInstance();</span>
<span class="fc" id="L84">    private final BoolList symbolMapNullFlags = new BoolList();</span>
<span class="fc" id="L85">    private final ObjList&lt;SymbolMapReader&gt; symbolMapReaders = new ObjList&lt;&gt;();</span>
<span class="fc" id="L86">    private final ObjList&lt;CharSequenceIntHashMap&gt; symbolMaps = new ObjList&lt;&gt;();</span>
<span class="fc" id="L87">    private final ObjList&lt;ByteCharSequenceIntHashMap&gt; utf8SymbolMaps = new ObjList&lt;&gt;();</span>
<span class="fc" id="L88">    private final Uuid uuid = new Uuid();</span>
    private final int walId;
    private final String walName;
    private int columnCount;
    private ColumnVersionReader columnVersionReader;
<span class="fc" id="L93">    private long currentTxnStartRowNum = -1;</span>
    private boolean distressed;
<span class="fc" id="L95">    private int lastSegmentTxn = -1;</span>
    private boolean open;
<span class="fc" id="L97">    private boolean rollSegmentOnNextRow = false;</span>
<span class="fc" id="L98">    private int segmentId = -1;</span>
<span class="fc" id="L99">    private int segmentLockFd = -1;</span>
<span class="fc" id="L100">    private long segmentRowCount = -1;</span>
    private TableToken tableToken;
    private TxReader txReader;
<span class="fc" id="L103">    private long txnMaxTimestamp = -1;</span>
<span class="fc" id="L104">    private long txnMinTimestamp = Long.MAX_VALUE;</span>
<span class="fc" id="L105">    private boolean txnOutOfOrder = false;</span>
<span class="fc" id="L106">    private int walLockFd = -1;</span>

    public WalWriter(
            CairoConfiguration configuration,
            TableToken tableToken,
            TableSequencerAPI tableSequencerAPI,
            Metrics metrics
<span class="fc" id="L113">    ) {</span>
<span class="fc" id="L114">        LOG.info().$(&quot;open '&quot;).utf8(tableToken.getDirName()).$('\'').$();</span>
<span class="fc" id="L115">        this.sequencer = tableSequencerAPI;</span>
<span class="fc" id="L116">        this.configuration = configuration;</span>
<span class="fc" id="L117">        this.mkDirMode = configuration.getMkDirMode();</span>
<span class="fc" id="L118">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L119">        this.tableToken = tableToken;</span>
<span class="fc" id="L120">        final int walId = tableSequencerAPI.getNextWalId(tableToken);</span>
<span class="fc" id="L121">        this.walName = WAL_NAME_BASE + walId;</span>
<span class="fc" id="L122">        this.walId = walId;</span>
<span class="fc" id="L123">        this.path = new Path().of(configuration.getRoot()).concat(tableToken).concat(walName);</span>
<span class="fc" id="L124">        this.rootLen = path.length();</span>
<span class="fc" id="L125">        this.metrics = metrics;</span>
<span class="fc" id="L126">        this.open = true;</span>

        try {
<span class="fc" id="L129">            lockWal();</span>
<span class="fc" id="L130">            mkWalDir();</span>

<span class="fc" id="L132">            metadata = new WalWriterMetadata(ff);</span>

<span class="fc" id="L134">            tableSequencerAPI.getTableMetadata(tableToken, metadata);</span>

<span class="fc" id="L136">            columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L137">            columns = new ObjList&lt;&gt;(columnCount * 2);</span>
<span class="fc" id="L138">            nullSetters = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L139">            initialSymbolCounts = new AtomicIntList(columnCount);</span>
<span class="fc" id="L140">            localSymbolIds = new IntList(columnCount);</span>

<span class="fc" id="L142">            events = new WalWriterEvents(ff);</span>
<span class="fc" id="L143">            events.of(symbolMaps, initialSymbolCounts, symbolMapNullFlags);</span>

<span class="fc" id="L145">            configureColumns();</span>
<span class="fc" id="L146">            openNewSegment();</span>
<span class="fc" id="L147">            configureSymbolTable();</span>
<span class="nc" id="L148">        } catch (Throwable e) {</span>
<span class="nc" id="L149">            doClose(false);</span>
<span class="nc" id="L150">            throw e;</span>
<span class="fc" id="L151">        }</span>
<span class="fc" id="L152">    }</span>

    @Override
    public void addColumn(CharSequence columnName, int columnType) {
<span class="fc" id="L156">        addColumn(</span>
                columnName,
                columnType,
<span class="fc" id="L159">                configuration.getDefaultSymbolCapacity(),</span>
<span class="fc" id="L160">                configuration.getDefaultSymbolCacheFlag(),</span>
                false,
<span class="fc" id="L162">                configuration.getIndexValueBlockSize()</span>
        );
<span class="fc" id="L164">    }</span>

    @Override
    public void addColumn(
            CharSequence columnName,
            int columnType,
            int symbolCapacity,
            boolean symbolCacheFlag,
            boolean isIndexed,
            int indexValueBlockCapacity
    ) {
<span class="fc" id="L175">        alterOp.clear();</span>
<span class="fc" id="L176">        alterOp.ofAddColumn(</span>
<span class="fc" id="L177">                getMetadata().getTableId(),</span>
                tableToken,
                0,
                columnName,
                0,
                columnType,
                symbolCapacity,
                symbolCacheFlag,
                isIndexed,
                indexValueBlockCapacity
        );
<span class="fc" id="L188">        apply(alterOp, true);</span>
<span class="fc" id="L189">    }</span>

    @Override
    public long apply(AlterOperation alterOp, boolean contextAllowsAnyStructureChanges) throws AlterTableContextException {
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (inTransaction()) {</span>
<span class="fc" id="L194">            throw CairoException.critical(0).put(&quot;cannot alter table with uncommitted inserts [table=&quot;)</span>
<span class="fc" id="L195">                    .put(tableToken.getTableName()).put(']');</span>
        }
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (alterOp.isStructural()) {</span>
<span class="fc" id="L198">            return applyStructural(alterOp);</span>
        } else {
<span class="fc" id="L200">            return applyNonStructural(alterOp, false);</span>
        }
    }

    // Returns table transaction number
    @Override
    public long apply(UpdateOperation operation) {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (inTransaction()) {</span>
<span class="nc" id="L208">            throw CairoException.critical(0).put(&quot;cannot update table with uncommitted inserts [table=&quot;)</span>
<span class="nc" id="L209">                    .put(tableToken.getTableName()).put(']');</span>
        }

        // it is guaranteed that there is no join in UPDATE statement
        // because SqlCompiler rejects the UPDATE if it contains join
<span class="fc" id="L214">        return applyNonStructural(operation, true);</span>

        // when join is allowed in UPDATE we have 2 options
        // 1. we could write the updated partitions into WAL.
        //   since we cannot really rely on row ids we should probably create
        //   a PARTITION_REWRITE event and use it here to replace the updated
        //   partitions entirely with new ones.
        // 2. we could still pass the SQL statement if we made sure that all
        //   tables involved in the join are guaranteed to be on the same
        //   version (exact same txn number) on each node when the update
        //   statement is run.
        //   so we would need to read current txn number for each table and
        //   put it into the SQL event as a requirement for running the SQL.
        //   when the WAL event is processed we would need to query the exact
        //   versions of each table involved in the join when running the SQL.
    }

    @Override
    public void close() {
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (isOpen()) {</span>
            try {
<span class="fc bfc" id="L235" title="All 2 branches covered.">                if (!distressed) {</span>
<span class="fc" id="L236">                    rollback();</span>
                }
                // if distressed then WAL writer will never be re-used, no rollback needed.
            } finally {
<span class="fc" id="L240">                doClose(true);</span>
            }
        }
<span class="fc" id="L243">    }</span>

    // Returns sequencer transaction number
    @Override
    public long commit() {
<span class="fc" id="L248">        checkDistressed();</span>
        try {
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (inTransaction()) {</span>
<span class="fc" id="L251">                LOG.debug().$(&quot;committing data block [wal=&quot;).$(path).$(Files.SEPARATOR).$(segmentId).$(&quot;, rowLo=&quot;).$(currentTxnStartRowNum).$(&quot;, roHi=&quot;).$(segmentRowCount).I$();</span>
<span class="fc" id="L252">                final long rowsToCommit = getUncommittedRowCount();</span>
<span class="fc" id="L253">                lastSegmentTxn = events.appendData(currentTxnStartRowNum, segmentRowCount, txnMinTimestamp, txnMaxTimestamp, txnOutOfOrder);</span>
<span class="fc" id="L254">                final long seqTxn = getSequencerTxn();</span>
<span class="fc" id="L255">                resetDataTxnProperties();</span>
<span class="fc" id="L256">                mayRollSegmentOnNextRow();</span>
<span class="fc" id="L257">                metrics.getWalMetrics().addRowsWritten(rowsToCommit);</span>
<span class="fc" id="L258">                return seqTxn;</span>
            }
<span class="fc" id="L260">        } catch (CairoException ex) {</span>
<span class="fc" id="L261">            distressed = true;</span>
<span class="fc" id="L262">            throw ex;</span>
<span class="nc" id="L263">        } catch (Throwable th) {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (!isDistressed()) {</span>
                // If distressed, not point to rollback, WalWriter will be not re-used anymore.
<span class="nc" id="L266">                rollback();</span>
            }
<span class="nc" id="L268">            throw th;</span>
<span class="fc" id="L269">        }</span>
<span class="fc" id="L270">        return NO_TXN;</span>
    }

    public void doClose(boolean truncate) {
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (open) {</span>
<span class="fc" id="L275">            open = false;</span>
<span class="fc" id="L276">            metadata.close(Vm.TRUNCATE_TO_POINTER);</span>
<span class="fc" id="L277">            Misc.free(events);</span>
<span class="fc" id="L278">            freeSymbolMapReaders();</span>
<span class="fc" id="L279">            Misc.free(symbolMapMem);</span>
<span class="fc" id="L280">            freeColumns(truncate);</span>

<span class="fc" id="L282">            releaseSegmentLock();</span>

            try {
<span class="fc" id="L285">                releaseWalLock();</span>
            } finally {
<span class="fc" id="L287">                Misc.free(path);</span>
<span class="fc" id="L288">                LOG.info().$(&quot;closed '&quot;).utf8(tableToken.getTableName()).$('\'').$();</span>
            }
        }
<span class="fc" id="L291">    }</span>

    @Override
    public TableRecordMetadata getMetadata() {
<span class="fc" id="L295">        return metadata;</span>
    }

    public int getSegmentId() {
<span class="nc" id="L299">        return segmentId;</span>
    }

    public long getSegmentRowCount() {
<span class="fc" id="L303">        return segmentRowCount;</span>
    }

    @Override
    public long getStructureVersion() {
<span class="fc" id="L308">        return metadata.getStructureVersion();</span>
    }

    @Override
    public int getSymbolCountWatermark(int columnIndex) {
        // It could be the case that ILP I/O thread has newer metadata version than
        // the writer, so it may be requesting a watermark for a recently added column.
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (columnIndex &gt; initialSymbolCounts.size() - 1) {</span>
<span class="nc" id="L316">            return 0;</span>
        }
<span class="nc" id="L318">        return initialSymbolCounts.get(columnIndex);</span>
    }

    public TableToken getTableToken() {
<span class="fc" id="L322">        return tableToken;</span>
    }

    @Override
    public long getUncommittedRowCount() {
<span class="fc" id="L327">        return segmentRowCount - currentTxnStartRowNum;</span>
    }

    public int getWalId() {
<span class="fc" id="L331">        return walId;</span>
    }

    public String getWalName() {
<span class="fc" id="L335">        return walName;</span>
    }

    public void goActive() {
<span class="fc" id="L339">        goActive(Long.MAX_VALUE);</span>
<span class="fc" id="L340">    }</span>

    public boolean goActive(long maxStructureVersion) {
        try {
<span class="fc" id="L344">            applyMetadataChangeLog(maxStructureVersion);</span>
<span class="fc" id="L345">            return true;</span>
<span class="nc" id="L346">        } catch (CairoException e) {</span>
<span class="nc" id="L347">            LOG.critical().$(&quot;could not apply structure changes, WAL will be closed [table=&quot;).$(tableToken.getTableName())</span>
<span class="nc" id="L348">                    .$(&quot;, walId=&quot;).$(walId)</span>
<span class="nc" id="L349">                    .$(&quot;, errno=&quot;).$(e.getErrno())</span>
<span class="nc" id="L350">                    .$(&quot;, error=&quot;).$((Throwable) e).I$();</span>
<span class="nc" id="L351">            distressed = true;</span>
<span class="nc" id="L352">            return false;</span>
        }
    }

    @Override
    public void ic() {
<span class="fc" id="L358">        commit();</span>
<span class="fc" id="L359">    }</span>

    @Override
    public void ic(long o3MaxLag) {
<span class="nc" id="L363">        commit();</span>
<span class="nc" id="L364">    }</span>

    public boolean inTransaction() {
<span class="fc bfc" id="L367" title="All 2 branches covered.">        return segmentRowCount &gt; currentTxnStartRowNum;</span>
    }

    public boolean isDistressed() {
<span class="fc" id="L371">        return distressed;</span>
    }

    public boolean isOpen() {
<span class="fc" id="L375">        return this.open;</span>
    }

    @Override
    public TableWriter.Row newRow() {
<span class="fc" id="L380">        return newRow(0L);</span>
    }

    @Override
    public TableWriter.Row newRow(long timestamp) {
<span class="fc" id="L385">        checkDistressed();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if (timestamp &lt; Timestamps.O3_MIN_TS) {</span>
<span class="fc" id="L387">            throw CairoException.nonCritical().put(&quot;timestamp before 1970-01-01 is not allowed&quot;);</span>
        }
        try {
<span class="fc bfc" id="L390" title="All 2 branches covered.">            if (rollSegmentOnNextRow) {</span>
<span class="fc" id="L391">                rollSegment();</span>
<span class="fc" id="L392">                rollSegmentOnNextRow = false;</span>
            }

<span class="fc" id="L395">            final int timestampIndex = metadata.getTimestampIndex();</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (timestampIndex != -1) {</span>
                //avoid lookups by having a designated field with primaryColumn
<span class="fc" id="L398">                final MemoryMA primaryColumn = getPrimaryColumn(timestampIndex);</span>
<span class="fc" id="L399">                primaryColumn.putLong128(timestamp, segmentRowCount);</span>
<span class="fc" id="L400">                setRowValueNotNull(timestampIndex);</span>
<span class="fc" id="L401">                row.timestamp = timestamp;</span>
            }
<span class="fc" id="L403">            return row;</span>
<span class="fc" id="L404">        } catch (Throwable e) {</span>
<span class="fc" id="L405">            distressed = true;</span>
<span class="fc" id="L406">            throw e;</span>
        }
    }

    public void rollUncommittedToNewSegment() {
<span class="fc" id="L411">        final long uncommittedRows = getUncommittedRowCount();</span>
<span class="fc" id="L412">        final int newSegmentId = segmentId + 1;</span>

<span class="fc" id="L414">        path.trimTo(rootLen);</span>

<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (uncommittedRows &gt; 0) {</span>
<span class="fc" id="L417">            createSegmentDir(newSegmentId);</span>
<span class="fc" id="L418">            path.trimTo(rootLen);</span>
<span class="fc" id="L419">            final LongList newColumnFiles = new LongList();</span>
<span class="fc" id="L420">            newColumnFiles.setPos(columnCount * NEW_COL_RECORD_SIZE);</span>
<span class="fc" id="L421">            newColumnFiles.fill(0, columnCount * NEW_COL_RECORD_SIZE, -1);</span>
<span class="fc" id="L422">            rowValueIsNotNull.fill(0, columnCount, -1);</span>

            try {
<span class="fc" id="L425">                final int timestampIndex = metadata.getTimestampIndex();</span>
<span class="fc" id="L426">                LOG.info().$(&quot;rolling uncommitted rows to new segment [wal=&quot;)</span>
<span class="fc" id="L427">                        .$(path).$(Files.SEPARATOR).$(newSegmentId)</span>
<span class="fc" id="L428">                        .$(&quot;, rowCount=&quot;).$(uncommittedRows).I$();</span>

<span class="fc bfc" id="L430" title="All 2 branches covered.">                for (int columnIndex = 0; columnIndex &lt; columnCount; columnIndex++) {</span>
<span class="fc" id="L431">                    final int columnType = metadata.getColumnType(columnIndex);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                    if (columnType &gt; 0) {</span>
<span class="fc" id="L433">                        final MemoryMA primaryColumn = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L434">                        final MemoryMA secondaryColumn = getSecondaryColumn(columnIndex);</span>
<span class="fc" id="L435">                        final String columnName = metadata.getColumnName(columnIndex);</span>

<span class="fc" id="L437">                        CopyWalSegmentUtils.rollColumnToSegment(ff,</span>
<span class="fc" id="L438">                                configuration.getWriterFileOpenOpts(),</span>
                                primaryColumn,
                                secondaryColumn,
                                path,
                                newSegmentId,
                                columnName,
<span class="fc bfc" id="L444" title="All 2 branches covered.">                                columnIndex == timestampIndex ? -columnType : columnType,</span>
                                currentTxnStartRowNum,
                                uncommittedRows,
                                newColumnFiles,
                                columnIndex
                        );
<span class="fc" id="L450">                    } else {</span>
<span class="fc" id="L451">                        rowValueIsNotNull.setQuick(columnIndex, COLUMN_DELETED_NULL_FLAG);</span>
                    }
                }
<span class="fc" id="L454">            } catch (Throwable e) {</span>
<span class="fc" id="L455">                closeSegmentSwitchFiles(newColumnFiles);</span>
<span class="fc" id="L456">                throw e;</span>
<span class="fc" id="L457">            }</span>
<span class="fc" id="L458">            switchColumnsToNewSegment(newColumnFiles);</span>
<span class="fc" id="L459">            rollLastWalEventRecord(newSegmentId, uncommittedRows);</span>
<span class="fc" id="L460">            segmentId = newSegmentId;</span>
<span class="fc" id="L461">            segmentRowCount = uncommittedRows;</span>
<span class="fc" id="L462">            currentTxnStartRowNum = 0;</span>
<span class="pc bpc" id="L463" title="2 of 4 branches missed.">        } else if (segmentRowCount &gt; 0 &amp;&amp; uncommittedRows == 0) {</span>
<span class="fc" id="L464">            rollSegmentOnNextRow = true;</span>
        }
<span class="fc" id="L466">    }</span>

    @Override
    public void rollback() {
        try {
<span class="pc bpc" id="L471" title="1 of 4 branches missed.">            if (inTransaction() || hasDirtyColumns(currentTxnStartRowNum)) {</span>
<span class="fc" id="L472">                setAppendPosition(currentTxnStartRowNum);</span>
<span class="fc" id="L473">                segmentRowCount = currentTxnStartRowNum;</span>
<span class="fc" id="L474">                txnMinTimestamp = Long.MAX_VALUE;</span>
<span class="fc" id="L475">                txnMaxTimestamp = -1;</span>
<span class="fc" id="L476">                txnOutOfOrder = false;</span>
            }
<span class="nc" id="L478">        } catch (Throwable th) {</span>
            // Set to dissatisfied state, otherwise the pool will keep trying to rollback until the stack overflow
<span class="nc" id="L480">            distressed = true;</span>
<span class="nc" id="L481">            throw th;</span>
<span class="fc" id="L482">        }</span>
<span class="fc" id="L483">    }</span>

    @Override
    public boolean supportsMultipleWriters() {
<span class="fc" id="L487">        return true;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L492">        return &quot;WalWriter{&quot; +</span>
                &quot;name=&quot; + walName +
<span class="fc" id="L494">                &quot;, table=&quot; + tableToken.getTableName() +</span>
                '}';
    }

    @Override
    public void truncate() {
        try {
<span class="fc" id="L501">            lastSegmentTxn = events.truncate();</span>
<span class="fc" id="L502">            getSequencerTxn();</span>
<span class="nc" id="L503">        } catch (Throwable th) {</span>
<span class="nc" id="L504">            rollback();</span>
<span class="nc" id="L505">            throw th;</span>
<span class="fc" id="L506">        }</span>
<span class="fc" id="L507">    }</span>

    public void updateTableToken(TableToken tableToken) {
<span class="fc" id="L510">        this.tableToken = tableToken;</span>
<span class="fc" id="L511">    }</span>

    private static void configureNullSetters(ObjList&lt;Runnable&gt; nullers, int type, MemoryA mem1, MemoryA mem2) {
<span class="pc bpc" id="L514" title="1 of 17 branches missed.">        switch (ColumnType.tagOf(type)) {</span>
            case ColumnType.BOOLEAN:
            case ColumnType.BYTE:
<span class="fc" id="L517">                nullers.add(() -&gt; mem1.putByte((byte) 0));</span>
<span class="fc" id="L518">                break;</span>
            case ColumnType.DOUBLE:
<span class="fc" id="L520">                nullers.add(() -&gt; mem1.putDouble(Double.NaN));</span>
<span class="fc" id="L521">                break;</span>
            case ColumnType.FLOAT:
<span class="fc" id="L523">                nullers.add(() -&gt; mem1.putFloat(Float.NaN));</span>
<span class="fc" id="L524">                break;</span>
            case ColumnType.INT:
<span class="fc" id="L526">                nullers.add(() -&gt; mem1.putInt(Numbers.INT_NaN));</span>
<span class="fc" id="L527">                break;</span>
            case ColumnType.LONG:
            case ColumnType.DATE:
            case ColumnType.TIMESTAMP:
<span class="fc" id="L531">                nullers.add(() -&gt; mem1.putLong(Numbers.LONG_NaN));</span>
<span class="fc" id="L532">                break;</span>
            case ColumnType.LONG256:
<span class="fc" id="L534">                nullers.add(() -&gt; mem1.putLong256(Numbers.LONG_NaN, Numbers.LONG_NaN, Numbers.LONG_NaN, Numbers.LONG_NaN));</span>
<span class="fc" id="L535">                break;</span>
            case ColumnType.SHORT:
<span class="fc" id="L537">                nullers.add(() -&gt; mem1.putShort((short) 0));</span>
<span class="fc" id="L538">                break;</span>
            case ColumnType.CHAR:
<span class="fc" id="L540">                nullers.add(() -&gt; mem1.putChar((char) 0));</span>
<span class="fc" id="L541">                break;</span>
            case ColumnType.STRING:
<span class="fc" id="L543">                nullers.add(() -&gt; mem2.putLong(mem1.putNullStr()));</span>
<span class="fc" id="L544">                break;</span>
            case ColumnType.SYMBOL:
<span class="fc" id="L546">                nullers.add(() -&gt; mem1.putInt(SymbolTable.VALUE_IS_NULL));</span>
<span class="fc" id="L547">                break;</span>
            case ColumnType.BINARY:
<span class="fc" id="L549">                nullers.add(() -&gt; mem2.putLong(mem1.putNullBin()));</span>
<span class="fc" id="L550">                break;</span>
            case ColumnType.GEOBYTE:
<span class="fc" id="L552">                nullers.add(() -&gt; mem1.putByte(GeoHashes.BYTE_NULL));</span>
<span class="fc" id="L553">                break;</span>
            case ColumnType.GEOSHORT:
<span class="fc" id="L555">                nullers.add(() -&gt; mem1.putShort(GeoHashes.SHORT_NULL));</span>
<span class="fc" id="L556">                break;</span>
            case ColumnType.GEOINT:
<span class="fc" id="L558">                nullers.add(() -&gt; mem1.putInt(GeoHashes.INT_NULL));</span>
<span class="fc" id="L559">                break;</span>
            case ColumnType.GEOLONG:
<span class="fc" id="L561">                nullers.add(() -&gt; mem1.putLong(GeoHashes.NULL));</span>
<span class="fc" id="L562">                break;</span>
            case ColumnType.LONG128:
                // fall through
            case ColumnType.UUID:
<span class="fc" id="L566">                nullers.add(() -&gt; mem1.putLong128(Numbers.LONG_NaN, Numbers.LONG_NaN));</span>
<span class="fc" id="L567">                break;</span>
            default:
<span class="nc" id="L569">                throw new UnsupportedOperationException(&quot;unsupported column type: &quot; + ColumnType.nameOf(type));</span>
        }
<span class="fc" id="L571">    }</span>

    private static void freeNullSetter(ObjList&lt;Runnable&gt; nullSetters, int columnIndex) {
<span class="fc" id="L574">        nullSetters.setQuick(columnIndex, NOOP);</span>
<span class="fc" id="L575">    }</span>

    private static int getPrimaryColumnIndex(int index) {
<span class="fc" id="L578">        return index * 2;</span>
    }

    private static int getSecondaryColumnIndex(int index) {
<span class="fc" id="L582">        return getPrimaryColumnIndex(index) + 1;</span>
    }

    private void applyMetadataChangeLog(long structureVersionHi) {
<span class="fc" id="L586">        try (TableMetadataChangeLog log = sequencer.getMetadataChangeLog(tableToken, metadata.getStructureVersion())) {</span>
<span class="fc" id="L587">            long structVer = getStructureVersion();</span>
<span class="fc bfc" id="L588" title="All 4 branches covered.">            while (log.hasNext() &amp;&amp; structVer &lt; structureVersionHi) {</span>
<span class="fc" id="L589">                TableMetadataChange chg = log.next();</span>
                try {
<span class="fc" id="L591">                    chg.apply(metaWriterSvc, true);</span>
<span class="fc" id="L592">                } catch (CairoException e) {</span>
<span class="fc" id="L593">                    distressed = true;</span>
<span class="fc" id="L594">                    throw e;</span>
<span class="fc" id="L595">                }</span>

<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                if (++structVer != getStructureVersion()) {</span>
<span class="nc" id="L598">                    distressed = true;</span>
<span class="nc" id="L599">                    throw CairoException.critical(0)</span>
<span class="nc" id="L600">                            .put(&quot;could not apply table definition changes to the current transaction, version unchanged&quot;);</span>
                }
<span class="fc" id="L602">            }</span>
        }
<span class="fc" id="L604">    }</span>

    private long applyNonStructural(AbstractOperation op, boolean verifyStructureVersion) {
<span class="fc bfc" id="L607" title="All 2 branches covered.">        if (op.getSqlExecutionContext() == null) {</span>
<span class="fc" id="L608">            throw CairoException.critical(0).put(&quot;failed to commit ALTER SQL to WAL, sql context is empty [table=&quot;).put(tableToken.getTableName()).put(']');</span>
        }
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                (verifyStructureVersion &amp;&amp; op.getTableVersion() != getStructureVersion())</span>
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">                        || op.getTableId() != metadata.getTableId()) {</span>
<span class="fc" id="L613">            throw TableReferenceOutOfDateException.of(tableToken, metadata.getTableId(), op.getTableId(), getStructureVersion(), op.getTableVersion());</span>
        }

        try {
<span class="fc" id="L617">            lastSegmentTxn = events.appendSql(op.getCmdType(), op.getSqlText(), op.getSqlExecutionContext());</span>
<span class="fc" id="L618">            return getSequencerTxn();</span>
<span class="fc" id="L619">        } catch (Throwable th) {</span>
            // perhaps half record was written to WAL-e, better to not use this WAL writer instance
<span class="fc" id="L621">            distressed = true;</span>
<span class="fc" id="L622">            throw th;</span>
        }
    }

    private long applyStructural(AlterOperation alterOp) {
        long txn;
        do {
<span class="fc" id="L629">            boolean retry = true;</span>
            try {
<span class="fc" id="L631">                metaValidatorSvc.startAlterValidation();</span>
<span class="fc" id="L632">                alterOp.apply(metaValidatorSvc, true);</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">                if (metaValidatorSvc.structureVersion != metadata.getStructureVersion() + 1) {</span>
<span class="fc" id="L634">                    retry = false;</span>
<span class="fc" id="L635">                    throw CairoException.nonCritical()</span>
<span class="fc" id="L636">                            .put(&quot;statements containing multiple transactions, such as 'alter table add column col1, col2'&quot; +</span>
<span class="fc" id="L637">                                    &quot; are currently not supported for WAL tables [table=&quot;).put(tableToken.getTableName())</span>
<span class="fc" id="L638">                            .put(&quot;, oldStructureVersion=&quot;).put(metadata.getStructureVersion())</span>
<span class="fc" id="L639">                            .put(&quot;, newStructureVersion=&quot;).put(metaValidatorSvc.structureVersion).put(']');</span>
                }
<span class="fc" id="L641">            } catch (CairoException e) {</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">                if (retry) {</span>
                    // Table schema (metadata) changed and this Alter is not valid anymore.
                    // Try to update WAL metadata to latest and repeat one more time.
<span class="fc" id="L645">                    goActive();</span>
<span class="nc" id="L646">                    alterOp.apply(metaValidatorSvc, true);</span>
                } else {
<span class="fc" id="L648">                    throw e;</span>
                }
<span class="fc" id="L650">            }</span>

            try {
<span class="fc" id="L653">                txn = sequencer.nextStructureTxn(tableToken, metadata.getStructureVersion(), alterOp);</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">                if (txn == NO_TXN) {</span>
<span class="fc" id="L655">                    applyMetadataChangeLog(Long.MAX_VALUE);</span>
                }
<span class="fc" id="L657">            } catch (CairoException e) {</span>
<span class="fc" id="L658">                distressed = true;</span>
<span class="fc" id="L659">                throw e;</span>
<span class="fc" id="L660">            }</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">        } while (txn == NO_TXN);</span>

        // Apply to itself.
        try {
<span class="fc" id="L665">            alterOp.apply(metaWriterSvc, true);</span>
<span class="fc" id="L666">        } catch (Throwable th) {</span>
            // Transaction successful, but writing using this WAL writer should not be possible.
<span class="fc" id="L668">            LOG.error().$(&quot;Exception during alter [ex=&quot;).$(th).I$();</span>
<span class="fc" id="L669">            distressed = true;</span>
<span class="fc" id="L670">        }</span>
<span class="fc" id="L671">        return txn;</span>
    }

    private void checkDistressed() {
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (!distressed) {</span>
<span class="fc" id="L676">            return;</span>
        }
<span class="fc" id="L678">        throw CairoException.critical(0)</span>
<span class="fc" id="L679">                .put(&quot;WAL writer is distressed and cannot be used any more [table=&quot;).put(tableToken.getTableName())</span>
<span class="fc" id="L680">                .put(&quot;, wal=&quot;).put(walId).put(']');</span>
    }

    private void cleanupSymbolMapFiles(Path path, int rootLen, CharSequence columnName) {
<span class="fc" id="L684">        path.trimTo(rootLen);</span>
<span class="fc" id="L685">        BitmapIndexUtils.valueFileName(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc" id="L686">        ff.remove(path.$());</span>

<span class="fc" id="L688">        path.trimTo(rootLen);</span>
<span class="fc" id="L689">        BitmapIndexUtils.keyFileName(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc" id="L690">        ff.remove(path.$());</span>

<span class="fc" id="L692">        path.trimTo(rootLen);</span>
<span class="fc" id="L693">        TableUtils.charFileName(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc" id="L694">        ff.remove(path.$());</span>

<span class="fc" id="L696">        path.trimTo(rootLen);</span>
<span class="fc" id="L697">        TableUtils.offsetFileName(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc" id="L698">        ff.remove(path.$());</span>
<span class="fc" id="L699">    }</span>

    private void closeSegmentSwitchFiles(LongList newColumnFiles) {
        // Each record is about primary and secondary file. File descriptor is set every half a record.
<span class="fc" id="L703">        int halfRecord = NEW_COL_RECORD_SIZE / 2;</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">        for (int fdIndex = 0; fdIndex &lt; newColumnFiles.size(); fdIndex += halfRecord) {</span>
<span class="fc" id="L705">            final int fd = (int) newColumnFiles.get(fdIndex);</span>
<span class="fc" id="L706">            ff.close(fd);</span>
        }
<span class="fc" id="L708">    }</span>

    private void configureColumn(int index, int columnType) {
<span class="fc" id="L711">        final int baseIndex = getPrimaryColumnIndex(index);</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">        if (columnType &gt; 0) {</span>
<span class="fc" id="L713">            final MemoryMA primary = Vm.getMAInstance();</span>
<span class="fc" id="L714">            final MemoryMA secondary = createSecondaryMem(columnType);</span>
<span class="fc" id="L715">            columns.extendAndSet(baseIndex, primary);</span>
<span class="fc" id="L716">            columns.extendAndSet(baseIndex + 1, secondary);</span>
<span class="fc" id="L717">            configureNullSetters(nullSetters, columnType, primary, secondary);</span>
<span class="fc" id="L718">            rowValueIsNotNull.add(-1);</span>
<span class="fc" id="L719">        } else {</span>
<span class="fc" id="L720">            columns.extendAndSet(baseIndex, NullMemory.INSTANCE);</span>
<span class="fc" id="L721">            columns.extendAndSet(baseIndex + 1, NullMemory.INSTANCE);</span>
<span class="fc" id="L722">            nullSetters.add(NOOP);</span>
<span class="fc" id="L723">            rowValueIsNotNull.add(COLUMN_DELETED_NULL_FLAG);</span>
        }
<span class="fc" id="L725">    }</span>

    private void configureColumns() {
<span class="fc bfc" id="L728" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L729">            configureColumn(i, metadata.getColumnType(i));</span>
        }
<span class="fc" id="L731">    }</span>

    private void configureEmptySymbol(int columnWriterIndex) {
<span class="fc" id="L734">        symbolMapReaders.extendAndSet(columnWriterIndex, EmptySymbolMapReader.INSTANCE);</span>
<span class="fc" id="L735">        initialSymbolCounts.extendAndSet(columnWriterIndex, 0);</span>
<span class="fc" id="L736">        localSymbolIds.extendAndSet(columnWriterIndex, 0);</span>
<span class="fc" id="L737">        symbolMapNullFlags.extendAndSet(columnWriterIndex, false);</span>
<span class="fc" id="L738">        symbolMaps.extendAndSet(columnWriterIndex, new CharSequenceIntHashMap(8, 0.5, SymbolTable.VALUE_NOT_FOUND));</span>
<span class="fc" id="L739">        utf8SymbolMaps.extendAndSet(columnWriterIndex, new ByteCharSequenceIntHashMap(8, 0.5, SymbolTable.VALUE_NOT_FOUND));</span>
<span class="fc" id="L740">    }</span>

    private void configureSymbolMapWriter(
            int columnWriterIndex,
            CharSequence columnName,
            int symbolCount,
            long columnNameTxn
    ) {
<span class="fc bfc" id="L748" title="All 2 branches covered.">        if (symbolCount == 0) {</span>
<span class="fc" id="L749">            configureEmptySymbol(columnWriterIndex);</span>
<span class="fc" id="L750">            return;</span>
        }

        // Copy or hard link symbol map files.
<span class="fc" id="L754">        FilesFacade ff = configuration.getFilesFacade();</span>
<span class="fc" id="L755">        Path tempPath = Path.PATH.get();</span>
<span class="fc" id="L756">        tempPath.of(configuration.getRoot()).concat(tableToken);</span>
<span class="fc" id="L757">        int tempPathTripLen = tempPath.length();</span>

<span class="fc" id="L759">        path.trimTo(rootLen);</span>
<span class="fc" id="L760">        TableUtils.offsetFileName(tempPath, columnName, columnNameTxn);</span>
<span class="fc" id="L761">        TableUtils.offsetFileName(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">        if (-1 == ff.hardLink(tempPath.$(), path.$())) {</span>
            // This is fine, Table Writer can rename or drop the column.
<span class="fc" id="L764">            LOG.info().$(&quot;failed to link offset file [from=&quot;).$(tempPath)</span>
<span class="fc" id="L765">                    .$(&quot;, to=&quot;).$(path)</span>
<span class="fc" id="L766">                    .$(&quot;, errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L767">                    .I$();</span>
<span class="fc" id="L768">            configureEmptySymbol(columnWriterIndex);</span>
<span class="fc" id="L769">            return;</span>
        }

<span class="fc" id="L772">        tempPath.trimTo(tempPathTripLen);</span>
<span class="fc" id="L773">        path.trimTo(rootLen);</span>
<span class="fc" id="L774">        TableUtils.charFileName(tempPath, columnName, columnNameTxn);</span>
<span class="fc" id="L775">        TableUtils.charFileName(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">        if (-1 == ff.hardLink(tempPath.$(), path.$())) {</span>
            // This is fine, Table Writer can rename or drop the column.
<span class="fc" id="L778">            LOG.info().$(&quot;failed to link char file [from=&quot;).$(tempPath)</span>
<span class="fc" id="L779">                    .$(&quot;, to=&quot;).$(path)</span>
<span class="fc" id="L780">                    .$(&quot;, errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L781">                    .I$();</span>
<span class="fc" id="L782">            cleanupSymbolMapFiles(path, rootLen, columnName);</span>
<span class="fc" id="L783">            configureEmptySymbol(columnWriterIndex);</span>
<span class="fc" id="L784">            return;</span>
        }

<span class="fc" id="L787">        tempPath.trimTo(tempPathTripLen);</span>
<span class="fc" id="L788">        path.trimTo(rootLen);</span>
<span class="fc" id="L789">        BitmapIndexUtils.keyFileName(tempPath, columnName, columnNameTxn);</span>
<span class="fc" id="L790">        BitmapIndexUtils.keyFileName(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (-1 == ff.hardLink(tempPath.$(), path.$())) {</span>
            // This is fine, Table Writer can rename or drop the column.
<span class="fc" id="L793">            LOG.info().$(&quot;failed to link key file [from=&quot;).$(tempPath)</span>
<span class="fc" id="L794">                    .$(&quot;, to=&quot;).$(path)</span>
<span class="fc" id="L795">                    .$(&quot;, errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L796">                    .I$();</span>
<span class="fc" id="L797">            cleanupSymbolMapFiles(path, rootLen, columnName);</span>
<span class="fc" id="L798">            configureEmptySymbol(columnWriterIndex);</span>
<span class="fc" id="L799">            return;</span>
        }

<span class="fc" id="L802">        tempPath.trimTo(tempPathTripLen);</span>
<span class="fc" id="L803">        path.trimTo(rootLen);</span>
<span class="fc" id="L804">        BitmapIndexUtils.valueFileName(tempPath, columnName, columnNameTxn);</span>
<span class="fc" id="L805">        BitmapIndexUtils.valueFileName(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">        if (-1 == ff.hardLink(tempPath.$(), path.$())) {</span>
            // This is fine, Table Writer can rename or drop the column.
<span class="fc" id="L808">            LOG.info().$(&quot;failed to link value file [from=&quot;).$(tempPath)</span>
<span class="fc" id="L809">                    .$(&quot;, to=&quot;).$(path)</span>
<span class="fc" id="L810">                    .$(&quot;, errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L811">                    .I$();</span>
<span class="fc" id="L812">            cleanupSymbolMapFiles(path, rootLen, columnName);</span>
<span class="fc" id="L813">            configureEmptySymbol(columnWriterIndex);</span>
<span class="fc" id="L814">            return;</span>
        }

<span class="fc" id="L817">        path.trimTo(rootLen);</span>
<span class="fc" id="L818">        SymbolMapReader symbolMapReader = new SymbolMapReaderImpl(</span>
                configuration,
                path,
                columnName,
                COLUMN_NAME_TXN_NONE,
                symbolCount
        );

<span class="fc" id="L826">        symbolMapReaders.extendAndSet(columnWriterIndex, symbolMapReader);</span>
<span class="fc" id="L827">        symbolMaps.extendAndSet(columnWriterIndex, new CharSequenceIntHashMap(8, 0.5, SymbolTable.VALUE_NOT_FOUND));</span>
<span class="fc" id="L828">        utf8SymbolMaps.extendAndSet(columnWriterIndex, new ByteCharSequenceIntHashMap(8, 0.5, SymbolTable.VALUE_NOT_FOUND));</span>
<span class="fc" id="L829">        initialSymbolCounts.extendAndSet(columnWriterIndex, symbolCount);</span>
<span class="fc" id="L830">        localSymbolIds.extendAndSet(columnWriterIndex, 0);</span>
<span class="fc" id="L831">        symbolMapNullFlags.extendAndSet(columnWriterIndex, symbolMapReader.containsNullValue());</span>
<span class="fc" id="L832">    }</span>

    private void configureSymbolTable() {
<span class="fc" id="L835">        boolean initialized = false;</span>
        try {
<span class="fc" id="L837">            int denseSymbolIndex = 0;</span>

<span class="fc bfc" id="L839" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L840">                int columnType = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">                if (!ColumnType.isSymbol(columnType)) {</span>
                    // Maintain sparse list of symbol writers
                    // Note: we don't need to set initialSymbolCounts and symbolMapNullFlags values
                    // here since we already filled it with -1 and false initially
<span class="fc" id="L845">                    symbolMapReaders.extendAndSet(i, null);</span>
<span class="fc" id="L846">                    symbolMaps.extendAndSet(i, null);</span>
<span class="fc" id="L847">                    utf8SymbolMaps.extendAndSet(i, null);</span>
                } else {
<span class="fc bfc" id="L849" title="All 2 branches covered.">                    if (txReader == null) {</span>
<span class="fc" id="L850">                        txReader = new TxReader(ff);</span>
<span class="fc" id="L851">                        columnVersionReader = new ColumnVersionReader();</span>
                    }

<span class="fc bfc" id="L854" title="All 2 branches covered.">                    if (!initialized) {</span>
<span class="fc" id="L855">                        MillisecondClock milliClock = configuration.getMillisecondClock();</span>
<span class="fc" id="L856">                        long spinLockTimeout = configuration.getSpinLockTimeout();</span>

                        // todo: use own path
<span class="fc" id="L859">                        Path path = Path.PATH2.get();</span>
<span class="fc" id="L860">                        path.of(configuration.getRoot()).concat(tableToken).concat(TXN_FILE_NAME).$();</span>

                        // Does not matter which PartitionBy, as long as it is partitioned
                        // WAL tables must be partitioned
<span class="fc" id="L864">                        txReader.ofRO(path, PartitionBy.DAY);</span>
<span class="fc" id="L865">                        path.of(configuration.getRoot()).concat(tableToken).concat(COLUMN_VERSION_FILE_NAME).$();</span>
<span class="fc" id="L866">                        columnVersionReader.ofRO(ff, path);</span>

<span class="fc" id="L868">                        initialized = true;</span>
<span class="fc" id="L869">                        long structureVersion = getStructureVersion();</span>

                        do {
<span class="fc" id="L872">                            TableUtils.safeReadTxn(txReader, milliClock, spinLockTimeout);</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">                            if (txReader.getStructureVersion() != structureVersion) {</span>
<span class="fc" id="L874">                                initialized = false;</span>
<span class="fc" id="L875">                                break;</span>
                            }
<span class="fc" id="L877">                            columnVersionReader.readSafe(milliClock, spinLockTimeout);</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">                        } while (txReader.getColumnVersion() != columnVersionReader.getVersion());</span>
                    }

<span class="fc bfc" id="L881" title="All 2 branches covered.">                    if (initialized) {</span>
<span class="fc" id="L882">                        int symbolValueCount = txReader.getSymbolValueCount(denseSymbolIndex);</span>
<span class="fc" id="L883">                        long columnNameTxn = columnVersionReader.getDefaultColumnNameTxn(i);</span>
<span class="fc" id="L884">                        configureSymbolMapWriter(i, metadata.getColumnName(i), symbolValueCount, columnNameTxn);</span>
<span class="fc" id="L885">                    } else {</span>
                        // table on disk structure version does not match the structure version of the WalWriter
                        // it is not possible to re-use table symbol table because the column name may not match.
                        // The symbol counts stored as dense in _txn file and removal of symbols
                        // shifts the counts that's why it's not possible to find out the symbol count if metadata versions
                        // don't match.
<span class="fc" id="L891">                        configureSymbolMapWriter(i, metadata.getColumnName(i), 0, COLUMN_NAME_TXN_NONE);</span>
                    }
                }

<span class="pc bpc" id="L895" title="1 of 4 branches missed.">                if (columnType == ColumnType.SYMBOL || columnType == -ColumnType.SYMBOL) {</span>
<span class="fc" id="L896">                    denseSymbolIndex++;</span>
                }
            }
        } finally {
<span class="fc" id="L900">            Misc.free(columnVersionReader);</span>
<span class="fc" id="L901">            Misc.free(txReader);</span>
        }
<span class="fc" id="L903">    }</span>

    private MemoryMA createSecondaryMem(int columnType) {
<span class="fc bfc" id="L906" title="All 2 branches covered.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.BINARY:
            case ColumnType.STRING:
<span class="fc" id="L909">                return Vm.getMAInstance();</span>
            default:
<span class="fc" id="L911">                return null;</span>
        }
    }

    private int createSegmentDir(int segmentId) {
<span class="fc" id="L916">        path.trimTo(rootLen);</span>
<span class="fc" id="L917">        path.slash().put(segmentId);</span>
<span class="fc" id="L918">        final int segmentPathLen = path.length();</span>
<span class="fc" id="L919">        rolloverSegmentLock();</span>
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">        if (ff.mkdirs(path.slash$(), mkDirMode) != 0) {</span>
<span class="nc" id="L921">            throw CairoException.critical(ff.errno()).put(&quot;Cannot create WAL segment directory: &quot;).put(path);</span>
        }
<span class="fc" id="L923">        path.trimTo(segmentPathLen);</span>
<span class="fc" id="L924">        return segmentPathLen;</span>
    }

    private void freeAndRemoveColumnPair(ObjList&lt;MemoryMA&gt; columns, int pi, int si) {
<span class="fc" id="L928">        final MemoryMA primaryColumn = columns.getAndSetQuick(pi, NullMemory.INSTANCE);</span>
<span class="fc" id="L929">        final MemoryMA secondaryColumn = columns.getAndSetQuick(si, NullMemory.INSTANCE);</span>
<span class="fc" id="L930">        primaryColumn.close(true, Vm.TRUNCATE_TO_POINTER);</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">        if (secondaryColumn != null) {</span>
<span class="fc" id="L932">            secondaryColumn.close(true, Vm.TRUNCATE_TO_POINTER);</span>
        }
<span class="fc" id="L934">    }</span>

    private void freeColumns(boolean truncate) {
        // null check is because this method could be called from the constructor
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if (columns != null) {</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">            for (int i = 0, n = columns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L940">                final MemoryMA m = columns.getQuick(i);</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">                if (m != null) {</span>
<span class="fc" id="L942">                    m.close(truncate, Vm.TRUNCATE_TO_POINTER);</span>
                }
            }
        }
<span class="fc" id="L946">    }</span>

    private void freeSymbolMapReaders() {
<span class="fc" id="L949">        Misc.freeObjListIfCloseable(symbolMapReaders);</span>
<span class="fc" id="L950">    }</span>

    private MemoryMA getPrimaryColumn(int column) {
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">        assert column &lt; columnCount : &quot;Column index is out of bounds: &quot; + column + &quot; &gt;= &quot; + columnCount;</span>
<span class="fc" id="L954">        return columns.getQuick(getPrimaryColumnIndex(column));</span>
    }

    private MemoryMA getSecondaryColumn(int column) {
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">        assert column &lt; columnCount : &quot;Column index is out of bounds: &quot; + column + &quot; &gt;= &quot; + columnCount;</span>
<span class="fc" id="L959">        return columns.getQuick(getSecondaryColumnIndex(column));</span>
    }

    private long getSequencerTxn() {
        long seqTxn;
        do {
<span class="fc" id="L965">            seqTxn = sequencer.nextTxn(tableToken, walId, metadata.getStructureVersion(), segmentId, lastSegmentTxn);</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">            if (seqTxn == NO_TXN) {</span>
<span class="fc" id="L967">                applyMetadataChangeLog(Long.MAX_VALUE);</span>
            }
<span class="fc bfc" id="L969" title="All 2 branches covered.">        } while (seqTxn == NO_TXN);</span>
<span class="fc" id="L970">        return seqTxn;</span>
    }

    private boolean hasDirtyColumns(long currentTxnStartRowNum) {
<span class="fc bfc" id="L974" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L975">            long writtenCount = rowValueIsNotNull.getQuick(i);</span>
<span class="pc bpc" id="L976" title="1 of 4 branches missed.">            if (writtenCount &gt;= currentTxnStartRowNum &amp;&amp; writtenCount != COLUMN_DELETED_NULL_FLAG) {</span>
<span class="nc" id="L977">                return true;</span>
            }
        }
<span class="fc" id="L980">        return false;</span>
    }

    private void lockWal() {
        try {
<span class="fc" id="L985">            lockName(path);</span>
<span class="fc" id="L986">            walLockFd = TableUtils.lock(ff, path);</span>
        } finally {
<span class="fc" id="L988">            path.trimTo(rootLen);</span>
        }

<span class="pc bpc" id="L991" title="1 of 2 branches missed.">        if (walLockFd == -1) {</span>
<span class="nc" id="L992">            throw CairoException.critical(ff.errno()).put(&quot;Cannot lock table: &quot;).put(path.$());</span>
        }
<span class="fc" id="L994">    }</span>

    private void markColumnRemoved(int columnIndex) {
<span class="fc" id="L997">        final int pi = getPrimaryColumnIndex(columnIndex);</span>
<span class="fc" id="L998">        final int si = getSecondaryColumnIndex(columnIndex);</span>
<span class="fc" id="L999">        freeNullSetter(nullSetters, columnIndex);</span>
<span class="fc" id="L1000">        freeAndRemoveColumnPair(columns, pi, si);</span>
<span class="fc" id="L1001">        rowValueIsNotNull.setQuick(columnIndex, COLUMN_DELETED_NULL_FLAG);</span>
<span class="fc" id="L1002">    }</span>

    private void mayRollSegmentOnNextRow() {
<span class="pc bpc" id="L1005" title="2 of 6 branches missed.">        if (!rollSegmentOnNextRow &amp;&amp; (segmentRowCount &gt;= configuration.getWalSegmentRolloverRowCount()) || lastSegmentTxn &gt; Integer.MAX_VALUE - 2) {</span>
<span class="fc" id="L1006">            rollSegmentOnNextRow = true;</span>
        }
<span class="fc" id="L1008">    }</span>

    private void mkWalDir() {
<span class="fc" id="L1011">        final int walDirLength = path.length();</span>
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">        if (ff.mkdirs(path.slash$(), mkDirMode) != 0) {</span>
<span class="nc" id="L1013">            throw CairoException.critical(ff.errno()).put(&quot;Cannot create WAL directory: &quot;).put(path);</span>
        }
<span class="fc" id="L1015">        path.trimTo(walDirLength);</span>
<span class="fc" id="L1016">    }</span>

    private void openColumnFiles(CharSequence name, int columnIndex, int pathTrimToLen) {
        try {
<span class="fc" id="L1020">            final MemoryMA mem1 = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L1021">            mem1.close(true, Vm.TRUNCATE_TO_POINTER);</span>
<span class="fc" id="L1022">            mem1.of(ff,</span>
<span class="fc" id="L1023">                    dFile(path.trimTo(pathTrimToLen), name),</span>
<span class="fc" id="L1024">                    configuration.getDataAppendPageSize(),</span>
                    -1,
                    MemoryTag.MMAP_TABLE_WRITER,
<span class="fc" id="L1027">                    configuration.getWriterFileOpenOpts(),</span>
                    Files.POSIX_MADV_RANDOM
            );

<span class="fc" id="L1031">            final MemoryMA mem2 = getSecondaryColumn(columnIndex);</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">            if (mem2 != null) {</span>
<span class="fc" id="L1033">                mem2.close(true, Vm.TRUNCATE_TO_POINTER);</span>
<span class="fc" id="L1034">                mem2.of(ff,</span>
<span class="fc" id="L1035">                        iFile(path.trimTo(pathTrimToLen), name),</span>
<span class="fc" id="L1036">                        configuration.getDataAppendPageSize(),</span>
                        -1,
                        MemoryTag.MMAP_TABLE_WRITER,
<span class="fc" id="L1039">                        configuration.getWriterFileOpenOpts(),</span>
                        Files.POSIX_MADV_RANDOM
                );
<span class="fc" id="L1042">                mem2.putLong(0L);</span>
            }
        } finally {
<span class="fc" id="L1045">            path.trimTo(pathTrimToLen);</span>
        }
<span class="fc" id="L1047">    }</span>

    private void openNewSegment() {
        try {
<span class="fc" id="L1051">            segmentId++;</span>
<span class="fc" id="L1052">            currentTxnStartRowNum = 0;</span>
<span class="fc" id="L1053">            rowValueIsNotNull.fill(0, columnCount, -1);</span>
<span class="fc" id="L1054">            final int segmentPathLen = createSegmentDir(segmentId);</span>

<span class="fc bfc" id="L1056" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1057">                int type = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">                if (type &gt; 0) {</span>
<span class="fc" id="L1059">                    final CharSequence name = metadata.getColumnName(i);</span>
<span class="fc" id="L1060">                    openColumnFiles(name, i, segmentPathLen);</span>

<span class="fc bfc" id="L1062" title="All 4 branches covered.">                    if (type == ColumnType.SYMBOL &amp;&amp; symbolMapReaders.size() &gt; 0) {</span>
<span class="fc" id="L1063">                        final SymbolMapReader reader = symbolMapReaders.getQuick(i);</span>
<span class="fc" id="L1064">                        initialSymbolCounts.set(i, reader.getSymbolCount());</span>
<span class="fc" id="L1065">                        localSymbolIds.set(i, 0);</span>
<span class="fc" id="L1066">                        symbolMapNullFlags.set(i, reader.containsNullValue());</span>
<span class="fc" id="L1067">                        symbolMaps.getQuick(i).clear();</span>
<span class="fc" id="L1068">                        utf8SymbolMaps.getQuick(i).clear();</span>
                    }
<span class="fc" id="L1070">                } else {</span>
<span class="fc" id="L1071">                    rowValueIsNotNull.setQuick(i, COLUMN_DELETED_NULL_FLAG);</span>
                }
            }

<span class="fc" id="L1075">            segmentRowCount = 0;</span>
<span class="fc" id="L1076">            metadata.switchTo(path, segmentPathLen);</span>
<span class="fc" id="L1077">            events.openEventFile(path, segmentPathLen);</span>
<span class="fc" id="L1078">            lastSegmentTxn = 0;</span>
<span class="fc" id="L1079">            LOG.info().$(&quot;opened WAL segment [path='&quot;).$(path).$('\'').I$();</span>
        } finally {
<span class="fc" id="L1081">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L1083">    }</span>

    private void releaseSegmentLock() {
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (ff.close(segmentLockFd)) {</span>
<span class="fc" id="L1087">            segmentLockFd = -1;</span>
        }
<span class="fc" id="L1089">    }</span>

    private void releaseWalLock() {
<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">        if (ff.close(walLockFd)) {</span>
<span class="fc" id="L1093">            walLockFd = -1;</span>
        }
<span class="fc" id="L1095">    }</span>

    private void removeSymbolMapReader(int index) {
<span class="fc" id="L1098">        Misc.freeIfCloseable(symbolMapReaders.getAndSetQuick(index, null));</span>
<span class="fc" id="L1099">        symbolMaps.setQuick(index, null);</span>
<span class="fc" id="L1100">        utf8SymbolMaps.setQuick(index, null);</span>
<span class="fc" id="L1101">        initialSymbolCounts.set(index, -1);</span>
<span class="fc" id="L1102">        localSymbolIds.set(index, 0);</span>
<span class="fc" id="L1103">        symbolMapNullFlags.set(index, false);</span>
<span class="fc" id="L1104">        cleanupSymbolMapFiles(path, rootLen, metadata.getColumnName(index));</span>
<span class="fc" id="L1105">    }</span>

    private void renameColumnFiles(int columnType, CharSequence columnName, CharSequence newName) {
<span class="fc" id="L1108">        path.trimTo(rootLen).slash().put(segmentId);</span>
<span class="fc" id="L1109">        final Path tempPath = Path.PATH.get().of(path);</span>

<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if (ColumnType.isVariableLength(columnType)) {</span>
<span class="fc" id="L1112">            final int trimTo = path.length();</span>
<span class="fc" id="L1113">            iFile(path, columnName);</span>
<span class="fc" id="L1114">            iFile(tempPath, newName);</span>
<span class="pc bpc" id="L1115" title="1 of 2 branches missed.">            if (ff.rename(path.$(), tempPath.$()) != Files.FILES_RENAME_OK) {</span>
<span class="nc" id="L1116">                throw CairoException.critical(ff.errno()).put(&quot;could not rename WAL column file [from=&quot;).put(path).put(&quot;, to=&quot;).put(tempPath).put(']');</span>
            }
<span class="fc" id="L1118">            path.trimTo(trimTo);</span>
<span class="fc" id="L1119">            tempPath.trimTo(trimTo);</span>
        }

<span class="fc" id="L1122">        dFile(path, columnName);</span>
<span class="fc" id="L1123">        dFile(tempPath, newName);</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">        if (ff.rename(path.$(), tempPath.$()) != Files.FILES_RENAME_OK) {</span>
<span class="fc" id="L1125">            throw CairoException.critical(ff.errno()).put(&quot;could not rename WAL column file [from=&quot;).put(path).put(&quot;, to=&quot;).put(tempPath).put(']');</span>
        }
<span class="fc" id="L1127">    }</span>

    private void resetDataTxnProperties() {
<span class="fc" id="L1130">        currentTxnStartRowNum = segmentRowCount;</span>
<span class="fc" id="L1131">        txnMinTimestamp = Long.MAX_VALUE;</span>
<span class="fc" id="L1132">        txnMaxTimestamp = -1;</span>
<span class="fc" id="L1133">        txnOutOfOrder = false;</span>
<span class="fc" id="L1134">        resetSymbolMaps();</span>
<span class="fc" id="L1135">    }</span>

    private void resetSymbolMaps() {
<span class="fc" id="L1138">        final int numOfColumns = symbolMaps.size();</span>
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        for (int i = 0; i &lt; numOfColumns; i++) {</span>
<span class="fc" id="L1140">            final CharSequenceIntHashMap symbolMap = symbolMaps.getQuick(i);</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">            if (symbolMap != null) {</span>
<span class="fc" id="L1142">                symbolMap.clear();</span>
            }

<span class="fc" id="L1145">            final ByteCharSequenceIntHashMap dbcsSymbolMap = utf8SymbolMaps.getQuick(i);</span>
<span class="fc bfc" id="L1146" title="All 2 branches covered.">            if (dbcsSymbolMap != null) {</span>
<span class="fc" id="L1147">                dbcsSymbolMap.clear();</span>
            }

<span class="fc" id="L1150">            final SymbolMapReader reader = symbolMapReaders.getQuick(i);</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">            if (reader != null) {</span>
<span class="fc" id="L1152">                initialSymbolCounts.set(i, reader.getSymbolCount());</span>
<span class="fc" id="L1153">                localSymbolIds.set(i, 0);</span>
<span class="fc" id="L1154">                symbolMapNullFlags.set(i, reader.containsNullValue());</span>
            }
        }
<span class="fc" id="L1157">    }</span>

    private void rollLastWalEventRecord(int newSegmentId, long uncommittedRows) {
<span class="fc" id="L1160">        events.rollback();</span>
<span class="fc" id="L1161">        path.trimTo(rootLen).slash().put(newSegmentId);</span>
<span class="fc" id="L1162">        events.openEventFile(path, path.length());</span>
<span class="fc" id="L1163">        lastSegmentTxn = events.appendData(0, uncommittedRows, txnMinTimestamp, txnMaxTimestamp, txnOutOfOrder);</span>
<span class="fc" id="L1164">    }</span>

    private void rolloverSegmentLock() {
<span class="fc" id="L1167">        releaseSegmentLock();</span>
<span class="fc" id="L1168">        final int segmentPathLen = path.length();</span>
        try {
<span class="fc" id="L1170">            lockName(path);</span>
<span class="fc" id="L1171">            segmentLockFd = TableUtils.lock(ff, path);</span>
<span class="pc bpc" id="L1172" title="1 of 2 branches missed.">            if (segmentLockFd == -1) {</span>
<span class="nc" id="L1173">                path.trimTo(segmentPathLen);</span>
<span class="nc" id="L1174">                throw CairoException.critical(ff.errno()).put(&quot;Cannot lock wal segment: &quot;).put(path.$());</span>
            }
        } finally {
<span class="fc" id="L1177">            path.trimTo(segmentPathLen);</span>
        }
<span class="fc" id="L1179">    }</span>

    private void rowAppend(ObjList&lt;Runnable&gt; activeNullSetters, long rowTimestamp) {
<span class="fc bfc" id="L1182" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">            if (rowValueIsNotNull.getQuick(i) &lt; segmentRowCount) {</span>
<span class="fc" id="L1184">                activeNullSetters.getQuick(i).run();</span>
            }
        }

<span class="fc bfc" id="L1188" title="All 2 branches covered.">        if (rowTimestamp &gt; txnMaxTimestamp) {</span>
<span class="fc" id="L1189">            txnMaxTimestamp = rowTimestamp;</span>
        } else {
<span class="fc bfc" id="L1191" title="All 2 branches covered.">            txnOutOfOrder |= (txnMaxTimestamp != rowTimestamp);</span>
        }
<span class="fc bfc" id="L1193" title="All 2 branches covered.">        if (rowTimestamp &lt; txnMinTimestamp) {</span>
<span class="fc" id="L1194">            txnMinTimestamp = rowTimestamp;</span>
        }

<span class="fc" id="L1197">        segmentRowCount++;</span>
<span class="fc" id="L1198">    }</span>

    private void setAppendPosition(final long segmentRowCount) {
<span class="fc bfc" id="L1201" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1202">            setColumnSize(i, segmentRowCount);</span>
<span class="fc" id="L1203">            int type = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">            if (type &gt; 0) {</span>
<span class="fc" id="L1205">                rowValueIsNotNull.setQuick(i, segmentRowCount - 1);</span>
            }
        }
<span class="fc" id="L1208">    }</span>

    private void setColumnNull(int columnType, int columnIndex, long rowCount) {
<span class="fc bfc" id="L1211" title="All 2 branches covered.">        if (ColumnType.isVariableLength(columnType)) {</span>
<span class="fc" id="L1212">            setVarColumnVarFileNull(columnType, columnIndex, rowCount);</span>
<span class="fc" id="L1213">            setVarColumnFixedFileNull(columnType, columnIndex, rowCount);</span>
        } else {
<span class="fc" id="L1215">            setFixColumnNulls(columnType, columnIndex, rowCount);</span>
        }
<span class="fc" id="L1217">    }</span>

    private void setColumnSize(int columnIndex, long size) {
<span class="fc" id="L1220">        MemoryMA mem1 = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L1221">        MemoryMA mem2 = getSecondaryColumn(columnIndex);</span>
<span class="fc" id="L1222">        int type = metadata.getColumnType(columnIndex);</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        if (type &gt; 0) { // Not deleted</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">            if (size &gt; 0) {</span>
                // subtract column top
                final long m1pos;
<span class="fc bfc" id="L1227" title="All 2 branches covered.">                switch (ColumnType.tagOf(type)) {</span>
                    case ColumnType.BINARY:
                    case ColumnType.STRING:
<span class="pc bpc" id="L1230" title="1 of 2 branches missed.">                        assert mem2 != null;</span>
                        // Jump to the number of records written to read length of var column correctly
<span class="fc" id="L1232">                        mem2.jumpTo(size * Long.BYTES);</span>
<span class="fc" id="L1233">                        m1pos = Unsafe.getUnsafe().getLong(mem2.getAppendAddress());</span>
                        // Jump to the end of file to correctly trim the file
<span class="fc" id="L1235">                        mem2.jumpTo((size + 1) * Long.BYTES);</span>
<span class="fc" id="L1236">                        break;</span>
                    default:
<span class="fc bfc" id="L1238" title="All 2 branches covered.">                        if (columnIndex == metadata.getTimestampIndex()) {</span>
<span class="fc" id="L1239">                            m1pos = size &lt;&lt; 4;</span>
                        } else {
<span class="fc" id="L1241">                            m1pos = size &lt;&lt; ColumnType.pow2SizeOf(type);</span>
                        }
                        break;
                }
<span class="fc" id="L1245">                mem1.jumpTo(m1pos);</span>
<span class="fc" id="L1246">            } else {</span>
<span class="fc" id="L1247">                mem1.jumpTo(0);</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">                if (mem2 != null) {</span>
<span class="fc" id="L1249">                    mem2.jumpTo(0);</span>
<span class="fc" id="L1250">                    mem2.putLong(0);</span>
                }
            }
        }
<span class="fc" id="L1254">    }</span>

    private void setFixColumnNulls(int type, int columnIndex, long rowCount) {
<span class="fc" id="L1257">        MemoryMA fixedSizeColumn = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L1258">        long columnFileSize = rowCount * ColumnType.sizeOf(type);</span>
<span class="fc" id="L1259">        fixedSizeColumn.jumpTo(columnFileSize);</span>
<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">        if (columnFileSize &gt; 0) {</span>
<span class="fc" id="L1261">            long address = TableUtils.mapRW(ff, fixedSizeColumn.getFd(), columnFileSize, MEM_TAG);</span>
            try {
<span class="fc" id="L1263">                TableUtils.setNull(type, address, rowCount);</span>
            } finally {
<span class="fc" id="L1265">                ff.munmap(address, columnFileSize, MEM_TAG);</span>
            }
        }
<span class="fc" id="L1268">    }</span>

    private void setRowValueNotNull(int columnIndex) {
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">        assert rowValueIsNotNull.getQuick(columnIndex) != segmentRowCount;</span>
<span class="fc" id="L1272">        rowValueIsNotNull.setQuick(columnIndex, segmentRowCount);</span>
<span class="fc" id="L1273">    }</span>

    private void setVarColumnFixedFileNull(int columnType, int columnIndex, long rowCount) {
<span class="fc" id="L1276">        MemoryMA fixedSizeColumn = getSecondaryColumn(columnIndex);</span>
<span class="fc" id="L1277">        long fixedSizeColSize = (rowCount + 1) * Long.BYTES;</span>
<span class="fc" id="L1278">        fixedSizeColumn.jumpTo(fixedSizeColSize);</span>
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">        if (rowCount &gt; 0) {</span>
<span class="fc" id="L1280">            long addressFixed = TableUtils.mapRW(ff, fixedSizeColumn.getFd(), fixedSizeColSize, MEM_TAG);</span>
            try {
<span class="fc bfc" id="L1282" title="All 2 branches covered.">                if (columnType == ColumnType.STRING) {</span>
<span class="fc" id="L1283">                    Vect.setVarColumnRefs32Bit(addressFixed, 0, rowCount + 1);</span>
                } else {
<span class="fc" id="L1285">                    Vect.setVarColumnRefs64Bit(addressFixed, 0, rowCount + 1);</span>
                }
            } finally {
<span class="fc" id="L1288">                ff.munmap(addressFixed, fixedSizeColSize, MEM_TAG);</span>
            }
        }
<span class="fc" id="L1291">    }</span>

    private void setVarColumnVarFileNull(int columnType, int columnIndex, long rowCount) {
<span class="fc" id="L1294">        MemoryMA varColumn = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L1295">        long varColSize = rowCount * ColumnType.variableColumnLengthBytes(columnType);</span>
<span class="fc" id="L1296">        varColumn.jumpTo(varColSize);</span>
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        if (rowCount &gt; 0) {</span>
<span class="fc" id="L1298">            long address = TableUtils.mapRW(ff, varColumn.getFd(), varColSize, MEM_TAG);</span>
            try {
<span class="fc" id="L1300">                Vect.memset(address, varColSize, -1);</span>
            } finally {
<span class="fc" id="L1302">                ff.munmap(address, varColSize, MEM_TAG);</span>
            }
        }
<span class="fc" id="L1305">    }</span>

    private void switchColumnsToNewSegment(LongList newColumnFiles) {
<span class="fc bfc" id="L1308" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1309">            int newPrimaryFd = (int) newColumnFiles.get(i * NEW_COL_RECORD_SIZE);</span>
<span class="fc bfc" id="L1310" title="All 2 branches covered.">            if (newPrimaryFd &gt; -1) {</span>
<span class="fc" id="L1311">                MemoryMA primaryColumnFile = getPrimaryColumn(i);</span>
<span class="fc" id="L1312">                long currentOffset = newColumnFiles.get(i * NEW_COL_RECORD_SIZE + 1);</span>
<span class="fc" id="L1313">                long newOffset = newColumnFiles.get(i * NEW_COL_RECORD_SIZE + 2);</span>
<span class="fc" id="L1314">                primaryColumnFile.jumpTo(currentOffset);</span>
<span class="fc" id="L1315">                primaryColumnFile.switchTo(newPrimaryFd, newOffset, Vm.TRUNCATE_TO_POINTER);</span>

<span class="fc" id="L1317">                int newSecondaryFd = (int) newColumnFiles.get(i * NEW_COL_RECORD_SIZE + 3);</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">                if (newSecondaryFd &gt; -1) {</span>
<span class="fc" id="L1319">                    MemoryMA secondaryColumnFile = getSecondaryColumn(i);</span>
<span class="fc" id="L1320">                    currentOffset = newColumnFiles.get(i * NEW_COL_RECORD_SIZE + 4);</span>
<span class="fc" id="L1321">                    newOffset = newColumnFiles.get(i * NEW_COL_RECORD_SIZE + 5);</span>
<span class="fc" id="L1322">                    secondaryColumnFile.jumpTo(currentOffset);</span>
<span class="fc" id="L1323">                    secondaryColumnFile.switchTo(newSecondaryFd, newOffset, Vm.TRUNCATE_TO_POINTER);</span>
                }
            }
        }
<span class="fc" id="L1327">    }</span>

    SymbolMapReader getSymbolMapReader(int columnIndex) {
<span class="fc" id="L1330">        return symbolMapReaders.getQuick(columnIndex);</span>
    }

    void rollSegment() {
        try {
<span class="fc" id="L1335">            openNewSegment();</span>
<span class="fc" id="L1336">        } catch (Throwable e) {</span>
<span class="fc" id="L1337">            distressed = true;</span>
<span class="fc" id="L1338">            throw e;</span>
<span class="fc" id="L1339">        }</span>
<span class="fc" id="L1340">    }</span>

<span class="fc" id="L1342">    private class MetadataValidatorService implements MetadataServiceStub {</span>
        public long structureVersion;

        @Override
        public void addColumn(
                CharSequence columnName,
                int columnType,
                int symbolCapacity,
                boolean symbolCacheFlag,
                boolean isIndexed,
                int indexValueBlockCapacity,
                boolean isSequential
        ) {
<span class="pc bpc" id="L1355" title="1 of 2 branches missed.">            if (!TableUtils.isValidColumnName(columnName, columnName.length())) {</span>
<span class="nc" id="L1356">                throw CairoException.nonCritical().put(&quot;invalid column name: &quot;).put(columnName);</span>
            }
<span class="fc bfc" id="L1358" title="All 2 branches covered.">            if (metadata.getColumnIndexQuiet(columnName) &gt; -1) {</span>
<span class="fc" id="L1359">                throw CairoException.nonCritical().put(&quot;duplicate column name: &quot;).put(columnName);</span>
            }
<span class="pc bpc" id="L1361" title="1 of 2 branches missed.">            if (columnType &lt;= 0) {</span>
<span class="nc" id="L1362">                throw CairoException.nonCritical().put(&quot;invalid column type: &quot;).put(columnType);</span>
            }
<span class="fc" id="L1364">            structureVersion++;</span>
<span class="fc" id="L1365">        }</span>

        @Override
        public TableRecordMetadata getMetadata() {
<span class="nc" id="L1369">            return metadata;</span>
        }

        @Override
        public TableToken getTableToken() {
<span class="fc" id="L1374">            return tableToken;</span>
        }

        @Override
        public void removeColumn(CharSequence columnName) {
<span class="fc" id="L1379">            int columnIndex = metadata.getColumnIndexQuiet(columnName);</span>
<span class="pc bpc" id="L1380" title="1 of 4 branches missed.">            if (columnIndex &lt; 0 || metadata.getColumnType(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1381">                throw CairoException.nonCritical().put(&quot;cannot remove column, column does not exists [table=&quot;).put(tableToken.getTableName())</span>
<span class="fc" id="L1382">                        .put(&quot;, column=&quot;).put(columnName).put(']');</span>
            }

<span class="fc bfc" id="L1385" title="All 2 branches covered.">            if (columnIndex == metadata.getTimestampIndex()) {</span>
<span class="fc" id="L1386">                throw CairoException.nonCritical().put(&quot;cannot remove designated timestamp column [table=&quot;).put(tableToken.getTableName())</span>
<span class="fc" id="L1387">                        .put(&quot;, column=&quot;).put(columnName);</span>
            }
<span class="fc" id="L1389">            structureVersion++;</span>
<span class="fc" id="L1390">        }</span>

        @Override
        public void renameColumn(CharSequence columnName, CharSequence newName) {
<span class="fc" id="L1394">            int columnIndex = metadata.getColumnIndexQuiet(columnName);</span>
<span class="fc bfc" id="L1395" title="All 2 branches covered.">            if (columnIndex &lt; 0) {</span>
<span class="fc" id="L1396">                throw CairoException.nonCritical().put(&quot;cannot rename column, column does not exists [table=&quot;).put(tableToken.getTableName())</span>
<span class="fc" id="L1397">                        .put(&quot;, column=&quot;).put(columnName).put(']');</span>
            }
<span class="fc bfc" id="L1399" title="All 2 branches covered.">            if (columnIndex == metadata.getTimestampIndex()) {</span>
<span class="fc" id="L1400">                throw CairoException.nonCritical().put(&quot;cannot rename designated timestamp column [table=&quot;).put(tableToken.getTableName())</span>
<span class="fc" id="L1401">                        .put(&quot;, column=&quot;).put(columnName).put(']');</span>
            }

<span class="fc" id="L1404">            int columnIndexNew = metadata.getColumnIndexQuiet(newName);</span>
<span class="fc bfc" id="L1405" title="All 2 branches covered.">            if (columnIndexNew &gt; -1) {</span>
<span class="fc" id="L1406">                throw CairoException.nonCritical().put(&quot;cannot rename column, column with the name already exists [table=&quot;).put(tableToken.getTableName())</span>
<span class="fc" id="L1407">                        .put(&quot;, newName=&quot;).put(newName).put(']');</span>
            }
<span class="fc bfc" id="L1409" title="All 2 branches covered.">            if (!TableUtils.isValidColumnName(newName, newName.length())) {</span>
<span class="fc" id="L1410">                throw CairoException.nonCritical().put(&quot;invalid column name: &quot;).put(newName);</span>
            }
<span class="fc" id="L1412">            structureVersion++;</span>
<span class="fc" id="L1413">        }</span>

        public void startAlterValidation() {
<span class="fc" id="L1416">            structureVersion = metadata.getStructureVersion();</span>
<span class="fc" id="L1417">        }</span>
    }

<span class="fc" id="L1420">    private class MetadataWriterService implements MetadataServiceStub {</span>

        @Override
        public void addColumn(
                CharSequence columnName,
                int columnType,
                int symbolCapacity,
                boolean symbolCacheFlag,
                boolean isIndexed,
                int indexValueBlockCapacity,
                boolean isSequential
        ) {
<span class="fc" id="L1432">            int columnIndex = metadata.getColumnIndexQuiet(columnName);</span>

<span class="pc bpc" id="L1434" title="3 of 4 branches missed.">            if (columnIndex &lt; 0 || metadata.getColumnType(columnIndex) &lt; 0) {</span>
<span class="fc" id="L1435">                long uncommittedRows = getUncommittedRowCount();</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">                if (currentTxnStartRowNum &gt; 0) {</span>
                    // Roll last transaction to new segment
<span class="fc" id="L1438">                    rollUncommittedToNewSegment();</span>
                }

<span class="pc bpc" id="L1441" title="1 of 4 branches missed.">                if (currentTxnStartRowNum == 0 || segmentRowCount == currentTxnStartRowNum) {</span>
<span class="fc" id="L1442">                    long segmentRowCount = getUncommittedRowCount();</span>
<span class="fc" id="L1443">                    metadata.addColumn(columnName, columnType);</span>
<span class="fc" id="L1444">                    columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L1445">                    columnIndex = columnCount - 1;</span>
                    // create column file
<span class="fc" id="L1447">                    configureColumn(columnIndex, columnType);</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">                    if (ColumnType.isSymbol(columnType)) {</span>
<span class="fc" id="L1449">                        configureSymbolMapWriter(columnIndex, columnName, 0, -1);</span>
                    }

<span class="fc bfc" id="L1452" title="All 2 branches covered.">                    if (!rollSegmentOnNextRow) {</span>
                        // this means we have rolled uncommitted rows to a new segment already
                        // we should switch metadata to this new segment
<span class="fc" id="L1455">                        path.trimTo(rootLen).slash().put(segmentId);</span>
                        // this will close old _meta file and create the new one
<span class="fc" id="L1457">                        metadata.switchTo(path, path.length());</span>
<span class="fc" id="L1458">                        openColumnFiles(columnName, columnIndex, path.length());</span>
                    }
                    // if we did not have to roll uncommitted rows to a new segment
                    // it will add the column file and switch metadata file on next row write
                    // as part of rolling to a new segment

<span class="fc bfc" id="L1464" title="All 2 branches covered.">                    if (uncommittedRows &gt; 0) {</span>
<span class="fc" id="L1465">                        setColumnNull(columnType, columnIndex, segmentRowCount);</span>
                    }
<span class="fc" id="L1467">                    LOG.info().$(&quot;added column to WAL [path=&quot;).$(path).$(Files.SEPARATOR).$(segmentId).$(&quot;, columnName=&quot;).$(columnName).I$();</span>
<span class="fc" id="L1468">                } else {</span>
<span class="nc" id="L1469">                    throw CairoException.critical(0).put(&quot;column '&quot;).put(columnName)</span>
<span class="nc" id="L1470">                            .put(&quot;' was added, cannot apply commit because of concurrent table definition change&quot;);</span>
                }
<span class="fc" id="L1472">            } else {</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                if (metadata.getColumnType(columnIndex) == columnType) {</span>
                    // TODO: this should be some kind of warning probably that different wals adding the same column concurrently
<span class="nc" id="L1475">                    LOG.info().$(&quot;column has already been added by another WAL [path=&quot;).$(path).$(&quot;, columnName=&quot;).$(columnName).I$();</span>
                } else {
<span class="nc" id="L1477">                    throw CairoException.nonCritical().put(&quot;column '&quot;).put(columnName).put(&quot;' already exists&quot;);</span>
                }
            }
<span class="fc" id="L1480">        }</span>

        @Override
        public TableRecordMetadata getMetadata() {
<span class="nc" id="L1484">            return metadata;</span>
        }

        @Override
        public TableToken getTableToken() {
<span class="fc" id="L1489">            return tableToken;</span>
        }

        @Override
        public void removeColumn(CharSequence columnName) {
<span class="fc" id="L1494">            final int columnIndex = metadata.getColumnIndexQuiet(columnName);</span>
<span class="pc bpc" id="L1495" title="1 of 2 branches missed.">            if (columnIndex &gt; -1) {</span>
<span class="fc" id="L1496">                int type = metadata.getColumnType(columnIndex);</span>
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">                if (type &gt; 0) {</span>
<span class="fc bfc" id="L1498" title="All 2 branches covered.">                    if (currentTxnStartRowNum &gt; 0) {</span>
                        // Roll last transaction to new segment
<span class="fc" id="L1500">                        rollUncommittedToNewSegment();</span>
                    }

<span class="pc bpc" id="L1503" title="1 of 4 branches missed.">                    if (currentTxnStartRowNum == 0 || segmentRowCount == currentTxnStartRowNum) {</span>
<span class="fc" id="L1504">                        int index = metadata.getColumnIndex(columnName);</span>
<span class="fc" id="L1505">                        metadata.removeColumn(columnName);</span>
<span class="fc" id="L1506">                        columnCount = metadata.getColumnCount();</span>

<span class="fc bfc" id="L1508" title="All 2 branches covered.">                        if (!rollSegmentOnNextRow) {</span>
                            // this means we have rolled uncommitted rows to a new segment already
                            // we should switch metadata to this new segment
<span class="fc" id="L1511">                            path.trimTo(rootLen).slash().put(segmentId);</span>
                            // this will close old _meta file and create the new one
<span class="fc" id="L1513">                            metadata.switchTo(path, path.length());</span>
                        }
                        // if we did not have to roll uncommitted rows to a new segment
                        // it will switch metadata file on next row write
                        // as part of rolling to a new segment

<span class="fc bfc" id="L1519" title="All 2 branches covered.">                        if (ColumnType.isSymbol(type)) {</span>
<span class="fc" id="L1520">                            removeSymbolMapReader(index);</span>
                        }
<span class="fc" id="L1522">                        markColumnRemoved(index);</span>
<span class="fc" id="L1523">                        LOG.info().$(&quot;removed column from WAL [path=&quot;).$(path).$(&quot;, columnName=&quot;).$(columnName).I$();</span>
<span class="fc" id="L1524">                    } else {</span>
<span class="nc" id="L1525">                        throw CairoException.critical(0).put(&quot;column '&quot;).put(columnName)</span>
<span class="nc" id="L1526">                                .put(&quot;' was removed, cannot apply commit because of concurrent table definition change&quot;);</span>
                    }
                }
<span class="fc" id="L1529">            } else {</span>
<span class="nc" id="L1530">                throw CairoException.nonCritical().put(&quot;column '&quot;).put(columnName).put(&quot;' does not exists&quot;);</span>
            }
<span class="fc" id="L1532">        }</span>

        @Override
        public void renameColumn(CharSequence columnName, CharSequence newColumnName) {
<span class="fc" id="L1536">            final int columnIndex = metadata.getColumnIndexQuiet(columnName);</span>
<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">            if (columnIndex &gt; -1) {</span>
<span class="fc" id="L1538">                int columnType = metadata.getColumnType(columnIndex);</span>
<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">                if (columnType &gt; 0) {</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">                    if (currentTxnStartRowNum &gt; 0) {</span>
                        // Roll last transaction to new segment
<span class="fc" id="L1542">                        rollUncommittedToNewSegment();</span>
                    }

<span class="pc bpc" id="L1545" title="1 of 4 branches missed.">                    if (currentTxnStartRowNum == 0 || segmentRowCount == currentTxnStartRowNum) {</span>
<span class="fc" id="L1546">                        metadata.renameColumn(columnName, newColumnName);</span>
                        // We are not going to do any special for symbol readers which point
                        // to the files in the root of the table.
                        // We keep the symbol readers open against files with old name.
                        // Inconsistency between column name and symbol file names in the root
                        // does not matter, these files are for re-lookup only for the WAL writer
                        // and should not be serialised to the WAL segment.

<span class="fc bfc" id="L1554" title="All 2 branches covered.">                        if (!rollSegmentOnNextRow) {</span>
                            // this means we have rolled uncommitted rows to a new segment already
                            // we should switch metadata to this new segment
<span class="fc" id="L1557">                            path.trimTo(rootLen).slash().put(segmentId);</span>
                            // this will close old _meta file and create the new one
<span class="fc" id="L1559">                            metadata.switchTo(path, path.length());</span>
<span class="fc" id="L1560">                            renameColumnFiles(columnType, columnName, newColumnName);</span>
                        }
                        // if we did not have to roll uncommitted rows to a new segment
                        // it will switch metadata file on next row write
                        // as part of rolling to a new segment

<span class="fc" id="L1566">                        LOG.info().$(&quot;renamed column in wal [path=&quot;).$(path).$(&quot;, columnName=&quot;).$(columnName).$(&quot;, newColumnName=&quot;).$(newColumnName).I$();</span>
                    } else {
<span class="nc" id="L1568">                        throw CairoException.critical(0).put(&quot;column '&quot;).put(columnName)</span>
<span class="nc" id="L1569">                                .put(&quot;' was removed, cannot apply commit because of concurrent table definition change&quot;);</span>
                    }
                }
<span class="fc" id="L1572">            } else {</span>
<span class="nc" id="L1573">                throw CairoException.nonCritical().put(&quot;column '&quot;).put(columnName).put(&quot;' does not exists&quot;);</span>
            }
<span class="fc" id="L1575">        }</span>
    }

<span class="fc" id="L1578">    private class RowImpl implements TableWriter.Row {</span>
<span class="fc" id="L1579">        private final StringSink tempSink = new StringSink();</span>
        private long timestamp;

        @Override
        public void append() {
<span class="fc" id="L1584">            rowAppend(nullSetters, timestamp);</span>
<span class="fc" id="L1585">        }</span>

        @Override
        public void cancel() {
<span class="fc" id="L1589">            setAppendPosition(segmentRowCount);</span>
<span class="fc" id="L1590">        }</span>

        @Override
        public void putBin(int columnIndex, long address, long len) {
<span class="fc" id="L1594">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putBin(address, len));</span>
<span class="fc" id="L1595">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1596">        }</span>

        @Override
        public void putBin(int columnIndex, BinarySequence sequence) {
<span class="fc" id="L1600">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putBin(sequence));</span>
<span class="fc" id="L1601">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1602">        }</span>

        @Override
        public void putBool(int columnIndex, boolean value) {
<span class="fc" id="L1606">            getPrimaryColumn(columnIndex).putBool(value);</span>
<span class="fc" id="L1607">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1608">        }</span>

        @Override
        public void putByte(int columnIndex, byte value) {
<span class="fc" id="L1612">            getPrimaryColumn(columnIndex).putByte(value);</span>
<span class="fc" id="L1613">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1614">        }</span>

        @Override
        public void putChar(int columnIndex, char value) {
<span class="fc" id="L1618">            getPrimaryColumn(columnIndex).putChar(value);</span>
<span class="fc" id="L1619">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1620">        }</span>

        @Override
        public void putDouble(int columnIndex, double value) {
<span class="fc" id="L1624">            getPrimaryColumn(columnIndex).putDouble(value);</span>
<span class="fc" id="L1625">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1626">        }</span>

        @Override
        public void putFloat(int columnIndex, float value) {
<span class="fc" id="L1630">            getPrimaryColumn(columnIndex).putFloat(value);</span>
<span class="fc" id="L1631">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1632">        }</span>

        @Override
        public void putGeoHash(int index, long value) {
<span class="fc" id="L1636">            int type = metadata.getColumnType(index);</span>
<span class="fc" id="L1637">            WriterRowUtils.putGeoHash(index, value, type, this);</span>
<span class="fc" id="L1638">        }</span>

        @Override
        public void putGeoHashDeg(int index, double lat, double lon) {
<span class="nc" id="L1642">            final int type = metadata.getColumnType(index);</span>
<span class="nc" id="L1643">            WriterRowUtils.putGeoHash(index, GeoHashes.fromCoordinatesDegUnsafe(lat, lon, ColumnType.getGeoHashBits(type)), type, this);</span>
<span class="nc" id="L1644">        }</span>

        @Override
        public void putGeoStr(int index, CharSequence hash) {
<span class="nc" id="L1648">            final int type = metadata.getColumnType(index);</span>
<span class="nc" id="L1649">            WriterRowUtils.putGeoStr(index, hash, type, this);</span>
<span class="nc" id="L1650">        }</span>

        @Override
        public void putInt(int columnIndex, int value) {
<span class="fc" id="L1654">            getPrimaryColumn(columnIndex).putInt(value);</span>
<span class="fc" id="L1655">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1656">        }</span>

        @Override
        public void putLong(int columnIndex, long value) {
<span class="fc" id="L1660">            getPrimaryColumn(columnIndex).putLong(value);</span>
<span class="fc" id="L1661">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1662">        }</span>

        @Override
        public void putLong128(int columnIndex, long lo, long hi) {
<span class="fc" id="L1666">            MemoryA primaryColumn = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L1667">            primaryColumn.putLong(lo);</span>
<span class="fc" id="L1668">            primaryColumn.putLong(hi);</span>
<span class="fc" id="L1669">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1670">        }</span>

        @Override
        public void putLong256(int columnIndex, long l0, long l1, long l2, long l3) {
<span class="fc" id="L1674">            getPrimaryColumn(columnIndex).putLong256(l0, l1, l2, l3);</span>
<span class="fc" id="L1675">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1676">        }</span>

        @Override
        public void putLong256(int columnIndex, Long256 value) {
<span class="fc" id="L1680">            getPrimaryColumn(columnIndex).putLong256(value.getLong0(), value.getLong1(), value.getLong2(), value.getLong3());</span>
<span class="fc" id="L1681">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1682">        }</span>

        @Override
        public void putLong256(int columnIndex, CharSequence hexString) {
<span class="fc" id="L1686">            getPrimaryColumn(columnIndex).putLong256(hexString);</span>
<span class="fc" id="L1687">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1688">        }</span>

        @Override
        public void putLong256(int columnIndex, @NotNull CharSequence hexString, int start, int end) {
<span class="fc" id="L1692">            getPrimaryColumn(columnIndex).putLong256(hexString, start, end);</span>
<span class="fc" id="L1693">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1694">        }</span>

        @Override
        public void putShort(int columnIndex, short value) {
<span class="fc" id="L1698">            getPrimaryColumn(columnIndex).putShort(value);</span>
<span class="fc" id="L1699">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1700">        }</span>

        @Override
        public void putStr(int columnIndex, CharSequence value) {
<span class="fc" id="L1704">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putStr(value));</span>
<span class="fc" id="L1705">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1706">        }</span>

        @Override
        public void putStr(int columnIndex, char value) {
<span class="fc" id="L1710">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putStr(value));</span>
<span class="fc" id="L1711">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1712">        }</span>

        @Override
        public void putStr(int columnIndex, CharSequence value, int pos, int len) {
<span class="fc" id="L1716">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putStr(value, pos, len));</span>
<span class="fc" id="L1717">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1718">        }</span>

        @Override
        public void putStrUtf8AsUtf16(int columnIndex, DirectByteCharSequence value, boolean hasNonAsciiChars) {
<span class="fc" id="L1722">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putStrUtf8AsUtf16(value, hasNonAsciiChars));</span>
<span class="fc" id="L1723">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1724">        }</span>

        @Override
        public void putSym(int columnIndex, CharSequence value) {
<span class="fc" id="L1728">            final SymbolMapReader symbolMapReader = symbolMapReaders.getQuick(columnIndex);</span>
<span class="fc bfc" id="L1729" title="All 2 branches covered.">            if (symbolMapReader != null) {</span>
<span class="fc" id="L1730">                putSym0(columnIndex, value, symbolMapReader);</span>
            } else {
<span class="fc" id="L1732">                throw new UnsupportedOperationException();</span>
            }
<span class="fc" id="L1734">        }</span>

        @Override
        public void putSym(int columnIndex, char value) {
<span class="fc" id="L1738">            CharSequence str = SingleCharCharSequence.get(value);</span>
<span class="fc" id="L1739">            putSym(columnIndex, str);</span>
<span class="fc" id="L1740">        }</span>

        public void putSymUtf8(int columnIndex, DirectByteCharSequence value, boolean hasNonAsciiChars) {
            // this method will write column name to the buffer if it has to be utf8 decoded
            // otherwise it will write nothing.
<span class="fc" id="L1745">            final SymbolMapReader symbolMapReader = symbolMapReaders.getQuick(columnIndex);</span>
<span class="fc bfc" id="L1746" title="All 2 branches covered.">            if (symbolMapReader != null) {</span>
<span class="fc" id="L1747">                ByteCharSequenceIntHashMap utf8Map = utf8SymbolMaps.getQuick(columnIndex);</span>
<span class="fc" id="L1748">                int index = utf8Map.keyIndex(value);</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">                if (index &lt; 0) {</span>
<span class="fc" id="L1750">                    getPrimaryColumn(columnIndex).putInt(utf8Map.valueAt(index));</span>
<span class="fc" id="L1751">                    setRowValueNotNull(columnIndex);</span>
                } else {
                    // slow path, symbol is not in utf8 cache
<span class="fc" id="L1754">                    utf8Map.putAt(</span>
                            index,
<span class="fc" id="L1756">                            ByteCharSequence.newInstance(value),</span>
<span class="fc" id="L1757">                            putSymUtf8Slow(columnIndex, value, hasNonAsciiChars, symbolMapReader)</span>
                    );
                }
<span class="fc" id="L1760">            } else {</span>
<span class="fc" id="L1761">                throw new UnsupportedOperationException();</span>
            }
<span class="fc" id="L1763">        }</span>

        @Override
        public void putUuid(int columnIndex, CharSequence uuidStr) {
<span class="fc" id="L1767">            SqlUtil.implicitCastStrAsUuid(uuidStr, uuid);</span>
<span class="fc" id="L1768">            putLong128(columnIndex, uuid.getLo(), uuid.getHi());</span>
<span class="fc" id="L1769">        }</span>

        private MemoryA getPrimaryColumn(int columnIndex) {
<span class="fc" id="L1772">            return columns.getQuick(getPrimaryColumnIndex(columnIndex));</span>
        }

        private MemoryA getSecondaryColumn(int columnIndex) {
<span class="fc" id="L1776">            return columns.getQuick(getSecondaryColumnIndex(columnIndex));</span>
        }

        private int putSym0(int columnIndex, CharSequence utf16Value, SymbolMapReader symbolMapReader) {
            int key;
<span class="fc bfc" id="L1781" title="All 2 branches covered.">            if (utf16Value != null) {</span>
<span class="fc" id="L1782">                final CharSequenceIntHashMap utf16Map = symbolMaps.getQuick(columnIndex);</span>
<span class="fc" id="L1783">                final int index = utf16Map.keyIndex(utf16Value);</span>
<span class="fc bfc" id="L1784" title="All 2 branches covered.">                if (index &gt; -1) {</span>
<span class="fc" id="L1785">                    key = symbolMapReader.keyOf(utf16Value);</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">                    if (key == SymbolTable.VALUE_NOT_FOUND) {</span>
                        // Add it to in-memory symbol map
                        // Locally added symbols must have a continuous range of keys
<span class="fc" id="L1789">                        final int initialSymCount = initialSymbolCounts.get(columnIndex);</span>
<span class="fc" id="L1790">                        key = initialSymCount + localSymbolIds.postIncrement(columnIndex);</span>
                    }
                    // Chars.toString used as value is a parser buffer memory slice or mapped memory of symbolMapReader
<span class="fc" id="L1793">                    utf16Map.putAt(index, Chars.toString(utf16Value), key);</span>
                } else {
<span class="fc" id="L1795">                    key = utf16Map.valueAt(index);</span>
                }
<span class="fc" id="L1797">            } else {</span>
<span class="fc" id="L1798">                key = SymbolTable.VALUE_IS_NULL;</span>
<span class="fc" id="L1799">                symbolMapNullFlags.set(columnIndex, true);</span>
            }

<span class="fc" id="L1802">            getPrimaryColumn(columnIndex).putInt(key);</span>
<span class="fc" id="L1803">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L1804">            return key;</span>
        }

        private int putSymUtf8Slow(
                int columnIndex,
                DirectByteCharSequence utf8Value,
                boolean hasNonAsciiChars,
                SymbolMapReader symbolMapReader
        ) {
<span class="fc" id="L1813">            return putSym0(</span>
                    columnIndex,
<span class="fc" id="L1815">                    utf8ToUtf16(utf8Value, tempSink, hasNonAsciiChars),</span>
                    symbolMapReader
            );
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>