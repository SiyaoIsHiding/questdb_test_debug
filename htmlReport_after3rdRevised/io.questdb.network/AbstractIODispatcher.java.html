<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractIODispatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in questdb Coverage Results, io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.network</a> &gt; <span class="el_source">AbstractIODispatcher.java</span></div><h1>AbstractIODispatcher.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.network;

import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.mp.*;
import io.questdb.std.*;
import io.questdb.std.datetime.millitime.MillisecondClock;

import java.util.concurrent.atomic.AtomicInteger;

public abstract class AbstractIODispatcher&lt;C extends IOContext&gt; extends SynchronizedJob implements IODispatcher&lt;C&gt;, EagerThreadSetup {
    protected static final int DISCONNECT_SRC_IDLE = 1;
    protected static final int DISCONNECT_SRC_PEER_DISCONNECT = 3;
    protected static final int DISCONNECT_SRC_QUEUE = 0;
    protected static final int DISCONNECT_SRC_SHUTDOWN = 2;
    // OPM_XYZ = 3 is defined in the child classes
    protected static final int OPM_FD = 1;
    protected static final int OPM_OPERATION = 2;
    protected static final int OPM_TIMESTAMP = 0;
    private final static String[] DISCONNECT_SOURCES;
    protected final Log LOG;
    protected final int activeConnectionLimit;
    protected final MillisecondClock clock;
    protected final MPSequence disconnectPubSeq;
    protected final RingQueue&lt;IOEvent&lt;C&gt;&gt; disconnectQueue;
    protected final SCSequence disconnectSubSeq;
    protected final long idleConnectionTimeout;
    protected final int initialBias;
    protected final MPSequence interestPubSeq;
    protected final RingQueue&lt;IOEvent&lt;C&gt;&gt; interestQueue;
    protected final SCSequence interestSubSeq;
    protected final IOContextFactory&lt;C&gt; ioContextFactory;
    protected final SPSequence ioEventPubSeq;
    protected final RingQueue&lt;IOEvent&lt;C&gt;&gt; ioEventQueue;
    protected final MCSequence ioEventSubSeq;
    protected final NetworkFacade nf;
<span class="fc" id="L61">    protected final ObjLongMatrix&lt;C&gt; pending = new ObjLongMatrix&lt;&gt;(4);</span>
    private final IODispatcherConfiguration configuration;
<span class="fc" id="L63">    private final AtomicInteger connectionCount = new AtomicInteger();</span>
    private final boolean peerNoLinger;
    private final long queuedConnectionTimeoutMs;
    private final int rcvBufSize;
    private final int sndBufSize;
    private final int testConnectionBufSize;
<span class="fc" id="L69">    protected boolean closed = false;</span>
    protected int serverFd;
    private long closeListenFdEpochMs;
    private volatile boolean listening;
    private int port;
<span class="fc" id="L74">    protected final QueueConsumer&lt;IOEvent&lt;C&gt;&gt; disconnectContextRef = this::disconnectContext;</span>
    private long testConnectionBuf;

    public AbstractIODispatcher(
            IODispatcherConfiguration configuration,
            IOContextFactory&lt;C&gt; ioContextFactory
<span class="fc" id="L80">    ) {</span>
<span class="fc" id="L81">        this.LOG = LogFactory.getLog(configuration.getDispatcherLogName());</span>
<span class="fc" id="L82">        this.configuration = configuration;</span>
<span class="fc" id="L83">        this.nf = configuration.getNetworkFacade();</span>

<span class="fc" id="L85">        this.testConnectionBufSize = configuration.getTestConnectionBufferSize();</span>
<span class="fc" id="L86">        this.testConnectionBuf = Unsafe.malloc(this.testConnectionBufSize, MemoryTag.NATIVE_DEFAULT);</span>

<span class="fc" id="L88">        this.interestQueue = new RingQueue&lt;&gt;(IOEvent::new, configuration.getInterestQueueCapacity());</span>
<span class="fc" id="L89">        this.interestPubSeq = new MPSequence(interestQueue.getCycle());</span>
<span class="fc" id="L90">        this.interestSubSeq = new SCSequence();</span>
<span class="fc" id="L91">        this.interestPubSeq.then(this.interestSubSeq).then(this.interestPubSeq);</span>

<span class="fc" id="L93">        this.ioEventQueue = new RingQueue&lt;&gt;(IOEvent::new, configuration.getIOQueueCapacity());</span>
<span class="fc" id="L94">        this.ioEventPubSeq = new SPSequence(configuration.getIOQueueCapacity());</span>
<span class="fc" id="L95">        this.ioEventSubSeq = new MCSequence(configuration.getIOQueueCapacity());</span>
<span class="fc" id="L96">        this.ioEventPubSeq.then(this.ioEventSubSeq).then(this.ioEventPubSeq);</span>

<span class="fc" id="L98">        this.disconnectQueue = new RingQueue&lt;&gt;(IOEvent::new, configuration.getIOQueueCapacity());</span>
<span class="fc" id="L99">        this.disconnectPubSeq = new MPSequence(disconnectQueue.getCycle());</span>
<span class="fc" id="L100">        this.disconnectSubSeq = new SCSequence();</span>
<span class="fc" id="L101">        this.disconnectPubSeq.then(this.disconnectSubSeq).then(this.disconnectPubSeq);</span>

<span class="fc" id="L103">        this.clock = configuration.getClock();</span>
<span class="fc" id="L104">        this.activeConnectionLimit = configuration.getLimit();</span>
<span class="fc" id="L105">        this.ioContextFactory = ioContextFactory;</span>
<span class="fc" id="L106">        this.initialBias = configuration.getInitialBias();</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">        this.idleConnectionTimeout = configuration.getTimeout() &gt; 0 ? configuration.getTimeout() : Long.MIN_VALUE;</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        this.queuedConnectionTimeoutMs = configuration.getQueueTimeout() &gt; 0 ? configuration.getQueueTimeout() : 0;</span>
<span class="fc" id="L109">        this.sndBufSize = configuration.getSndBufSize();</span>
<span class="fc" id="L110">        this.rcvBufSize = configuration.getRcvBufSize();</span>
<span class="fc" id="L111">        this.peerNoLinger = configuration.getPeerNoLinger();</span>
<span class="fc" id="L112">        this.port = 0;</span>

<span class="fc" id="L114">        createListenFd();</span>
<span class="fc" id="L115">        listening = true;</span>
<span class="fc" id="L116">    }</span>

    @Override
    public void close() {
<span class="fc" id="L120">        closed = true;</span>

<span class="fc" id="L122">        processDisconnects(Long.MAX_VALUE);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        for (int i = 0, n = pending.size(); i &lt; n; i++) {</span>
<span class="fc" id="L124">            doDisconnect(pending.get(i), DISCONNECT_SRC_SHUTDOWN);</span>
        }

<span class="fc" id="L127">        interestSubSeq.consumeAll(interestQueue, this.disconnectContextRef);</span>
<span class="fc" id="L128">        ioEventSubSeq.consumeAll(ioEventQueue, this.disconnectContextRef);</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (serverFd &gt; 0) {</span>
<span class="fc" id="L130">            nf.close(serverFd, LOG);</span>
<span class="fc" id="L131">            serverFd = -1;</span>
        }

<span class="fc" id="L134">        testConnectionBuf = Unsafe.free(testConnectionBuf, testConnectionBufSize, MemoryTag.NATIVE_DEFAULT);</span>
<span class="fc" id="L135">    }</span>

    @Override
    public void disconnect(C context, int reason) {
<span class="fc" id="L139">        LOG.info()</span>
<span class="fc" id="L140">                .$(&quot;scheduling disconnect [fd=&quot;).$(context.getFd())</span>
<span class="fc" id="L141">                .$(&quot;, reason=&quot;).$(reason)</span>
<span class="fc" id="L142">                .I$();</span>
<span class="fc" id="L143">        final long cursor = disconnectPubSeq.nextBully();</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        assert cursor &gt; -1;</span>
<span class="fc" id="L145">        disconnectQueue.get(cursor).context = context;</span>
<span class="fc" id="L146">        disconnectPubSeq.done(cursor);</span>
<span class="fc" id="L147">    }</span>

    @Override
    public int getConnectionCount() {
<span class="fc" id="L151">        return connectionCount.get();</span>
    }

    @Override
    public int getPort() {
<span class="fc" id="L156">        return port;</span>
    }

    @Override
    public boolean isListening() {
<span class="fc" id="L161">        return listening;</span>
    }

    @Override
    public boolean processIOQueue(IORequestProcessor&lt;C&gt; processor) {
<span class="fc" id="L166">        long cursor = ioEventSubSeq.next();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        while (cursor == -2) {</span>
<span class="fc" id="L168">            Os.pause();</span>
<span class="fc" id="L169">            cursor = ioEventSubSeq.next();</span>
        }

<span class="fc" id="L172">        boolean useful = false;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (cursor &gt; -1) {</span>
<span class="fc" id="L174">            IOEvent&lt;C&gt; event = ioEventQueue.get(cursor);</span>
<span class="fc" id="L175">            C connectionContext = event.context;</span>
<span class="fc" id="L176">            final int operation = event.operation;</span>
<span class="fc" id="L177">            ioEventSubSeq.done(cursor);</span>
<span class="fc" id="L178">            useful = processor.onRequest(operation, connectionContext);</span>
        }

<span class="fc" id="L181">        return useful;</span>
    }

    @Override
    public void registerChannel(C context, int operation) {
<span class="fc" id="L186">        long cursor = interestPubSeq.nextBully();</span>
<span class="fc" id="L187">        IOEvent&lt;C&gt; evt = interestQueue.get(cursor);</span>
<span class="fc" id="L188">        evt.context = context;</span>
<span class="fc" id="L189">        evt.operation = operation;</span>
<span class="fc" id="L190">        LOG.debug().$(&quot;queuing [fd=&quot;).$(context.getFd()).$(&quot;, op=&quot;).$(operation).I$();</span>
<span class="fc" id="L191">        interestPubSeq.done(cursor);</span>
<span class="fc" id="L192">    }</span>

    @Override
    public void setup() {
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (ioContextFactory instanceof EagerThreadSetup) {</span>
<span class="fc" id="L197">            ((EagerThreadSetup) ioContextFactory).setup();</span>
        }
<span class="fc" id="L199">    }</span>

    private void addPending(int fd, long timestamp) {
        // append pending connection
        // all rows below watermark will be registered with epoll (or similar)
<span class="fc" id="L204">        int r = pending.addRow();</span>
<span class="fc" id="L205">        LOG.debug().$(&quot;pending [row=&quot;).$(r).$(&quot;, fd=&quot;).$(fd).$(']').$();</span>
<span class="fc" id="L206">        pending.set(r, OPM_TIMESTAMP, timestamp);</span>
<span class="fc" id="L207">        pending.set(r, OPM_FD, fd);</span>
<span class="fc" id="L208">        pending.set(r, OPM_OPERATION, -1);</span>
<span class="fc" id="L209">        pending.set(r, ioContextFactory.newInstance(fd, this));</span>
<span class="fc" id="L210">        pendingAdded(r);</span>
<span class="fc" id="L211">    }</span>

    private void createListenFd() throws NetworkError {
<span class="fc" id="L214">        this.serverFd = nf.socketTcp(false);</span>
<span class="fc" id="L215">        final int backlog = configuration.getListenBacklog();</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (this.port == 0) {</span>
            // Note that `configuration.getBindPort()` might also be 0.
            // In such case, we will bind to an ephemeral port.
<span class="fc" id="L219">            this.port = configuration.getBindPort();</span>
        }
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (nf.bindTcp(this.serverFd, configuration.getBindIPv4Address(), this.port)) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (this.port == 0) {</span>
                // We resolve port 0 only once. In case we close and re-open the
                // listening socket, we will reuse the previously resolved
                // ephemeral port.
<span class="fc" id="L226">                this.port = nf.resolvePort(this.serverFd);</span>
            }
<span class="fc" id="L228">            nf.listen(this.serverFd, backlog);</span>
        } else {
<span class="nc" id="L230">            throw NetworkError.instance(nf.errno()).couldNotBindSocket(</span>
<span class="nc" id="L231">                    configuration.getDispatcherLogName(),</span>
<span class="nc" id="L232">                    configuration.getBindIPv4Address(),</span>
                    this.port);
        }
<span class="fc" id="L235">        LOG.advisory().$(&quot;listening on &quot;).$ip(configuration.getBindIPv4Address()).$(':').$(configuration.getBindPort())</span>
<span class="fc" id="L236">                .$(&quot; [fd=&quot;).$(serverFd)</span>
<span class="fc" id="L237">                .$(&quot; backlog=&quot;).$(backlog)</span>
<span class="fc" id="L238">                .I$();</span>
<span class="fc" id="L239">    }</span>

    private void disconnectContext(IOEvent&lt;C&gt; event) {
<span class="fc" id="L242">        doDisconnect(event.context, DISCONNECT_SRC_QUEUE);</span>
<span class="fc" id="L243">    }</span>

    protected void accept(long timestamp) {
<span class="fc" id="L246">        int tlConCount = this.connectionCount.get();</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        while (tlConCount &lt; activeConnectionLimit) {</span>
            // this 'accept' is greedy, rather than to rely on epoll (or similar) to
            // fire accept requests at us one at a time we will be actively accepting
            // until nothing left.

<span class="fc" id="L252">            int fd = nf.accept(serverFd);</span>

<span class="fc bfc" id="L254" title="All 2 branches covered.">            if (fd &lt; 0) {</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">                if (nf.errno() != Net.EWOULDBLOCK) {</span>
<span class="nc" id="L256">                    LOG.error().$(&quot;could not accept [ret=&quot;).$(fd).$(&quot;, errno=&quot;).$(nf.errno()).$(']').$();</span>
                }
                break;
            }

<span class="fc bfc" id="L261" title="All 2 branches covered.">            if (nf.configureNonBlocking(fd) &lt; 0) {</span>
<span class="fc" id="L262">                LOG.error().$(&quot;could not configure non-blocking [fd=&quot;).$(fd).$(&quot;, errno=&quot;).$(nf.errno()).$(']').$();</span>
<span class="fc" id="L263">                nf.close(fd, LOG);</span>
<span class="fc" id="L264">                break;</span>
            }

<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            if (nf.setTcpNoDelay(fd, true) &lt; 0) {</span>
                // Randomly on OS X, if a client connects and the peer TCP socket has SO_LINGER set to false, then setting the TCP_NODELAY
                // option fails!
<span class="nc" id="L270">                LOG.info().$(&quot;could not turn off Nagle's algorithm [fd=&quot;).$(fd).$(&quot;, errno=&quot;).$(nf.errno()).$(']').$();</span>
            }

<span class="fc bfc" id="L273" title="All 2 branches covered.">            if (peerNoLinger) {</span>
<span class="fc" id="L274">                nf.configureNoLinger(fd);</span>
            }

<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            if (sndBufSize &gt; 0) {</span>
<span class="nc" id="L278">                nf.setSndBuf(fd, sndBufSize);</span>
            }

<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (rcvBufSize &gt; 0) {</span>
<span class="nc" id="L282">                nf.setRcvBuf(fd, rcvBufSize);</span>
            }

<span class="fc" id="L285">            LOG.info().$(&quot;connected [ip=&quot;).$ip(nf.getPeerIP(fd)).$(&quot;, fd=&quot;).$(fd).$(']').$();</span>
<span class="fc" id="L286">            tlConCount = connectionCount.incrementAndGet();</span>
<span class="fc" id="L287">            addPending(fd, timestamp);</span>
<span class="fc" id="L288">        }</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (tlConCount &gt;= activeConnectionLimit) {</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            if (connectionCount.get() &gt;= activeConnectionLimit) {</span>
<span class="fc" id="L292">                unregisterListenerFd();</span>
<span class="fc" id="L293">                listening = false;</span>
<span class="fc" id="L294">                closeListenFdEpochMs = timestamp + queuedConnectionTimeoutMs;</span>
<span class="fc" id="L295">                LOG.info().$(&quot;max connection limit reached, unregistered listener [serverFd=&quot;).$(serverFd).I$();</span>
            }
        }
<span class="fc" id="L298">    }</span>

    protected void doDisconnect(C context, int src) {
<span class="pc bpc" id="L301" title="1 of 4 branches missed.">        if (context == null || context.invalid()) {</span>
<span class="fc" id="L302">            return;</span>
        }

<span class="fc" id="L305">        final int fd = context.getFd();</span>
<span class="fc" id="L306">        LOG.info()</span>
<span class="fc" id="L307">                .$(&quot;disconnected [ip=&quot;).$ip(nf.getPeerIP(fd))</span>
<span class="fc" id="L308">                .$(&quot;, fd=&quot;).$(fd)</span>
<span class="fc" id="L309">                .$(&quot;, src=&quot;).$(DISCONNECT_SOURCES[src])</span>
<span class="fc" id="L310">                .I$();</span>
<span class="fc" id="L311">        nf.close(fd, LOG);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (closed) {</span>
<span class="fc" id="L313">            Misc.free(context);</span>
        } else {
<span class="fc" id="L315">            ioContextFactory.done(context);</span>
        }
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (connectionCount.getAndDecrement() &gt;= activeConnectionLimit) {</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">            if (connectionCount.get() &lt; activeConnectionLimit) {</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">                if (serverFd &lt; 0) {</span>
<span class="fc" id="L320">                    createListenFd();</span>
                }
<span class="fc" id="L322">                registerListenerFd();</span>
<span class="fc" id="L323">                listening = true;</span>
<span class="fc" id="L324">                LOG.info().$(&quot;below maximum connection limit, registered listener [serverFd=&quot;).$(serverFd).I$();</span>
            }
        }
<span class="fc" id="L327">    }</span>

    protected abstract void pendingAdded(int index);

    protected void processDisconnects(long epochMs) {
<span class="fc" id="L332">        disconnectSubSeq.consumeAll(disconnectQueue, this.disconnectContextRef);</span>
<span class="fc bfc" id="L333" title="All 6 branches covered.">        if (!listening &amp;&amp; serverFd &gt;= 0 &amp;&amp; epochMs &gt;= closeListenFdEpochMs) {</span>
<span class="fc" id="L334">            LOG.error().$(&quot;been unable to accept connections for &quot;).$(queuedConnectionTimeoutMs).$(&quot;ms, closing listener [serverFd=&quot;).$(serverFd).I$();</span>
<span class="fc" id="L335">            nf.close(serverFd);</span>
<span class="fc" id="L336">            serverFd = -1;</span>
        }
<span class="fc" id="L338">    }</span>

    protected void publishOperation(int operation, C context) {
<span class="fc" id="L341">        long cursor = ioEventPubSeq.nextBully();</span>
<span class="fc" id="L342">        IOEvent&lt;C&gt; evt = ioEventQueue.get(cursor);</span>
<span class="fc" id="L343">        evt.context = context;</span>
<span class="fc" id="L344">        evt.operation = operation;</span>
<span class="fc" id="L345">        ioEventPubSeq.done(cursor);</span>
<span class="fc" id="L346">        LOG.debug().$(&quot;fired [fd=&quot;).$(context.getFd()).$(&quot;, op=&quot;).$(operation).$(&quot;, pos=&quot;).$(cursor).$(']').$();</span>
<span class="fc" id="L347">    }</span>

    protected abstract void registerListenerFd();

    protected boolean testConnection(int fd) {
<span class="fc" id="L352">        return nf.testConnection(fd, testConnectionBuf, testConnectionBufSize);</span>
    }

    protected abstract void unregisterListenerFd();

    static {
<span class="fc" id="L358">        DISCONNECT_SOURCES = new String[]{&quot;queue&quot;, &quot;idle&quot;, &quot;shutdown&quot;, &quot;peer&quot;};</span>
<span class="fc" id="L359">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>