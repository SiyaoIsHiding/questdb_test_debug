<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LatestByAllIndexedRecordCursor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.engine.table</a> &gt; <span class="el_source">LatestByAllIndexedRecordCursor.java</span></div><h1>LatestByAllIndexedRecordCursor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.engine.table;

import io.questdb.MessageBus;
import io.questdb.cairo.BitmapIndexReader;
import io.questdb.cairo.ColumnType;
import io.questdb.cairo.DataUnavailableException;
import io.questdb.cairo.TableReader;
import io.questdb.cairo.sql.DataFrame;
import io.questdb.cairo.sql.DataFrameCursor;
import io.questdb.cairo.sql.SqlExecutionCircuitBreaker;
import io.questdb.cairo.vm.api.MemoryR;
import io.questdb.cutlass.text.AtomicBooleanCircuitBreaker;
import io.questdb.griffin.PlanSink;
import io.questdb.griffin.SqlException;
import io.questdb.griffin.SqlExecutionContext;
import io.questdb.griffin.engine.functions.geohash.GeoHashNative;
import io.questdb.mp.RingQueue;
import io.questdb.mp.SOUnboundedCountDownLatch;
import io.questdb.mp.Sequence;
import io.questdb.std.DirectLongList;
import io.questdb.std.IntList;
import io.questdb.std.Rows;
import io.questdb.std.Vect;
import io.questdb.tasks.LatestByTask;
import org.jetbrains.annotations.NotNull;

class LatestByAllIndexedRecordCursor extends AbstractDataFrameRecordCursor {
<span class="fc" id="L52">    protected final long indexShift = 0;</span>
    protected final DirectLongList prefixes;
    protected final DirectLongList rows;
    private final int columnIndex;
<span class="fc" id="L56">    private final SOUnboundedCountDownLatch doneLatch = new SOUnboundedCountDownLatch();</span>
<span class="fc" id="L57">    private final AtomicBooleanCircuitBreaker sharedCircuitBreaker = new AtomicBooleanCircuitBreaker();</span>
    protected long aIndex;
    protected long aLimit;
    protected SqlExecutionCircuitBreaker circuitBreaker;
    private long argumentsAddress;
    private MessageBus bus;
    private boolean isTreeMapBuilt;
    private int keyCount;
    private int workerCount;

    public LatestByAllIndexedRecordCursor(
            int columnIndex,
            @NotNull DirectLongList rows,
            @NotNull IntList columnIndexes,
            @NotNull DirectLongList prefixes
    ) {
<span class="fc" id="L73">        super(columnIndexes);</span>
<span class="fc" id="L74">        this.rows = rows;</span>
<span class="fc" id="L75">        this.columnIndex = columnIndex;</span>
<span class="fc" id="L76">        this.prefixes = prefixes;</span>
<span class="fc" id="L77">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (!isTreeMapBuilt) {</span>
<span class="fc" id="L82">            buildTreeMap();</span>
<span class="fc" id="L83">            isTreeMapBuilt = true;</span>
        }
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (aIndex &lt; aLimit) {</span>
<span class="fc" id="L86">            long row = rows.get(aIndex++) - 1; // we added 1 on cpp side</span>
<span class="fc" id="L87">            recordA.jumpTo(Rows.toPartitionIndex(row), Rows.toLocalRowID(row));</span>
<span class="fc" id="L88">            return true;</span>
        }
<span class="fc" id="L90">        return false;</span>
    }

    @Override
    public void of(DataFrameCursor dataFrameCursor, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L95">        this.dataFrameCursor = dataFrameCursor;</span>
<span class="fc" id="L96">        recordA.of(dataFrameCursor.getTableReader());</span>
<span class="fc" id="L97">        recordB.of(dataFrameCursor.getTableReader());</span>
<span class="fc" id="L98">        circuitBreaker = executionContext.getCircuitBreaker();</span>
<span class="fc" id="L99">        bus = executionContext.getMessageBus();</span>
<span class="fc" id="L100">        workerCount = executionContext.getSharedWorkerCount();</span>
<span class="fc" id="L101">        rows.clear();</span>
<span class="fc" id="L102">        keyCount = -1;</span>
<span class="fc" id="L103">        argumentsAddress = 0;</span>
<span class="fc" id="L104">        isTreeMapBuilt = false;</span>
<span class="fc" id="L105">    }</span>

    @Override
    public long size() {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        return isTreeMapBuilt ? aLimit - indexShift : -1;</span>
    }

    @Override
    public void toPlan(PlanSink sink) {
<span class="fc" id="L114">        sink.type(&quot;Index backward scan&quot;).meta(&quot;on&quot;).putColumnName(columnIndex);</span>
<span class="fc" id="L115">        sink.meta(&quot;parallel&quot;).val(true);</span>
<span class="fc" id="L116">    }</span>

    @Override
    public void toTop() {
<span class="fc" id="L120">        aIndex = indexShift;</span>
<span class="fc" id="L121">    }</span>

    private static long getChunkSize(int keyCount, int workerCount) {
<span class="fc" id="L124">        return (keyCount + workerCount - 1) / workerCount;</span>
    }

    private static int getPow2SizeOfGeoHashType(int type) {
<span class="fc" id="L128">        return 1 &lt;&lt; ColumnType.pow2SizeOfBits(ColumnType.getGeoHashBits(type));</span>
    }

    private static int getTaskCount(int keyCount, long chunkSize) {
<span class="fc" id="L132">        return (int) ((keyCount + chunkSize - 1) / chunkSize);</span>
    }

    private void buildTreeMap() {
        int taskCount;
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (keyCount &lt; 0) {</span>
<span class="fc" id="L138">            keyCount = getSymbolTable(columnIndex).getSymbolCount() + 1;</span>
<span class="fc" id="L139">            final long chunkSize = getChunkSize(keyCount, workerCount);</span>
<span class="fc" id="L140">            taskCount = getTaskCount(keyCount, chunkSize);</span>
<span class="fc" id="L141">            rows.setCapacity(keyCount);</span>
<span class="fc" id="L142">            GeoHashNative.iota(rows.getAddress(), rows.getCapacity(), 0);</span>

<span class="fc" id="L144">            argumentsAddress = LatestByArguments.allocateMemoryArray(taskCount);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">            for (long i = 0; i &lt; taskCount; ++i) {</span>
<span class="fc" id="L146">                final long klo = i * chunkSize;</span>
<span class="fc" id="L147">                final long khi = Long.min(klo + chunkSize, keyCount);</span>
<span class="fc" id="L148">                final long argsAddress = argumentsAddress + i * LatestByArguments.MEMORY_SIZE;</span>
<span class="fc" id="L149">                LatestByArguments.setRowsAddress(argsAddress, rows.getAddress());</span>
<span class="fc" id="L150">                LatestByArguments.setRowsCapacity(argsAddress, rows.getCapacity());</span>
<span class="fc" id="L151">                LatestByArguments.setKeyLo(argsAddress, klo);</span>
<span class="fc" id="L152">                LatestByArguments.setKeyHi(argsAddress, khi);</span>
<span class="fc" id="L153">                LatestByArguments.setRowsSize(argsAddress, 0);</span>
            }

<span class="fc" id="L156">            sharedCircuitBreaker.reset();</span>
<span class="fc" id="L157">        } else {</span>
<span class="fc" id="L158">            final long chunkSize = getChunkSize(keyCount, workerCount);</span>
<span class="fc" id="L159">            taskCount = getTaskCount(keyCount, chunkSize);</span>
        }

<span class="fc" id="L162">        int hashColumnIndex = -1;</span>
<span class="fc" id="L163">        int hashColumnType = ColumnType.UNDEFINED;</span>
<span class="fc" id="L164">        long prefixesAddress = 0;</span>
<span class="fc" id="L165">        long prefixesCount = 0;</span>

<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (prefixes.size() &gt; 2) {</span>
<span class="fc" id="L168">            hashColumnIndex = (int) prefixes.get(0);</span>
<span class="fc" id="L169">            hashColumnType = (int) prefixes.get(1);</span>
<span class="fc" id="L170">            prefixesAddress = prefixes.getAddress() + 2 * Long.BYTES;</span>
<span class="fc" id="L171">            prefixesCount = prefixes.size() - 2;</span>
        }

        // frame metadata is based on TableReader, which is &quot;full&quot; metadata
        // this cursor works with subset of columns, which warrants column index remap
<span class="fc" id="L176">        int frameColumnIndex = columnIndexes.getQuick(columnIndex);</span>

<span class="fc" id="L178">        final RingQueue&lt;LatestByTask&gt; queue = bus.getLatestByQueue();</span>
<span class="fc" id="L179">        final Sequence pubSeq = bus.getLatestByPubSeq();</span>
<span class="fc" id="L180">        final Sequence subSeq = bus.getLatestBySubSeq();</span>
<span class="fc" id="L181">        final TableReader reader = dataFrameCursor.getTableReader();</span>

        DataFrame frame;
<span class="fc" id="L184">        long foundRowCount = 0;</span>
<span class="fc" id="L185">        int queuedCount = 0;</span>
        try {
<span class="fc bfc" id="L187" title="All 4 branches covered.">            while ((frame = dataFrameCursor.next()) != null &amp;&amp; foundRowCount &lt; keyCount) {</span>
<span class="fc" id="L188">                doneLatch.reset();</span>
<span class="fc" id="L189">                final BitmapIndexReader indexReader = frame.getBitmapIndexReader(frameColumnIndex, BitmapIndexReader.DIR_BACKWARD);</span>

<span class="fc" id="L191">                final long rowLo = frame.getRowLo();</span>
<span class="fc" id="L192">                final long rowHi = frame.getRowHi() - 1;</span>

<span class="fc" id="L194">                final long keyBaseAddress = indexReader.getKeyBaseAddress();</span>
<span class="fc" id="L195">                final long keysMemorySize = indexReader.getKeyMemorySize();</span>
<span class="fc" id="L196">                final long valueBaseAddress = indexReader.getValueBaseAddress();</span>
<span class="fc" id="L197">                final long valuesMemorySize = indexReader.getValueMemorySize();</span>
<span class="fc" id="L198">                final int valueBlockCapacity = indexReader.getValueBlockCapacity();</span>
<span class="fc" id="L199">                final long unIndexedNullCount = indexReader.getUnIndexedNullCount();</span>
<span class="fc" id="L200">                final int partitionIndex = frame.getPartitionIndex();</span>

<span class="fc" id="L202">                long hashColumnAddress = 0;</span>

                // hashColumnIndex can be -1 for latest by part only (no prefixes to match)
<span class="fc bfc" id="L205" title="All 2 branches covered.">                if (hashColumnIndex &gt; -1) {</span>
<span class="fc" id="L206">                    final int columnBase = reader.getColumnBase(partitionIndex);</span>
<span class="fc" id="L207">                    final int primaryColumnIndex = TableReader.getPrimaryColumnIndex(columnBase, hashColumnIndex);</span>
<span class="fc" id="L208">                    final MemoryR column = reader.getColumn(primaryColumnIndex);</span>
<span class="fc" id="L209">                    hashColumnAddress = column.getPageAddress(0);</span>
                }

                // -1 must be dead case here
<span class="fc bfc" id="L213" title="All 2 branches covered.">                final int hashesColumnSize = ColumnType.isGeoHash(hashColumnType) ? getPow2SizeOfGeoHashType(hashColumnType) : -1;</span>

<span class="fc" id="L215">                queuedCount = 0;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                for (long i = 0; i &lt; taskCount; ++i) {</span>
<span class="fc" id="L217">                    final long argsAddress = argumentsAddress + i * LatestByArguments.MEMORY_SIZE;</span>
<span class="fc" id="L218">                    final long found = LatestByArguments.getRowsSize(argsAddress);</span>
<span class="fc" id="L219">                    final long keyHi = LatestByArguments.getKeyHi(argsAddress);</span>
<span class="fc" id="L220">                    final long keyLo = LatestByArguments.getKeyLo(argsAddress);</span>

                    // Skip range if all keys found
<span class="fc bfc" id="L223" title="All 2 branches covered.">                    if (found &gt;= keyHi - keyLo) {</span>
<span class="fc" id="L224">                        continue;</span>
                    }
                    // Update hash column address with current frame value
<span class="fc" id="L227">                    LatestByArguments.setHashesAddress(argsAddress, hashColumnAddress);</span>

<span class="fc" id="L229">                    final long seq = pubSeq.next();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">                    if (seq &lt; 0) {</span>
<span class="nc" id="L231">                        circuitBreaker.statefulThrowExceptionIfTrippedNoThrottle();</span>
<span class="nc" id="L232">                        GeoHashNative.latestByAndFilterPrefix(</span>
                                keyBaseAddress,
                                keysMemorySize,
                                valueBaseAddress,
                                valuesMemorySize,
                                argsAddress,
                                unIndexedNullCount,
                                rowHi,
                                rowLo,
                                partitionIndex,
                                valueBlockCapacity,
                                hashColumnAddress,
                                hashesColumnSize,
                                prefixesAddress,
                                prefixesCount
                        );
                    } else {
<span class="fc" id="L249">                        queue.get(seq).of(</span>
                                keyBaseAddress,
                                keysMemorySize,
                                valueBaseAddress,
                                valuesMemorySize,
                                argsAddress,
                                unIndexedNullCount,
                                rowHi,
                                rowLo,
                                partitionIndex,
                                valueBlockCapacity,
                                hashColumnAddress,
                                hashesColumnSize,
                                prefixesAddress,
                                prefixesCount,
                                doneLatch,
                                sharedCircuitBreaker
                        );
<span class="fc" id="L267">                        pubSeq.done(seq);</span>
<span class="fc" id="L268">                        queuedCount++;</span>
                    }
                }

                // process our own queue
                // this should fix deadlock with 1 worker configuration
<span class="fc bfc" id="L274" title="All 2 branches covered.">                while (doneLatch.getCount() &gt; -queuedCount) {</span>
<span class="fc" id="L275">                    circuitBreaker.statefulThrowExceptionIfTrippedNoThrottle();</span>
<span class="fc" id="L276">                    long seq = subSeq.next();</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                    if (seq &gt; -1) {</span>
<span class="fc" id="L278">                        queue.get(seq).run();</span>
<span class="fc" id="L279">                        subSeq.done(seq);</span>
                    }
<span class="fc" id="L281">                }</span>

<span class="fc" id="L283">                doneLatch.await(queuedCount);</span>

<span class="fc" id="L285">                foundRowCount = 0; // Reset found counter</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">                for (int i = 0; i &lt; taskCount; i++) {</span>
<span class="fc" id="L287">                    final long address = argumentsAddress + i * LatestByArguments.MEMORY_SIZE;</span>
<span class="fc" id="L288">                    foundRowCount += LatestByArguments.getRowsSize(address);</span>
                }
<span class="fc" id="L290">            }</span>
<span class="fc" id="L291">        } catch (DataUnavailableException e) {</span>
            // We're not yet done, so no need to cancel the circuit breaker. 
<span class="fc" id="L293">            throw e;</span>
<span class="fc" id="L294">        } catch (Throwable t) {</span>
<span class="fc" id="L295">            sharedCircuitBreaker.cancel();</span>
<span class="fc" id="L296">            throw t;</span>
        } finally {
<span class="fc" id="L298">            processTasks(queuedCount);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (sharedCircuitBreaker.isCanceled()) {</span>
<span class="fc" id="L300">                LatestByArguments.releaseMemoryArray(argumentsAddress, taskCount);</span>
<span class="fc" id="L301">                argumentsAddress = 0;</span>
            }
        }

<span class="fc" id="L305">        long rowCount = 0;</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (argumentsAddress &gt; 0) {</span>
<span class="fc" id="L307">            rowCount = GeoHashNative.slideFoundBlocks(argumentsAddress, taskCount);</span>
<span class="fc" id="L308">            LatestByArguments.releaseMemoryArray(argumentsAddress, taskCount);</span>
<span class="fc" id="L309">            argumentsAddress = 0;</span>
        }
<span class="fc" id="L311">        aLimit = rowCount;</span>
<span class="fc" id="L312">        aIndex = indexShift;</span>
<span class="fc" id="L313">        postProcessRows();</span>
<span class="fc" id="L314">    }</span>

    private void postProcessRows() {
<span class="fc" id="L317">        Vect.sortULongAscInPlace(rows.getAddress(), aLimit);</span>
<span class="fc" id="L318">    }</span>

    private void processTasks(int queuedCount) {
<span class="fc" id="L321">        final RingQueue&lt;LatestByTask&gt; queue = bus.getLatestByQueue();</span>
<span class="fc" id="L322">        final Sequence subSeq = bus.getLatestBySubSeq();</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">        while (doneLatch.getCount() &gt; -queuedCount) {</span>
<span class="fc" id="L324">            long seq = subSeq.next();</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">            if (seq &gt; -1) {</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                if (circuitBreaker.checkIfTripped()) {</span>
<span class="fc" id="L327">                    sharedCircuitBreaker.cancel();</span>
                }
<span class="fc" id="L329">                queue.get(seq).run();</span>
<span class="fc" id="L330">                subSeq.done(seq);</span>
            }
<span class="fc" id="L332">        }</span>
<span class="fc" id="L333">        doneLatch.await(queuedCount);</span>
<span class="fc" id="L334">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>