<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TextMetadataParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.text</a> &gt; <span class="el_source">TextMetadataParser.java</span></div><h1>TextMetadataParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.text;

import io.questdb.cairo.ColumnType;
import io.questdb.cutlass.json.JsonException;
import io.questdb.cutlass.json.JsonLexer;
import io.questdb.cutlass.json.JsonParser;
import io.questdb.cutlass.text.types.TypeAdapter;
import io.questdb.cutlass.text.types.TypeManager;
import io.questdb.griffin.SqlKeywords;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.*;
import io.questdb.std.datetime.DateLocale;
import io.questdb.std.datetime.DateLocaleFactory;
import io.questdb.std.datetime.microtime.TimestampFormatFactory;
import io.questdb.std.datetime.millitime.DateFormatFactory;
import io.questdb.std.str.AbstractCharSequence;

import java.io.Closeable;

public class TextMetadataParser implements JsonParser, Mutable, Closeable {
<span class="fc" id="L46">    private static final Log LOG = LogFactory.getLog(TextMetadataParser.class);</span>
    private static final int P_INDEX = 6;
    private static final int P_LOCALE = 4;
    private static final int P_NAME = 1;
    private static final int P_PATTERN = 3;
    private static final int P_TYPE = 2;
    private static final int P_UTF8 = 5;
    private static final int S_NEED_ARRAY = 1;
    private static final int S_NEED_OBJECT = 2;
    private static final int S_NEED_PROPERTY = 3;
<span class="fc" id="L56">    private static final CharSequenceIntHashMap propertyNameMap = new CharSequenceIntHashMap();</span>
    private final ObjList&lt;CharSequence&gt; columnNames;
    private final ObjList&lt;TypeAdapter&gt; columnTypes;
    private final ObjectPool&lt;FloatingCharSequence&gt; csPool;
    private final DateFormatFactory dateFormatFactory;
    private final DateLocale dateLocale;
    private final DateLocaleFactory dateLocaleFactory;
    private final TimestampFormatFactory timestampFormatFactory;
    private final TypeManager typeManager;
    private long buf;
<span class="fc" id="L66">    private long bufCapacity = 0;</span>
<span class="fc" id="L67">    private int bufSize = 0;</span>
<span class="fc" id="L68">    private boolean index = false;</span>
    private CharSequence locale;
    private int localePosition;
    private CharSequence name;
    private CharSequence pattern;
    private int propertyIndex;
<span class="fc" id="L74">    private int state = S_NEED_ARRAY;</span>
    private CharSequence tableName;
<span class="fc" id="L76">    private int type = -1;</span>
<span class="fc" id="L77">    private boolean utf8 = false;</span>

<span class="fc" id="L79">    public TextMetadataParser(TextConfiguration textConfiguration, TypeManager typeManager) {</span>
<span class="fc" id="L80">        this.columnNames = new ObjList&lt;&gt;();</span>
<span class="fc" id="L81">        this.columnTypes = new ObjList&lt;&gt;();</span>
<span class="fc" id="L82">        this.csPool = new ObjectPool&lt;&gt;(FloatingCharSequence::new, textConfiguration.getMetadataStringPoolCapacity());</span>
<span class="fc" id="L83">        this.dateLocaleFactory = typeManager.getInputFormatConfiguration().getDateLocaleFactory();</span>
<span class="fc" id="L84">        this.dateFormatFactory = typeManager.getInputFormatConfiguration().getDateFormatFactory();</span>
<span class="fc" id="L85">        this.timestampFormatFactory = typeManager.getInputFormatConfiguration().getTimestampFormatFactory();</span>
<span class="fc" id="L86">        this.typeManager = typeManager;</span>
<span class="fc" id="L87">        this.dateLocale = textConfiguration.getDefaultDateLocale();</span>
<span class="fc" id="L88">    }</span>

    @Override
    public void clear() {
<span class="fc" id="L92">        bufSize = 0;</span>
<span class="fc" id="L93">        state = S_NEED_ARRAY;</span>
<span class="fc" id="L94">        columnNames.clear();</span>
<span class="fc" id="L95">        columnTypes.clear();</span>
<span class="fc" id="L96">        csPool.clear();</span>
<span class="fc" id="L97">        clearStage();</span>
<span class="fc" id="L98">    }</span>

    @Override
    public void close() {
<span class="fc" id="L102">        clear();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (bufCapacity &gt; 0) {</span>
<span class="fc" id="L104">            Unsafe.free(buf, bufCapacity, MemoryTag.NATIVE_TEXT_PARSER_RSS);</span>
<span class="fc" id="L105">            bufCapacity = 0;</span>
        }
<span class="fc" id="L107">    }</span>

    public ObjList&lt;CharSequence&gt; getColumnNames() {
<span class="fc" id="L110">        return columnNames;</span>
    }

    public ObjList&lt;TypeAdapter&gt; getColumnTypes() {
<span class="fc" id="L114">        return columnTypes;</span>
    }

    @Override
    public void onEvent(int code, CharSequence tag, int position) throws JsonException {
<span class="fc bfc" id="L119" title="All 7 branches covered.">        switch (code) {</span>
            case JsonLexer.EVT_ARRAY_START:
<span class="fc bfc" id="L121" title="All 2 branches covered.">                if (state != S_NEED_ARRAY) {</span>
<span class="fc" id="L122">                    throw JsonException.$(position, &quot;Unexpected array&quot;);</span>
                }
<span class="fc" id="L124">                state = S_NEED_OBJECT;</span>
<span class="fc" id="L125">                break;</span>
            case JsonLexer.EVT_OBJ_START:
<span class="fc bfc" id="L127" title="All 2 branches covered.">                if (state != S_NEED_OBJECT) {</span>
<span class="fc" id="L128">                    throw JsonException.$(position, &quot;Unexpected object&quot;);</span>
                }
<span class="fc" id="L130">                state = S_NEED_PROPERTY;</span>
<span class="fc" id="L131">                break;</span>
            case JsonLexer.EVT_NAME:
<span class="fc" id="L133">                this.propertyIndex = propertyNameMap.get(tag);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">                if (this.propertyIndex == -1) {</span>
<span class="fc" id="L135">                    LOG.info().$(&quot;unknown [table=&quot;).$(tableName).$(&quot;, tag=&quot;).$(tag).$(']').$();</span>
                }
                break;
            case JsonLexer.EVT_VALUE:
<span class="fc bfc" id="L139" title="All 7 branches covered.">                switch (propertyIndex) {</span>
                    case P_NAME:
<span class="fc" id="L141">                        name = copy(tag);</span>
<span class="fc" id="L142">                        break;</span>
                    case P_TYPE:
<span class="fc" id="L144">                        type = ColumnType.typeOf(tag);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                        if (type == -1) {</span>
<span class="fc" id="L146">                            throw JsonException.$(position, &quot;Invalid type&quot;);</span>
                        }
                        break;
                    case P_PATTERN:
<span class="fc" id="L150">                        pattern = copy(tag);</span>
<span class="fc" id="L151">                        break;</span>
                    case P_LOCALE:
<span class="fc" id="L153">                        locale = copy(tag);</span>
<span class="fc" id="L154">                        localePosition = position;</span>
<span class="fc" id="L155">                        break;</span>
                    case P_UTF8:
<span class="fc" id="L157">                        utf8 = SqlKeywords.isTrueKeyword(tag);</span>
<span class="fc" id="L158">                        break;</span>
                    case P_INDEX:
<span class="fc" id="L160">                        index = SqlKeywords.isTrueKeyword(tag);</span>
<span class="fc" id="L161">                        break;</span>
                    default:
<span class="fc" id="L163">                        LOG.info().$(&quot;ignoring [table=&quot;).$(tableName).$(&quot;, value=&quot;).$(tag).$(']').$();</span>
<span class="fc" id="L164">                        break;</span>
                }
                break;
            case JsonLexer.EVT_OBJ_END:
<span class="fc" id="L168">                state = S_NEED_OBJECT;</span>
<span class="fc" id="L169">                createImportedType(position);</span>
<span class="fc" id="L170">                break;</span>
            case JsonLexer.EVT_ARRAY_VALUE:
<span class="fc" id="L172">                throw JsonException.$(position, &quot;Must be an object&quot;);</span>
            default:
                break;
        }
<span class="fc" id="L176">    }</span>

    private static void checkInputs(int position, CharSequence name, int type) throws JsonException {
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (name == null) {</span>
<span class="fc" id="L180">            throw JsonException.$(position, &quot;Missing 'name' property&quot;);</span>
        }

<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (type == -1) {</span>
<span class="fc" id="L184">            throw JsonException.$(position, &quot;Missing 'type' property&quot;);</span>
        }
<span class="fc" id="L186">    }</span>

    private static void strcpyw(final CharSequence value, final int len, final long address) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L190">            Unsafe.getUnsafe().putChar(address + ((long) i &lt;&lt; 1), value.charAt(i));</span>
        }
<span class="fc" id="L192">    }</span>

    private void clearStage() {
<span class="fc" id="L195">        name = null;</span>
<span class="fc" id="L196">        type = -1;</span>
<span class="fc" id="L197">        pattern = null;</span>
<span class="fc" id="L198">        locale = null;</span>
<span class="fc" id="L199">        localePosition = 0;</span>
<span class="fc" id="L200">        utf8 = false;</span>
<span class="fc" id="L201">        index = false;</span>
<span class="fc" id="L202">    }</span>

    private CharSequence copy(CharSequence tag) {
<span class="fc" id="L205">        final int l = tag.length() * 2;</span>
<span class="fc" id="L206">        final long n = bufSize + l;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (n &gt; bufCapacity) {</span>
<span class="fc" id="L208">            long ptr = Unsafe.malloc(n * 2, MemoryTag.NATIVE_TEXT_PARSER_RSS);</span>
<span class="fc" id="L209">            Vect.memcpy(ptr, buf, bufSize);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            if (bufCapacity &gt; 0) {</span>
<span class="fc" id="L211">                Unsafe.free(buf, bufCapacity, MemoryTag.NATIVE_TEXT_PARSER_RSS);</span>
            }
<span class="fc" id="L213">            buf = ptr;</span>
<span class="fc" id="L214">            bufCapacity = n * 2;</span>
        }

<span class="fc" id="L217">        strcpyw(tag, l / 2, buf + bufSize);</span>
<span class="fc" id="L218">        CharSequence cs = csPool.next().of(bufSize, l / 2);</span>
<span class="fc" id="L219">        bufSize += l;</span>
<span class="fc" id="L220">        return cs;</span>
    }

    private void createImportedType(int position) throws JsonException {
<span class="fc" id="L224">        checkInputs(position, name, type);</span>

<span class="fc" id="L226">        columnNames.add(name);</span>

<span class="fc bfc" id="L228" title="All 4 branches covered.">        switch (ColumnType.tagOf(type)) {</span>
            case ColumnType.DATE:
<span class="fc bfc" id="L230" title="All 2 branches covered.">                DateLocale dateLocale = locale == null ? this.dateLocale : dateLocaleFactory.getLocale(locale);</span>

<span class="fc bfc" id="L232" title="All 2 branches covered.">                if (dateLocale == null) {</span>
<span class="fc" id="L233">                    throw JsonException.$(localePosition, &quot;Invalid date locale&quot;);</span>
                }

                // date pattern is required
<span class="fc bfc" id="L237" title="All 2 branches covered.">                if (pattern == null) {</span>
<span class="fc" id="L238">                    throw JsonException.$(0, &quot;DATE format pattern is required&quot;);</span>
                }
<span class="fc" id="L240">                columnTypes.add(typeManager.nextDateAdapter().of(dateFormatFactory.get(pattern), dateLocale));</span>
<span class="fc" id="L241">                break;</span>
            case ColumnType.TIMESTAMP:
                DateLocale timestampLocale =
<span class="fc bfc" id="L244" title="All 2 branches covered.">                        locale == null ?</span>
<span class="fc" id="L245">                                this.dateLocale</span>
<span class="fc" id="L246">                                : dateLocaleFactory.getLocale(locale);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">                if (timestampLocale == null) {</span>
<span class="fc" id="L248">                    throw JsonException.$(localePosition, &quot;Invalid timestamp locale&quot;);</span>
                }

                // timestamp pattern is required
<span class="fc bfc" id="L252" title="All 2 branches covered.">                if (pattern == null) {</span>
<span class="fc" id="L253">                    throw JsonException.$(0, &quot;TIMESTAMP format pattern is required&quot;);</span>
                }
<span class="fc" id="L255">                columnTypes.add(typeManager.nextTimestampAdapter(utf8, timestampFormatFactory.get(pattern), timestampLocale));</span>
<span class="fc" id="L256">                break;</span>
            case ColumnType.SYMBOL:
<span class="fc" id="L258">                columnTypes.add(typeManager.nextSymbolAdapter(index));</span>
<span class="fc" id="L259">                break;</span>
            default:
<span class="fc" id="L261">                columnTypes.add(typeManager.getTypeAdapter(type));</span>
                break;
        }
        // prepare for next iteration
<span class="fc" id="L265">        clearStage();</span>
<span class="fc" id="L266">    }</span>

    void setTableName(CharSequence tableName) {
<span class="fc" id="L269">        this.tableName = tableName;</span>
<span class="fc" id="L270">    }</span>

<span class="fc" id="L272">    private class FloatingCharSequence extends AbstractCharSequence implements Mutable {</span>

        private int len;
        private int offset;

        @Override
        public char charAt(int index) {
<span class="fc" id="L279">            return Unsafe.getUnsafe().getChar(buf + offset + index * 2L);</span>
        }

        @Override
        public void clear() {
<span class="fc" id="L284">        }</span>

        @Override
        public int length() {
<span class="fc" id="L288">            return len;</span>
        }

        CharSequence of(int lo, int len) {
<span class="fc" id="L292">            this.offset = lo;</span>
<span class="fc" id="L293">            this.len = len;</span>
<span class="fc" id="L294">            return this;</span>
        }
    }

    static {
<span class="fc" id="L299">        propertyNameMap.put(&quot;name&quot;, P_NAME);</span>
<span class="fc" id="L300">        propertyNameMap.put(&quot;type&quot;, P_TYPE);</span>
<span class="fc" id="L301">        propertyNameMap.put(&quot;pattern&quot;, P_PATTERN);</span>
<span class="fc" id="L302">        propertyNameMap.put(&quot;locale&quot;, P_LOCALE);</span>
<span class="fc" id="L303">        propertyNameMap.put(&quot;utf8&quot;, P_UTF8);</span>
<span class="fc" id="L304">        propertyNameMap.put(&quot;index&quot;, P_INDEX);</span>
<span class="fc" id="L305">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>