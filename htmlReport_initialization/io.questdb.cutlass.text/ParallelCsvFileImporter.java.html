<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParallelCsvFileImporter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.text</a> &gt; <span class="el_source">ParallelCsvFileImporter.java</span></div><h1>ParallelCsvFileImporter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.text;

import io.questdb.MessageBus;
import io.questdb.cairo.*;
import io.questdb.cairo.security.AllowAllCairoSecurityContext;
import io.questdb.cairo.sql.ExecutionCircuitBreaker;
import io.questdb.cairo.sql.RecordMetadata;
import io.questdb.cairo.sql.TableRecordMetadata;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryMARW;
import io.questdb.cutlass.text.types.*;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.mp.Job;
import io.questdb.mp.RingQueue;
import io.questdb.mp.Sequence;
import io.questdb.std.*;
import io.questdb.std.datetime.DateFormat;
import io.questdb.std.str.DirectCharSink;
import io.questdb.std.str.Path;
import io.questdb.std.str.StringSink;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.TestOnly;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.util.function.Consumer;

import static io.questdb.cairo.TableUtils.TXN_FILE_NAME;


/**
 * Class is responsible for importing of large unordered import files into partitioned tables.
 * It does the following (in parallel) :
 * - splits the file into N-chunks, scans in parallel and finds correct line start for each chunk
 * - scans each chunk and extracts timestamps and line offsets to per-partition index files
 * (index files are stored as $inputWorkDir/$inputFileName/$partitionName/$workerId_$chunkNumber)
 * then it sorts each file by timestamp value
 * - merges all partition index chunks into one index file per partition (index.m)
 * - loads partitions into separate tables using merged indexes (one table per worker)
 * - scans all symbol columns to build per-column global symbol table
 * - remaps all symbol values
 * - moves and attaches partitions from temp tables to target table
 * - removes temp tables and index files
 */
public class ParallelCsvFileImporter implements Closeable, Mutable {
    private static final int DEFAULT_MIN_CHUNK_SIZE = 300 * 1024 * 1024;
    private static final String LOCK_REASON = &quot;parallel import&quot;;
<span class="fc" id="L74">    private static final Log LOG = LogFactory.getLog(ParallelCsvFileImporter.class);</span>
    private static final int NO_INDEX = -1;
    private final CairoEngine cairoEngine;
    //holds result of first phase - boundary scanning
    //count of quotes, even new lines, odd new lines, offset to first even newline, offset to first odd newline
    private final LongList chunkStats;
    private final Sequence collectSeq;
    private final CairoConfiguration configuration;
    private final FilesFacade ff;
    //holds input for second phase - indexing: offset and start line number for each chunk
    private final LongList indexChunkStats;
    private final Path inputFilePath;
    private final CharSequence inputRoot;
    private final CharSequence inputWorkRoot;
    private final TextImportJob localImportJob;
    private final ObjectPool&lt;OtherToTimestampAdapter&gt; otherToTimestampAdapterPool;
    private final LongList partitionKeysAndSizes;
    private final StringSink partitionNameSink;
    private final ObjList&lt;PartitionInfo&gt; partitions;
    private final Sequence pubSeq;
    private final RingQueue&lt;TextImportTask&gt; queue;
    private final CairoSecurityContext securityContext;
    private final TableStructureAdapter targetTableStructure;
    //stores 3 values per task : index, lo, hi (lo, hi are indexes in partitionNames)
    private final IntList taskDistribution;
    private final TextDelimiterScanner textDelimiterScanner;
    private final TextMetadataDetector textMetadataDetector;
    private final Path tmpPath;
    private final TypeManager typeManager;
    private final DirectCharSink utf8Sink;
    private final int workerCount;
    private int atomicity;
    private ExecutionCircuitBreaker circuitBreaker;
    private byte columnDelimiter;
    private boolean createdWorkDir;
    private CharSequence errorMessage;
    private long errors;
    private boolean forceHeader;
    private long importId;
    //path to import directory under, usually $inputWorkRoot/$tableName
    private CharSequence importRoot;
    //name of file to process in inputRoot dir
    private CharSequence inputFileName;
    //incremented in phase 2
    private long linesIndexed;
<span class="fc" id="L119">    private int minChunkSize = DEFAULT_MIN_CHUNK_SIZE;</span>
    private int partitionBy;
<span class="fc" id="L121">    private byte phase = TextImportTask.PHASE_SETUP;</span>
    private long phaseErrors;
    //row stats are incremented in phase 3
    private long rowsHandled;
    private long rowsImported;
    private long startMs;//start time of current phase (in millis)
    //import status variables
<span class="fc" id="L128">    private byte status = TextImportTask.STATUS_STARTED;</span>
<span class="fc" id="L129">    private final Consumer&lt;TextImportTask&gt; checkStatusRef = this::updateStatus;</span>
<span class="fc" id="L130">    private final Consumer&lt;TextImportTask&gt; collectChunkStatsRef = this::collectChunkStats;</span>
<span class="fc" id="L131">    private final Consumer&lt;TextImportTask&gt; collectStubRef = this::collectStub;</span>
<span class="fc" id="L132">    private final Consumer&lt;TextImportTask&gt; collectDataImportStatsRef = this::collectDataImportStats;</span>
<span class="fc" id="L133">    private final Consumer&lt;TextImportTask&gt; collectIndexStatsRef = this::collectIndexStats;</span>
    private PhaseStatusReporter statusReporter;
    //input params start
    private CharSequence tableName;
    private TableToken tableToken;
    private boolean targetTableCreated;
    private int targetTableStatus;
    private int taskCount;
    private TimestampAdapter timestampAdapter;
    //name of timestamp column
    private CharSequence timestampColumn;
    //input params end
    //index of timestamp column in input file
    private int timestampIndex;

<span class="fc" id="L148">    public ParallelCsvFileImporter(CairoEngine cairoEngine, int workerCount) {</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (workerCount &lt; 1) {</span>
<span class="fc" id="L150">            throw TextImportException.instance(TextImportTask.PHASE_SETUP, &quot;Invalid worker count set [value=&quot;).put(workerCount).put(']');</span>
        }

<span class="fc" id="L153">        MessageBus bus = cairoEngine.getMessageBus();</span>
<span class="fc" id="L154">        RingQueue&lt;TextImportTask&gt; queue = bus.getTextImportQueue();</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (queue.getCycle() &lt; 1) {</span>
<span class="fc" id="L156">            throw TextImportException.instance(TextImportTask.PHASE_SETUP, &quot;Parallel import queue size cannot be zero!&quot;);</span>
        }

<span class="fc" id="L159">        this.cairoEngine = cairoEngine;</span>
<span class="fc" id="L160">        this.workerCount = workerCount;</span>

<span class="fc" id="L162">        this.queue = queue;</span>
<span class="fc" id="L163">        this.pubSeq = bus.getTextImportPubSeq();</span>
<span class="fc" id="L164">        this.collectSeq = bus.getTextImportColSeq();</span>
<span class="fc" id="L165">        this.localImportJob = new TextImportJob(bus);</span>

<span class="fc" id="L167">        this.securityContext = AllowAllCairoSecurityContext.INSTANCE;</span>
<span class="fc" id="L168">        this.configuration = cairoEngine.getConfiguration();</span>

<span class="fc" id="L170">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L171">        this.inputRoot = configuration.getSqlCopyInputRoot();</span>
<span class="fc" id="L172">        this.inputWorkRoot = configuration.getSqlCopyInputWorkRoot();</span>

<span class="fc" id="L174">        TextConfiguration textConfiguration = configuration.getTextConfiguration();</span>
<span class="fc" id="L175">        this.utf8Sink = new DirectCharSink(textConfiguration.getUtf8SinkSize());</span>
<span class="fc" id="L176">        this.typeManager = new TypeManager(textConfiguration, utf8Sink);</span>
<span class="fc" id="L177">        this.textDelimiterScanner = new TextDelimiterScanner(textConfiguration);</span>
<span class="fc" id="L178">        this.textMetadataDetector = new TextMetadataDetector(typeManager, textConfiguration);</span>

<span class="fc" id="L180">        this.targetTableStructure = new TableStructureAdapter(configuration);</span>
<span class="fc" id="L181">        this.targetTableStatus = -1;</span>
<span class="fc" id="L182">        this.targetTableCreated = false;</span>

<span class="fc" id="L184">        this.atomicity = Atomicity.SKIP_COL;</span>
<span class="fc" id="L185">        this.createdWorkDir = false;</span>
<span class="fc" id="L186">        this.otherToTimestampAdapterPool = new ObjectPool&lt;&gt;(OtherToTimestampAdapter::new, 4);</span>
<span class="fc" id="L187">        this.inputFilePath = new Path();</span>
<span class="fc" id="L188">        this.tmpPath = new Path();</span>

<span class="fc" id="L190">        this.chunkStats = new LongList();</span>
<span class="fc" id="L191">        this.indexChunkStats = new LongList();</span>
<span class="fc" id="L192">        this.partitionKeysAndSizes = new LongList();</span>
<span class="fc" id="L193">        this.partitionNameSink = new StringSink();</span>
<span class="fc" id="L194">        this.partitions = new ObjList&lt;&gt;();</span>
<span class="fc" id="L195">        this.taskDistribution = new IntList();</span>
<span class="fc" id="L196">    }</span>

    public static void createTable(
            final FilesFacade ff,
            int mkDirMode,
            final CharSequence root,
            final CharSequence tableDir,
            final CharSequence tableName,
            TableStructure structure,
            int tableId
    ) {
<span class="fc" id="L207">        try (Path path = new Path()) {</span>
<span class="fc bfc" id="L208" title="All 3 branches covered.">            switch (TableUtils.exists(ff, path, root, tableDir, 0, tableDir.length())) {</span>
                case TableUtils.TABLE_EXISTS:
                    int errno;
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">                    if ((errno = ff.rmdir(path)) != 0) {</span>
<span class="fc" id="L212">                        LOG.error().$(&quot;could not overwrite table [tableName='&quot;).utf8(tableName).$(&quot;',path='&quot;).utf8(path).$(&quot;, errno=&quot;).$(errno).I$();</span>
<span class="fc" id="L213">                        throw CairoException.critical(errno).put(&quot;could not overwrite [tableName=&quot;).put(tableName).put(&quot;]&quot;);</span>
                    }
                case TableUtils.TABLE_DOES_NOT_EXIST:
<span class="fc" id="L216">                    try (MemoryMARW memory = Vm.getMARWInstance()) {</span>
<span class="fc" id="L217">                        TableUtils.createTable(</span>
                                ff,
                                root,
                                mkDirMode,
                                memory,
                                path,
                                tableDir,
                                structure,
                                ColumnType.VERSION,
                                tableId
                        );
                    }
<span class="fc" id="L229">                    break;</span>
                default:
<span class="fc" id="L231">                    throw TextException.$(&quot;name is reserved [tableName=&quot;).put(tableName).put(']');</span>
            }
        }
<span class="fc" id="L234">    }</span>

    @Override
    public void clear() {
<span class="fc" id="L238">        importId = -1;</span>
<span class="fc" id="L239">        chunkStats.clear();</span>
<span class="fc" id="L240">        indexChunkStats.clear();</span>
<span class="fc" id="L241">        partitionKeysAndSizes.clear();</span>
<span class="fc" id="L242">        partitionNameSink.clear();</span>
<span class="fc" id="L243">        taskDistribution.clear();</span>
<span class="fc" id="L244">        utf8Sink.clear();</span>
<span class="fc" id="L245">        typeManager.clear();</span>
<span class="fc" id="L246">        textMetadataDetector.clear();</span>
<span class="fc" id="L247">        otherToTimestampAdapterPool.clear();</span>
<span class="fc" id="L248">        partitions.clear();</span>
<span class="fc" id="L249">        linesIndexed = 0;</span>
<span class="fc" id="L250">        rowsHandled = 0;</span>
<span class="fc" id="L251">        rowsImported = 0;</span>
<span class="fc" id="L252">        errors = 0;</span>
<span class="fc" id="L253">        phaseErrors = 0;</span>
<span class="fc" id="L254">        inputFileName = null;</span>
<span class="fc" id="L255">        tableName = null;</span>
<span class="fc" id="L256">        tableToken = null;</span>
<span class="fc" id="L257">        timestampColumn = null;</span>
<span class="fc" id="L258">        timestampIndex = -1;</span>
<span class="fc" id="L259">        partitionBy = -1;</span>
<span class="fc" id="L260">        columnDelimiter = -1;</span>
<span class="fc" id="L261">        timestampAdapter = null;</span>
<span class="fc" id="L262">        forceHeader = false;</span>
<span class="fc" id="L263">        status = TextImportTask.STATUS_STARTED;</span>
<span class="fc" id="L264">        phase = TextImportTask.PHASE_SETUP;</span>
<span class="fc" id="L265">        errorMessage = null;</span>
<span class="fc" id="L266">        targetTableStatus = -1;</span>
<span class="fc" id="L267">        targetTableCreated = false;</span>
<span class="fc" id="L268">        atomicity = Atomicity.SKIP_COL;</span>
<span class="fc" id="L269">        taskCount = -1;</span>
<span class="fc" id="L270">        createdWorkDir = false;</span>
<span class="fc" id="L271">    }</span>

    @Override
    public void close() {
<span class="fc" id="L275">        clear();</span>
<span class="fc" id="L276">        this.inputFilePath.close();</span>
<span class="fc" id="L277">        this.tmpPath.close();</span>
<span class="fc" id="L278">        this.utf8Sink.close();</span>
<span class="fc" id="L279">        this.textMetadataDetector.close();</span>
<span class="fc" id="L280">        this.textDelimiterScanner.close();</span>
<span class="fc" id="L281">        this.localImportJob.close();</span>
<span class="fc" id="L282">    }</span>

    public void of(
            CharSequence tableName,
            CharSequence inputFileName,
            long importId,
            int partitionBy,
            byte columnDelimiter,
            CharSequence timestampColumn,
            CharSequence timestampFormat,
            boolean forceHeader,
            ExecutionCircuitBreaker circuitBreaker,
            int atomicity
    ) {
<span class="fc" id="L296">        clear();</span>
<span class="fc" id="L297">        this.circuitBreaker = circuitBreaker;</span>
<span class="fc" id="L298">        this.tableName = tableName;</span>
<span class="fc" id="L299">        this.tableToken = cairoEngine.lockTableName(tableName, false);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (tableToken == null) {</span>
<span class="fc" id="L301">            tableToken = cairoEngine.getTableToken(tableName);</span>
        }
<span class="fc" id="L303">        this.importRoot = tmpPath.of(inputWorkRoot).concat(tableToken).toString();</span>
<span class="fc" id="L304">        this.inputFileName = inputFileName;</span>
<span class="fc" id="L305">        this.timestampColumn = timestampColumn;</span>
<span class="fc" id="L306">        this.partitionBy = partitionBy;</span>
<span class="fc" id="L307">        this.columnDelimiter = columnDelimiter;</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (timestampFormat != null) {</span>
<span class="fc" id="L309">            DateFormat dateFormat = typeManager.getInputFormatConfiguration().getTimestampFormatFactory().get(timestampFormat);</span>
<span class="fc" id="L310">            this.timestampAdapter = (TimestampAdapter) typeManager.nextTimestampAdapter(</span>
                    false,
                    dateFormat,
<span class="fc" id="L313">                    configuration.getTextConfiguration().getDefaultDateLocale()</span>
            );
        }
<span class="fc" id="L316">        this.forceHeader = forceHeader;</span>
<span class="fc" id="L317">        this.timestampIndex = -1;</span>
<span class="fc" id="L318">        this.status = TextImportTask.STATUS_STARTED;</span>
<span class="fc" id="L319">        this.phase = TextImportTask.PHASE_SETUP;</span>
<span class="fc" id="L320">        this.targetTableStatus = -1;</span>
<span class="fc" id="L321">        this.targetTableCreated = false;</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        this.atomicity = Atomicity.isValid(atomicity) ? atomicity : Atomicity.SKIP_ROW;</span>
<span class="fc" id="L323">        this.importId = importId;</span>
<span class="fc" id="L324">        inputFilePath.of(inputRoot).concat(inputFileName).$();</span>
<span class="fc" id="L325">    }</span>

    @TestOnly
    public void of(
            CharSequence tableName,
            CharSequence inputFileName,
            long importId,
            int partitionBy,
            byte columnDelimiter,
            CharSequence timestampColumn,
            CharSequence tsFormat,
            boolean forceHeader,
            ExecutionCircuitBreaker circuitBreaker
    ) {
<span class="fc" id="L339">        of(</span>
                tableName,
                inputFileName,
                importId,
                partitionBy,
                columnDelimiter,
                timestampColumn,
                tsFormat,
                forceHeader,
                circuitBreaker,
                Atomicity.SKIP_COL
        );
<span class="fc" id="L351">    }</span>

    @TestOnly
    public void of(
            CharSequence tableName,
            CharSequence inputFileName,
            long importId,
            int partitionBy,
            byte columnDelimiter,
            CharSequence timestampColumn,
            CharSequence timestampFormat,
            boolean forceHeader
    ) {
<span class="fc" id="L364">        of(</span>
                tableName,
                inputFileName,
                importId,
                partitionBy,
                columnDelimiter,
                timestampColumn,
                timestampFormat,
                forceHeader,
                null,
                Atomicity.SKIP_COL
        );
<span class="fc" id="L376">    }</span>

    public void process() throws TextImportException {
<span class="fc" id="L379">        final long startMs = getCurrentTimeMs();</span>

<span class="fc" id="L381">        int fd = -1;</span>
        try {
            try {
<span class="fc" id="L384">                updateImportStatus(TextImportTask.STATUS_STARTED, Numbers.LONG_NaN, Numbers.LONG_NaN, 0);</span>

                try {
<span class="fc" id="L387">                    fd = TableUtils.openRO(ff, inputFilePath, LOG);</span>
<span class="nc" id="L388">                } catch (CairoException e) {</span>
<span class="nc" id="L389">                    throw TextImportException.instance(TextImportTask.PHASE_SETUP, e.getFlyweightMessage(), e.getErrno());</span>
<span class="fc" id="L390">                }</span>

<span class="fc" id="L392">                long length = ff.length(fd);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                if (length &lt; 1) {</span>
<span class="fc" id="L394">                    throw TextImportException.instance(TextImportTask.PHASE_SETUP, &quot;ignored empty input file [file='&quot;).put(inputFilePath).put(']');</span>
                }

<span class="fc" id="L397">                try (TableWriter writer = parseStructure(fd)) {</span>
<span class="fc" id="L398">                    phaseBoundaryCheck(length);</span>
<span class="fc" id="L399">                    phaseIndexing();</span>
<span class="fc" id="L400">                    phasePartitionImport();</span>
<span class="fc" id="L401">                    phaseSymbolTableMerge(writer);</span>
<span class="fc" id="L402">                    phaseUpdateSymbolKeys(writer);</span>
<span class="fc" id="L403">                    phaseBuildSymbolIndex(writer);</span>
                    try {
<span class="fc" id="L405">                        movePartitions();</span>
<span class="fc" id="L406">                        attachPartitions(writer);</span>
<span class="fc" id="L407">                    } catch (Throwable t) {</span>
<span class="fc" id="L408">                        cleanUp(writer);</span>
<span class="fc" id="L409">                        throw t;</span>
<span class="fc" id="L410">                    }</span>
<span class="fc" id="L411">                    updateImportStatus(TextImportTask.STATUS_FINISHED, rowsHandled, rowsImported, errors);</span>
<span class="fc" id="L412">                } catch (Throwable t) {</span>
<span class="fc" id="L413">                    cleanUp();</span>
<span class="fc" id="L414">                    throw t;</span>
                } finally {
<span class="fc bfc" id="L416" title="All 2 branches covered.">                    if (createdWorkDir) {</span>
<span class="fc" id="L417">                        removeWorkDir();</span>
                    }
                }
                // these are the leftovers that also need to be converted
<span class="fc" id="L421">            } catch (CairoException e) {</span>
<span class="fc" id="L422">                throw TextImportException.instance(TextImportTask.PHASE_CLEANUP, e.getFlyweightMessage(), e.getErrno());</span>
<span class="fc" id="L423">            } catch (TextException e) {</span>
<span class="fc" id="L424">                throw TextImportException.instance(TextImportTask.PHASE_CLEANUP, e.getFlyweightMessage());</span>
            } finally {
<span class="fc" id="L426">                ff.close(fd);</span>
            }
<span class="fc" id="L428">        } catch (TextImportException e) {</span>
<span class="fc" id="L429">            LOG.error()</span>
<span class="fc" id="L430">                    .$(&quot;could not import [phase=&quot;).$(TextImportTask.getPhaseName(e.getPhase()))</span>
<span class="fc" id="L431">                    .$(&quot;, ex=&quot;).$(e.getFlyweightMessage())</span>
<span class="fc" id="L432">                    .I$();</span>
<span class="fc" id="L433">            throw e;</span>
<span class="fc" id="L434">        }</span>

<span class="fc" id="L436">        long endMs = getCurrentTimeMs();</span>
<span class="fc" id="L437">        LOG.info()</span>
<span class="fc" id="L438">                .$(&quot;import complete [importId=&quot;).$hexPadded(importId)</span>
<span class="fc" id="L439">                .$(&quot;, file=`&quot;).$(inputFilePath).$('`')</span>
<span class="fc" id="L440">                .$(&quot;', time=&quot;).$((endMs - startMs) / 1000).$(&quot;s&quot;).I$();</span>
<span class="fc" id="L441">    }</span>

    public void setMinChunkSize(int minChunkSize) {
<span class="fc" id="L444">        this.minChunkSize = minChunkSize;</span>
<span class="fc" id="L445">    }</span>

    public void setStatusReporter(final PhaseStatusReporter reporter) {
<span class="fc" id="L448">        this.statusReporter = reporter;</span>
<span class="fc" id="L449">    }</span>

    public void updateImportStatus(byte status, long rowsHandled, long rowsImported, long errors) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">        if (this.statusReporter != null) {</span>
<span class="fc" id="L453">            this.statusReporter.report(TextImportTask.NO_PHASE, status, null, rowsHandled, rowsImported, errors);</span>
        }
<span class="fc" id="L455">    }</span>

    public void updatePhaseStatus(byte phase, byte status, @Nullable final CharSequence msg) {
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (this.statusReporter != null) {</span>
<span class="fc" id="L459">            this.statusReporter.report(phase, status, msg, Numbers.LONG_NaN, Numbers.LONG_NaN, phaseErrors);</span>
        }
<span class="fc" id="L461">    }</span>

    private void attachPartitions(TableWriter writer) throws TextImportException {
<span class="fc" id="L464">        phasePrologue(TextImportTask.PHASE_ATTACH_PARTITIONS);</span>

        // Go descending, attaching last partition is more expensive than others
<span class="fc bfc" id="L467" title="All 2 branches covered.">        for (int i = partitions.size() - 1; i &gt; -1; i--) {</span>
<span class="fc" id="L468">            PartitionInfo partition = partitions.getQuick(i);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            if (partition.importedRows == 0) {</span>
<span class="fc" id="L470">                continue;</span>
            }

<span class="fc" id="L473">            final CharSequence partitionDirName = partition.name;</span>
            try {
<span class="fc" id="L475">                final long timestamp = PartitionBy.parsePartitionDirName(partitionDirName, partitionBy);</span>
<span class="fc" id="L476">                writer.attachPartition(timestamp, partition.importedRows);</span>
<span class="fc" id="L477">            } catch (CairoException e) {</span>
<span class="fc" id="L478">                throw TextImportException.instance(</span>
                                TextImportTask.PHASE_ATTACH_PARTITIONS, &quot;could not attach [partition='&quot;)
<span class="fc" id="L480">                        .put(partitionDirName).put(&quot;', msg=&quot;)</span>
<span class="fc" id="L481">                        .put('[').put(e.getErrno()).put(&quot;] &quot;).put(e.getFlyweightMessage()).put(']');</span>
<span class="fc" id="L482">            }</span>
        }

<span class="fc" id="L485">        phaseEpilogue(TextImportTask.PHASE_ATTACH_PARTITIONS);</span>
<span class="fc" id="L486">    }</span>

    private void cleanUp(TableWriter writer) {
<span class="pc bpc" id="L489" title="1 of 4 branches missed.">        if (targetTableStatus == TableUtils.TABLE_EXISTS &amp;&amp; writer != null) {</span>
<span class="fc" id="L490">            writer.truncate();</span>
        }
<span class="fc" id="L492">    }</span>

    private void cleanUp() {
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (tableToken != null) {</span>
<span class="fc" id="L496">            cairoEngine.unlockTableName(tableToken);</span>
        }
<span class="fc bfc" id="L498" title="All 4 branches covered.">        if (targetTableStatus == TableUtils.TABLE_DOES_NOT_EXIST &amp;&amp; targetTableCreated) {</span>
<span class="fc" id="L499">            cairoEngine.drop(securityContext, tmpPath, tableToken);</span>
        }
<span class="fc" id="L501">    }</span>

    private int collect(int queuedCount, Consumer&lt;TextImportTask&gt; consumer) {
<span class="fc" id="L504">        int collectedCount = 0;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">        while (collectedCount &lt; queuedCount) {</span>
<span class="fc" id="L506">            final long seq = collectSeq.next();</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (seq &gt; -1) {</span>
<span class="fc" id="L508">                TextImportTask task = queue.get(seq);</span>
<span class="fc" id="L509">                consumer.accept(task);</span>
<span class="fc" id="L510">                task.clear();</span>
<span class="fc" id="L511">                collectSeq.done(seq);</span>
<span class="fc" id="L512">                collectedCount += 1;</span>
<span class="fc" id="L513">            } else {</span>
<span class="fc" id="L514">                stealWork();</span>
            }
<span class="fc" id="L516">        }</span>
<span class="fc" id="L517">        return collectedCount;</span>
    }

    private void collectChunkStats(final TextImportTask task) {
<span class="fc" id="L521">        updateStatus(task);</span>
<span class="fc" id="L522">        final TextImportTask.PhaseBoundaryCheck phaseBoundaryCheck = task.getCountQuotesPhase();</span>
<span class="fc" id="L523">        final int chunkOffset = 5 * task.getChunkIndex();</span>
<span class="fc" id="L524">        chunkStats.set(chunkOffset, phaseBoundaryCheck.getQuoteCount());</span>
<span class="fc" id="L525">        chunkStats.set(chunkOffset + 1, phaseBoundaryCheck.getNewLineCountEven());</span>
<span class="fc" id="L526">        chunkStats.set(chunkOffset + 2, phaseBoundaryCheck.getNewLineCountOdd());</span>
<span class="fc" id="L527">        chunkStats.set(chunkOffset + 3, phaseBoundaryCheck.getNewLineOffsetEven());</span>
<span class="fc" id="L528">        chunkStats.set(chunkOffset + 4, phaseBoundaryCheck.getNewLineOffsetOdd());</span>
<span class="fc" id="L529">    }</span>

    private void collectDataImportStats(final TextImportTask task) {
<span class="fc" id="L532">        updateStatus(task);</span>

<span class="fc" id="L534">        final TextImportTask.PhasePartitionImport phase = task.getImportPartitionDataPhase();</span>
<span class="fc" id="L535">        LongList rows = phase.getImportedRows();</span>

<span class="fc bfc" id="L537" title="All 2 branches covered.">        for (int i = 0, n = rows.size(); i &lt; n; i += 2) {</span>
<span class="fc" id="L538">            partitions.get((int) rows.get(i)).importedRows = rows.get(i + 1);</span>
        }
<span class="fc" id="L540">        rowsHandled += phase.getRowsHandled();</span>
<span class="fc" id="L541">        rowsImported += phase.getRowsImported();</span>
<span class="fc" id="L542">        phaseErrors += phase.getErrors();</span>
<span class="fc" id="L543">        errors += phase.getErrors();</span>
<span class="fc" id="L544">    }</span>

    private void collectIndexStats(final TextImportTask task) {
<span class="fc" id="L547">        updateStatus(task);</span>
<span class="fc" id="L548">        final TextImportTask.PhaseIndexing phaseIndexing = task.getBuildPartitionIndexPhase();</span>
<span class="fc" id="L549">        final LongList keys = phaseIndexing.getPartitionKeysAndSizes();</span>
<span class="fc" id="L550">        this.partitionKeysAndSizes.add(keys);</span>
<span class="fc" id="L551">        this.linesIndexed += phaseIndexing.getLineCount();</span>
<span class="fc" id="L552">        this.phaseErrors += phaseIndexing.getErrorCount();</span>
<span class="fc" id="L553">        this.errors += phaseIndexing.getErrorCount();</span>
<span class="fc" id="L554">    }</span>

    private void collectStub(final TextImportTask task) {
<span class="fc" id="L557">        updateStatus(task);</span>
<span class="fc" id="L558">    }</span>

    private void createWorkDir() {
        // First, create the work root dir, if it doesn't exist.
<span class="fc" id="L562">        Path workDirPath = tmpPath.of(inputWorkRoot).slash$();</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (!ff.exists(workDirPath)) {</span>
<span class="fc" id="L564">            int result = ff.mkdir(workDirPath, configuration.getMkDirMode());</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">            if (result != 0) {</span>
<span class="fc" id="L566">                throw CairoException.critical(ff.errno()).put(&quot;could not create import work root directory [path='&quot;).put(workDirPath).put(&quot;']&quot;);</span>
            }
        }

        // Next, remove and recreate the per-table sub-dir.
<span class="fc" id="L571">        removeWorkDir();</span>
<span class="fc" id="L572">        workDirPath = tmpPath.of(importRoot).slash$();</span>
<span class="fc" id="L573">        int result = ff.mkdir(workDirPath, configuration.getMkDirMode());</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if (result != 0) {</span>
<span class="fc" id="L575">            throw CairoException.critical(ff.errno()).put(&quot;could not create temporary import work directory [path='&quot;).put(workDirPath).put(&quot;']&quot;);</span>
        }

<span class="fc" id="L578">        createdWorkDir = true;</span>
<span class="fc" id="L579">        LOG.info().$(&quot;temporary import directory [path='&quot;).$(workDirPath).I$();</span>
<span class="fc" id="L580">    }</span>

    private long getCurrentTimeMs() {
<span class="fc" id="L583">        return configuration.getMillisecondClock().getTicks();</span>
    }

    private int getTaskCount() {
<span class="fc" id="L587">        return taskDistribution.size() / 3;</span>
    }

    private boolean isOneOfMainDirectories(CharSequence p) {
<span class="fc" id="L591">        String path = normalize(p);</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">        if (path == null) {</span>
<span class="nc" id="L593">            return false;</span>
        }

<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        return path.equals(normalize(configuration.getConfRoot())) ||</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">                path.equals(normalize(configuration.getRoot())) ||</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">                path.equals(normalize(configuration.getDbDirectory())) ||</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">                path.equals(normalize(configuration.getSnapshotRoot())) ||</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">                path.equals(normalize(configuration.getBackupRoot()));</span>
    }

    private void logTypeError(int i, int type) {
<span class="fc" id="L604">        LOG.info()</span>
<span class="fc" id="L605">                .$(&quot;mis-detected [table=&quot;).$(tableName)</span>
<span class="fc" id="L606">                .$(&quot;, column=&quot;).$(i)</span>
<span class="fc" id="L607">                .$(&quot;, type=&quot;).$(ColumnType.nameOf(type))</span>
<span class="fc" id="L608">                .$(&quot;, workerCount=&quot;).$(workerCount)</span>
<span class="fc" id="L609">                .I$();</span>
<span class="fc" id="L610">    }</span>

    private void movePartitions() {
<span class="fc" id="L613">        phasePrologue(TextImportTask.PHASE_MOVE_PARTITIONS);</span>
<span class="fc" id="L614">        final int taskCount = getTaskCount();</span>

        try {
<span class="fc bfc" id="L617" title="All 2 branches covered.">            for (int i = 0; i &lt; taskCount; i++) {</span>
<span class="fc" id="L618">                int index = taskDistribution.getQuick(i * 3);</span>
<span class="fc" id="L619">                int lo = taskDistribution.getQuick(i * 3 + 1);</span>
<span class="fc" id="L620">                int hi = taskDistribution.getQuick(i * 3 + 2);</span>

<span class="fc" id="L622">                final Path srcPath = localImportJob.getTmpPath1().of(importRoot).concat(tableName).put('_').put(index);</span>
<span class="fc" id="L623">                final Path dstPath = localImportJob.getTmpPath2().of(configuration.getRoot()).concat(tableToken);</span>

<span class="fc" id="L625">                final int srcPlen = srcPath.length();</span>
<span class="fc" id="L626">                final int dstPlen = dstPath.length();</span>

<span class="pc bpc" id="L628" title="1 of 2 branches missed.">                if (!ff.exists(dstPath.slash$())) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                    if (ff.mkdirs(dstPath, configuration.getMkDirMode()) != 0) {</span>
<span class="nc" id="L630">                        throw TextException.$(&quot;could not create partition directory [path='&quot;).put(dstPath).put(&quot;', errno=&quot;).put(ff.errno()).put(']');</span>
                    }
                }

<span class="fc bfc" id="L634" title="All 2 branches covered.">                for (int j = lo; j &lt; hi; j++) {</span>
<span class="fc" id="L635">                    PartitionInfo partition = partitions.get(j);</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">                    if (partition.importedRows == 0) {</span>
<span class="fc" id="L637">                        continue;</span>
                    }
<span class="fc" id="L639">                    final CharSequence partitionName = partition.name;</span>

<span class="fc" id="L641">                    srcPath.trimTo(srcPlen).concat(partitionName);</span>
<span class="fc" id="L642">                    dstPath.trimTo(dstPlen).concat(partitionName).put(configuration.getAttachPartitionSuffix());</span>

<span class="fc" id="L644">                    int res = ff.rename(srcPath.slash$(), dstPath.slash$());</span>

<span class="fc bfc" id="L646" title="All 2 branches covered.">                    if (res == Files.FILES_RENAME_ERR_EXDEV) {</span>
<span class="fc" id="L647">                        LOG.info().$(srcPath).$(&quot; and &quot;).$(dstPath).$(&quot; are not on the same mounted filesystem. Partitions will be copied.&quot;).$();</span>

<span class="fc bfc" id="L649" title="All 2 branches covered.">                        if (ff.mkdirs(dstPath, configuration.getMkDirMode()) != 0) {</span>
<span class="fc" id="L650">                            throw TextException.$(&quot;could not create partition directory [path='&quot;).put(dstPath).put(&quot;', errno=&quot;).put(ff.errno()).put(']');</span>
                        }

<span class="fc" id="L653">                        ff.iterateDir(srcPath, (long name, int type) -&gt; {</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">                            if (type == Files.DT_FILE) {</span>
<span class="fc" id="L655">                                srcPath.trimTo(srcPlen).concat(partitionName).concat(name).$();</span>
<span class="fc" id="L656">                                dstPath.trimTo(dstPlen).concat(partitionName).put(configuration.getAttachPartitionSuffix()).concat(name).$();</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">                                if (ff.copy(srcPath, dstPath) &lt; 0) {</span>
<span class="fc" id="L658">                                    throw TextException.$(&quot;could not copy partition file [to='&quot;).put(dstPath).put(&quot;', errno=&quot;).put(ff.errno()).put(']');</span>
                                }
                            }
<span class="fc" id="L661">                        });</span>
<span class="fc" id="L662">                        srcPath.parent();</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">                    } else if (res != Files.FILES_RENAME_OK) {</span>
<span class="fc" id="L664">                        throw CairoException.critical(ff.errno()).put(&quot;could not copy partition file [to=&quot;).put(dstPath).put(']');</span>
                    }
                }
            }
<span class="fc" id="L668">        } catch (CairoException e) {</span>
<span class="fc" id="L669">            throw TextImportException.instance(TextImportTask.PHASE_MOVE_PARTITIONS, e.getFlyweightMessage(), e.getErrno());</span>
<span class="fc" id="L670">        } catch (TextException e) {</span>
<span class="fc" id="L671">            throw TextImportException.instance(TextImportTask.PHASE_MOVE_PARTITIONS, e.getFlyweightMessage());</span>
<span class="fc" id="L672">        }</span>
<span class="fc" id="L673">        phaseEpilogue(TextImportTask.PHASE_MOVE_PARTITIONS);</span>
<span class="fc" id="L674">    }</span>

    private String normalize(CharSequence c) {
        try {
<span class="fc bfc" id="L678" title="All 2 branches covered.">            if (c == null) {</span>
<span class="fc" id="L679">                return null;</span>
            }
<span class="fc" id="L681">            return new File(c.toString()).getCanonicalPath().replace(File.separatorChar, '/');</span>
<span class="nc" id="L682">        } catch (IOException e) {</span>
<span class="nc" id="L683">            LOG.error().$(&quot;could not normalize [path='&quot;).$(c).$(&quot;', message=&quot;).$(e.getMessage()).I$();</span>
<span class="nc" id="L684">            return null;</span>
        }
    }

    private TableWriter openWriterAndOverrideImportMetadata(
            ObjList&lt;CharSequence&gt; names,
            ObjList&lt;TypeAdapter&gt; types,
            CairoSecurityContext cairoSecurityContext,
            TypeManager typeManager
    ) throws TextException {
<span class="fc" id="L694">        TableWriter writer = cairoEngine.getWriter(cairoSecurityContext, tableToken, LOCK_REASON);</span>
<span class="fc" id="L695">        RecordMetadata metadata = writer.getMetadata();</span>

<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (metadata.getColumnCount() &lt; types.size()) {</span>
<span class="fc" id="L698">            writer.close();</span>
<span class="fc" id="L699">            throw TextException.$(&quot;column count mismatch [textColumnCount=&quot;).put(types.size())</span>
<span class="fc" id="L700">                    .put(&quot;, tableColumnCount=&quot;).put(metadata.getColumnCount())</span>
<span class="fc" id="L701">                    .put(&quot;, table=&quot;).put(tableName)</span>
<span class="fc" id="L702">                    .put(']');</span>
        }

        //remap index is only needed to adjust names and types
        //workers will import data into temp tables without remapping
<span class="fc" id="L707">        IntList remapIndex = new IntList();</span>
<span class="fc" id="L708">        remapIndex.ensureCapacity(types.size());</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        for (int i = 0, n = types.size(); i &lt; n; i++) {</span>

<span class="fc" id="L711">            final int columnIndex = metadata.getColumnIndexQuiet(names.getQuick(i));</span>
<span class="fc bfc" id="L712" title="All 4 branches covered.">            final int idx = (columnIndex &gt; -1 &amp;&amp; columnIndex != i) ? columnIndex : i; // check for strict match ?</span>
<span class="fc" id="L713">            remapIndex.set(i, idx);</span>

<span class="fc" id="L715">            final int columnType = metadata.getColumnType(idx);</span>
<span class="fc" id="L716">            final TypeAdapter detectedAdapter = types.getQuick(i);</span>
<span class="fc" id="L717">            final int detectedType = detectedAdapter.getType();</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (detectedType != columnType) {</span>
                // when DATE type is mis-detected as STRING we
                // would not have either date format nor locale to
                // use when populating this field
<span class="fc bfc" id="L722" title="All 4 branches covered.">                switch (ColumnType.tagOf(columnType)) {</span>
                    case ColumnType.DATE:
<span class="fc" id="L724">                        logTypeError(i, detectedType);</span>
<span class="fc" id="L725">                        types.setQuick(i, BadDateAdapter.INSTANCE);</span>
<span class="fc" id="L726">                        break;</span>
                    case ColumnType.TIMESTAMP:
<span class="fc bfc" id="L728" title="All 2 branches covered.">                        if (detectedAdapter instanceof TimestampCompatibleAdapter) {</span>
<span class="fc" id="L729">                            types.setQuick(i, otherToTimestampAdapterPool.next().of((TimestampCompatibleAdapter) detectedAdapter));</span>
                        } else {
<span class="fc" id="L731">                            logTypeError(i, detectedType);</span>
<span class="fc" id="L732">                            types.setQuick(i, BadTimestampAdapter.INSTANCE);</span>
                        }
<span class="fc" id="L734">                        break;</span>
                    case ColumnType.BINARY:
<span class="fc" id="L736">                        writer.close();</span>
<span class="fc" id="L737">                        throw TextException.$(&quot;cannot import text into BINARY column [index=&quot;).put(i).put(']');</span>
                    default:
<span class="fc" id="L739">                        types.setQuick(i, typeManager.getTypeAdapter(columnType));</span>
                        break;
                }
            }
        }

        //at this point we've to use target table columns names otherwise partition attach could fail on metadata differences
        //(if header names or synthetic names are different from table's)
<span class="fc bfc" id="L747" title="All 2 branches covered.">        for (int i = 0, n = remapIndex.size(); i &lt; n; i++) {</span>
<span class="fc" id="L748">            names.set(i, metadata.getColumnName(remapIndex.get(i)));</span>
        }

        //add table columns missing in input file
<span class="fc bfc" id="L752" title="All 2 branches covered.">        if (names.size() &lt; metadata.getColumnCount()) {</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">            for (int i = 0, n = metadata.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L754">                boolean unused = true;</span>

<span class="fc bfc" id="L756" title="All 2 branches covered.">                for (int r = 0, rn = remapIndex.size(); r &lt; rn; r++) {</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                    if (remapIndex.get(r) == i) {</span>
<span class="fc" id="L758">                        unused = false;</span>
<span class="fc" id="L759">                        break;</span>
                    }
                }

<span class="fc bfc" id="L763" title="All 2 branches covered.">                if (unused) {</span>
<span class="fc" id="L764">                    names.add(metadata.getColumnName(i));</span>
<span class="fc" id="L765">                    types.add(typeManager.getTypeAdapter(metadata.getColumnType(i)));</span>
                }
            }
        }

<span class="fc" id="L770">        return writer;</span>
    }

    private void phaseBuildSymbolIndex(TableWriter writer) throws TextImportException {
<span class="fc" id="L774">        phasePrologue(TextImportTask.PHASE_BUILD_SYMBOL_INDEX);</span>

<span class="fc" id="L776">        final RecordMetadata metadata = writer.getMetadata();</span>
<span class="fc" id="L777">        final int columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L778">        final int tmpTableCount = getTaskCount();</span>

<span class="fc" id="L780">        boolean isAnyIndexed = false;</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L782">            isAnyIndexed |= metadata.isColumnIndexed(i);</span>
        }

<span class="fc bfc" id="L785" title="All 2 branches covered.">        if (isAnyIndexed) {</span>
<span class="fc" id="L786">            int queuedCount = 0;</span>
<span class="fc" id="L787">            int collectedCount = 0;</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">            for (int t = 0; t &lt; tmpTableCount; ++t) {</span>
                while (true) {
<span class="fc" id="L790">                    final long seq = pubSeq.next();</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">                    if (seq &gt; -1) {</span>
<span class="fc" id="L792">                        final TextImportTask task = queue.get(seq);</span>
<span class="fc" id="L793">                        task.setChunkIndex(t);</span>
<span class="fc" id="L794">                        task.setCircuitBreaker(circuitBreaker);</span>
                        // this task will create its own copy of TableWriter to build indexes concurrently?
<span class="fc" id="L796">                        task.ofPhaseBuildSymbolIndex(cairoEngine, targetTableStructure, importRoot, t, metadata);</span>
<span class="fc" id="L797">                        pubSeq.done(seq);</span>
<span class="fc" id="L798">                        queuedCount++;</span>
<span class="fc" id="L799">                        break;</span>
                    } else {
<span class="fc" id="L801">                        collectedCount += collect(queuedCount - collectedCount, checkStatusRef);</span>
                    }
<span class="fc" id="L803">                }</span>
            }

<span class="fc" id="L806">            collectedCount += collect(queuedCount - collectedCount, checkStatusRef);</span>
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">            assert collectedCount == queuedCount;</span>
        }

<span class="fc" id="L810">        phaseEpilogue(TextImportTask.PHASE_BUILD_SYMBOL_INDEX);</span>
<span class="fc" id="L811">    }</span>

    private void phaseEpilogue(byte phase) {
<span class="fc" id="L814">        throwErrorIfNotOk();</span>
<span class="fc" id="L815">        long endMs = getCurrentTimeMs();</span>
<span class="fc" id="L816">        LOG.info()</span>
<span class="fc" id="L817">                .$(&quot;finished [importId=&quot;).$hexPadded(importId)</span>
<span class="fc" id="L818">                .$(&quot;, phase=&quot;).$(TextImportTask.getPhaseName(phase))</span>
<span class="fc" id="L819">                .$(&quot;, file=`&quot;).$(inputFilePath)</span>
<span class="fc" id="L820">                .$(&quot;`, duration=&quot;).$((endMs - startMs) / 1000).$('s')</span>
<span class="fc" id="L821">                .$(&quot;, errors=&quot;).$(phaseErrors)</span>
<span class="fc" id="L822">                .I$();</span>
<span class="fc" id="L823">        updatePhaseStatus(phase, TextImportTask.STATUS_FINISHED, null);</span>
<span class="fc" id="L824">    }</span>

    private void phasePartitionImport() throws TextImportException {
<span class="fc bfc" id="L827" title="All 2 branches covered.">        if (partitions.size() == 0) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (linesIndexed &gt; 0) {</span>
<span class="fc" id="L829">                throw TextImportException.instance(TextImportTask.PHASE_PARTITION_IMPORT,</span>
                        &quot;All rows were skipped. Possible reasons: timestamp format mismatch or rows exceed maximum line length (65k).&quot;);
            } else {
<span class="fc" id="L832">                throw TextImportException.instance(TextImportTask.PHASE_PARTITION_IMPORT,</span>
                        &quot;No rows in input file to import.&quot;);
            }
        }

<span class="fc" id="L837">        phasePrologue(TextImportTask.PHASE_PARTITION_IMPORT);</span>
<span class="fc" id="L838">        this.taskCount = assignPartitions(partitions, workerCount);</span>

<span class="fc" id="L840">        int queuedCount = 0;</span>
<span class="fc" id="L841">        int collectedCount = 0;</span>
<span class="fc" id="L842">        taskDistribution.clear();</span>

<span class="fc bfc" id="L844" title="All 2 branches covered.">        for (int i = 0; i &lt; taskCount; ++i) {</span>
<span class="fc" id="L845">            int lo = 0;</span>
<span class="pc bpc" id="L846" title="1 of 4 branches missed.">            while (lo &lt; partitions.size() &amp;&amp; partitions.getQuick(lo).taskId != i) {</span>
<span class="fc" id="L847">                lo++;</span>
            }
<span class="fc" id="L849">            int hi = lo + 1;</span>
<span class="fc bfc" id="L850" title="All 4 branches covered.">            while (hi &lt; partitions.size() &amp;&amp; partitions.getQuick(hi).taskId == i) {</span>
<span class="fc" id="L851">                hi++;</span>
            }

            while (true) {
<span class="fc" id="L855">                final long seq = pubSeq.next();</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">                if (seq &gt; -1) {</span>
<span class="fc" id="L857">                    final TextImportTask task = queue.get(seq);</span>
<span class="fc" id="L858">                    task.setChunkIndex(i);</span>
<span class="fc" id="L859">                    task.setCircuitBreaker(circuitBreaker);</span>
<span class="fc" id="L860">                    task.ofPhasePartitionImport(</span>
                            cairoEngine,
                            targetTableStructure,
<span class="fc" id="L863">                            textMetadataDetector.getColumnTypes(),</span>
                            atomicity,
                            columnDelimiter,
                            importRoot,
                            inputFileName,
                            i,
                            lo,
                            hi,
                            partitions
                    );
<span class="fc" id="L873">                    pubSeq.done(seq);</span>
<span class="fc" id="L874">                    queuedCount++;</span>
<span class="fc" id="L875">                    break;</span>
                } else {
<span class="fc" id="L877">                    collectedCount += collect(queuedCount - collectedCount, collectDataImportStatsRef);</span>
                }
<span class="fc" id="L879">            }</span>

<span class="fc" id="L881">            taskDistribution.add(i);</span>
<span class="fc" id="L882">            taskDistribution.add(lo);</span>
<span class="fc" id="L883">            taskDistribution.add(hi);</span>
        }

<span class="fc" id="L886">        collectedCount += collect(queuedCount - collectedCount, collectDataImportStatsRef);</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">        assert collectedCount == queuedCount;</span>

<span class="fc" id="L889">        phaseEpilogue(TextImportTask.PHASE_PARTITION_IMPORT);</span>
<span class="fc" id="L890">    }</span>

    private void phasePrologue(byte phase) {
<span class="fc" id="L893">        phaseErrors = 0;</span>
<span class="fc" id="L894">        LOG.info()</span>
<span class="fc" id="L895">                .$(&quot;started [importId=&quot;).$hexPadded(importId)</span>
<span class="fc" id="L896">                .$(&quot;, phase=&quot;).$(TextImportTask.getPhaseName(phase))</span>
<span class="fc" id="L897">                .$(&quot;, file=`&quot;).$(inputFilePath)</span>
<span class="fc" id="L898">                .$(&quot;`, workerCount=&quot;).$(workerCount).I$();</span>
<span class="fc" id="L899">        updatePhaseStatus(phase, TextImportTask.STATUS_STARTED, null);</span>
<span class="fc" id="L900">        startMs = getCurrentTimeMs();</span>
<span class="fc" id="L901">    }</span>

    private void phaseSymbolTableMerge(final TableWriter writer) throws TextImportException {
<span class="fc" id="L904">        phasePrologue(TextImportTask.PHASE_SYMBOL_TABLE_MERGE);</span>
<span class="fc" id="L905">        final int tmpTableCount = getTaskCount();</span>

<span class="fc" id="L907">        int queuedCount = 0;</span>
<span class="fc" id="L908">        int collectedCount = 0;</span>
<span class="fc" id="L909">        TableRecordMetadata tableMetadata = writer.getMetadata();</span>

<span class="fc bfc" id="L911" title="All 2 branches covered.">        for (int columnIndex = 0, size = tableMetadata.getColumnCount(); columnIndex &lt; size; columnIndex++) {</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">            if (ColumnType.isSymbol(tableMetadata.getColumnType(columnIndex))) {</span>
<span class="fc" id="L913">                final CharSequence symbolColumnName = tableMetadata.getColumnName(columnIndex);</span>
<span class="fc" id="L914">                int tmpTableSymbolColumnIndex = targetTableStructure.getSymbolColumnIndex(symbolColumnName);</span>

                while (true) {
<span class="fc" id="L917">                    final long seq = pubSeq.next();</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">                    if (seq &gt; -1) {</span>
<span class="fc" id="L919">                        final TextImportTask task = queue.get(seq);</span>
<span class="fc" id="L920">                        task.setChunkIndex(columnIndex);</span>
<span class="fc" id="L921">                        task.ofPhaseSymbolTableMerge(</span>
                                configuration,
                                importRoot,
                                writer,
                                tableToken,
                                symbolColumnName,
                                columnIndex,
                                tmpTableSymbolColumnIndex,
                                tmpTableCount,
                                partitionBy
                        );
<span class="fc" id="L932">                        pubSeq.done(seq);</span>
<span class="fc" id="L933">                        queuedCount++;</span>
<span class="fc" id="L934">                        break;</span>
                    } else {
<span class="fc" id="L936">                        collectedCount += collect(queuedCount - collectedCount, collectStubRef);</span>
                    }
<span class="fc" id="L938">                }</span>
            }
        }

<span class="fc" id="L942">        collectedCount += collect(queuedCount - collectedCount, collectStubRef);</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">        assert collectedCount == queuedCount;</span>

<span class="fc" id="L945">        phaseEpilogue(TextImportTask.PHASE_SYMBOL_TABLE_MERGE);</span>
<span class="fc" id="L946">    }</span>

    private void phaseUpdateSymbolKeys(final TableWriter writer) throws TextImportException {
<span class="fc" id="L949">        phasePrologue(TextImportTask.PHASE_UPDATE_SYMBOL_KEYS);</span>

<span class="fc" id="L951">        final int tmpTableCount = getTaskCount();</span>
<span class="fc" id="L952">        int queuedCount = 0;</span>
<span class="fc" id="L953">        int collectedCount = 0;</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">        for (int t = 0; t &lt; tmpTableCount; ++t) {</span>

<span class="fc" id="L956">            tmpPath.of(importRoot).concat(tableToken.getTableName()).put('_').put(t);</span>

<span class="fc" id="L958">            try (TxReader txFile = new TxReader(ff).ofRO(tmpPath.concat(TXN_FILE_NAME).$(), partitionBy)) {</span>
<span class="fc" id="L959">                txFile.unsafeLoadAll();</span>
<span class="fc" id="L960">                final int partitionCount = txFile.getPartitionCount();</span>

<span class="fc bfc" id="L962" title="All 2 branches covered.">                for (int p = 0; p &lt; partitionCount; p++) {</span>
<span class="fc" id="L963">                    final long partitionSize = txFile.getPartitionSize(p);</span>
<span class="fc" id="L964">                    final long partitionTimestamp = txFile.getPartitionTimestamp(p);</span>
<span class="fc" id="L965">                    TableRecordMetadata tableMetadata = writer.getMetadata();</span>
<span class="fc" id="L966">                    int symbolColumnIndex = 0;</span>

<span class="pc bpc" id="L968" title="1 of 2 branches missed.">                    if (partitionSize == 0) {</span>
<span class="nc" id="L969">                        continue;</span>
                    }

<span class="fc bfc" id="L972" title="All 2 branches covered.">                    for (int c = 0, size = tableMetadata.getColumnCount(); c &lt; size; c++) {</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">                        if (ColumnType.isSymbol(tableMetadata.getColumnType(c))) {</span>
<span class="fc" id="L974">                            final CharSequence symbolColumnName = tableMetadata.getColumnName(c);</span>
<span class="fc" id="L975">                            final int symbolCount = txFile.getSymbolValueCount(symbolColumnIndex++);</span>

                            while (true) {
<span class="fc" id="L978">                                final long seq = pubSeq.next();</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">                                if (seq &gt; -1) {</span>
<span class="fc" id="L980">                                    final TextImportTask task = queue.get(seq);</span>
<span class="fc" id="L981">                                    task.setChunkIndex(t);</span>
<span class="fc" id="L982">                                    task.setCircuitBreaker(circuitBreaker);</span>
<span class="fc" id="L983">                                    task.ofPhaseUpdateSymbolKeys(</span>
                                            cairoEngine,
                                            targetTableStructure,
                                            t,
                                            partitionSize,
                                            partitionTimestamp,
                                            importRoot,
                                            symbolColumnName,
                                            symbolCount
                                    );
<span class="fc" id="L993">                                    pubSeq.done(seq);</span>
<span class="fc" id="L994">                                    queuedCount++;</span>
<span class="fc" id="L995">                                    break;</span>
                                } else {
<span class="fc" id="L997">                                    collectedCount += collect(queuedCount - collectedCount, collectStubRef);</span>
                                }
<span class="fc" id="L999">                            }</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L1006">        collectedCount += collect(queuedCount - collectedCount, collectStubRef);</span>
<span class="pc bpc" id="L1007" title="1 of 2 branches missed.">        assert collectedCount == queuedCount;</span>

<span class="fc" id="L1009">        phaseEpilogue(TextImportTask.PHASE_UPDATE_SYMBOL_KEYS);</span>
<span class="fc" id="L1010">    }</span>

    private void processChunkStats(long fileLength, int chunks) {
<span class="fc" id="L1013">        long quotes = chunkStats.get(0);</span>

<span class="fc" id="L1015">        indexChunkStats.setPos(0);</span>
        //set first chunk offset and line number
<span class="fc" id="L1017">        indexChunkStats.add(0);</span>
<span class="fc" id="L1018">        indexChunkStats.add(0);</span>

        long lines;
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">        long totalLines = chunks &gt; 0 ? chunkStats.get(1) + 1 : 1;</span>

<span class="fc bfc" id="L1023" title="All 2 branches covered.">        for (int i = 1; i &lt; chunks; i++) {</span>
            long startPos;
<span class="fc bfc" id="L1025" title="All 2 branches covered.">            if ((quotes &amp; 1) == 1) { // if number of quotes is odd then use odd starter</span>
<span class="fc" id="L1026">                startPos = chunkStats.get(5 * i + 4);</span>
<span class="fc" id="L1027">                lines = chunkStats.get(5 * i + 2);</span>
            } else {
<span class="fc" id="L1029">                startPos = chunkStats.get(5 * i + 3);</span>
<span class="fc" id="L1030">                lines = chunkStats.get(5 * i + 1);</span>
            }

            //if whole chunk  belongs to huge quoted string or contains one very long line
            //then it should be ignored here and merged with previous chunk
<span class="fc bfc" id="L1035" title="All 2 branches covered.">            if (startPos &gt; -1) {</span>
<span class="fc" id="L1036">                indexChunkStats.add(startPos);</span>
<span class="fc" id="L1037">                indexChunkStats.add(totalLines);</span>
            }

<span class="fc" id="L1040">            quotes += chunkStats.get(5 * i);</span>
<span class="fc" id="L1041">            totalLines += lines;</span>
        }

<span class="fc bfc" id="L1044" title="All 2 branches covered.">        if (indexChunkStats.get(indexChunkStats.size() - 2) &lt; fileLength) {</span>
<span class="fc" id="L1045">            indexChunkStats.add(fileLength);</span>
<span class="fc" id="L1046">            indexChunkStats.add(totalLines);//doesn't matter</span>
        }
<span class="fc" id="L1048">    }</span>

    private void processIndexStats() {
<span class="fc" id="L1051">        LongHashSet set = new LongHashSet();</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">        for (int i = 0, n = partitionKeysAndSizes.size(); i &lt; n; i += 2) {</span>
<span class="fc" id="L1053">            set.add(partitionKeysAndSizes.get(i));</span>
        }

<span class="fc" id="L1056">        LongList distinctKeys = new LongList();</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">        for (int i = 0, n = set.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1058">            distinctKeys.add(set.get(i));</span>
        }
<span class="fc" id="L1060">        distinctKeys.sort();</span>

<span class="fc" id="L1062">        LongList totalSizes = new LongList();</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">        for (int i = 0, n = distinctKeys.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1064">            long key = distinctKeys.getQuick(i);</span>
<span class="fc" id="L1065">            long size = 0;</span>

<span class="fc bfc" id="L1067" title="All 2 branches covered.">            for (int j = 0, m = partitionKeysAndSizes.size(); j &lt; m; j += 2) {</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">                if (partitionKeysAndSizes.getQuick(j) == key) {</span>
<span class="fc" id="L1069">                    size += partitionKeysAndSizes.get(j + 1);</span>
                }
            }

<span class="fc" id="L1073">            totalSizes.add(size);</span>
        }

<span class="fc" id="L1076">        DateFormat dirFormat = PartitionBy.getPartitionDirFormatMethod(partitionBy);</span>

<span class="fc bfc" id="L1078" title="All 2 branches covered.">        for (int i = 0, n = distinctKeys.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1079">            long key = distinctKeys.getQuick(i);</span>
<span class="fc" id="L1080">            long size = totalSizes.getQuick(i);</span>

<span class="fc" id="L1082">            partitionNameSink.clear();</span>
<span class="fc" id="L1083">            dirFormat.format(distinctKeys.get(i), null, null, partitionNameSink);</span>
<span class="fc" id="L1084">            String dirName = partitionNameSink.toString();</span>

<span class="fc" id="L1086">            partitions.add(new PartitionInfo(key, dirName, size));</span>
        }
<span class="fc" id="L1088">    }</span>

    private void removeWorkDir() {
<span class="fc" id="L1091">        Path workDirPath = tmpPath.of(importRoot).$();</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">        if (ff.exists(workDirPath)) {</span>
<span class="fc bfc" id="L1093" title="All 2 branches covered.">            if (isOneOfMainDirectories(importRoot)) {</span>
<span class="fc" id="L1094">                throw TextException.$(&quot;could not remove import work directory because it points to one of main directories [path='&quot;).put(workDirPath).put(&quot;'] .&quot;);</span>
            }

<span class="fc" id="L1097">            LOG.info().$(&quot;removing import work directory [path='&quot;).$(workDirPath).$(&quot;']&quot;).$();</span>

<span class="fc" id="L1099">            int errno = ff.rmdir(workDirPath);</span>
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">            if (errno != 0) {</span>
<span class="nc" id="L1101">                throw TextException.$(&quot;could not remove import work directory [path='&quot;).put(workDirPath).put(&quot;', errno=&quot;).put(errno).put(']');</span>
            }
        }
<span class="fc" id="L1104">    }</span>

    private void stealWork() {
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        if (localImportJob.run(0, Job.RUNNING_STATUS)) {</span>
<span class="fc" id="L1108">            return;</span>
        }
<span class="fc" id="L1110">        Os.pause();</span>
<span class="fc" id="L1111">    }</span>

    private void throwErrorIfNotOk() {
<span class="fc bfc" id="L1114" title="All 2 branches covered.">        if (status == TextImportTask.STATUS_FAILED) {</span>
<span class="fc" id="L1115">            throw TextImportException.instance(phase, &quot;import failed [phase=&quot;)</span>
<span class="fc" id="L1116">                    .put(TextImportTask.getPhaseName(phase))</span>
<span class="fc" id="L1117">                    .put(&quot;, msg=`&quot;).put(errorMessage).put(&quot;`]&quot;);</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">        } else if (status == TextImportTask.STATUS_CANCELLED) {</span>
<span class="fc" id="L1119">            TextImportException ex = TextImportException.instance(phase, &quot;import cancelled [phase=&quot;)</span>
<span class="fc" id="L1120">                    .put(TextImportTask.getPhaseName(phase))</span>
<span class="fc" id="L1121">                    .put(&quot;, msg=`&quot;).put(errorMessage).put(&quot;`]&quot;);</span>
<span class="fc" id="L1122">            ex.setCancelled(true);</span>
<span class="fc" id="L1123">            throw ex;</span>
        }
<span class="fc" id="L1125">    }</span>

    private void updateStatus(final TextImportTask task) {
<span class="pc bpc" id="L1128" title="1 of 4 branches missed.">        boolean cancelledOrFailed = status == TextImportTask.STATUS_FAILED || status == TextImportTask.STATUS_CANCELLED;</span>
<span class="fc bfc" id="L1129" title="All 6 branches covered.">        if (!cancelledOrFailed &amp;&amp; (task.isFailed() || task.isCancelled())) {</span>
<span class="fc" id="L1130">            status = task.getStatus();</span>
<span class="fc" id="L1131">            phase = task.getPhase();</span>
<span class="fc" id="L1132">            errorMessage = task.getErrorMessage();</span>
        }
<span class="fc" id="L1134">    }</span>

    //load balances existing partitions between given number of workers using partition sizes
    //returns number of tasks
    static int assignPartitions(ObjList&lt;PartitionInfo&gt; partitions, int workerCount) {
<span class="fc" id="L1139">        partitions.sort((p1, p2) -&gt; Long.compare(p2.bytes, p1.bytes));</span>
<span class="fc" id="L1140">        long[] workerSums = new long[workerCount];</span>

<span class="fc bfc" id="L1142" title="All 2 branches covered.">        for (int i = 0, n = partitions.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1143">            int minIdx = -1;</span>
<span class="fc" id="L1144">            long minSum = Long.MAX_VALUE;</span>

<span class="fc bfc" id="L1146" title="All 2 branches covered.">            for (int j = 0; j &lt; workerCount; j++) {</span>
<span class="fc bfc" id="L1147" title="All 2 branches covered.">                if (workerSums[j] == 0) {</span>
<span class="fc" id="L1148">                    minIdx = j;</span>
<span class="fc" id="L1149">                    break;</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">                } else if (workerSums[j] &lt; minSum) {</span>
<span class="fc" id="L1151">                    minSum = workerSums[j];</span>
<span class="fc" id="L1152">                    minIdx = j;</span>
                }
            }

<span class="fc" id="L1156">            workerSums[minIdx] += partitions.getQuick(i).bytes;</span>
<span class="fc" id="L1157">            partitions.getQuick(i).taskId = minIdx;</span>
        }

<span class="fc" id="L1160">        partitions.sort((p1, p2) -&gt; {</span>
<span class="fc" id="L1161">            long workerIdDiff = p1.taskId - p2.taskId;</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">            if (workerIdDiff != 0) {</span>
<span class="fc" id="L1163">                return (int) workerIdDiff;</span>
            }

<span class="fc" id="L1166">            return Long.compare(p1.key, p2.key);</span>
        });

<span class="fc" id="L1169">        int taskIds = 0;</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">        for (int i = 0, n = workerSums.length; i &lt; n; i++) {</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">            if (workerSums[i] != 0) {</span>
<span class="fc" id="L1172">                taskIds++;</span>
            }
        }

<span class="fc" id="L1176">        return taskIds;</span>
    }

    TableWriter parseStructure(int fd) throws TextImportException {
<span class="fc" id="L1180">        phasePrologue(TextImportTask.PHASE_ANALYZE_FILE_STRUCTURE);</span>
<span class="fc" id="L1181">        final CairoConfiguration configuration = cairoEngine.getConfiguration();</span>

<span class="fc" id="L1183">        final int textAnalysisMaxLines = configuration.getTextConfiguration().getTextAnalysisMaxLines();</span>
<span class="fc" id="L1184">        int len = configuration.getSqlCopyBufferSize();</span>
<span class="fc" id="L1185">        long buf = Unsafe.malloc(len, MemoryTag.NATIVE_IMPORT);</span>

<span class="fc" id="L1187">        try (TextLexerWrapper tlw = new TextLexerWrapper(configuration.getTextConfiguration())) {</span>
<span class="fc" id="L1188">            long n = ff.read(fd, buf, len, 0);</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">            if (n &gt; 0) {</span>
<span class="fc bfc" id="L1190" title="All 2 branches covered.">                if (columnDelimiter &lt; 0) {</span>
<span class="fc" id="L1191">                    columnDelimiter = textDelimiterScanner.scan(buf, buf + n);</span>
                }

<span class="fc" id="L1194">                AbstractTextLexer lexer = tlw.getLexer(columnDelimiter);</span>
<span class="fc" id="L1195">                lexer.setSkipLinesWithExtraValues(false);</span>

<span class="fc" id="L1197">                final ObjList&lt;CharSequence&gt; names = new ObjList&lt;&gt;();</span>
<span class="fc" id="L1198">                final ObjList&lt;TypeAdapter&gt; types = new ObjList&lt;&gt;();</span>
<span class="fc bfc" id="L1199" title="All 4 branches covered.">                if (timestampColumn != null &amp;&amp; timestampAdapter != null) {</span>
<span class="fc" id="L1200">                    names.add(timestampColumn);</span>
<span class="fc" id="L1201">                    types.add(timestampAdapter);</span>
                }

<span class="fc" id="L1204">                textMetadataDetector.of(tableName, names, types, forceHeader);</span>
<span class="fc" id="L1205">                lexer.parse(buf, buf + n, textAnalysisMaxLines, textMetadataDetector);</span>
<span class="fc" id="L1206">                textMetadataDetector.evaluateResults(lexer.getLineCount(), lexer.getErrorCount());</span>
<span class="fc" id="L1207">                forceHeader = textMetadataDetector.isHeader();</span>

<span class="fc" id="L1209">                TableWriter writer = prepareTable(</span>
                        securityContext,
<span class="fc" id="L1211">                        textMetadataDetector.getColumnNames(),</span>
<span class="fc" id="L1212">                        textMetadataDetector.getColumnTypes(),</span>
                        inputFilePath,
                        typeManager
                );
<span class="fc" id="L1216">                phaseEpilogue(TextImportTask.PHASE_ANALYZE_FILE_STRUCTURE);</span>
<span class="fc" id="L1217">                return writer;</span>
            } else {
<span class="fc" id="L1219">                throw TextException.$(&quot;could not read from file '&quot;).put(inputFilePath).put(&quot;' to analyze structure&quot;);</span>
            }
<span class="fc" id="L1221">        } catch (CairoException e) {</span>
<span class="fc" id="L1222">            throw TextImportException.instance(TextImportTask.PHASE_ANALYZE_FILE_STRUCTURE, e.getFlyweightMessage(), e.getErrno());</span>
<span class="fc" id="L1223">        } catch (TextException e) {</span>
<span class="fc" id="L1224">            throw TextImportException.instance(TextImportTask.PHASE_ANALYZE_FILE_STRUCTURE, e.getFlyweightMessage());</span>
        } finally {
<span class="fc" id="L1226">            Unsafe.free(buf, len, MemoryTag.NATIVE_IMPORT);</span>
        }
    }

    //returns list with N chunk boundaries
    LongList phaseBoundaryCheck(long fileLength) throws TextImportException {
<span class="fc" id="L1232">        phasePrologue(TextImportTask.PHASE_BOUNDARY_CHECK);</span>
<span class="pc bpc" id="L1233" title="2 of 4 branches missed.">        assert (workerCount &gt; 0 &amp;&amp; minChunkSize &gt; 0);</span>

<span class="fc bfc" id="L1235" title="All 2 branches covered.">        if (workerCount == 1) {</span>
<span class="fc" id="L1236">            indexChunkStats.setPos(0);</span>
<span class="fc" id="L1237">            indexChunkStats.add(0);</span>
<span class="fc" id="L1238">            indexChunkStats.add(0);</span>
<span class="fc" id="L1239">            indexChunkStats.add(fileLength);</span>
<span class="fc" id="L1240">            indexChunkStats.add(0);</span>
<span class="fc" id="L1241">            phaseEpilogue(TextImportTask.PHASE_BOUNDARY_CHECK);</span>
<span class="fc" id="L1242">            return indexChunkStats;</span>
        }

<span class="fc" id="L1245">        long chunkSize = Math.max(minChunkSize, (fileLength + workerCount - 1) / workerCount);</span>
<span class="fc" id="L1246">        final int chunks = (int) Math.max((fileLength + chunkSize - 1) / chunkSize, 1);</span>

<span class="fc" id="L1248">        int queuedCount = 0;</span>
<span class="fc" id="L1249">        int collectedCount = 0;</span>

<span class="fc" id="L1251">        chunkStats.setPos(chunks * 5);</span>
<span class="fc" id="L1252">        chunkStats.zero(0);</span>

<span class="fc bfc" id="L1254" title="All 2 branches covered.">        for (int i = 0; i &lt; chunks; i++) {</span>
<span class="fc" id="L1255">            final long chunkLo = i * chunkSize;</span>
<span class="fc" id="L1256">            final long chunkHi = Long.min(chunkLo + chunkSize, fileLength);</span>
            while (true) {
<span class="fc" id="L1258">                final long seq = pubSeq.next();</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">                if (seq &gt; -1) {</span>
<span class="fc" id="L1260">                    final TextImportTask task = queue.get(seq);</span>
<span class="fc" id="L1261">                    task.setChunkIndex(i);</span>
<span class="fc" id="L1262">                    task.setCircuitBreaker(circuitBreaker);</span>
<span class="fc" id="L1263">                    task.ofPhaseBoundaryCheck(ff, inputFilePath, chunkLo, chunkHi);</span>
<span class="fc" id="L1264">                    pubSeq.done(seq);</span>
<span class="fc" id="L1265">                    queuedCount++;</span>
<span class="fc" id="L1266">                    break;</span>
                } else {
<span class="fc" id="L1268">                    collectedCount += collect(queuedCount - collectedCount, collectChunkStatsRef);</span>
                }
<span class="fc" id="L1270">            }</span>
        }

<span class="fc" id="L1273">        collectedCount += collect(queuedCount - collectedCount, collectChunkStatsRef);</span>
<span class="pc bpc" id="L1274" title="1 of 2 branches missed.">        assert collectedCount == queuedCount;</span>

<span class="fc" id="L1276">        processChunkStats(fileLength, chunks);</span>
<span class="fc" id="L1277">        phaseEpilogue(TextImportTask.PHASE_BOUNDARY_CHECK);</span>
<span class="fc" id="L1278">        return indexChunkStats;</span>
    }

    void phaseIndexing() throws TextException {
<span class="fc" id="L1282">        phasePrologue(TextImportTask.PHASE_INDEXING);</span>

<span class="fc" id="L1284">        int queuedCount = 0;</span>
<span class="fc" id="L1285">        int collectedCount = 0;</span>

<span class="fc" id="L1287">        createWorkDir();</span>

<span class="fc" id="L1289">        boolean forceHeader = this.forceHeader;</span>
<span class="fc bfc" id="L1290" title="All 2 branches covered.">        for (int i = 0, n = indexChunkStats.size() - 2; i &lt; n; i += 2) {</span>
<span class="fc" id="L1291">            int colIdx = i / 2;</span>

<span class="fc" id="L1293">            final long chunkLo = indexChunkStats.get(i);</span>
<span class="fc" id="L1294">            final long lineNumber = indexChunkStats.get(i + 1);</span>
<span class="fc" id="L1295">            final long chunkHi = indexChunkStats.get(i + 2);</span>

            while (true) {
<span class="fc" id="L1298">                final long seq = pubSeq.next();</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">                if (seq &gt; -1) {</span>
<span class="fc" id="L1300">                    final TextImportTask task = queue.get(seq);</span>
<span class="fc" id="L1301">                    task.setChunkIndex(colIdx);</span>
<span class="fc" id="L1302">                    task.setCircuitBreaker(circuitBreaker);</span>
<span class="fc" id="L1303">                    task.ofPhaseIndexing(</span>
                            chunkLo,
                            chunkHi,
                            lineNumber,
                            colIdx,
                            inputFileName,
                            importRoot,
                            partitionBy,
                            columnDelimiter,
                            timestampIndex,
                            timestampAdapter,
                            forceHeader,
                            atomicity
                    );
<span class="fc bfc" id="L1317" title="All 2 branches covered.">                    if (forceHeader) {</span>
<span class="fc" id="L1318">                        forceHeader = false;</span>
                    }
<span class="fc" id="L1320">                    pubSeq.done(seq);</span>
<span class="fc" id="L1321">                    queuedCount++;</span>
<span class="fc" id="L1322">                    break;</span>
                } else {
<span class="fc" id="L1324">                    collectedCount += collect(queuedCount - collectedCount, collectIndexStatsRef);</span>
                }
<span class="fc" id="L1326">            }</span>
        }

<span class="fc" id="L1329">        collectedCount += collect(queuedCount - collectedCount, collectIndexStatsRef);</span>
<span class="pc bpc" id="L1330" title="1 of 2 branches missed.">        assert collectedCount == queuedCount;</span>
<span class="fc" id="L1331">        processIndexStats();</span>

<span class="fc" id="L1333">        phaseEpilogue(TextImportTask.PHASE_INDEXING);</span>
<span class="fc" id="L1334">    }</span>

    TableWriter prepareTable(
            CairoSecurityContext cairoSecurityContext,
            ObjList&lt;CharSequence&gt; names,
            ObjList&lt;TypeAdapter&gt; types,
            Path path,
            TypeManager typeManager
    ) throws TextException {
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">        if (types.size() == 0) {</span>
<span class="nc" id="L1344">            throw CairoException.nonCritical().put(&quot;cannot determine text structure&quot;);</span>
        }
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        if (partitionBy == PartitionBy.NONE) {</span>
<span class="fc" id="L1347">            throw CairoException.nonCritical().put(&quot;partition strategy for parallel import cannot be NONE&quot;);</span>
        }

<span class="fc bfc" id="L1350" title="All 2 branches covered.">        if (partitionBy &lt; 0) {</span>
<span class="fc" id="L1351">            partitionBy = PartitionBy.NONE;</span>
        }

<span class="pc bpc" id="L1354" title="1 of 4 branches missed.">        if (timestampIndex == -1 &amp;&amp; timestampColumn != null) {</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">            for (int i = 0, n = names.size(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">                if (Chars.equalsIgnoreCase(names.get(i), timestampColumn)) {</span>
<span class="fc" id="L1357">                    timestampIndex = i;</span>
<span class="fc" id="L1358">                    break;</span>
                }
            }
        }

<span class="fc" id="L1363">        TableWriter writer = null;</span>

        try {
<span class="fc" id="L1366">            targetTableStatus = cairoEngine.getStatus(cairoSecurityContext, path, tableToken);</span>
<span class="pc bpc" id="L1367" title="1 of 3 branches missed.">            switch (targetTableStatus) {</span>
                case TableUtils.TABLE_DOES_NOT_EXIST:
<span class="fc bfc" id="L1369" title="All 2 branches covered.">                    if (partitionBy == PartitionBy.NONE) {</span>
<span class="fc" id="L1370">                        throw TextException.$(&quot;partition by unit must be set when importing to new table&quot;);</span>
                    }
<span class="fc bfc" id="L1372" title="All 2 branches covered.">                    if (timestampColumn == null) {</span>
<span class="fc" id="L1373">                        throw TextException.$(&quot;timestamp column must be set when importing to new table&quot;);</span>
                    }
<span class="fc bfc" id="L1375" title="All 2 branches covered.">                    if (timestampIndex == -1) {</span>
<span class="fc" id="L1376">                        throw TextException.$(&quot;timestamp column '&quot;).put(timestampColumn).put(&quot;' not found in file header&quot;);</span>
                    }

<span class="fc" id="L1379">                    validate(names, types, null, NO_INDEX);</span>
<span class="fc" id="L1380">                    targetTableStructure.of(tableName, names, types, timestampIndex, partitionBy);</span>

<span class="fc" id="L1382">                    createTable(</span>
                            ff,
<span class="fc" id="L1384">                            configuration.getMkDirMode(),</span>
<span class="fc" id="L1385">                            configuration.getRoot(),</span>
<span class="fc" id="L1386">                            tableToken.getDirName(),</span>
<span class="fc" id="L1387">                            targetTableStructure.getTableName(),</span>
                            targetTableStructure,
<span class="fc" id="L1389">                            tableToken.getTableId()</span>
                    );
<span class="fc" id="L1391">                    cairoEngine.registerTableToken(tableToken);</span>
<span class="fc" id="L1392">                    targetTableCreated = true;</span>
<span class="fc" id="L1393">                    writer = cairoEngine.getWriter(cairoSecurityContext, tableToken, LOCK_REASON);</span>
<span class="fc" id="L1394">                    partitionBy = writer.getPartitionBy();</span>
<span class="fc" id="L1395">                    break;</span>
                case TableUtils.TABLE_EXISTS:
<span class="fc" id="L1397">                    writer = openWriterAndOverrideImportMetadata(names, types, cairoSecurityContext, typeManager);</span>

<span class="fc bfc" id="L1399" title="All 2 branches covered.">                    if (writer.getRowCount() &gt; 0) {</span>
<span class="fc" id="L1400">                        throw TextException.$(&quot;target table must be empty [table=&quot;).put(tableName).put(']');</span>
                    }

<span class="fc" id="L1403">                    CharSequence designatedTimestampColumnName = writer.getDesignatedTimestampColumnName();</span>
<span class="fc" id="L1404">                    int designatedTimestampIndex = writer.getMetadata().getTimestampIndex();</span>
<span class="fc bfc" id="L1405" title="All 4 branches covered.">                    if (PartitionBy.isPartitioned(partitionBy) &amp;&amp; partitionBy != writer.getPartitionBy()) {</span>
<span class="fc" id="L1406">                        throw TextException.$(&quot;declared partition by unit doesn't match table's&quot;);</span>
                    }
<span class="fc" id="L1408">                    partitionBy = writer.getPartitionBy();</span>
<span class="fc bfc" id="L1409" title="All 2 branches covered.">                    if (!PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L1410">                        throw TextException.$(&quot;target table is not partitioned&quot;);</span>
                    }
<span class="fc" id="L1412">                    validate(names, types, designatedTimestampColumnName, designatedTimestampIndex);</span>
<span class="fc" id="L1413">                    targetTableStructure.of(tableName, names, types, timestampIndex, partitionBy);</span>
<span class="fc" id="L1414">                    break;</span>
                default:
<span class="nc" id="L1416">                    throw TextException.$(&quot;name is reserved [table=&quot;).put(tableName).put(']');</span>
            }

<span class="fc" id="L1419">            inputFilePath.of(inputRoot).concat(inputFileName).$();//getStatus might override it</span>
<span class="fc" id="L1420">            targetTableStructure.setIgnoreColumnIndexedFlag(true);</span>

<span class="pc bpc" id="L1422" title="1 of 4 branches missed.">            if (timestampAdapter == null &amp;&amp; ColumnType.isTimestamp(types.getQuick(timestampIndex).getType())) {</span>
<span class="fc" id="L1423">                timestampAdapter = (TimestampAdapter) types.getQuick(timestampIndex);</span>
            }
<span class="fc" id="L1425">        } catch (Throwable t) {</span>
<span class="fc bfc" id="L1426" title="All 2 branches covered.">            if (writer != null) {</span>
<span class="fc" id="L1427">                writer.close();</span>
            }

<span class="fc" id="L1430">            throw t;</span>
<span class="fc" id="L1431">        }</span>

<span class="fc" id="L1433">        return writer;</span>
    }

    void validate(ObjList&lt;CharSequence&gt; names,
                  ObjList&lt;TypeAdapter&gt; types,
                  CharSequence designatedTimestampColumnName,
                  int designatedTimestampIndex) throws TextException {
<span class="pc bpc" id="L1440" title="1 of 4 branches missed.">        if (timestampColumn == null &amp;&amp; designatedTimestampColumnName == null) {</span>
<span class="nc" id="L1441">            timestampIndex = NO_INDEX;</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">        } else if (timestampColumn != null) {</span>
<span class="fc" id="L1443">            timestampIndex = names.indexOf(timestampColumn);</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">            if (timestampIndex == NO_INDEX) {</span>
<span class="fc" id="L1445">                throw TextException.$(&quot;invalid timestamp column [name='&quot;).put(timestampColumn).put(&quot;']&quot;);</span>
            }
        } else {
<span class="fc" id="L1448">            timestampIndex = names.indexOf(designatedTimestampColumnName);</span>
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">            if (timestampIndex == NO_INDEX) {</span>
                // columns in the imported file may not have headers, then use writer timestamp index
<span class="nc" id="L1451">                timestampIndex = designatedTimestampIndex;</span>
            }
        }

<span class="pc bpc" id="L1455" title="1 of 2 branches missed.">        if (timestampIndex != NO_INDEX) {</span>
<span class="fc" id="L1456">            final TypeAdapter timestampAdapter = types.getQuick(timestampIndex);</span>
<span class="fc" id="L1457">            final int typeTag = ColumnType.tagOf(timestampAdapter.getType());</span>
<span class="pc bpc" id="L1458" title="1 of 6 branches missed.">            if ((typeTag != ColumnType.LONG &amp;&amp; typeTag != ColumnType.TIMESTAMP) || timestampAdapter == BadTimestampAdapter.INSTANCE) {</span>
<span class="fc" id="L1459">                throw TextException.$(&quot;column is not a timestamp [no=&quot;).put(timestampIndex)</span>
<span class="fc" id="L1460">                        .put(&quot;, name='&quot;).put(timestampColumn).put(&quot;']&quot;);</span>
            }
        }
<span class="fc" id="L1463">    }</span>

    @FunctionalInterface
    public interface PhaseStatusReporter {
        void report(byte phase, byte status, @Nullable final CharSequence msg, long rowsHandled, long rowsImported, long errors);
    }

    static class PartitionInfo {
        final long bytes;
        final long key;
        final CharSequence name;
        long importedRows;//used to detect partitions that need skipping (because e.g. no data was imported for them)
        int taskId;//assigned worker/task id

<span class="fc" id="L1477">        PartitionInfo(long key, CharSequence name, long bytes) {</span>
<span class="fc" id="L1478">            this.key = key;</span>
<span class="fc" id="L1479">            this.name = name;</span>
<span class="fc" id="L1480">            this.bytes = bytes;</span>
<span class="fc" id="L1481">        }</span>

<span class="fc" id="L1483">        PartitionInfo(long key, CharSequence name, long bytes, int taskId) {</span>
<span class="fc" id="L1484">            this.key = key;</span>
<span class="fc" id="L1485">            this.name = name;</span>
<span class="fc" id="L1486">            this.bytes = bytes;</span>
<span class="fc" id="L1487">            this.taskId = taskId;</span>
<span class="fc" id="L1488">        }</span>

        @Override
        public boolean equals(Object o) {
<span class="pc bpc" id="L1492" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L1493" title="2 of 4 branches missed.">            if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L1494">            PartitionInfo that = (PartitionInfo) o;</span>
<span class="pc bpc" id="L1495" title="5 of 10 branches missed.">            return key == that.key &amp;&amp; bytes == that.bytes &amp;&amp; taskId == that.taskId &amp;&amp; importedRows == that.importedRows &amp;&amp; name.equals(that.name);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L1500">            return &quot;PartitionInfo{&quot; +</span>
                    &quot;key=&quot; + key +
                    &quot;, name=&quot; + name +
                    &quot;, bytes=&quot; + bytes +
                    &quot;, taskId=&quot; + taskId +
                    &quot;, importedRows=&quot; + importedRows +
                    '}';
        }
    }

    public static class TableStructureAdapter implements TableStructure {
<span class="fc" id="L1511">        private final LongList columnBits = new LongList();</span>
        private final CairoConfiguration configuration;
        private ObjList&lt;CharSequence&gt; columnNames;
        private boolean ignoreColumnIndexedFlag;
        private int partitionBy;
        private CharSequence tableName;
        private int timestampColumnIndex;

<span class="fc" id="L1519">        public TableStructureAdapter(CairoConfiguration configuration) {</span>
<span class="fc" id="L1520">            this.configuration = configuration;</span>
<span class="fc" id="L1521">        }</span>

        @Override
        public int getColumnCount() {
<span class="fc" id="L1525">            return columnNames.size();</span>
        }

        @Override
        public CharSequence getColumnName(int columnIndex) {
<span class="fc" id="L1530">            return columnNames.getQuick(columnIndex);</span>
        }

        @Override
        public int getColumnType(int columnIndex) {
<span class="fc" id="L1535">            return Numbers.decodeLowInt(columnBits.getQuick(columnIndex));</span>
        }

        @Override
        public int getIndexBlockCapacity(int columnIndex) {
<span class="fc" id="L1540">            return configuration.getIndexValueBlockSize();</span>
        }

        @Override
        public int getMaxUncommittedRows() {
<span class="fc" id="L1545">            return configuration.getMaxUncommittedRows();</span>
        }

        @Override
        public long getO3MaxLag() {
<span class="fc" id="L1550">            return configuration.getO3MaxLag();</span>
        }

        @Override
        public int getPartitionBy() {
<span class="fc" id="L1555">            return partitionBy;</span>
        }

        @Override
        public boolean getSymbolCacheFlag(int columnIndex) {
<span class="fc" id="L1560">            return false;</span>
        }

        @Override
        public int getSymbolCapacity(int columnIndex) {
<span class="fc" id="L1565">            return configuration.getDefaultSymbolCapacity();</span>
        }

        public int getSymbolColumnIndex(CharSequence symbolColumnName) {
<span class="fc" id="L1569">            int index = -1;</span>
<span class="pc bpc" id="L1570" title="1 of 2 branches missed.">            for (int i = 0, n = columnNames.size(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">                if (getColumnType(i) == ColumnType.SYMBOL) {</span>
<span class="fc" id="L1572">                    index++;</span>
                }

<span class="fc bfc" id="L1575" title="All 2 branches covered.">                if (symbolColumnName.equals(columnNames.get(i))) {</span>
<span class="fc" id="L1576">                    return index;</span>
                }
            }

<span class="nc" id="L1580">            return -1;</span>
        }

        @Override
        public CharSequence getTableName() {
<span class="fc" id="L1585">            return tableName;</span>
        }

        @Override
        public int getTimestampIndex() {
<span class="fc" id="L1590">            return timestampColumnIndex;</span>
        }

        @Override
        public boolean isIndexed(int columnIndex) {
<span class="pc bpc" id="L1595" title="1 of 4 branches missed.">            return !ignoreColumnIndexedFlag &amp;&amp; Numbers.decodeHighInt(columnBits.getQuick(columnIndex)) != 0;</span>
        }

        @Override
        public boolean isSequential(int columnIndex) {
<span class="fc" id="L1600">            return false;</span>
        }

        @Override
        public boolean isWalEnabled() {
<span class="pc bpc" id="L1605" title="1 of 4 branches missed.">            return configuration.getWalEnabledDefault() &amp;&amp; PartitionBy.isPartitioned(partitionBy);</span>
        }

        public void of(final CharSequence tableName,
                       final ObjList&lt;CharSequence&gt; names,
                       final ObjList&lt;TypeAdapter&gt; types,
                       final int timestampColumnIndex,
                       final int partitionBy
        ) {
<span class="fc" id="L1614">            this.tableName = tableName;</span>
<span class="fc" id="L1615">            this.columnNames = names;</span>
<span class="fc" id="L1616">            this.ignoreColumnIndexedFlag = false;</span>

<span class="fc" id="L1618">            this.columnBits.clear();</span>
<span class="fc bfc" id="L1619" title="All 2 branches covered.">            for (int i = 0, size = types.size(); i &lt; size; i++) {</span>
<span class="fc" id="L1620">                final TypeAdapter adapter = types.getQuick(i);</span>
<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">                this.columnBits.add(Numbers.encodeLowHighInts(adapter.getType(), adapter.isIndexed() ? 1 : 0));</span>
            }

<span class="fc" id="L1624">            this.timestampColumnIndex = timestampColumnIndex;</span>
<span class="fc" id="L1625">            this.partitionBy = partitionBy;</span>
<span class="fc" id="L1626">        }</span>

        public void setIgnoreColumnIndexedFlag(boolean flag) {
<span class="fc" id="L1629">            this.ignoreColumnIndexedFlag = flag;</span>
<span class="fc" id="L1630">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>