<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TextImportTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.text</a> &gt; <span class="el_source">TextImportTask.java</span></div><h1>TextImportTask.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.text;

import io.questdb.cairo.*;
import io.questdb.cairo.sql.ExecutionCircuitBreaker;
import io.questdb.cairo.sql.RecordMetadata;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryCMARW;
import io.questdb.cutlass.text.types.TimestampAdapter;
import io.questdb.cutlass.text.types.TypeAdapter;
import io.questdb.griffin.engine.functions.columns.ColumnUtils;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.std.*;
import io.questdb.std.str.DirectByteCharSequence;
import io.questdb.std.str.DirectCharSink;
import io.questdb.std.str.Path;
import io.questdb.std.str.StringSink;
import org.jetbrains.annotations.Nullable;

import static io.questdb.cairo.TableUtils.TXN_FILE_NAME;
import static io.questdb.cutlass.text.ParallelCsvFileImporter.createTable;

<span class="fc" id="L47">public class TextImportTask {</span>

    public static final byte NO_PHASE = -1;
    public static final byte PHASE_ANALYZE_FILE_STRUCTURE = 9;
    public static final byte PHASE_ATTACH_PARTITIONS = 8;
    public static final byte PHASE_BOUNDARY_CHECK = 1;
    public static final byte PHASE_BUILD_SYMBOL_INDEX = 6;
    public static final byte PHASE_CLEANUP = 10;
    public static final byte PHASE_INDEXING = 2;
    public static final byte PHASE_MOVE_PARTITIONS = 7;
    public static final byte PHASE_PARTITION_IMPORT = 3;
    public static final byte PHASE_SETUP = 0;
    public static final byte PHASE_SYMBOL_TABLE_MERGE = 4;
    public static final byte PHASE_UPDATE_SYMBOL_KEYS = 5;
    public static final byte STATUS_CANCELLED = 3;
    public static final byte STATUS_FAILED = 2;
    public static final byte STATUS_FINISHED = 1;
    public static final byte STATUS_STARTED = 0;
<span class="fc" id="L65">    private static final Log LOG = LogFactory.getLog(TextImportTask.class);</span>
<span class="fc" id="L66">    private static final IntObjHashMap&lt;String&gt; PHASE_NAME_MAP = new IntObjHashMap&lt;&gt;();</span>
<span class="fc" id="L67">    private static final IntObjHashMap&lt;String&gt; STATUS_NAME_MAP = new IntObjHashMap&lt;&gt;();</span>

<span class="fc" id="L69">    private final PhaseBoundaryCheck phaseBoundaryCheck = new PhaseBoundaryCheck();</span>
<span class="fc" id="L70">    private final PhaseBuildSymbolIndex phaseBuildSymbolIndex = new PhaseBuildSymbolIndex();</span>
<span class="fc" id="L71">    private final PhaseIndexing phaseIndexing = new PhaseIndexing();</span>
<span class="fc" id="L72">    private final PhasePartitionImport phasePartitionImport = new PhasePartitionImport();</span>
<span class="fc" id="L73">    private final PhaseSymbolTableMerge phaseSymbolTableMerge = new PhaseSymbolTableMerge();</span>
<span class="fc" id="L74">    private final PhaseUpdateSymbolKeys phaseUpdateSymbolKeys = new PhaseUpdateSymbolKeys();</span>
    private int chunkIndex;
    private @Nullable ExecutionCircuitBreaker circuitBreaker;
    private @Nullable CharSequence errorMessage;
    private byte phase;
    private byte status;

    public static String getPhaseName(byte phase) {
<span class="fc" id="L82">        return PHASE_NAME_MAP.get(phase);</span>
    }

    public static String getStatusName(byte status) {
<span class="fc" id="L86">        return STATUS_NAME_MAP.get(status);</span>
    }

    public void clear() {
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (phase == PHASE_BOUNDARY_CHECK) {</span>
<span class="fc" id="L91">            phaseBoundaryCheck.clear();</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        } else if (phase == PHASE_INDEXING) {</span>
<span class="fc" id="L93">            phaseIndexing.clear();</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        } else if (phase == PHASE_PARTITION_IMPORT) {</span>
<span class="fc" id="L95">            phasePartitionImport.clear();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        } else if (phase == PHASE_SYMBOL_TABLE_MERGE) {</span>
<span class="fc" id="L97">            phaseSymbolTableMerge.clear();</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        } else if (phase == PHASE_UPDATE_SYMBOL_KEYS) {</span>
<span class="fc" id="L99">            phaseUpdateSymbolKeys.clear();</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        } else if (phase == PHASE_BUILD_SYMBOL_INDEX) {</span>
<span class="fc" id="L101">            phaseBuildSymbolIndex.clear();</span>
        } else {
<span class="nc" id="L103">            throw TextException.$(&quot;Unexpected phase &quot;).put(phase);</span>
        }
<span class="fc" id="L105">    }</span>

    public PhaseIndexing getBuildPartitionIndexPhase() {
<span class="fc" id="L108">        return phaseIndexing;</span>
    }

    public int getChunkIndex() {
<span class="fc" id="L112">        return chunkIndex;</span>
    }

    public PhaseBoundaryCheck getCountQuotesPhase() {
<span class="fc" id="L116">        return phaseBoundaryCheck;</span>
    }

    public @Nullable CharSequence getErrorMessage() {
<span class="fc" id="L120">        return errorMessage;</span>
    }

    public PhasePartitionImport getImportPartitionDataPhase() {
<span class="fc" id="L124">        return phasePartitionImport;</span>
    }

    public byte getPhase() {
<span class="fc" id="L128">        return phase;</span>
    }

    public byte getStatus() {
<span class="fc" id="L132">        return status;</span>
    }

    public boolean isCancelled() {
<span class="fc bfc" id="L136" title="All 2 branches covered.">        return this.status == STATUS_CANCELLED;</span>
    }

    public boolean isFailed() {
<span class="fc bfc" id="L140" title="All 2 branches covered.">        return this.status == STATUS_FAILED;</span>
    }

    public void ofPhaseBoundaryCheck(final FilesFacade ff, Path path, long chunkStart, long chunkEnd) {
<span class="fc" id="L144">        this.phase = PHASE_BOUNDARY_CHECK;</span>
<span class="fc" id="L145">        this.phaseBoundaryCheck.of(ff, path, chunkStart, chunkEnd);</span>
<span class="fc" id="L146">    }</span>

    public void ofPhaseBuildSymbolIndex(
            CairoEngine cairoEngine,
            TableStructure tableStructure,
            CharSequence root,
            int index,
            RecordMetadata metadata
    ) {
<span class="fc" id="L155">        this.phase = PHASE_BUILD_SYMBOL_INDEX;</span>
<span class="fc" id="L156">        this.phaseBuildSymbolIndex.of(cairoEngine, tableStructure, root, index, metadata);</span>
<span class="fc" id="L157">    }</span>

    public void ofPhaseIndexing(
            long chunkStart,
            long chunkEnd,
            long lineNumber,
            int index,
            CharSequence inputFileName,
            CharSequence importRoot,
            int partitionBy,
            byte columnDelimiter,
            int timestampIndex,
            TimestampAdapter adapter,
            boolean ignoreHeader,
            int atomicity
    ) {
<span class="fc" id="L173">        this.phase = PHASE_INDEXING;</span>
<span class="fc" id="L174">        this.phaseIndexing.of(</span>
                chunkStart,
                chunkEnd,
                lineNumber,
                index,
                inputFileName,
                importRoot,
                partitionBy,
                columnDelimiter,
                timestampIndex,
                adapter,
                ignoreHeader,
                atomicity
        );
<span class="fc" id="L188">    }</span>

    public void ofPhaseSymbolTableMerge(
            CairoConfiguration cfg,
            CharSequence importRoot,
            TableWriter writer,
            TableToken tableToken,
            CharSequence column,
            int columnIndex,
            int symbolColumnIndex,
            int tmpTableCount,
            int partitionBy
    ) {
<span class="fc" id="L201">        this.phase = PHASE_SYMBOL_TABLE_MERGE;</span>
<span class="fc" id="L202">        this.phaseSymbolTableMerge.of(</span>
                cfg,
                importRoot,
                writer,
                tableToken,
                column,
                columnIndex,
                symbolColumnIndex,
                tmpTableCount,
                partitionBy
        );
<span class="fc" id="L213">    }</span>

    public void ofPhaseUpdateSymbolKeys(
            CairoEngine cairoEngine,
            TableStructure tableStructure,
            int index,
            long partitionSize,
            long partitionTimestamp,
            CharSequence root,
            CharSequence columnName,
            int symbolCount
    ) {
<span class="fc" id="L225">        this.phase = PHASE_UPDATE_SYMBOL_KEYS;</span>
<span class="fc" id="L226">        this.phaseUpdateSymbolKeys.of(</span>
                cairoEngine,
                tableStructure,
                index,
                partitionSize,
                partitionTimestamp,
                root,
                columnName,
                symbolCount
        );
<span class="fc" id="L236">    }</span>

    public boolean run(
            TextLexerWrapper lf,
            CsvFileIndexer indexer,
            DirectCharSink utf8Sink,
            DirectLongList unmergedIndexes,
            long fileBufAddr,
            long fileBufSize,
            Path p1,
            Path p2
    ) {
        try {
<span class="fc" id="L249">            LOG.debug().$(&quot;starting [phase=&quot;).$(getPhaseName(phase)).$(&quot;,index=&quot;).$(chunkIndex).I$();</span>

<span class="fc" id="L251">            this.status = STATUS_STARTED;</span>
<span class="fc" id="L252">            this.errorMessage = null;</span>

<span class="fc" id="L254">            throwIfCancelled();</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">            if (phase == PHASE_BOUNDARY_CHECK) {</span>
<span class="fc" id="L257">                phaseBoundaryCheck.run(fileBufAddr, fileBufSize);</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            } else if (phase == PHASE_INDEXING) {</span>
<span class="fc" id="L259">                phaseIndexing.run(indexer, fileBufAddr, fileBufSize);</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            } else if (phase == PHASE_PARTITION_IMPORT) {</span>
<span class="fc" id="L261">                phasePartitionImport.run(lf, fileBufAddr, fileBufSize, utf8Sink, unmergedIndexes, p1, p2);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            } else if (phase == PHASE_SYMBOL_TABLE_MERGE) {</span>
<span class="fc" id="L263">                phaseSymbolTableMerge.run(p1);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            } else if (phase == PHASE_UPDATE_SYMBOL_KEYS) {</span>
<span class="fc" id="L265">                phaseUpdateSymbolKeys.run(p1);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            } else if (phase == PHASE_BUILD_SYMBOL_INDEX) {</span>
<span class="fc" id="L267">                phaseBuildSymbolIndex.run();</span>
            } else {
<span class="nc" id="L269">                throw TextException.$(&quot;Unexpected phase &quot;).put(phase);</span>
            }

<span class="fc" id="L272">            LOG.debug().$(&quot;finished [phase=&quot;).$(getPhaseName(phase)).$(&quot;,index=&quot;).$(chunkIndex).I$();</span>
<span class="fc" id="L273">        } catch (TextImportException e) {</span>
<span class="fc" id="L274">            this.status = STATUS_CANCELLED;</span>
<span class="fc" id="L275">            this.errorMessage = e.getMessage();</span>
<span class="fc" id="L276">            LOG.error().$(&quot;Import cancelled [phase=&quot;).$(getPhaseName(e.getPhase())).I$();</span>
<span class="fc" id="L277">            return false;</span>
<span class="fc" id="L278">        } catch (Throwable t) {</span>
<span class="fc" id="L279">            LOG.error()</span>
<span class="fc" id="L280">                    .$(&quot;could not import [phase=&quot;).$(getPhaseName(phase))</span>
<span class="fc" id="L281">                    .$(&quot;, ex=&quot;).$(t)</span>
<span class="fc" id="L282">                    .I$();</span>
<span class="fc" id="L283">            this.status = STATUS_FAILED;</span>
<span class="fc" id="L284">            this.errorMessage = t.getMessage();</span>
<span class="fc" id="L285">            return false;</span>
<span class="fc" id="L286">        }</span>

<span class="fc" id="L288">        return true;</span>
    }

    public void setChunkIndex(int chunkIndex) {
<span class="fc" id="L292">        this.chunkIndex = chunkIndex;</span>
<span class="fc" id="L293">    }</span>

    public void setCircuitBreaker(@Nullable ExecutionCircuitBreaker circuitBreaker) {
<span class="fc" id="L296">        this.circuitBreaker = circuitBreaker;</span>
<span class="fc" id="L297">    }</span>

    private TextImportException getCancelException() {
<span class="fc" id="L300">        TextImportException ex = TextImportException.instance(this.phase, &quot;Cancelled&quot;);</span>
<span class="fc" id="L301">        ex.setCancelled(true);</span>
<span class="fc" id="L302">        return ex;</span>
    }

    private void throwIfCancelled() throws TextImportException {
<span class="fc bfc" id="L306" title="All 4 branches covered.">        if (circuitBreaker != null &amp;&amp; circuitBreaker.checkIfTripped()) {</span>
<span class="fc" id="L307">            throw getCancelException();</span>
        }
<span class="fc" id="L309">    }</span>

    void ofPhasePartitionImport(
            CairoEngine cairoEngine,
            TableStructure targetTableStructure,
            ObjList&lt;TypeAdapter&gt; types,
            int atomicity,
            byte columnDelimiter,
            CharSequence importRoot,
            CharSequence inputFileName,
            int index,
            int lo,
            int hi,
            final ObjList&lt;ParallelCsvFileImporter.PartitionInfo&gt; partitions
    ) {
<span class="fc" id="L324">        this.phase = PHASE_PARTITION_IMPORT;</span>
<span class="fc" id="L325">        this.phasePartitionImport.of(</span>
                cairoEngine,
                targetTableStructure,
                types,
                atomicity,
                columnDelimiter,
                importRoot,
                inputFileName,
                index,
                lo,
                hi,
                partitions
        );
<span class="fc" id="L338">    }</span>

<span class="fc" id="L340">    public static class PhaseBoundaryCheck {</span>
        private long chunkEnd;
        private long chunkStart;
        private FilesFacade ff;
        private long newLineCountEven;
        private long newLineCountOdd;
        private long newLineOffsetEven;
        private long newLineOffsetOdd;
        private Path path;
        private long quoteCount;

        public void clear() {
<span class="fc" id="L352">            this.ff = null;</span>
<span class="fc" id="L353">            this.path = null;</span>
<span class="fc" id="L354">            this.chunkStart = -1;</span>
<span class="fc" id="L355">            this.chunkEnd = -1;</span>
<span class="fc" id="L356">        }</span>

        public long getNewLineCountEven() {
<span class="fc" id="L359">            return newLineCountEven;</span>
        }

        public long getNewLineCountOdd() {
<span class="fc" id="L363">            return newLineCountOdd;</span>
        }

        public long getNewLineOffsetEven() {
<span class="fc" id="L367">            return newLineOffsetEven;</span>
        }

        public long getNewLineOffsetOdd() {
<span class="fc" id="L371">            return newLineOffsetOdd;</span>
        }

        public long getQuoteCount() {
<span class="fc" id="L375">            return quoteCount;</span>
        }

        public void of(final FilesFacade ff, Path path, long chunkStart, long chunkEnd) {
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            assert ff != null;</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">            assert path != null;</span>
<span class="pc bpc" id="L381" title="2 of 4 branches missed.">            assert chunkStart &gt;= 0 &amp;&amp; chunkEnd &gt; chunkStart;</span>

<span class="fc" id="L383">            this.ff = ff;</span>
<span class="fc" id="L384">            this.path = path;</span>
<span class="fc" id="L385">            this.chunkStart = chunkStart;</span>
<span class="fc" id="L386">            this.chunkEnd = chunkEnd;</span>
<span class="fc" id="L387">        }</span>

        public void run(long fileBufPtr, long fileBufSize) throws TextException {
<span class="fc" id="L390">            long offset = chunkStart;</span>

            //output vars
<span class="fc" id="L393">            long quotes = 0;</span>
<span class="fc" id="L394">            long[] nlCount = new long[2];</span>
<span class="fc" id="L395">            long[] nlFirst = new long[]{-1, -1};</span>

            long read;
            long ptr;
            long hi;

<span class="fc" id="L401">            int fd = TableUtils.openRO(ff, path, LOG);</span>
<span class="fc" id="L402">            ff.fadvise(fd, chunkStart, chunkEnd - chunkStart, Files.POSIX_FADV_SEQUENTIAL);</span>
            try {

                do {
<span class="fc" id="L406">                    long leftToRead = Math.min(chunkEnd - offset, fileBufSize);</span>
<span class="fc" id="L407">                    read = (int) ff.read(fd, fileBufPtr, leftToRead, offset);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                    if (read &lt; 1) {</span>
<span class="fc" id="L409">                        break;</span>
                    }
<span class="fc" id="L411">                    hi = fileBufPtr + read;</span>
<span class="fc" id="L412">                    ptr = fileBufPtr;</span>

<span class="fc bfc" id="L414" title="All 2 branches covered.">                    while (ptr &lt; hi) {</span>
<span class="fc" id="L415">                        final byte c = Unsafe.getUnsafe().getByte(ptr++);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">                        if (c == '&quot;') {</span>
<span class="fc" id="L417">                            quotes++;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                        } else if (c == '\n') {</span>
<span class="fc" id="L419">                            nlCount[(int) (quotes &amp; 1)]++;</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">                            if (nlFirst[(int) (quotes &amp; 1)] == -1) {</span>
<span class="fc" id="L421">                                nlFirst[(int) (quotes &amp; 1)] = offset + (ptr - fileBufPtr);</span>
                            }
                        }
<span class="fc" id="L424">                    }</span>

<span class="fc" id="L426">                    offset += read;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">                } while (offset &lt; chunkEnd);</span>

<span class="pc bpc" id="L429" title="1 of 4 branches missed.">                if (read &lt; 0 || offset &lt; chunkEnd) {</span>
<span class="fc" id="L430">                    throw TextException</span>
<span class="fc" id="L431">                            .$(&quot;could not read import file [path='&quot;).put(path)</span>
<span class="fc" id="L432">                            .put(&quot;', offset=&quot;).put(offset)</span>
<span class="fc" id="L433">                            .put(&quot;, errno=&quot;).put(ff.errno())</span>
<span class="fc" id="L434">                            .put(']');</span>
                }
            } finally {
<span class="fc" id="L437">                ff.close(fd);</span>
            }

<span class="fc" id="L440">            this.quoteCount = quotes;</span>
<span class="fc" id="L441">            this.newLineCountEven = nlCount[0];</span>
<span class="fc" id="L442">            this.newLineCountOdd = nlCount[1];</span>
<span class="fc" id="L443">            this.newLineOffsetEven = nlFirst[0];</span>
<span class="fc" id="L444">            this.newLineOffsetOdd = nlFirst[1];</span>
<span class="fc" id="L445">        }</span>
    }

<span class="fc" id="L448">    public static class PhaseBuildSymbolIndex {</span>
<span class="fc" id="L449">        private final StringSink tableNameSink = new StringSink();</span>
        private CairoEngine cairoEngine;
        private int index;
        private RecordMetadata metadata;
        private CharSequence root;
        private TableStructure tableStructure;

        public void clear() {
<span class="fc" id="L457">            this.cairoEngine = null;</span>
<span class="fc" id="L458">            this.tableStructure = null;</span>
<span class="fc" id="L459">            this.root = null;</span>
<span class="fc" id="L460">            this.index = -1;</span>
<span class="fc" id="L461">            this.metadata = null;</span>
<span class="fc" id="L462">        }</span>

        public void of(
                CairoEngine cairoEngine,
                TableStructure tableStructure,
                CharSequence root,
                int index, RecordMetadata metadata) {
<span class="fc" id="L469">            this.cairoEngine = cairoEngine;</span>
<span class="fc" id="L470">            this.tableStructure = tableStructure;</span>
<span class="fc" id="L471">            this.root = root;</span>
<span class="fc" id="L472">            this.index = index;</span>
<span class="fc" id="L473">            this.metadata = metadata;</span>
<span class="fc" id="L474">        }</span>

        public void run() {
<span class="fc" id="L477">            final CairoConfiguration configuration = cairoEngine.getConfiguration();</span>

<span class="fc" id="L479">            tableNameSink.clear();</span>
<span class="fc" id="L480">            tableNameSink.put(tableStructure.getTableName()).put('_').put(index);</span>
<span class="fc" id="L481">            String tableName = tableNameSink.toString();</span>
<span class="fc" id="L482">            TableToken tableToken = new TableToken(tableName, tableName, (int) cairoEngine.getTableIdGenerator().getNextId(), false);</span>

<span class="fc" id="L484">            final int columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L485">            try (TableWriter w = new TableWriter(configuration,</span>
                    tableToken,
<span class="fc" id="L487">                    cairoEngine.getMessageBus(),</span>
                    null,
                    true,
                    DefaultLifecycleManager.INSTANCE,
                    root,
<span class="fc" id="L492">                    cairoEngine.getMetrics())) {</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">                for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                    if (metadata.isColumnIndexed(i)) {</span>
<span class="fc" id="L495">                        w.addIndex(metadata.getColumnName(i), metadata.getIndexValueBlockCapacity(i));</span>
                    }
                }
            }
<span class="fc" id="L499">        }</span>
    }

<span class="fc" id="L502">    public static class PhaseSymbolTableMerge {</span>
        private CairoConfiguration cfg;
        private CharSequence column;
        private int columnIndex;
        private CharSequence importRoot;
        private int partitionBy;
        private int symbolColumnIndex;
        private TableToken tableToken;
        private int tmpTableCount;
        private TableWriter writer;

        public void clear() {
<span class="fc" id="L514">            this.cfg = null;</span>
<span class="fc" id="L515">            this.importRoot = null;</span>
<span class="fc" id="L516">            this.writer = null;</span>
<span class="fc" id="L517">            this.tableToken = null;</span>
<span class="fc" id="L518">            this.column = null;</span>
<span class="fc" id="L519">            this.columnIndex = -1;</span>
<span class="fc" id="L520">            this.symbolColumnIndex = -1;</span>
<span class="fc" id="L521">            this.tmpTableCount = -1;</span>
<span class="fc" id="L522">            this.partitionBy = -1;</span>
<span class="fc" id="L523">        }</span>

        public void of(CairoConfiguration cfg,
                       CharSequence importRoot,
                       TableWriter writer,
                       TableToken tableToken,
                       CharSequence column,
                       int columnIndex,
                       int symbolColumnIndex,
                       int tmpTableCount,
                       int partitionBy
        ) {
<span class="fc" id="L535">            this.cfg = cfg;</span>
<span class="fc" id="L536">            this.importRoot = importRoot;</span>
<span class="fc" id="L537">            this.writer = writer;</span>
<span class="fc" id="L538">            this.tableToken = tableToken;</span>
<span class="fc" id="L539">            this.column = column;</span>
<span class="fc" id="L540">            this.columnIndex = columnIndex;</span>
<span class="fc" id="L541">            this.symbolColumnIndex = symbolColumnIndex;</span>
<span class="fc" id="L542">            this.tmpTableCount = tmpTableCount;</span>
<span class="fc" id="L543">            this.partitionBy = partitionBy;</span>
<span class="fc" id="L544">        }</span>

        public void run(Path path) {
<span class="fc" id="L547">            final FilesFacade ff = cfg.getFilesFacade();</span>
<span class="fc" id="L548">            path.of(importRoot).concat(tableToken.getTableName());</span>
<span class="fc" id="L549">            int plen = path.length();</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            for (int i = 0; i &lt; tmpTableCount; i++) {</span>
<span class="fc" id="L551">                path.trimTo(plen);</span>
<span class="fc" id="L552">                path.put('_').put(i);</span>
<span class="fc" id="L553">                int tableLen = path.length();</span>
<span class="fc" id="L554">                try (TxReader txFile = new TxReader(ff).ofRO(path.concat(TXN_FILE_NAME).$(), partitionBy)) {</span>
<span class="fc" id="L555">                    path.trimTo(tableLen);</span>
<span class="fc" id="L556">                    txFile.unsafeLoadAll();</span>
<span class="fc" id="L557">                    int symbolCount = txFile.getSymbolValueCount(symbolColumnIndex);</span>
                    try (
<span class="fc" id="L559">                            SymbolMapReaderImpl reader = new SymbolMapReaderImpl(</span>
                                    cfg,
                                    path,
                                    column,
                                    TableUtils.COLUMN_NAME_TXN_NONE, symbolCount
                            );
<span class="fc" id="L565">                            MemoryCMARW mem = Vm.getSmallCMARWInstance(</span>
                                    ff,
<span class="fc" id="L567">                                    path.concat(column).put(TableUtils.SYMBOL_KEY_REMAP_FILE_SUFFIX).$(),</span>
                                    MemoryTag.MMAP_IMPORT,
<span class="fc" id="L569">                                    cfg.getWriterFileOpenOpts()</span>
                            )
                    ) {
                        // It is possible to skip symbol rewrite when symbols do not clash.
                        // From our benchmarks rewriting symbols take a tiny fraction of time compared to everything else
                        // so that we don't need to optimise this yet.
<span class="fc" id="L575">                        SymbolMapWriter.mergeSymbols(writer.getSymbolMapWriter(columnIndex), reader, mem);</span>
                    }
                }
            }
<span class="fc" id="L579">        }</span>
    }

<span class="fc" id="L582">    public static class PhaseUpdateSymbolKeys {</span>
        CharSequence columnName;
        int index;
        long partitionSize;
        long partitionTimestamp;
        CharSequence root;
        int symbolCount;
        private CairoEngine cairoEngine;
        private TableStructure tableStructure;

        public void clear() {
<span class="fc" id="L593">            this.cairoEngine = null;</span>
<span class="fc" id="L594">            this.tableStructure = null;</span>
<span class="fc" id="L595">            this.index = -1;</span>
<span class="fc" id="L596">            this.partitionSize = -1;</span>
<span class="fc" id="L597">            this.partitionTimestamp = -1;</span>
<span class="fc" id="L598">            this.root = null;</span>
<span class="fc" id="L599">            this.columnName = null;</span>
<span class="fc" id="L600">            this.symbolCount = -1;</span>
<span class="fc" id="L601">        }</span>

        public void of(CairoEngine cairoEngine,
                       TableStructure tableStructure,
                       int index,
                       long partitionSize,
                       long partitionTimestamp,
                       CharSequence root,
                       CharSequence columnName,
                       int symbolCount
        ) {
<span class="fc" id="L612">            this.cairoEngine = cairoEngine;</span>
<span class="fc" id="L613">            this.tableStructure = tableStructure;</span>
<span class="fc" id="L614">            this.index = index;</span>
<span class="fc" id="L615">            this.partitionSize = partitionSize;</span>
<span class="fc" id="L616">            this.partitionTimestamp = partitionTimestamp;</span>
<span class="fc" id="L617">            this.root = root;</span>
<span class="fc" id="L618">            this.columnName = columnName;</span>
<span class="fc" id="L619">            this.symbolCount = symbolCount;</span>
<span class="fc" id="L620">        }</span>

        public void run(Path path) {
<span class="fc" id="L623">            final FilesFacade ff = cairoEngine.getConfiguration().getFilesFacade();</span>

<span class="fc" id="L625">            TableToken tableToken = cairoEngine.getTableToken(tableStructure.getTableName());</span>
<span class="fc" id="L626">            path.of(root).concat(tableToken.getTableName()).put('_').put(index);</span>
<span class="fc" id="L627">            int plen = path.length();</span>
<span class="fc" id="L628">            PartitionBy.setSinkForPartition(path.slash(), tableStructure.getPartitionBy(), partitionTimestamp, false);</span>
<span class="fc" id="L629">            path.concat(columnName).put(TableUtils.FILE_SUFFIX_D);</span>

<span class="fc" id="L631">            long columnMemory = 0;</span>
<span class="fc" id="L632">            long columnMemorySize = 0;</span>
<span class="fc" id="L633">            long remapTableMemory = 0;</span>
<span class="fc" id="L634">            long remapTableMemorySize = 0;</span>
<span class="fc" id="L635">            int columnFd = -1;</span>
<span class="fc" id="L636">            int remapFd = -1;</span>
            try {
<span class="fc" id="L638">                columnFd = TableUtils.openFileRWOrFail(ff, path.$(), CairoConfiguration.O_NONE);</span>
<span class="fc" id="L639">                columnMemorySize = ff.length(columnFd);</span>

<span class="fc" id="L641">                path.trimTo(plen);</span>
<span class="fc" id="L642">                path.concat(columnName).put(TableUtils.SYMBOL_KEY_REMAP_FILE_SUFFIX);</span>
<span class="fc" id="L643">                remapFd = TableUtils.openFileRWOrFail(ff, path.$(), CairoConfiguration.O_NONE);</span>
<span class="fc" id="L644">                remapTableMemorySize = ff.length(remapFd);</span>

<span class="pc bpc" id="L646" title="1 of 4 branches missed.">                if (columnMemorySize &gt;= Integer.BYTES &amp;&amp; remapTableMemorySize &gt;= Integer.BYTES) {</span>
<span class="fc" id="L647">                    columnMemory = TableUtils.mapRW(ff, columnFd, columnMemorySize, MemoryTag.MMAP_IMPORT);</span>
<span class="fc" id="L648">                    remapTableMemory = TableUtils.mapRW(ff, remapFd, remapTableMemorySize, MemoryTag.MMAP_IMPORT);</span>
<span class="fc" id="L649">                    long columnMemSize = partitionSize * Integer.BYTES;</span>
<span class="fc" id="L650">                    long remapMemSize = (long) symbolCount * Integer.BYTES;</span>
<span class="fc" id="L651">                    ColumnUtils.symbolColumnUpdateKeys(columnMemory, columnMemSize, remapTableMemory, remapMemSize);</span>
                }
            } finally {
<span class="fc" id="L654">                ff.close(columnFd);</span>
<span class="fc" id="L655">                ff.close(remapFd);</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">                if (columnMemory &gt; 0) {</span>
<span class="fc" id="L657">                    ff.munmap(columnMemory, columnMemorySize, MemoryTag.MMAP_IMPORT);</span>
                }
<span class="fc bfc" id="L659" title="All 2 branches covered.">                if (remapTableMemory &gt; 0) {</span>
<span class="fc" id="L660">                    ff.munmap(remapTableMemory, remapTableMemorySize, MemoryTag.MMAP_IMPORT);</span>
                }
            }
<span class="fc" id="L663">        }</span>
    }

<span class="fc" id="L666">    public class PhaseIndexing {</span>
        //stores partition key and size for all indexed partitions
<span class="fc" id="L668">        private final LongList partitionKeysAndSizes = new LongList();</span>
        private TimestampAdapter adapter;
        private int atomicity;
        private long chunkEnd;
        private long chunkStart;
        private byte columnDelimiter;
        private long errorCount;
        private boolean ignoreHeader;
        private CharSequence importRoot;
        private int index;
        private CharSequence inputFileName;
        private long lineCount;
        private long lineNumber;
        private int partitionBy;
        private int timestampIndex;

        public void clear() {
<span class="fc" id="L685">            this.chunkStart = -1;</span>
<span class="fc" id="L686">            this.chunkEnd = -1;</span>
<span class="fc" id="L687">            this.lineNumber = -1;</span>
<span class="fc" id="L688">            this.lineCount = 0;</span>
<span class="fc" id="L689">            this.errorCount = 0;</span>

<span class="fc" id="L691">            this.index = -1;</span>
<span class="fc" id="L692">            this.inputFileName = null;</span>
<span class="fc" id="L693">            this.importRoot = null;</span>
<span class="fc" id="L694">            this.partitionBy = -1;</span>
<span class="fc" id="L695">            this.columnDelimiter = (byte) -1;</span>
<span class="fc" id="L696">            this.timestampIndex = -1;</span>
<span class="fc" id="L697">            this.adapter = null;</span>
<span class="fc" id="L698">            this.ignoreHeader = false;</span>
<span class="fc" id="L699">            this.atomicity = -1;</span>
<span class="fc" id="L700">        }</span>

        public long getErrorCount() {
<span class="fc" id="L703">            return errorCount;</span>
        }

        public long getLineCount() {
<span class="fc" id="L707">            return lineCount;</span>
        }

        public LongList getPartitionKeysAndSizes() {
<span class="fc" id="L711">            return partitionKeysAndSizes;</span>
        }

        public void of(long chunkStart,
                       long chunkEnd,
                       long lineNumber,
                       int index,
                       CharSequence inputFileName,
                       CharSequence importRoot,
                       int partitionBy,
                       byte columnDelimiter,
                       int timestampIndex,
                       TimestampAdapter adapter,
                       boolean ignoreHeader,
                       int atomicity
        ) {
<span class="pc bpc" id="L727" title="2 of 4 branches missed.">            assert chunkStart &gt;= 0 &amp;&amp; chunkEnd &gt; chunkStart;</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">            assert lineNumber &gt;= 0;</span>

<span class="fc" id="L730">            this.chunkStart = chunkStart;</span>
<span class="fc" id="L731">            this.chunkEnd = chunkEnd;</span>
<span class="fc" id="L732">            this.lineNumber = lineNumber;</span>

<span class="fc" id="L734">            this.index = index;</span>
<span class="fc" id="L735">            this.inputFileName = inputFileName;</span>
<span class="fc" id="L736">            this.importRoot = importRoot;</span>
<span class="fc" id="L737">            this.partitionBy = partitionBy;</span>
<span class="fc" id="L738">            this.columnDelimiter = columnDelimiter;</span>
<span class="fc" id="L739">            this.timestampIndex = timestampIndex;</span>
<span class="fc" id="L740">            this.adapter = adapter;</span>
<span class="fc" id="L741">            this.ignoreHeader = ignoreHeader;</span>
<span class="fc" id="L742">            this.atomicity = atomicity;</span>
<span class="fc" id="L743">        }</span>

        public void run(CsvFileIndexer indexer, long fileBufAddr, long fileBufSize) throws TextException {
            try {
<span class="fc" id="L747">                indexer.of(</span>
                        inputFileName,
                        importRoot,
                        index,
                        partitionBy,
                        columnDelimiter,
                        timestampIndex,
                        adapter,
                        ignoreHeader,
                        atomicity,
                        circuitBreaker
                );
<span class="fc" id="L759">                indexer.index(chunkStart, chunkEnd, lineNumber, partitionKeysAndSizes, fileBufAddr, fileBufSize);</span>
<span class="fc" id="L760">                lineCount = indexer.getLineCount();</span>
<span class="fc" id="L761">                errorCount = indexer.getErrorCount();</span>
<span class="fc" id="L762">            } catch (TextException e) {</span>
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">                if (indexer.isCancelled()) {</span>
<span class="nc" id="L764">                    throw getCancelException();</span>
                } else {
<span class="fc" id="L766">                    throw e;</span>
                }
            } finally {
<span class="fc" id="L769">                indexer.clear();</span>
            }
<span class="fc" id="L771">        }</span>
    }

<span class="fc" id="L774">    public class PhasePartitionImport {</span>
<span class="fc" id="L775">        private final LongList importedRows = new LongList();</span>
<span class="fc" id="L776">        private final LongList offsets = new LongList();</span>
<span class="fc" id="L777">        private final StringSink tableNameSink = new StringSink();</span>
        private int atomicity;
        private CairoEngine cairoEngine;
        private byte columnDelimiter;
        private long errors;
        private int hi;
        private CharSequence importRoot;
        private int index;
        private CharSequence inputFileName;
        private int lo;
        private long offset;
        private ObjList&lt;ParallelCsvFileImporter.PartitionInfo&gt; partitions;
        private long rowsHandled;
        private long rowsImported;
        private TableWriter tableWriterRef;
        private TableStructure targetTableStructure;
        private TimestampAdapter timestampAdapter;
        private int timestampIndex;
        private ObjList&lt;TypeAdapter&gt; types;
        private DirectCharSink utf8Sink;
<span class="fc" id="L797">        private final CsvTextLexer.Listener onFieldsPartitioned = this::onFieldsPartitioned;</span>

        public void clear() {
<span class="fc" id="L800">            this.cairoEngine = null;</span>
<span class="fc" id="L801">            this.targetTableStructure = null;</span>
<span class="fc" id="L802">            this.types = null;</span>
<span class="fc" id="L803">            this.atomicity = -1;</span>
<span class="fc" id="L804">            this.columnDelimiter = (byte) -1;</span>
<span class="fc" id="L805">            this.importRoot = null;</span>
<span class="fc" id="L806">            this.inputFileName = null;</span>
<span class="fc" id="L807">            this.index = -1;</span>
<span class="fc" id="L808">            this.partitions = null;</span>
<span class="fc" id="L809">            this.timestampIndex = -1;</span>
<span class="fc" id="L810">            this.timestampAdapter = null;</span>

<span class="fc" id="L812">            this.offset = 0;</span>
<span class="fc" id="L813">            this.importedRows.clear();</span>
<span class="fc" id="L814">            this.tableNameSink.clear();</span>
<span class="fc" id="L815">            this.rowsHandled = 0;</span>
<span class="fc" id="L816">            this.rowsImported = 0;</span>
<span class="fc" id="L817">            this.errors = 0;</span>

<span class="fc" id="L819">            this.utf8Sink = null;</span>
<span class="fc" id="L820">        }</span>

        public long getErrors() {
<span class="fc" id="L823">            return errors;</span>
        }

        public LongList getImportedRows() {
<span class="fc" id="L827">            return importedRows;</span>
        }

        public long getRowsHandled() {
<span class="fc" id="L831">            return rowsHandled;</span>
        }

        public long getRowsImported() {
<span class="fc" id="L835">            return rowsImported;</span>
        }

        public void run(
                TextLexerWrapper lf,
                long fileBufAddr,
                long fileBufSize,
                DirectCharSink utf8Sink,
                DirectLongList unmergedIndexes,
                Path path,
                Path tmpPath
        ) throws TextException {

<span class="fc" id="L848">            this.utf8Sink = utf8Sink;</span>

<span class="fc" id="L850">            final CairoConfiguration configuration = cairoEngine.getConfiguration();</span>
<span class="fc" id="L851">            final FilesFacade ff = configuration.getFilesFacade();</span>

<span class="fc" id="L853">            tableNameSink.clear();</span>
<span class="fc" id="L854">            tableNameSink.put(targetTableStructure.getTableName()).put('_').put(index);</span>
<span class="fc" id="L855">            String publicTableName = tableNameSink.toString();</span>
<span class="fc" id="L856">            TableToken tableToken = new TableToken(publicTableName, publicTableName, (int) cairoEngine.getTableIdGenerator().getNextId(), false);</span>
<span class="fc" id="L857">            createTable(ff, configuration.getMkDirMode(), importRoot, tableToken.getDirName(), publicTableName, targetTableStructure, 0);</span>

            try (
<span class="fc" id="L860">                    TableWriter writer = new TableWriter(</span>
                            configuration,
                            tableToken,
<span class="fc" id="L863">                            cairoEngine.getMessageBus(),</span>
                            null,
                            true,
                            DefaultLifecycleManager.INSTANCE,
                            importRoot,
<span class="fc" id="L868">                            cairoEngine.getMetrics())</span>
            ) {
<span class="fc" id="L870">                tableWriterRef = writer;</span>
<span class="fc" id="L871">                AbstractTextLexer lexer = lf.getLexer(columnDelimiter);</span>
<span class="fc" id="L872">                lexer.setTableName(tableNameSink);</span>
<span class="fc" id="L873">                lexer.setSkipLinesWithExtraValues(false);</span>

                long prevErrors;
                try {
<span class="fc bfc" id="L877" title="All 2 branches covered.">                    for (int i = lo; i &lt; hi; i++) {</span>
<span class="fc" id="L878">                        throwIfCancelled();</span>

<span class="fc" id="L880">                        lexer.clear();</span>
<span class="fc" id="L881">                        prevErrors = errors;</span>

<span class="fc" id="L883">                        final CharSequence name = partitions.getQuick(i).name;</span>
<span class="fc" id="L884">                        path.of(importRoot).concat(name);</span>
<span class="fc" id="L885">                        mergePartitionIndexAndImportData(</span>
                                ff,
<span class="fc" id="L887">                                configuration.getIOURingFacade(),</span>
<span class="fc" id="L888">                                configuration.isIOURingEnabled(),</span>
                                path,
                                lexer,
                                fileBufAddr,
                                fileBufSize,
                                utf8Sink,
                                unmergedIndexes,
                                tmpPath
                        );

<span class="fc" id="L898">                        long newErrors = errors - prevErrors;</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">                        long imported = atomicity == Atomicity.SKIP_ROW ? lexer.getLineCount() - newErrors : lexer.getLineCount();</span>
<span class="fc" id="L900">                        importedRows.add(i);</span>
<span class="fc" id="L901">                        importedRows.add(imported);</span>
<span class="fc" id="L902">                        rowsHandled += lexer.getLineCount();</span>
<span class="fc" id="L903">                        rowsImported += imported;</span>

<span class="fc" id="L905">                        LOG.info()</span>
<span class="fc" id="L906">                                .$(&quot;imported data [temp_table=&quot;).$(tableNameSink)</span>
<span class="fc" id="L907">                                .$(&quot;, partition=&quot;).$(name)</span>
<span class="fc" id="L908">                                .$(&quot;, lines=&quot;).$(lexer.getLineCount())</span>
<span class="fc" id="L909">                                .$(&quot;, errors=&quot;).$(newErrors)</span>
<span class="fc" id="L910">                                .I$();</span>
                    }
                } finally {
<span class="fc" id="L913">                    writer.commit(CommitMode.SYNC);</span>
                }
            }
<span class="fc" id="L916">        }</span>

        private void consumeIOURing(
                FilesFacade ff,
                long sqeMin,
                AbstractTextLexer lexer,
                long fileBufAddr,
                LongList offsets,
                IOURing ring,
                int cc,
                Path tmpPath
        ) {
<span class="nc" id="L928">            int submitted = ring.submit();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            assert submitted == cc;</span>

<span class="nc" id="L931">            long nextCqe = sqeMin;</span>
<span class="nc" id="L932">            int writtenMax = 0;</span>
            // consume submitted tasks
<span class="nc bnc" id="L934" title="All 2 branches missed.">            for (int i = 0; i &lt; submitted; i++) {</span>

<span class="nc bnc" id="L936" title="All 2 branches missed.">                while (!ring.nextCqe()) {</span>
<span class="nc" id="L937">                    Os.pause();</span>
                }

<span class="nc bnc" id="L940" title="All 2 branches missed.">                if (ring.getCqeRes() &lt; 0) {</span>
<span class="nc" id="L941">                    throw TextException</span>
<span class="nc" id="L942">                            .$(&quot;could not read from file [path='&quot;).put(tmpPath)</span>
<span class="nc" id="L943">                            .put(&quot;', errno=&quot;).put(ff.errno())</span>
<span class="nc" id="L944">                            .put(&quot;, offset=&quot;).put(offset)</span>
<span class="nc" id="L945">                            .put(&quot;]&quot;);</span>
                }

<span class="nc bnc" id="L948" title="All 2 branches missed.">                if (ring.getCqeId() == nextCqe) {</span>
                    // only parse lines in order of submissions
<span class="nc" id="L950">                    nextCqe++;</span>
<span class="nc" id="L951">                    parseLinesAndWrite(lexer, fileBufAddr, offsets, writtenMax);</span>
<span class="nc" id="L952">                    writtenMax++;</span>
                }
            }

            // if reads came out of order, the writtenMax should be less than submitted
<span class="nc bnc" id="L957" title="All 2 branches missed.">            for (int i = writtenMax; i &lt; submitted; i++) {</span>
<span class="nc" id="L958">                parseLinesAndWrite(lexer, fileBufAddr, offsets, i);</span>
            }
<span class="nc" id="L960">        }</span>

        private TableWriter.Row getRow(DirectByteCharSequence dbcs, long offset) {
            final long timestamp;
            try {
<span class="fc" id="L965">                timestamp = timestampAdapter.getTimestamp(dbcs);</span>
<span class="nc" id="L966">            } catch (Throwable e) {</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                if (atomicity == Atomicity.SKIP_ALL) {</span>
<span class="nc" id="L968">                    throw TextException.$(&quot;could not parse timestamp [offset=&quot;).put(offset).put(&quot;, msg=&quot;).put(e.getMessage()).put(']');</span>
                } else {
<span class="nc" id="L970">                    logError(offset, timestampIndex, dbcs);</span>
<span class="nc" id="L971">                    return null;</span>
                }
<span class="fc" id="L973">            }</span>
<span class="fc" id="L974">            return tableWriterRef.newRow(timestamp);</span>
        }

        private void importPartitionData(
                final IOURingFacade rf,
                final boolean ioURingEnabled,
                final AbstractTextLexer lexer,
                long address,
                long size,
                long fileBufAddr,
                long fileBufSize,
                DirectCharSink utf8Sink,
                Path tmpPath
        ) throws TextException {
<span class="pc bpc" id="L988" title="1 of 4 branches missed.">            if (ioURingEnabled &amp;&amp; rf.isAvailable()) {</span>
<span class="nc" id="L989">                importPartitionDataURing(</span>
                        rf,
                        lexer,
                        address,
                        size,
                        fileBufAddr,
                        fileBufSize,
                        utf8Sink,
                        tmpPath
                );
            } else {
<span class="fc" id="L1000">                importPartitionDataVanilla(</span>
                        lexer,
                        address,
                        size,
                        fileBufAddr,
                        fileBufSize,
                        utf8Sink,
                        tmpPath
                );
            }
<span class="fc" id="L1010">        }</span>

        private void importPartitionDataURing(
                final IOURingFacade rf,
                AbstractTextLexer lexer,
                long address,
                long size,
                long fileBufAddr,
                long fileBufSize,
                DirectCharSink utf8Sink,
                Path tmpPath
        ) {
<span class="nc" id="L1022">            final CairoConfiguration configuration = cairoEngine.getConfiguration();</span>
<span class="nc" id="L1023">            final FilesFacade ff = configuration.getFilesFacade();</span>

<span class="nc" id="L1025">            offsets.clear();</span>
<span class="nc" id="L1026">            lexer.setupBeforeExactLines(onFieldsPartitioned);</span>

<span class="nc" id="L1028">            int fd = -1;</span>
            try {
<span class="nc" id="L1030">                tmpPath.of(configuration.getSqlCopyInputRoot()).concat(inputFileName).$();</span>
<span class="nc" id="L1031">                utf8Sink.clear();</span>
<span class="nc" id="L1032">                fd = TableUtils.openRO(ff, tmpPath, LOG);</span>

<span class="nc" id="L1034">                final long len = ff.length(fd);</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                if (len == -1) {</span>
<span class="nc" id="L1036">                    throw CairoException.critical(ff.errno())</span>
<span class="nc" id="L1037">                            .put(&quot;could not get length of file [path=&quot;).put(tmpPath)</span>
<span class="nc" id="L1038">                            .put(']');</span>
                }

<span class="nc" id="L1041">                ff.fadvise(fd, 0, len, Files.POSIX_FADV_RANDOM);</span>

<span class="nc" id="L1043">                final long MASK = ~((255L) &lt;&lt; 56 | (255L) &lt;&lt; 48);</span>
<span class="nc" id="L1044">                final long count = size / (2 * Long.BYTES);</span>

<span class="nc" id="L1046">                int ringCapacity = 32;</span>
<span class="nc" id="L1047">                long sqeMin = 0;</span>
<span class="nc" id="L1048">                long sqeMax = -1;</span>
<span class="nc" id="L1049">                try (IOURing ring = rf.newInstance(ringCapacity)) {</span>
<span class="nc" id="L1050">                    long addr = fileBufAddr;</span>
<span class="nc" id="L1051">                    long lim = fileBufAddr + fileBufSize;</span>
<span class="nc" id="L1052">                    int cc = 0;</span>
                    int bytesToRead;
                    int additionalLines;
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                    for (long i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1056">                        throwIfCancelled();</span>

<span class="nc" id="L1058">                        final long lengthAndOffset = Unsafe.getUnsafe().getLong(address + i * 2L * Long.BYTES + Long.BYTES);</span>
<span class="nc" id="L1059">                        final int lineLength = (int) (lengthAndOffset &gt;&gt;&gt; 48);</span>
                        // the offset is used by the callback to report errors
<span class="nc" id="L1061">                        offset = lengthAndOffset &amp; MASK;</span>
<span class="nc" id="L1062">                        bytesToRead = lineLength;</span>

                        // schedule reads until we either run out of ring capacity or
                        // our read buffer size

<span class="nc bnc" id="L1067" title="All 6 branches missed.">                        if (cc == ringCapacity || (cc &gt; 0 &amp;&amp; addr + lineLength &gt; lim)) {</span>
                            // we are out of ring capacity or our buffer is exhausted
<span class="nc" id="L1069">                            consumeIOURing(ff, sqeMin, lexer, fileBufAddr, offsets, ring, cc, tmpPath);</span>

<span class="nc" id="L1071">                            cc = 0;</span>
<span class="nc" id="L1072">                            addr = fileBufAddr;</span>
<span class="nc" id="L1073">                            offsets.clear();</span>
<span class="nc" id="L1074">                            sqeMin = sqeMax + 1;</span>
                        }
<span class="nc bnc" id="L1076" title="All 2 branches missed.">                        if (addr + lineLength &gt; lim) {</span>
<span class="nc" id="L1077">                            throw TextException.$(&quot;buffer overflow [path='&quot;).put(tmpPath)</span>
<span class="nc" id="L1078">                                    .put(&quot;', lineLength=&quot;).put(lineLength)</span>
<span class="nc" id="L1079">                                    .put(&quot;, fileBufSize=&quot;).put(fileBufSize)</span>
<span class="nc" id="L1080">                                    .put(&quot;]&quot;);</span>
                        }

                        // try to coalesce ahead lines into the same read, if they're sequential
<span class="nc" id="L1084">                        additionalLines = 0;</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">                        for (long j = i + 1; j &lt; count; j++) {</span>
<span class="nc" id="L1086">                            long nextLengthAndOffset = Unsafe.getUnsafe().getLong(address + j * 2L * Long.BYTES + Long.BYTES);</span>
<span class="nc" id="L1087">                            int nextLineLength = (int) (nextLengthAndOffset &gt;&gt;&gt; 48);</span>
<span class="nc" id="L1088">                            long nextOffset = nextLengthAndOffset &amp; MASK;</span>

                            // line indexing stops on first EOL char, e.g. \r, but it could be followed by \n
<span class="nc" id="L1091">                            long diff = nextOffset - offset - bytesToRead;</span>
<span class="nc" id="L1092">                            long nextBytesToRead = diff + nextLineLength;</span>
<span class="nc bnc" id="L1093" title="All 6 branches missed.">                            if (diff &gt; -1 &amp;&amp; diff &lt; 2 &amp;&amp; addr + bytesToRead + nextBytesToRead &lt;= lim) {</span>
<span class="nc" id="L1094">                                bytesToRead += nextBytesToRead;</span>
<span class="nc" id="L1095">                                additionalLines++;</span>
                            } else {
                                break;
                            }
                        }
<span class="nc" id="L1100">                        i += additionalLines;</span>

<span class="nc" id="L1102">                        sqeMax = ring.enqueueRead(fd, offset, addr, bytesToRead);</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                        if (sqeMax == -1) {</span>
<span class="nc" id="L1104">                            throw TextException.$(&quot;io_uring error [path='&quot;).put(tmpPath)</span>
<span class="nc" id="L1105">                                    .put(&quot;', cqeRes=&quot;).put(-ring.getCqeRes())</span>
<span class="nc" id="L1106">                                    .put(&quot;]&quot;);</span>
                        }

<span class="nc" id="L1109">                        offsets.add(addr - fileBufAddr, bytesToRead);</span>

<span class="nc" id="L1111">                        cc++;</span>
<span class="nc" id="L1112">                        addr += bytesToRead;</span>
                    } // for

                    // check if something is enqueued
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                    if (cc &gt; 0) {</span>
<span class="nc" id="L1117">                        consumeIOURing(ff, sqeMin, lexer, fileBufAddr, offsets, ring, cc, tmpPath);</span>
                    }
                }

            } finally {
<span class="nc" id="L1122">                ff.close(fd);</span>
            }
<span class="nc" id="L1124">        }</span>

        private void importPartitionDataVanilla(
                AbstractTextLexer lexer,
                long address,
                long size,
                long fileBufAddr,
                long fileBufSize,
                DirectCharSink utf8Sink,
                Path tmpPath
        ) {
<span class="fc" id="L1135">            final CairoConfiguration configuration = cairoEngine.getConfiguration();</span>
<span class="fc" id="L1136">            final FilesFacade ff = configuration.getFilesFacade();</span>

<span class="fc" id="L1138">            lexer.setupBeforeExactLines(onFieldsPartitioned);</span>

<span class="fc" id="L1140">            int fd = -1;</span>
            try {
<span class="fc" id="L1142">                tmpPath.of(configuration.getSqlCopyInputRoot()).concat(inputFileName).$();</span>
<span class="fc" id="L1143">                utf8Sink.clear();</span>
<span class="fc" id="L1144">                fd = TableUtils.openRO(ff, tmpPath, LOG);</span>

<span class="fc" id="L1146">                final long len = ff.length(fd);</span>
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">                if (len == -1) {</span>
<span class="nc" id="L1148">                    throw CairoException.critical(ff.errno()).put(</span>
<span class="nc" id="L1149">                                    &quot;could not get length of file [path=&quot;).put(tmpPath)</span>
<span class="nc" id="L1150">                            .put(']');</span>
                }

<span class="fc" id="L1153">                ff.fadvise(fd, 0, len, Files.POSIX_FADV_RANDOM);</span>

<span class="fc" id="L1155">                final long MASK = ~((255L) &lt;&lt; 56 | (255L) &lt;&lt; 48);</span>
<span class="fc" id="L1156">                final long count = size / (2 * Long.BYTES);</span>
                int bytesToRead;
                int additionalLines;

<span class="fc bfc" id="L1160" title="All 2 branches covered.">                for (long i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L1161">                    throwIfCancelled();</span>

<span class="fc" id="L1163">                    long lengthAndOffset = Unsafe.getUnsafe().getLong(address + i * 2L * Long.BYTES + Long.BYTES);</span>
<span class="fc" id="L1164">                    int lineLength = (int) (lengthAndOffset &gt;&gt;&gt; 48);</span>
<span class="fc" id="L1165">                    offset = lengthAndOffset &amp; MASK;</span>
<span class="fc" id="L1166">                    bytesToRead = lineLength;</span>

                    // try to coalesce ahead lines into the same read, if they're sequential
<span class="fc" id="L1169">                    additionalLines = 0;</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">                    for (long j = i + 1; j &lt; count; j++) {</span>
<span class="fc" id="L1171">                        long nextLengthAndOffset = Unsafe.getUnsafe().getLong(address + j * 2L * Long.BYTES + Long.BYTES);</span>
<span class="fc" id="L1172">                        int nextLineLength = (int) (nextLengthAndOffset &gt;&gt;&gt; 48);</span>
<span class="fc" id="L1173">                        long nextOffset = nextLengthAndOffset &amp; MASK;</span>

                        // line indexing stops on first EOL char, e.g. \r, but it could be followed by \n
<span class="fc" id="L1176">                        long diff = nextOffset - offset - bytesToRead;</span>
<span class="fc" id="L1177">                        long nextBytesToRead = diff + nextLineLength;</span>
<span class="pc bpc" id="L1178" title="2 of 6 branches missed.">                        if (diff &gt; -1 &amp;&amp; diff &lt; 2 &amp;&amp; bytesToRead + nextBytesToRead &lt;= fileBufSize) {</span>
<span class="fc" id="L1179">                            bytesToRead += diff + nextLineLength;</span>
<span class="fc" id="L1180">                            additionalLines++;</span>
                        } else {
                            break;
                        }
                    }
<span class="fc" id="L1185">                    i += additionalLines;</span>

<span class="fc bfc" id="L1187" title="All 2 branches covered.">                    if (bytesToRead &gt; fileBufSize) {</span>
<span class="fc" id="L1188">                        throw TextException</span>
<span class="fc" id="L1189">                                .$(&quot;buffer overflow [path='&quot;).put(tmpPath)</span>
<span class="fc" id="L1190">                                .put(&quot;', bytesToRead=&quot;).put(bytesToRead)</span>
<span class="fc" id="L1191">                                .put(&quot;, fileBufSize=&quot;).put(fileBufSize)</span>
<span class="fc" id="L1192">                                .put(&quot;]&quot;);</span>
                    }

<span class="fc" id="L1195">                    long n = ff.read(fd, fileBufAddr, bytesToRead, offset);</span>
<span class="fc bfc" id="L1196" title="All 2 branches covered.">                    if (n &gt; 0) {</span>
                        // at this phase there is no way for lines to be split across buffers
<span class="fc" id="L1198">                        lexer.parseExactLines(fileBufAddr, fileBufAddr + n);</span>
                    } else {
<span class="fc" id="L1200">                        throw TextException</span>
<span class="fc" id="L1201">                                .$(&quot;could not read from file [path='&quot;).put(tmpPath)</span>
<span class="fc" id="L1202">                                .put(&quot;', errno=&quot;).put(ff.errno())</span>
<span class="fc" id="L1203">                                .put(&quot;, offset=&quot;).put(offset)</span>
<span class="fc" id="L1204">                                .put(&quot;]&quot;);</span>
                    }
                }
            } finally {
<span class="fc" id="L1208">                ff.close(fd);</span>
            }
<span class="fc" id="L1210">        }</span>

        private void logError(long offset, int column, final DirectByteCharSequence dbcs) {
<span class="fc" id="L1213">            LOG.error()</span>
<span class="fc" id="L1214">                    .$(&quot;type syntax [type=&quot;).$(ColumnType.nameOf(types.getQuick(column).getType()))</span>
<span class="fc" id="L1215">                    .$(&quot;, offset=&quot;).$(offset)</span>
<span class="fc" id="L1216">                    .$(&quot;, column=&quot;).$(column)</span>
<span class="fc" id="L1217">                    .$(&quot;, value='&quot;).$(dbcs)</span>
<span class="fc" id="L1218">                    .$(&quot;']&quot;).$();</span>
<span class="fc" id="L1219">        }</span>

        private void mergePartitionIndexAndImportData(
                final FilesFacade ff,
                final IOURingFacade rf,
                boolean ioURingEnabled,
                Path partitionPath,
                final AbstractTextLexer lexer,
                long fileBufAddr,
                long fileBufSize,
                DirectCharSink utf8Sink,
                DirectLongList unmergedIndexes,
                Path tmpPath
        ) throws TextException {
<span class="fc" id="L1233">            unmergedIndexes.clear();</span>
<span class="fc" id="L1234">            partitionPath.slash$();</span>
<span class="fc" id="L1235">            int partitionLen = partitionPath.length();</span>

<span class="fc" id="L1237">            long mergedIndexSize = -1;</span>
<span class="fc" id="L1238">            long mergeIndexAddr = 0;</span>
<span class="fc" id="L1239">            int fd = -1;</span>
            try {
<span class="fc" id="L1241">                mergedIndexSize = openIndexChunks(ff, partitionPath, unmergedIndexes, partitionLen);</span>

<span class="fc bfc" id="L1243" title="All 2 branches covered.">                if (unmergedIndexes.size() &gt; 2) { // there's more than 1 chunk so we've to merge</span>
<span class="fc" id="L1244">                    partitionPath.trimTo(partitionLen);</span>
<span class="fc" id="L1245">                    partitionPath.concat(CsvFileIndexer.INDEX_FILE_NAME).$();</span>

<span class="fc" id="L1247">                    fd = TableUtils.openFileRWOrFail(ff, partitionPath, CairoConfiguration.O_NONE);</span>
<span class="fc" id="L1248">                    mergeIndexAddr = TableUtils.mapRW(ff, fd, mergedIndexSize, MemoryTag.MMAP_IMPORT);</span>

<span class="fc" id="L1250">                    Vect.mergeLongIndexesAsc(unmergedIndexes.getAddress(), (int) unmergedIndexes.size() / 2, mergeIndexAddr);</span>
                    // release chunk memory because it's been copied to merge area
<span class="fc" id="L1252">                    unmap(ff, unmergedIndexes);</span>

<span class="fc" id="L1254">                    importPartitionData(</span>
                            rf,
                            ioURingEnabled,
                            lexer,
                            mergeIndexAddr,
                            mergedIndexSize,
                            fileBufAddr,
                            fileBufSize,
                            utf8Sink,
                            tmpPath
                    );
                } else { // we can use the single chunk as is
<span class="fc" id="L1266">                    importPartitionData(</span>
                            rf,
                            ioURingEnabled,
                            lexer,
<span class="fc" id="L1270">                            unmergedIndexes.get(0),</span>
                            mergedIndexSize,
                            fileBufAddr,
                            fileBufSize,
                            utf8Sink,
                            tmpPath
                    );
                }
            } finally {
<span class="fc" id="L1279">                ff.close(fd);</span>
<span class="fc" id="L1280">                ff.munmap(mergeIndexAddr, mergedIndexSize, MemoryTag.MMAP_IMPORT);</span>
<span class="fc" id="L1281">                unmap(ff, unmergedIndexes);</span>
            }
<span class="fc" id="L1283">        }</span>

        private boolean onField(
                long offset,
                final DirectByteCharSequence dbcs,
                TableWriter.Row w,
                int fieldIndex
        ) throws TextException {
<span class="fc" id="L1291">            TypeAdapter type = this.types.getQuick(fieldIndex);</span>
            try {
<span class="fc" id="L1293">                type.write(w, fieldIndex, dbcs, utf8Sink);</span>
<span class="fc" id="L1294">            } catch (NumericException | Utf8Exception | ImplicitCastException ignore) {</span>
<span class="fc" id="L1295">                errors++;</span>
<span class="fc" id="L1296">                logError(offset, fieldIndex, dbcs);</span>
<span class="fc bfc" id="L1297" title="All 3 branches covered.">                switch (atomicity) {</span>
                    case Atomicity.SKIP_ALL:
<span class="fc" id="L1299">                        tableWriterRef.rollback();</span>
<span class="fc" id="L1300">                        throw TextException.$(&quot;bad syntax [line offset=&quot;).put(offset).put(&quot;,column=&quot;).put(fieldIndex).put(']');</span>
                    case Atomicity.SKIP_ROW:
<span class="fc" id="L1302">                        w.cancel();</span>
<span class="fc" id="L1303">                        return true;</span>
                    default: // SKIP column
                        break;
                }
<span class="nc" id="L1307">            } catch (Exception e) {</span>
<span class="nc" id="L1308">                throw TextException.$(&quot;unexpected error [line offset=&quot;).put(offset).put(&quot;,column=&quot;).put(fieldIndex).put(&quot;,message=&quot;).put(e.getMessage()).put(']');</span>
<span class="fc" id="L1309">            }</span>
<span class="fc" id="L1310">            return false;</span>
        }

        private void onFieldsPartitioned(long line, ObjList&lt;DirectByteCharSequence&gt; values, int valuesLength) {
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">            assert tableWriterRef != null;</span>
<span class="fc" id="L1315">            DirectByteCharSequence dbcs = values.getQuick(timestampIndex);</span>
<span class="fc" id="L1316">            final TableWriter.Row w = getRow(dbcs, offset);</span>
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">            if (w == null) {</span>
<span class="nc" id="L1318">                return;</span>
            }
<span class="fc bfc" id="L1320" title="All 2 branches covered.">            for (int i = 0; i &lt; valuesLength; i++) {</span>
<span class="fc" id="L1321">                dbcs = values.getQuick(i);</span>
<span class="fc bfc" id="L1322" title="All 4 branches covered.">                if (i == timestampIndex || dbcs.length() == 0) {</span>
<span class="fc" id="L1323">                    continue;</span>
                }
<span class="fc bfc" id="L1325" title="All 2 branches covered.">                if (onField(offset, dbcs, w, i)) return;</span>
            }
<span class="fc" id="L1327">            w.append();</span>
<span class="fc" id="L1328">        }</span>

        private long openIndexChunks(FilesFacade ff, Path partitionPath, DirectLongList mergeIndexes, int partitionLen) {
<span class="fc" id="L1331">            long mergedIndexSize = 0;</span>
<span class="fc" id="L1332">            long chunk = ff.findFirst(partitionPath);</span>
<span class="pc bpc" id="L1333" title="1 of 2 branches missed.">            if (chunk &gt; 0) {</span>
                try {
                    do {
                        // chunk loop
<span class="fc" id="L1337">                        long chunkName = ff.findName(chunk);</span>
<span class="fc" id="L1338">                        long chunkType = ff.findType(chunk);</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">                        if (chunkType == Files.DT_FILE) {</span>
<span class="fc" id="L1340">                            partitionPath.trimTo(partitionLen);</span>
<span class="fc" id="L1341">                            partitionPath.concat(chunkName).$();</span>

<span class="fc" id="L1343">                            int fd = TableUtils.openRO(ff, partitionPath, LOG);</span>
<span class="fc" id="L1344">                            long size = 0;</span>
<span class="fc" id="L1345">                            long address = -1;</span>

                            try {
<span class="fc" id="L1348">                                size = ff.length(fd);</span>
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">                                if (size &lt; 1) {</span>
<span class="nc" id="L1350">                                    throw TextException.$(&quot;index chunk is empty [path='&quot;).put(partitionPath).put(']');</span>
                                }
<span class="fc" id="L1352">                                address = TableUtils.mapRO(ff, fd, size, MemoryTag.MMAP_IMPORT);</span>
<span class="fc" id="L1353">                                mergeIndexes.add(address);</span>
<span class="fc" id="L1354">                                mergeIndexes.add(size / CsvFileIndexer.INDEX_ENTRY_SIZE);</span>
<span class="fc" id="L1355">                                mergedIndexSize += size;</span>
<span class="nc" id="L1356">                            } catch (Throwable t) {</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                                if (address != -1) { //release mem if it can't be added to mergeIndexes</span>
<span class="nc" id="L1358">                                    ff.munmap(address, size, MemoryTag.MMAP_IMPORT);</span>
                                }
<span class="nc" id="L1360">                                throw t;</span>
                            } finally {
<span class="fc" id="L1362">                                ff.close(fd);</span>
                            }
                        }
<span class="fc bfc" id="L1365" title="All 2 branches covered.">                    } while (ff.findNext(chunk) &gt; 0);</span>
                } finally {
<span class="fc" id="L1367">                    ff.findClose(chunk);</span>
                }
            }
<span class="fc" id="L1370">            return mergedIndexSize;</span>
        }

        private void parseLinesAndWrite(AbstractTextLexer lexer, long fileBufAddr, LongList offsets, int j) {
<span class="nc" id="L1374">            final long lo = fileBufAddr + offsets.getQuick(j * 2);</span>
<span class="nc" id="L1375">            final long hi = lo + offsets.getQuick(j * 2 + 1);</span>
<span class="nc" id="L1376">            lexer.parseExactLines(lo, hi);</span>
<span class="nc" id="L1377">        }</span>

        private void unmap(FilesFacade ff, DirectLongList mergeIndexes) {
<span class="fc bfc" id="L1380" title="All 2 branches covered.">            for (long i = 0, sz = mergeIndexes.size() / 2; i &lt; sz; i++) {</span>
<span class="fc" id="L1381">                final long addr = mergeIndexes.get(2 * i);</span>
<span class="fc" id="L1382">                final long size = mergeIndexes.get(2 * i + 1) * CsvFileIndexer.INDEX_ENTRY_SIZE;</span>
<span class="fc" id="L1383">                ff.munmap(addr, size, MemoryTag.MMAP_IMPORT);</span>
            }
<span class="fc" id="L1385">            mergeIndexes.clear();</span>
<span class="fc" id="L1386">        }</span>

        void of(
                CairoEngine cairoEngine,
                TableStructure targetTableStructure,
                ObjList&lt;TypeAdapter&gt; types,
                int atomicity,
                byte columnDelimiter,
                CharSequence importRoot,
                CharSequence inputFileName,
                int index,
                int lo,
                int hi,
                final ObjList&lt;ParallelCsvFileImporter.PartitionInfo&gt; partitions
        ) {
<span class="fc" id="L1401">            this.cairoEngine = cairoEngine;</span>
<span class="fc" id="L1402">            this.targetTableStructure = targetTableStructure;</span>
<span class="fc" id="L1403">            this.types = types;</span>
<span class="fc" id="L1404">            this.atomicity = atomicity;</span>
<span class="fc" id="L1405">            this.columnDelimiter = columnDelimiter;</span>
<span class="fc" id="L1406">            this.importRoot = importRoot;</span>
<span class="fc" id="L1407">            this.inputFileName = inputFileName;</span>
<span class="fc" id="L1408">            this.index = index;</span>
<span class="fc" id="L1409">            this.lo = lo;</span>
<span class="fc" id="L1410">            this.hi = hi;</span>
<span class="fc" id="L1411">            this.partitions = partitions;</span>
<span class="fc" id="L1412">            this.timestampIndex = targetTableStructure.getTimestampIndex();</span>
<span class="pc bpc" id="L1413" title="2 of 4 branches missed.">            this.timestampAdapter = (timestampIndex &gt; -1 &amp;&amp; timestampIndex &lt; types.size()) ? (TimestampAdapter) types.getQuick(timestampIndex) : null;</span>
<span class="fc" id="L1414">            this.errors = 0;</span>
<span class="fc" id="L1415">            this.importedRows.clear();</span>
<span class="fc" id="L1416">        }</span>
    }

    static {
<span class="fc" id="L1420">        PHASE_NAME_MAP.put(PHASE_SETUP, &quot;setup&quot;);</span>
<span class="fc" id="L1421">        PHASE_NAME_MAP.put(PHASE_BOUNDARY_CHECK, &quot;boundary_check&quot;);</span>
<span class="fc" id="L1422">        PHASE_NAME_MAP.put(PHASE_INDEXING, &quot;indexing&quot;);</span>
<span class="fc" id="L1423">        PHASE_NAME_MAP.put(PHASE_PARTITION_IMPORT, &quot;partition_import&quot;);</span>
<span class="fc" id="L1424">        PHASE_NAME_MAP.put(PHASE_SYMBOL_TABLE_MERGE, &quot;symbol_table_merge&quot;);</span>
<span class="fc" id="L1425">        PHASE_NAME_MAP.put(PHASE_UPDATE_SYMBOL_KEYS, &quot;update_symbol_keys&quot;);</span>
<span class="fc" id="L1426">        PHASE_NAME_MAP.put(PHASE_BUILD_SYMBOL_INDEX, &quot;build_symbol_index&quot;);</span>
<span class="fc" id="L1427">        PHASE_NAME_MAP.put(PHASE_MOVE_PARTITIONS, &quot;move_partitions&quot;);</span>
<span class="fc" id="L1428">        PHASE_NAME_MAP.put(PHASE_ATTACH_PARTITIONS, &quot;attach_partitions&quot;);</span>
<span class="fc" id="L1429">        PHASE_NAME_MAP.put(PHASE_ANALYZE_FILE_STRUCTURE, &quot;analyze_file_structure&quot;);</span>
<span class="fc" id="L1430">        PHASE_NAME_MAP.put(PHASE_CLEANUP, &quot;cleanup&quot;);</span>

<span class="fc" id="L1432">        STATUS_NAME_MAP.put(STATUS_STARTED, &quot;started&quot;);</span>
<span class="fc" id="L1433">        STATUS_NAME_MAP.put(STATUS_FINISHED, &quot;finished&quot;);</span>
<span class="fc" id="L1434">        STATUS_NAME_MAP.put(STATUS_FAILED, &quot;failed&quot;);</span>
<span class="fc" id="L1435">        STATUS_NAME_MAP.put(STATUS_CANCELLED, &quot;cancelled&quot;);</span>
<span class="fc" id="L1436">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>