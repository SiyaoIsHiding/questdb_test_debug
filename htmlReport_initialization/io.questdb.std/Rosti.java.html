<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Rosti.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.std</a> &gt; <span class="el_source">Rosti.java</span></div><h1>Rosti.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.std;

import io.questdb.cairo.ColumnTypes;
import org.jetbrains.annotations.TestOnly;

import static io.questdb.std.Numbers.hexDigits;

<span class="pc" id="L32">public final class Rosti {</span>

    public static long alloc(ColumnTypes types, long capacity) {
        // min capacity that works on all platforms is 16  
<span class="pc bpc" id="L36" title="1 of 2 branches missed.">        assert capacity &gt;= 16;</span>

<span class="fc" id="L38">        final int columnCount = types.getColumnCount();</span>
<span class="fc" id="L39">        final long mem = Unsafe.malloc(4L * columnCount, MemoryTag.NATIVE_ROSTI);</span>
        try {
<span class="fc" id="L41">            long p = mem;</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L43">                Unsafe.getUnsafe().putInt(p, types.getColumnType(i));</span>
<span class="fc" id="L44">                p += Integer.BYTES;</span>
            }
            // this is not an exact size of memory allocated for Rosti, but this is useful to
            // track that we free these maps
<span class="fc" id="L48">            long pRosti = alloc(mem, columnCount, Numbers.ceilPow2(capacity) - 1);</span>
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">            if (pRosti != 0) {</span>
<span class="fc" id="L50">                Unsafe.recordMemAlloc(getAllocMemory(pRosti), MemoryTag.NATIVE_ROSTI);</span>
            }
<span class="fc" id="L52">            return pRosti;</span>
        } finally {
<span class="fc" id="L54">            Unsafe.free(mem, 4L * columnCount, MemoryTag.NATIVE_ROSTI);</span>
        }
    }

    public static native void clear(long pRosti);

    //turns on normal allocation inside rosti
    @TestOnly
    public static native void disableOOMOnMalloc();

    //triggers OOM on next allocation happening inside rosti
    @TestOnly
    public static native void enableOOMOnMalloc();

    public static void free(long pRosti) {
<span class="fc" id="L69">        long size = getAllocMemory(pRosti);</span>
<span class="fc" id="L70">        free0(pRosti);</span>
<span class="fc" id="L71">        Unsafe.recordMemAlloc(-size, MemoryTag.NATIVE_ROSTI);</span>
<span class="fc" id="L72">    }</span>

    public static native long getAllocMemory(long pRosti);

    public static long getCapacity(long pRosti) {
<span class="fc" id="L77">        return Unsafe.getUnsafe().getLong(pRosti + 3 * Long.BYTES);</span>
    }

    public static long getCtrl(long pRosti) {
<span class="fc" id="L81">        return Unsafe.getUnsafe().getLong(pRosti);</span>
    }

    public static long getInitialValueSlot(long pRosti, int columnIndex) {
<span class="fc" id="L85">        return getInitialValuesSlot(pRosti) + Unsafe.getUnsafe().getInt(getValueOffsets(pRosti) + columnIndex * 4L);</span>
    }

    public static long getInitialValuesSlot(long pRosti) {
<span class="fc" id="L89">        return Unsafe.getUnsafe().getLong(pRosti + 8 * Long.BYTES);</span>
    }

    public static long getSize(long pRosti) {
<span class="fc" id="L93">        return Unsafe.getUnsafe().getLong(pRosti + 2 * Long.BYTES);</span>
    }

    public static long getSlotShift(long pRosti) {
<span class="fc" id="L97">        return Unsafe.getUnsafe().getLong(pRosti + 5 * Long.BYTES);</span>
    }

    public static long getSlotSize(long pRosti) {
<span class="fc" id="L101">        return Unsafe.getUnsafe().getLong(pRosti + 4 * Long.BYTES);</span>
    }

    public static long getSlots(long pRosti) {
<span class="fc" id="L105">        return Unsafe.getUnsafe().getLong(pRosti + Long.BYTES);</span>
    }

    public static long getValueOffsets(long pRosti) {
<span class="fc" id="L109">        return Unsafe.getUnsafe().getLong(pRosti + 7 * Long.BYTES);</span>
    }

    //returns true if rosti is set to trigger OOM on  allocation
    @TestOnly
    public static native boolean isOOMOnMalloc();

    public static native boolean keyedHourCount(long pRosti, long pKeys, long count, int valueOffset);

    public static native boolean keyedHourCountDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourCountInt(long pRosti, long pKeys, long pInt, long count, int valueOffset);

    public static native boolean keyedHourCountLong(long pRosti, long pKeys, long pLong, long count, int valueOffset);

    public static native boolean keyedHourDistinct(long pRosti, long pKeys, long count);

    public static native boolean keyedHourKSumDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourMaxDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourMaxInt(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourMaxLong(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourMinDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourMinInt(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourMinLong(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourNSumDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourSumDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourSumInt(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedHourSumLong(long pRosti, long pKeys, long pLong, long count, int valueOffset);

    // sum long256
    public static native boolean keyedHourSumLong256(long pRosti, long pKeys, long pLong256, long count, int valueOffset);

    public static native boolean keyedHourSumLongLong(long pRosti, long pKeys, long pLong, long count, int valueOffset);

    public static native boolean keyedIntAvgDoubleWrapUp(long pRosti, int valueOffset, double valueAtNull, long valueAtNullCount);

    public static native boolean keyedIntAvgLongLongWrapUp(long pRosti, int valueOffset, double valueAtNull, long valueAtNullCount);

    // avg long
    public static native boolean keyedIntAvgLongWrapUp(long pRosti, int valueOffset, double valueAtNull, long valueAtNullCount);

    public static native boolean keyedIntCount(long pRosti, long pKeys, long count, int valueOffset);

    public static native boolean keyedIntCountDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntCountInt(long pRosti, long pKeys, long pInt, long count, int valueOffset);

    public static native boolean keyedIntCountLong(long pRosti, long pKeys, long pLong, long count, int valueOffset);

    public static native boolean keyedIntCountMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntCountWrapUp(long pRosti, int valueOffset, long valueAtNull);

    public static native boolean keyedIntDistinct(long pRosti, long pKeys, long count);

    // ksum double
    public static native boolean keyedIntKSumDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntKSumDoubleMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntKSumDoubleWrapUp(long pRosti, int valueOffset, double valueAtNull, long valueAtNullCount);

    // max double
    public static native boolean keyedIntMaxDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntMaxDoubleMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntMaxDoubleWrapUp(long pRosti, int valueOffset, double valueAtNull);

    // max int
    public static native boolean keyedIntMaxInt(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntMaxIntMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntMaxIntWrapUp(long pRosti, int valueOffset, int valueAtNull);

    // max long
    public static native boolean keyedIntMaxLong(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntMaxLongMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntMaxLongWrapUp(long pRosti, int valueOffset, long valueAtNull);

    // min double
    public static native boolean keyedIntMinDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntMinDoubleMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntMinDoubleWrapUp(long pRosti, int valueOffset, double valueAtNull);

    // min int
    public static native boolean keyedIntMinInt(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntMinIntMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntMinIntWrapUp(long pRosti, int valueOffset, int valueAtNull);

    // min long
    public static native boolean keyedIntMinLong(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntMinLongMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntMinLongWrapUp(long pRosti, int valueOffset, long valueAtNull);

    // nsum double
    public static native boolean keyedIntNSumDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntNSumDoubleMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntNSumDoubleWrapUp(long pRosti, int valueOffset, double valueAtNull, long valueAtNullCount, double valueAtNullC);

    // sum double
    public static native boolean keyedIntSumDouble(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntSumDoubleMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntSumDoubleWrapUp(long pRosti, int valueOffset, double valueAtNull, long valueAtNullCount);

    // sum int
    public static native boolean keyedIntSumInt(long pRosti, long pKeys, long pDouble, long count, int valueOffset);

    public static native boolean keyedIntSumIntMerge(long pRostiA, long pRostiB, int valueOffset);

    // sum long
    public static native boolean keyedIntSumLong(long pRosti, long pKeys, long pLong, long count, int valueOffset);

    public static native boolean keyedIntSumLong256(long pRosti, long pKeys, long pLong, long count, int valueOffset);

    public static native boolean keyedIntSumLong256Merge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntSumLong256WrapUp(long pRosti, int valueOffset, long v0, long v1, long v2, long v3, long valueAtNullCount);

    public static native boolean keyedIntSumLongLong(long pRosti, long pKeys, long pLong, long count, int valueOffset);

    public static native boolean keyedIntSumLongLongMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntSumLongLongWrapUp(long pRosti, int valueOffset, long valueAtNull, long valueAtNullCount);

    public static native boolean keyedIntSumLongMerge(long pRostiA, long pRostiB, int valueOffset);

    public static native boolean keyedIntSumLongWrapUp(long pRosti, int valueOffset, long valueAtNull, long valueAtNullCount);

    public static void printRosti(long pRosti) {
<span class="fc" id="L262">        final long slots = getSlots(pRosti);</span>
<span class="fc" id="L263">        final long shift = getSlotShift(pRosti);</span>
<span class="fc" id="L264">        long ctrl = getCtrl(pRosti);</span>
<span class="fc" id="L265">        final long start = ctrl;</span>
<span class="fc" id="L266">        long count = getSize(pRosti);</span>
<span class="fc" id="L267">        System.out.println(&quot;size=&quot; + count);</span>
<span class="fc" id="L268">        System.out.println(&quot;capacity=&quot; + getCapacity(pRosti));</span>
<span class="fc" id="L269">        System.out.println(&quot;slot size=&quot; + getSlotSize(pRosti));</span>
<span class="fc" id="L270">        System.out.println(&quot;slot shift=&quot; + getSlotShift(pRosti));</span>
<span class="fc" id="L271">        System.out.print(&quot;initial slot=&quot;);</span>
<span class="fc" id="L272">        long initialSlot = getInitialValuesSlot(pRosti);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        for (long i = 0, n = getSlotSize(pRosti); i &lt; n; i++) {</span>

<span class="fc" id="L275">            byte b = Unsafe.getUnsafe().getByte(initialSlot + i);</span>
            final int v;
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            if (b &lt; 0) {</span>
<span class="nc" id="L278">                v = 256 + b;</span>
            } else {
<span class="fc" id="L280">                v = b;</span>
            }

<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            if (v &lt; 0x10) {</span>
<span class="fc" id="L284">                System.out.print('0');</span>
<span class="fc" id="L285">                System.out.print(hexDigits[b]);</span>
            } else {
<span class="nc" id="L287">                System.out.print(hexDigits[v / 0x10]);</span>
<span class="nc" id="L288">                System.out.print(hexDigits[v % 0x10]);</span>
            }

<span class="fc" id="L291">            System.out.print(' ');</span>
        }
<span class="fc" id="L293">        System.out.println();</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        while (count &gt; 0) {</span>
<span class="nc" id="L295">            byte b = Unsafe.getUnsafe().getByte(ctrl);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">            if ((b &amp; 0x80) == 0) {</span>
<span class="nc" id="L297">                long p = slots + ((ctrl - start) &lt;&lt; shift);</span>
<span class="nc" id="L298">                System.out.println(Unsafe.getUnsafe().getInt(p) + &quot; -&gt; &quot; + Unsafe.getUnsafe().getDouble(p + 12));</span>
<span class="nc" id="L299">                count--;</span>
            }
<span class="nc" id="L301">            ctrl++;</span>
<span class="nc" id="L302">        }</span>
<span class="fc" id="L303">    }</span>

    public static boolean reset(long pRosti, int size) {
<span class="fc" id="L306">        long oldSize = Rosti.getAllocMemory(pRosti);</span>
<span class="fc" id="L307">        boolean success = reset0(pRosti, Numbers.ceilPow2(size) - 1);</span>
<span class="fc" id="L308">        updateMemoryUsage(pRosti, oldSize);</span>
<span class="fc" id="L309">        return success;</span>
    }

    public static void updateMemoryUsage(long pRosti, long oldSize) {
<span class="fc" id="L313">        long newSize = Rosti.getAllocMemory(pRosti);</span>
<span class="fc" id="L314">        Unsafe.recordMemAlloc(newSize - oldSize, MemoryTag.NATIVE_ROSTI);</span>
<span class="fc" id="L315">    }</span>

    private static native long alloc(long pKeyTypes, int keyTypeCount, long capacity);

    private static native void free0(long pRosti);

    //clears and shrinks to given size
    private static native boolean reset0(long pRosti, int size);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>