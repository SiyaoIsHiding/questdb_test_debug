<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Numbers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.std</a> &gt; <span class="el_source">Numbers.java</span></div><h1>Numbers.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.std;

// @formatter:off
import io.questdb.cairo.ImplicitCastException;
import io.questdb.std.datetime.microtime.Timestamps;
import io.questdb.std.fastdouble.FastDoubleParser;
import io.questdb.std.fastdouble.FastFloatParser;
import io.questdb.std.str.CharSink;
//#if jdk.version==8
//$import sun.misc.FDBigInteger;
//#else
import jdk.internal.math.FDBigInteger;
//#endif
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;

public final class Numbers {
    public static final int INT_NaN = Integer.MIN_VALUE;
    public static final long JULIAN_EPOCH_OFFSET_USEC = 946684800000000L;
    public static final long LONG_NaN = Long.MIN_VALUE;
    public static final int MAX_SCALE = 19;
    public static final int SIGNIFICAND_WIDTH = 53;
    public static final long SIGN_BIT_MASK = 0x8000000000000000L;
    public static final int SIZE_1MB = 1024 * 1024;
    public static final double TOLERANCE = 1E-15d;
<span class="fc" id="L51">    public static final char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};</span>
    public final static int[] hexNumbers;
    public final static int pow10max;
    private static final int EXP_BIAS = 1023;
    private static final long EXP_BIT_MASK = 0x7FF0000000000000L;
    private static final int EXP_SHIFT = SIGNIFICAND_WIDTH - 1;
    static final long EXP_ONE = ((long) EXP_BIAS) &lt;&lt; EXP_SHIFT; // exponent of 1.0
    private static final long FRACT_HOB = (1L &lt;&lt; EXP_SHIFT); // assumed High-Order bit
<span class="fc" id="L59">    private static final long[] LONG_5_POW = new long[]{1L, 5L, 25L, 125L, 625L, 3125L, 15625L, 78125L, 390625L, 1953125L, 9765625L, 48828125L, 244140625L, 1220703125L, 6103515625L, 30517578125L, 152587890625L, 762939453125L, 3814697265625L, 19073486328125L, 95367431640625L, 476837158203125L, 2384185791015625L, 11920928955078125L, 59604644775390625L, 298023223876953125L, 1490116119384765625L};</span>
    private static final int MAX_SMALL_BIN_EXP = 62;
    private static final int MIN_SMALL_BIN_EXP = -(63 / 3);
<span class="fc" id="L62">    private static final int[] N_5_BITS = new int[]{0, 3, 5, 7, 10, 12, 14, 17, 19, 21, 24, 26, 28, 31, 33, 35, 38, 40, 42, 45, 47, 49, 52, 54, 56, 59, 61};</span>
    private static final long SIGNIF_BIT_MASK = 0x000FFFFFFFFFFFFFL;
<span class="fc" id="L64">    private static final int[] SMALL_5_POW = new int[]{1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625, 48828125, 244140625, 1220703125};</span>
<span class="fc" id="L65">    private static final int[] insignificantDigitsNumber = new int[]{0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19};</span>
<span class="fc" id="L66">    private static final LongHexAppender[] longHexAppender = new LongHexAppender[Long.SIZE + 1];</span>
<span class="fc" id="L67">    private static final LongHexAppender[] longHexAppenderPad64 = new LongHexAppender[Long.SIZE + 1];</span>
    private static final long[] pow10;
<span class="fc" id="L69">    private static final double[] pow10dNeg =</span>
            new double[]{1, 1E-1, 1E-2, 1E-3, 1E-4, 1E-5, 1E-6, 1E-7, 1E-8, 1E-9, 1E-10, 1E-11, 1E-12, 1E-13, 1E-14, 1E-15, 1E-16, 1E-17, 1E-18, 1E-19, 1E-20, 1E-21, 1E-22, 1E-23, 1E-24, 1E-25, 1E-26, 1E-27, 1E-28, 1E-29, 1E-30, 1E-31, 1E-32, 1E-33, 1E-34, 1E-35, 1E-36, 1E-37, 1E-38, 1E-39, 1E-40, 1E-41, 1E-42, 1E-43, 1E-44, 1E-45, 1E-46, 1E-47, 1E-48, 1E-49, 1E-50, 1E-51, 1E-52, 1E-53, 1E-54, 1E-55, 1E-56, 1E-57, 1E-58, 1E-59, 1E-60, 1E-61, 1E-62, 1E-63, 1E-64, 1E-65, 1E-66, 1E-67, 1E-68, 1E-69, 1E-70, 1E-71, 1E-72, 1E-73, 1E-74, 1E-75, 1E-76, 1E-77, 1E-78, 1E-79, 1E-80, 1E-81, 1E-82, 1E-83, 1E-84, 1E-85, 1E-86, 1E-87, 1E-88, 1E-89, 1E-90, 1E-91, 1E-92, 1E-93, 1E-94, 1E-95, 1E-96, 1E-97, 1E-98, 1E-99, 1E-100, 1E-101, 1E-102, 1E-103, 1E-104, 1E-105, 1E-106, 1E-107, 1E-108, 1E-109, 1E-110, 1E-111, 1E-112, 1E-113, 1E-114, 1E-115, 1E-116, 1E-117, 1E-118, 1E-119, 1E-120, 1E-121, 1E-122, 1E-123, 1E-124, 1E-125, 1E-126, 1E-127, 1E-128, 1E-129, 1E-130, 1E-131, 1E-132, 1E-133, 1E-134, 1E-135, 1E-136, 1E-137, 1E-138, 1E-139, 1E-140, 1E-141, 1E-142, 1E-143, 1E-144, 1E-145, 1E-146, 1E-147, 1E-148, 1E-149, 1E-150, 1E-151, 1E-152, 1E-153, 1E-154, 1E-155, 1E-156, 1E-157, 1E-158, 1E-159, 1E-160, 1E-161, 1E-162, 1E-163, 1E-164, 1E-165, 1E-166, 1E-167, 1E-168, 1E-169, 1E-170, 1E-171, 1E-172, 1E-173, 1E-174, 1E-175, 1E-176, 1E-177, 1E-178, 1E-179, 1E-180, 1E-181, 1E-182, 1E-183, 1E-184, 1E-185, 1E-186, 1E-187, 1E-188, 1E-189, 1E-190, 1E-191, 1E-192, 1E-193, 1E-194, 1E-195, 1E-196, 1E-197, 1E-198, 1E-199, 1E-200, 1E-201, 1E-202, 1E-203, 1E-204, 1E-205, 1E-206, 1E-207, 1E-208, 1E-209, 1E-210, 1E-211, 1E-212, 1E-213, 1E-214, 1E-215, 1E-216, 1E-217, 1E-218, 1E-219, 1E-220, 1E-221, 1E-222, 1E-223, 1E-224, 1E-225, 1E-226, 1E-227, 1E-228, 1E-229, 1E-230, 1E-231, 1E-232, 1E-233, 1E-234, 1E-235, 1E-236, 1E-237, 1E-238, 1E-239, 1E-240, 1E-241, 1E-242, 1E-243, 1E-244, 1E-245, 1E-246, 1E-247, 1E-248, 1E-249, 1E-250, 1E-251, 1E-252, 1E-253, 1E-254, 1E-255, 1E-256, 1E-257, 1E-258, 1E-259, 1E-260, 1E-261, 1E-262, 1E-263, 1E-264, 1E-265, 1E-266, 1E-267, 1E-268, 1E-269, 1E-270, 1E-271, 1E-272, 1E-273, 1E-274, 1E-275, 1E-276, 1E-277, 1E-278, 1E-279, 1E-280, 1E-281, 1E-282, 1E-283, 1E-284, 1E-285, 1E-286, 1E-287, 1E-288, 1E-289, 1E-290, 1E-291, 1E-292, 1E-293, 1E-294, 1E-295, 1E-296, 1E-297, 1E-298, 1E-299, 1E-300, 1E-301, 1E-302, 1E-303, 1E-304, 1E-305, 1E-306, 1E-307, 1E-308};

    private Numbers() {
    }

    public static void append(CharSink sink, final float value, int scale) {
<span class="fc" id="L76">        float f = value;</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (f == Float.POSITIVE_INFINITY) {</span>
<span class="fc" id="L78">            sink.put(&quot;Infinity&quot;);</span>
<span class="fc" id="L79">            return;</span>
        }

<span class="fc bfc" id="L82" title="All 2 branches covered.">        if (f == Float.NEGATIVE_INFINITY) {</span>
<span class="fc" id="L83">            sink.put(&quot;-Infinity&quot;);</span>
<span class="fc" id="L84">            return;</span>
        }

<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (Float.isNaN(f)) {</span>
<span class="fc" id="L88">            sink.put(&quot;NaN&quot;);</span>
<span class="fc" id="L89">            return;</span>
        }

        // it is very awkward to distinguish between 0.0 and -0.0
        // -0.0 &lt; 0 is false
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">        if (f &lt; 0 || 1 / f == Float.NEGATIVE_INFINITY) {</span>
<span class="fc" id="L95">            sink.put('-');</span>
<span class="fc" id="L96">            f = -f;</span>
        }
<span class="fc" id="L98">        int factor = (int) pow10[scale];</span>
<span class="fc" id="L99">        int scaled = (int) (f * factor + 0.5);</span>
<span class="fc" id="L100">        int targetScale = scale + 1;</span>
        int z;
<span class="fc bfc" id="L102" title="All 4 branches covered.">        while (targetScale &lt; 11 &amp;&amp; (z = factor * 10) &lt;= scaled) {</span>
<span class="fc" id="L103">            factor = z;</span>
<span class="fc" id="L104">            targetScale++;</span>
        }

<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (targetScale == 11) {</span>
<span class="fc" id="L108">            sink.put(Float.toString(f));</span>
<span class="fc" id="L109">            return;</span>
        }

<span class="fc bfc" id="L112" title="All 2 branches covered.">        while (targetScale &gt; 0) {</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">            if (targetScale-- == scale) {</span>
<span class="fc" id="L114">                sink.put('.');</span>
            }
<span class="fc" id="L116">            sink.put((char) ('0' + scaled / factor % 10));</span>
<span class="fc" id="L117">            factor /= 10;</span>
        }
<span class="fc" id="L119">    }</span>

    public static void append(CharSink sink, final int value) {
<span class="fc" id="L122">        int i = value;</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            if (i == Integer.MIN_VALUE) {</span>
<span class="fc" id="L125">                sink.put(&quot;NaN&quot;);</span>
<span class="fc" id="L126">                return;</span>
            }
<span class="fc" id="L128">            sink.put('-');</span>
<span class="fc" id="L129">            i = -i;</span>
        }
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (i &lt; 10) {</span>
<span class="fc" id="L132">            sink.put((char) ('0' + i));</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        } else if (i &lt; 100) {  // two</span>
<span class="fc" id="L134">            appendInt2(sink, i);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        } else if (i &lt; 1000) { // three</span>
<span class="fc" id="L136">            appendInt3(sink, i);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        } else if (i &lt; 10000) { // four</span>
<span class="fc" id="L138">            appendInt4(sink, i);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        } else if (i &lt; 100000) { // five</span>
<span class="fc" id="L140">            appendInt5(sink, i);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        } else if (i &lt; 1000000) { // six</span>
<span class="fc" id="L142">            appendInt6(sink, i);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        } else if (i &lt; 10000000) { // seven</span>
<span class="fc" id="L144">            appendInt7(sink, i);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        } else if (i &lt; 100000000) { // eight</span>
<span class="fc" id="L146">            appendInt8(sink, i);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        } else if (i &lt; 1000000000) { // nine</span>
<span class="fc" id="L148">            appendInt9(sink, i);</span>
        } else {
            // ten
<span class="fc" id="L151">            appendInt10(sink, i);</span>
        }
<span class="fc" id="L153">    }</span>

    public static void append(CharSink sink, final long value) {
<span class="fc" id="L156">        append(sink, value, true);</span>
<span class="fc" id="L157">    }</span>

    public static void append(CharSink sink, final long value, final boolean checkNaN) {
<span class="fc" id="L160">        long i = value;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (i == Long.MIN_VALUE) {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                if (checkNaN) {</span>
<span class="fc" id="L164">                    sink.put(&quot;NaN&quot;);</span>
                } else {
                    // we cannot negate Long.MIN_VALUE, so we have to special case it
<span class="fc" id="L167">                    sink.put(&quot;-9223372036854775808&quot;);</span>
                }
<span class="fc" id="L169">                return;</span>
            }
<span class="fc" id="L171">            sink.put('-');</span>
<span class="fc" id="L172">            i = -i;</span>
        }

<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (i &lt; 10) {</span>
<span class="fc" id="L176">            sink.put((char) ('0' + i));</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        } else if (i &lt; 100) {  // two</span>
<span class="fc" id="L178">            appendLong2(sink, i);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        } else if (i &lt; 1000) { // three</span>
<span class="fc" id="L180">            appendLong3(sink, i);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        } else if (i &lt; 10000) { // four</span>
<span class="fc" id="L182">            appendLong4(sink, i);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        } else if (i &lt; 100000) { // five</span>
<span class="fc" id="L184">            appendLong5(sink, i);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        } else if (i &lt; 1000000) { // six</span>
<span class="fc" id="L186">            appendLong6(sink, i);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        } else if (i &lt; 10000000) { // seven</span>
<span class="fc" id="L188">            appendLong7(sink, i);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        } else if (i &lt; 100000000) { // eight</span>
<span class="fc" id="L190">            appendLong8(sink, i);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        } else if (i &lt; 1000000000) { // nine</span>
<span class="fc" id="L192">            appendLong9(sink, i);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        } else if (i &lt; 10000000000L) {</span>
<span class="fc" id="L194">            appendLong10(sink, i);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        } else if (i &lt; 100000000000L) { //  eleven</span>
<span class="fc" id="L196">            appendLong11(sink, i);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        } else if (i &lt; 1000000000000L) { //  twelve</span>
<span class="fc" id="L198">            appendLong12(sink, i);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        } else if (i &lt; 10000000000000L) { //  thirteen</span>
<span class="fc" id="L200">            appendLong13(sink, i);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        } else if (i &lt; 100000000000000L) { //  fourteen</span>
<span class="fc" id="L202">            appendLong14(sink, i);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        } else if (i &lt; 1000000000000000L) { //  fifteen</span>
<span class="fc" id="L204">            appendLong15(sink, i);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        } else if (i &lt; 10000000000000000L) { //  sixteen</span>
<span class="fc" id="L206">            appendLong16(sink, i);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        } else if (i &lt; 100000000000000000L) { //  seventeen</span>
<span class="fc" id="L208">            appendLong17(sink, i);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        } else if (i &lt; 1000000000000000000L) { //  eighteen</span>
<span class="fc" id="L210">            appendLong18(sink, i);</span>
        } else { //  nineteen
<span class="fc" id="L212">            appendLong19(sink, i);</span>
        }
<span class="fc" id="L214">    }</span>

    public static void append(CharSink sink, double value) {
<span class="fc" id="L217">        append(sink, value, MAX_SCALE);</span>
<span class="fc" id="L218">    }</span>

    public static void append(CharSink sink, double value, int scale) {
<span class="fc" id="L221">        final char[] digits = sink.getDoubleDigitsBuffer();</span>
<span class="fc" id="L222">        final long doubleBits = Double.doubleToRawLongBits(value);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        boolean negative = (doubleBits &amp; SIGN_BIT_MASK) != 0L;</span>
<span class="fc" id="L224">        long significantBitCount = doubleBits &amp; SIGNIF_BIT_MASK;</span>
<span class="fc" id="L225">        int binExp = (int) ((doubleBits &amp; EXP_BIT_MASK) &gt;&gt; EXP_SHIFT);</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (binExp == 2047) {</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (significantBitCount == 0L) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if (negative) {</span>
<span class="fc" id="L230">                    sink.put(&quot;-Infinity&quot;);</span>
                } else {
<span class="fc" id="L232">                    sink.put(&quot;Infinity&quot;);</span>
                }
            } else {
<span class="fc" id="L235">                sink.put(&quot;NaN&quot;);</span>
            }
        } else {
            int fractionBits;
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (binExp == 0) {</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                if (significantBitCount == 0L) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                    if (negative) {</span>
<span class="fc" id="L242">                        sink.put(&quot;-0.0&quot;);</span>
                    } else {
<span class="fc" id="L244">                        sink.put(&quot;0.0&quot;);</span>
                    }
<span class="fc" id="L246">                    return;</span>
                }

<span class="fc" id="L249">                int leadingZeros = Long.numberOfLeadingZeros(significantBitCount);</span>
<span class="fc" id="L250">                int shift = leadingZeros - (63 - EXP_SHIFT);</span>
<span class="fc" id="L251">                significantBitCount &lt;&lt;= shift;</span>
<span class="fc" id="L252">                binExp = 1 - shift;</span>
<span class="fc" id="L253">                fractionBits = 64 - leadingZeros;</span>
<span class="fc" id="L254">            } else {</span>
<span class="fc" id="L255">                significantBitCount |= FRACT_HOB;</span>
<span class="fc" id="L256">                fractionBits = 53;</span>
            }

<span class="fc" id="L259">            binExp -= EXP_BIAS;</span>

<span class="fc" id="L261">            appendDouble0(binExp, significantBitCount, fractionBits, negative, digits, sink, scale);</span>
        }
<span class="fc" id="L263">    }</span>

    public static void appendHex(CharSink sink, final int value) {
<span class="fc" id="L266">        int i = value;</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (i &lt; 0) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (i == Integer.MIN_VALUE) {</span>
<span class="nc" id="L269">                sink.put(&quot;NaN&quot;);</span>
<span class="nc" id="L270">                return;</span>
            }
<span class="nc" id="L272">            sink.put('-');</span>
<span class="nc" id="L273">            i = -i;</span>
        }
        int c;
<span class="fc bfc" id="L276" title="All 2 branches covered.">        if (i &lt; 0x10) {</span>
<span class="fc" id="L277">            sink.put('0');</span>
<span class="fc" id="L278">            sink.put(hexDigits[i]);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        } else if (i &lt; 0x100) {  // two</span>
<span class="fc" id="L280">            sink.put(hexDigits[i / 0x10]);</span>
<span class="fc" id="L281">            sink.put(hexDigits[i % 0x10]);</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        } else if (i &lt; 0x1000) { // three</span>
<span class="fc" id="L283">            sink.put('0');</span>
<span class="fc" id="L284">            sink.put(hexDigits[i / 0x100]);</span>
<span class="fc" id="L285">            sink.put(hexDigits[(c = i % 0x100) / 0x10]);</span>
<span class="fc" id="L286">            sink.put(hexDigits[c % 0x10]);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        } else if (i &lt; 0x10000) { // four</span>
<span class="nc" id="L288">            sink.put(hexDigits[i / 0x1000]);</span>
<span class="nc" id="L289">            sink.put(hexDigits[(c = i % 0x1000) / 0x100]);</span>
<span class="nc" id="L290">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L291">            sink.put(hexDigits[c % 0x10]);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        } else if (i &lt; 0x100000) { // five</span>
<span class="nc" id="L293">            sink.put('0');</span>
<span class="nc" id="L294">            sink.put(hexDigits[i / 0x10000]);</span>
<span class="nc" id="L295">            sink.put(hexDigits[(c = i % 0x10000) / 0x1000]);</span>
<span class="nc" id="L296">            sink.put(hexDigits[(c = c % 0x1000) / 0x100]);</span>
<span class="nc" id="L297">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L298">            sink.put(hexDigits[c % 0x10]);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        } else if (i &lt; 0x1000000) { // six</span>
<span class="nc" id="L300">            sink.put(hexDigits[i / 0x100000]);</span>
<span class="nc" id="L301">            sink.put(hexDigits[(c = i % 0x100000) / 0x10000]);</span>
<span class="nc" id="L302">            sink.put(hexDigits[(c = c % 0x10000) / 0x1000]);</span>
<span class="nc" id="L303">            sink.put(hexDigits[(c = c % 0x1000) / 0x100]);</span>
<span class="nc" id="L304">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L305">            sink.put(hexDigits[c % 0x10]);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        } else if (i &lt; 0x10000000) { // seven</span>
<span class="nc" id="L307">            sink.put('0');</span>
<span class="nc" id="L308">            sink.put(hexDigits[i / 0x1000000]);</span>
<span class="nc" id="L309">            sink.put(hexDigits[(c = i % 0x1000000) / 0x100000]);</span>
<span class="nc" id="L310">            sink.put(hexDigits[(c = c % 0x100000) / 0x10000]);</span>
<span class="nc" id="L311">            sink.put(hexDigits[(c = c % 0x10000) / 0x1000]);</span>
<span class="nc" id="L312">            sink.put(hexDigits[(c = c % 0x1000) / 0x100]);</span>
<span class="nc" id="L313">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L314">            sink.put(hexDigits[c % 0x10]);</span>
        } else { // eight
<span class="nc" id="L316">            sink.put(hexDigits[i / 0x10000000]);</span>
<span class="nc" id="L317">            sink.put(hexDigits[(c = i % 0x10000000) / 0x1000000]);</span>
<span class="nc" id="L318">            sink.put(hexDigits[(c = c % 0x1000000) / 0x100000]);</span>
<span class="nc" id="L319">            sink.put(hexDigits[(c = c % 0x100000) / 0x10000]);</span>
<span class="nc" id="L320">            sink.put(hexDigits[(c = c % 0x10000) / 0x1000]);</span>
<span class="nc" id="L321">            sink.put(hexDigits[(c = c % 0x1000) / 0x100]);</span>
<span class="nc" id="L322">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L323">            sink.put(hexDigits[c % 0x10]);</span>
        }
<span class="fc" id="L325">    }</span>

    public static void appendHex(CharSink sink, final long value, boolean pad) {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (value == Integer.MIN_VALUE) {</span>
<span class="nc" id="L329">            sink.put(&quot;NaN&quot;);</span>
<span class="nc" id="L330">            return;</span>
        }
<span class="fc bfc" id="L332" title="All 2 branches covered.">        int bit = value == 0 ? 0 : 64 - Long.numberOfLeadingZeros(value);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        LongHexAppender[] array = pad ? longHexAppenderPad64 : longHexAppender;</span>
<span class="fc" id="L334">        array[bit].append(sink, value);</span>
<span class="fc" id="L335">    }</span>

    /**
     * Append a long value to a CharSink in hex format.
     * 
     * @param sink the CharSink to append to
     * @param value the value to append
     * @param padToBytes if non-zero, pad the output to the specified number of bytes
     */
    public static void appendHexPadded(CharSink sink, long value, int padToBytes) {
<span class="pc bpc" id="L345" title="2 of 4 branches missed.">        assert padToBytes &gt;= 0 &amp;&amp; padToBytes &lt;= 8;</span>
        // This code might be unclear, so here are some hints: 
        // This method uses longHexAppender() and longHexAppender() is always padding to a whole byte. It never prints
        // just a nibble. It means the longHexAppender() will print value 0xf as &quot;0f&quot;. Value 0xff will be printed as &quot;ff&quot;.
        // Value 0xfff will be printed as &quot;0fff&quot;. Value 0xffff will be printed as &quot;ffff&quot; and so on. 
        // So this method needs to pad only from the next whole byte up.
        // In other words: This method always pads with full bytes (=even number of zeros), never with just a nibble.

        // Example 1: Value is 0xF and padToBytes is 2. This means the desired output is 000f. 
        // longHexAppender() pads to a full byte. This means it will output is 0f. So this method needs to pad with 2 zeros.

        // Example 2: The value is 0xFF and padToBytes is 2. This means the desired output is 00ff.
        // longHexAppender() will output &quot;ff&quot;. This is a full byte so longHexAppender() will not do any padding on its own. 
        // So this method needs to pad with 2 zeros.
<span class="fc" id="L359">        int leadingZeroBits = Long.numberOfLeadingZeros(value);</span>
<span class="fc" id="L360">        int padToBits = padToBytes &lt;&lt; 3;</span>
<span class="fc" id="L361">        int bitsToPad = padToBits - (Long.SIZE - leadingZeroBits);</span>
<span class="fc" id="L362">        int bytesToPad = (bitsToPad &gt;&gt; 3);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        for (int i = 0; i &lt; bytesToPad; i++) {</span>
<span class="fc" id="L364">            sink.put('0');</span>
<span class="fc" id="L365">            sink.put('0');</span>
        }
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (value == 0) {</span>
<span class="fc" id="L368">            return;</span>
        }
<span class="fc" id="L370">        int bit = 64 - leadingZeroBits;</span>
<span class="fc" id="L371">        longHexAppender[bit].append(sink, value);</span>
<span class="fc" id="L372">    }</span>

    public static void appendHexPadded(CharSink sink, final int value) {
<span class="fc" id="L375">        int i = value;</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if (i &lt; 0) {</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (i == Integer.MIN_VALUE) {</span>
<span class="nc" id="L378">                sink.put(&quot;NaN&quot;);</span>
<span class="nc" id="L379">                return;</span>
            }
<span class="nc" id="L381">            sink.put('-');</span>
<span class="nc" id="L382">            i = -i;</span>
        }
        int c;
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (i &lt; 0x10) {</span>
<span class="fc" id="L386">            sink.put('0');</span>
<span class="fc" id="L387">            sink.put('0');</span>
<span class="fc" id="L388">            sink.put('0');</span>
<span class="fc" id="L389">            sink.put('0');</span>
<span class="fc" id="L390">            sink.put('0');</span>
<span class="fc" id="L391">            sink.put('0');</span>
<span class="fc" id="L392">            sink.put('0');</span>
<span class="fc" id="L393">            sink.put(hexDigits[i]);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        } else if (i &lt; 0x100) {  // two</span>
<span class="fc" id="L395">            sink.put('0');</span>
<span class="fc" id="L396">            sink.put('0');</span>
<span class="fc" id="L397">            sink.put('0');</span>
<span class="fc" id="L398">            sink.put('0');</span>
<span class="fc" id="L399">            sink.put('0');</span>
<span class="fc" id="L400">            sink.put('0');</span>
<span class="fc" id="L401">            sink.put(hexDigits[i / 0x10]);</span>
<span class="fc" id="L402">            sink.put(hexDigits[i % 0x10]);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        } else if (i &lt; 0x1000) { // three</span>
<span class="fc" id="L404">            sink.put('0');</span>
<span class="fc" id="L405">            sink.put('0');</span>
<span class="fc" id="L406">            sink.put('0');</span>
<span class="fc" id="L407">            sink.put('0');</span>
<span class="fc" id="L408">            sink.put('0');</span>
<span class="fc" id="L409">            sink.put(hexDigits[i / 0x100]);</span>
<span class="fc" id="L410">            sink.put(hexDigits[(c = i % 0x100) / 0x10]);</span>
<span class="fc" id="L411">            sink.put(hexDigits[c % 0x10]);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        } else if (i &lt; 0x10000) { // four</span>
<span class="nc" id="L413">            sink.put('0');</span>
<span class="nc" id="L414">            sink.put('0');</span>
<span class="nc" id="L415">            sink.put('0');</span>
<span class="nc" id="L416">            sink.put('0');</span>
<span class="nc" id="L417">            sink.put(hexDigits[i / 0x1000]);</span>
<span class="nc" id="L418">            sink.put(hexDigits[(c = i % 0x1000) / 0x100]);</span>
<span class="nc" id="L419">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L420">            sink.put(hexDigits[c % 0x10]);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        } else if (i &lt; 0x100000) { // five</span>
<span class="nc" id="L422">            sink.put('0');</span>
<span class="nc" id="L423">            sink.put('0');</span>
<span class="nc" id="L424">            sink.put('0');</span>
<span class="nc" id="L425">            sink.put(hexDigits[i / 0x10000]);</span>
<span class="nc" id="L426">            sink.put(hexDigits[(c = i % 0x10000) / 0x1000]);</span>
<span class="nc" id="L427">            sink.put(hexDigits[(c = c % 0x1000) / 0x100]);</span>
<span class="nc" id="L428">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L429">            sink.put(hexDigits[c % 0x10]);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        } else if (i &lt; 0x1000000) { // six</span>
<span class="nc" id="L431">            sink.put('0');</span>
<span class="nc" id="L432">            sink.put('0');</span>
<span class="nc" id="L433">            sink.put(hexDigits[i / 0x100000]);</span>
<span class="nc" id="L434">            sink.put(hexDigits[(c = i % 0x100000) / 0x10000]);</span>
<span class="nc" id="L435">            sink.put(hexDigits[(c = c % 0x10000) / 0x1000]);</span>
<span class="nc" id="L436">            sink.put(hexDigits[(c = c % 0x1000) / 0x100]);</span>
<span class="nc" id="L437">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L438">            sink.put(hexDigits[c % 0x10]);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        } else if (i &lt; 0x10000000) { // seven</span>
<span class="nc" id="L440">            sink.put('0');</span>
<span class="nc" id="L441">            sink.put(hexDigits[i / 0x1000000]);</span>
<span class="nc" id="L442">            sink.put(hexDigits[(c = i % 0x1000000) / 0x100000]);</span>
<span class="nc" id="L443">            sink.put(hexDigits[(c = c % 0x100000) / 0x10000]);</span>
<span class="nc" id="L444">            sink.put(hexDigits[(c = c % 0x10000) / 0x1000]);</span>
<span class="nc" id="L445">            sink.put(hexDigits[(c = c % 0x1000) / 0x100]);</span>
<span class="nc" id="L446">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L447">            sink.put(hexDigits[c % 0x10]);</span>
        } else { // eight
<span class="nc" id="L449">            sink.put(hexDigits[i / 0x10000000]);</span>
<span class="nc" id="L450">            sink.put(hexDigits[(c = i % 0x10000000) / 0x1000000]);</span>
<span class="nc" id="L451">            sink.put(hexDigits[(c = c % 0x1000000) / 0x100000]);</span>
<span class="nc" id="L452">            sink.put(hexDigits[(c = c % 0x100000) / 0x10000]);</span>
<span class="nc" id="L453">            sink.put(hexDigits[(c = c % 0x10000) / 0x1000]);</span>
<span class="nc" id="L454">            sink.put(hexDigits[(c = c % 0x1000) / 0x100]);</span>
<span class="nc" id="L455">            sink.put(hexDigits[(c = c % 0x100) / 0x10]);</span>
<span class="nc" id="L456">            sink.put(hexDigits[c % 0x10]);</span>
        }
<span class="fc" id="L458">    }</span>

    public static void appendLong256(long a, long b, long c, long d, CharSink sink) {
<span class="pc bpc" id="L461" title="2 of 8 branches missed.">        if (a == Numbers.LONG_NaN &amp;&amp; b == Numbers.LONG_NaN &amp;&amp; c == Numbers.LONG_NaN &amp;&amp; d == Numbers.LONG_NaN) {</span>
<span class="fc" id="L462">            return;</span>
        }
<span class="fc" id="L464">        sink.put(&quot;0x&quot;);</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if (d != 0L) {</span>
<span class="fc" id="L466">            appendLong256Four(a, b, c, d, sink);</span>
<span class="fc" id="L467">            return;</span>
        }

<span class="fc bfc" id="L470" title="All 2 branches covered.">        if (c != 0L) {</span>
<span class="fc" id="L471">            appendLong256Three(a, b, c, sink);</span>
<span class="fc" id="L472">            return;</span>
        }

<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (b != 0L) {</span>
<span class="fc" id="L476">            appendLong256Two(a, b, sink);</span>
<span class="fc" id="L477">            return;</span>
        }

<span class="fc" id="L480">        appendHex(sink, a, false);</span>
<span class="fc" id="L481">    }</span>

    public static void appendUuid(long lo, long hi, CharSink sink) {
<span class="fc" id="L484">        appendHexPadded(sink, (hi &gt;&gt; 32) &amp; 0xFFFFFFFFL, 4);</span>
<span class="fc" id="L485">        sink.put('-');</span>
<span class="fc" id="L486">        appendHexPadded(sink, (hi &gt;&gt; 16) &amp; 0xFFFF, 2);</span>
<span class="fc" id="L487">        sink.put('-');</span>
<span class="fc" id="L488">        appendHexPadded(sink, hi &amp; 0xFFFF, 2);</span>
<span class="fc" id="L489">        sink.put('-');</span>
<span class="fc" id="L490">        appendHexPadded(sink, lo &gt;&gt; 48 &amp; 0xFFFF, 2);</span>
<span class="fc" id="L491">        sink.put('-');</span>
<span class="fc" id="L492">        appendHexPadded(sink, lo &amp; 0xFFFFFFFFFFFFL, 6);</span>
<span class="fc" id="L493">    }</span>

    public static int bswap(int value) {
<span class="fc" id="L496">        return ((value &gt;&gt; 24) &amp; 0xff) | ((value &lt;&lt; 8) &amp; 0xff0000) | ((value &gt;&gt; 8) &amp; 0xff00) | ((value &lt;&lt; 24) &amp; 0xff000000);</span>
    }

    public static short bswap(short value) {
<span class="fc" id="L500">        return (short) ((((value &gt;&gt; 8) &amp; 0xff) | (value &lt;&lt; 8)) &amp; 0xffff);</span>
    }

    public static long bswap(long val) {
<span class="fc" id="L504">        val = ((val &lt;&lt; 8) &amp; 0xFF00FF00FF00FF00L) | ((val &gt;&gt; 8) &amp; 0x00FF00FF00FF00FFL);</span>
<span class="fc" id="L505">        val = ((val &lt;&lt; 16) &amp; 0xFFFF0000FFFF0000L) | ((val &gt;&gt; 16) &amp; 0x0000FFFF0000FFFFL);</span>
<span class="fc" id="L506">        return (val &lt;&lt; 32) | ((val &gt;&gt; 32) &amp; 0xFFFFFFFFL);</span>
    }

    public static int ceilPow2(int value) {
<span class="fc" id="L510">        int i = value;</span>
<span class="fc bfc" id="L511" title="All 4 branches covered.">        if ((i != 0) &amp;&amp; (i &amp; (i - 1)) &gt; 0) {</span>
<span class="fc" id="L512">            i |= (i &gt;&gt;&gt; 1);</span>
<span class="fc" id="L513">            i |= (i &gt;&gt;&gt; 2);</span>
<span class="fc" id="L514">            i |= (i &gt;&gt;&gt; 4);</span>
<span class="fc" id="L515">            i |= (i &gt;&gt;&gt; 8);</span>
<span class="fc" id="L516">            i |= (i &gt;&gt;&gt; 16);</span>
<span class="fc" id="L517">            i++;</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">            if (i &lt; 0) {</span>
<span class="fc" id="L520">                i &gt;&gt;&gt;= 1;</span>
            }
        }

<span class="fc" id="L524">        return i;</span>
    }

    public static long ceilPow2(long value) {
<span class="fc" id="L528">        long i = value;</span>
<span class="pc bpc" id="L529" title="1 of 4 branches missed.">        if ((i != 0) &amp;&amp; (i &amp; (i - 1)) &gt; 0) {</span>
<span class="fc" id="L530">            i |= (i &gt;&gt;&gt; 1);</span>
<span class="fc" id="L531">            i |= (i &gt;&gt;&gt; 2);</span>
<span class="fc" id="L532">            i |= (i &gt;&gt;&gt; 4);</span>
<span class="fc" id="L533">            i |= (i &gt;&gt;&gt; 8);</span>
<span class="fc" id="L534">            i |= (i &gt;&gt;&gt; 16);</span>
<span class="fc" id="L535">            i |= (i &gt;&gt;&gt; 32);</span>
<span class="fc" id="L536">            i++;</span>

<span class="pc bpc" id="L538" title="1 of 2 branches missed.">            if (i &lt; 0) {</span>
<span class="nc" id="L539">                i &gt;&gt;&gt;= 1;</span>
            }
        }
<span class="fc" id="L542">        return i;</span>
    }

    public static int compare(double a, double b) {
<span class="fc bfc" id="L546" title="All 2 branches covered.">        if (a &lt; b) {</span>
<span class="fc" id="L547">            return -1;</span>
        }

<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (a &gt; b) {</span>
<span class="fc" id="L551">            return 1;</span>
        }

        // Cannot use doubleToRawLongBits because of possibility of NaNs.
<span class="fc" id="L555">        long thisBits = Double.doubleToLongBits(1);</span>
<span class="fc" id="L556">        long anotherBits = Double.doubleToLongBits(b);</span>

        // Values are equal
        // (-0.0, 0.0) or (!NaN, NaN)
<span class="fc" id="L560">        return Long.compare(anotherBits, thisBits);</span>
    }

    public static int compare(float a, float b) {
<span class="fc bfc" id="L564" title="All 2 branches covered.">        if (a &lt; b) {</span>
<span class="fc" id="L565">            return -1;</span>
        }
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (a &gt; b) {</span>
<span class="fc" id="L568">            return 1;</span>
        }

        // Cannot use floatToRawIntBits because of possibility of NaNs.
<span class="nc" id="L572">        int thisBits = Float.floatToIntBits(a);</span>
<span class="nc" id="L573">        int anotherBits = Float.floatToIntBits(b);</span>

        // Values are equal
        // (-0.0, 0.0) or (!NaN, NaN)
<span class="nc" id="L577">        return Integer.compare(anotherBits, thisBits);                          // (0.0, -0.0) or (NaN, !NaN)</span>
    }

    public static int decodeHighInt(long val) {
<span class="fc" id="L581">        return (int) (val &gt;&gt; 32);</span>
    }

    public static short decodeHighShort(int val) {
<span class="fc" id="L585">        return (short) (val &gt;&gt; 16);</span>
    }

    public static int decodeLowInt(long val) {
<span class="fc" id="L589">        return (int) (val &amp; 0xffffffffL);</span>
    }

    public static short decodeLowShort(int val) {
<span class="fc" id="L593">        return (short) (val &amp; 0xffff);</span>
    }

    public static long encodeLowHighInts(int low, int high) {
<span class="fc" id="L597">        return ((Integer.toUnsignedLong(high)) &lt;&lt; 32L) | Integer.toUnsignedLong(low);</span>
    }

    public static int encodeLowHighShorts(short low, short high) {
<span class="fc" id="L601">        return ((Short.toUnsignedInt(high)) &lt;&lt; 16) | Short.toUnsignedInt(low);</span>
    }

    public static boolean extractLong256(CharSequence value, int len, Long256Acceptor acceptor) {
<span class="fc bfc" id="L605" title="All 10 branches covered.">        if (len &gt; 2 &amp;&amp; ((len &amp; 1) == 0) &amp;&amp; len &lt; 67 &amp;&amp; value.charAt(0) == '0' &amp;&amp; value.charAt(1) == 'x') {</span>
            try {
<span class="fc" id="L607">                Long256FromCharSequenceDecoder.decode(value, 2, len, acceptor);</span>
<span class="fc" id="L608">                return true;</span>
<span class="fc" id="L609">            } catch (ImplicitCastException e) {</span>
<span class="fc" id="L610">                return false;</span>
            }
        }
<span class="fc" id="L613">        return false;</span>
    }

    public static int hexToDecimal(int c) throws NumericException {
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (c &gt; 127) {</span>
<span class="fc" id="L618">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L620">        int r = hexNumbers[c];</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (r == -1) {</span>
<span class="fc" id="L622">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L624">        return r;</span>
    }

    public static double intToDouble(int value) {
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">        if (value != Numbers.INT_NaN) {</span>
<span class="fc" id="L629">            return value;</span>
        }
<span class="nc" id="L631">        return Double.NaN;</span>
    }

    public static float intToFloat(int value) {
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (value != Numbers.INT_NaN) {</span>
<span class="fc" id="L636">            return value;</span>
        }
<span class="nc" id="L638">        return Float.NaN;</span>
    }

    public static long intToLong(int value) {
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">        if (value != Numbers.INT_NaN) {</span>
<span class="fc" id="L643">            return value;</span>
        }
<span class="nc" id="L645">        return Numbers.LONG_NaN;</span>
    }

    public static long interleaveBits(long x, long y) {
<span class="fc" id="L649">        return spreadBits(x) | (spreadBits(y) &lt;&lt; 1);</span>
    }

    public static boolean isFinite(double d) {
<span class="fc bfc" id="L653" title="All 2 branches covered.">        return ((Double.doubleToRawLongBits(d) &amp; EXP_BIT_MASK) != EXP_BIT_MASK);</span>
    }

    public static boolean isPow2(int value) {
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        return (value &amp; (value - 1)) == 0;</span>
    }

    public static float longToFloat(long value) {
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (value != Numbers.LONG_NaN) {</span>
<span class="nc" id="L662">            return value;</span>
        }
<span class="nc" id="L664">        return Float.NaN;</span>
    }

    public static int msb(int value) {
<span class="fc" id="L668">        return 31 - Integer.numberOfLeadingZeros(value);</span>
    }

    public static int msb(long value) {
<span class="fc" id="L672">        return 63 - Long.numberOfLeadingZeros(value);</span>
    }

    public static boolean notDigit(char c) {
<span class="fc bfc" id="L676" title="All 4 branches covered.">        return c &lt; '0' || c &gt; '9';</span>
    }

    public static double parseDouble(CharSequence sequence) throws NumericException {
<span class="fc" id="L680">        return FastDoubleParser.parseDouble(sequence, true);</span>
    }

    public static double parseDouble(long str, int len) throws NumericException {
<span class="fc" id="L684">        return FastDoubleParser.parseDouble(str, len, true);</span>
    }

    public static float parseFloat(CharSequence sequence) throws NumericException {
<span class="fc" id="L688">        return FastFloatParser.parseFloat(sequence, true);</span>
    }

    public static int parseHexInt(CharSequence sequence) throws NumericException {
<span class="fc" id="L692">        return parseHexInt(sequence, 0, sequence.length());</span>
    }

    public static int parseHexInt(CharSequence sequence, int lo, int hi) throws NumericException {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        if (hi == 0) {</span>
<span class="nc" id="L697">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L700">        int val = 0;</span>
        int r;
<span class="fc bfc" id="L702" title="All 2 branches covered.">        for (int i = lo; i &lt; hi; i++) {</span>
<span class="fc" id="L703">            int c = sequence.charAt(i);</span>
<span class="fc" id="L704">            int n = val &lt;&lt; 4;</span>
<span class="fc" id="L705">            r = n + hexToDecimal(c);</span>
<span class="fc" id="L706">            val = r;</span>
        }
<span class="fc" id="L708">        return val;</span>
    }

    public static long parseHexLong(CharSequence sequence, int lo, int hi) throws NumericException {
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        if (hi == 0) {</span>
<span class="nc" id="L713">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L716">        long val = 0;</span>
        long r;
<span class="fc bfc" id="L718" title="All 2 branches covered.">        for (int i = lo; i &lt; hi; i++) {</span>
<span class="fc" id="L719">            int c = sequence.charAt(i);</span>
<span class="fc" id="L720">            long n = val &lt;&lt; 4;</span>
<span class="fc" id="L721">            r = n + hexToDecimal(c);</span>
<span class="fc" id="L722">            val = r;</span>
        }
<span class="fc" id="L724">        return val;</span>
    }

    public static int parseInt(CharSequence sequence) throws NumericException {
<span class="fc bfc" id="L728" title="All 2 branches covered.">        if (sequence == null) {</span>
<span class="fc" id="L729">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L732">        return parseInt0(sequence, 0, sequence.length());</span>
    }

    public static int parseInt(CharSequence sequence, int p, int lim) throws NumericException {
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">        if (sequence == null) {</span>
<span class="nc" id="L737">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L739">        return parseInt0(sequence, p, lim);</span>
    }

    public static long parseInt000Greedy(CharSequence sequence, final int p, int lim) throws NumericException {

<span class="fc bfc" id="L744" title="All 2 branches covered.">        if (lim == p) {</span>
<span class="fc" id="L745">            throw NumericException.INSTANCE;</span>
        }

<span class="pc bpc" id="L748" title="1 of 2 branches missed.">        boolean negative = sequence.charAt(p) == '-';</span>
<span class="fc" id="L749">        int i = p;</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">        if (negative) {</span>
<span class="nc" id="L751">            i++;</span>
        }

<span class="pc bpc" id="L754" title="2 of 4 branches missed.">        if (i &gt;= lim || notDigit(sequence.charAt(i))) {</span>
<span class="nc" id="L755">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L758">        int val = 0;</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">        for (; i &lt; lim; i++) {</span>
<span class="fc" id="L760">            char c = sequence.charAt(i);</span>

<span class="fc bfc" id="L762" title="All 2 branches covered.">            if (notDigit(c)) {</span>
<span class="fc" id="L763">                break;</span>
            }

            // val * 10 + (c - '0')
<span class="fc" id="L767">            int r = (val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0');</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">            if (r &gt; val) {</span>
<span class="nc" id="L769">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L771">            val = r;</span>
        }

<span class="fc" id="L774">        final int len = i - p;</span>

<span class="pc bpc" id="L776" title="3 of 6 branches missed.">        if (len &gt; 3 || val == Integer.MIN_VALUE &amp;&amp; !negative) {</span>
<span class="fc" id="L777">            throw NumericException.INSTANCE;</span>
        }

<span class="fc bfc" id="L780" title="All 2 branches covered.">        while (i - p &lt; 3) {</span>
<span class="fc" id="L781">            val *= 10;</span>
<span class="fc" id="L782">            i++;</span>
        }

<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        return encodeLowHighInts(negative ? val : -val, len);</span>
    }

    public static int parseIntQuiet(CharSequence sequence) {
        try {
<span class="fc bfc" id="L790" title="All 4 branches covered.">            if (sequence == null || Chars.equals(&quot;NaN&quot;, sequence)) {</span>
<span class="fc" id="L791">                return Numbers.INT_NaN;</span>
            }
<span class="fc" id="L793">            return parseInt0(sequence, 0, sequence.length());</span>
<span class="fc" id="L794">        } catch (NumericException e) {</span>
<span class="fc" id="L795">            return Numbers.INT_NaN;</span>
        }

    }

    public static long parseIntSafely(CharSequence sequence, final int p, int lim) throws NumericException {

<span class="fc bfc" id="L802" title="All 2 branches covered.">        if (lim == p) {</span>
<span class="fc" id="L803">            throw NumericException.INSTANCE;</span>
        }

<span class="fc bfc" id="L806" title="All 2 branches covered.">        boolean negative = sequence.charAt(p) == '-';</span>
<span class="fc" id="L807">        int i = p;</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">        if (negative) {</span>
<span class="fc" id="L809">            i++;</span>
        }

<span class="pc bpc" id="L812" title="1 of 4 branches missed.">        if (i &gt;= lim || notDigit(sequence.charAt(i))) {</span>
<span class="fc" id="L813">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L816">        int val = 0;</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">        for (; i &lt; lim; i++) {</span>
<span class="fc" id="L818">            char c = sequence.charAt(i);</span>

<span class="fc bfc" id="L820" title="All 2 branches covered.">            if (notDigit(c)) {</span>
<span class="fc" id="L821">                break;</span>
            }

            // val * 10 + (c - '0')
<span class="fc" id="L825">            int r = (val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0');</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">            if (r &gt; val) {</span>
<span class="fc" id="L827">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L829">            val = r;</span>
        }

<span class="pc bpc" id="L832" title="3 of 4 branches missed.">        if (val == Integer.MIN_VALUE &amp;&amp; !negative) {</span>
<span class="nc" id="L833">            throw NumericException.INSTANCE;</span>
        }

<span class="fc bfc" id="L836" title="All 2 branches covered.">        return encodeLowHighInts(negative ? val : -val, i - p);</span>
    }

    public static int parseIntSize(CharSequence sequence) throws NumericException {
<span class="fc" id="L840">        int lim = sequence.length();</span>

<span class="pc bpc" id="L842" title="1 of 2 branches missed.">        if (lim == 0) {</span>
<span class="nc" id="L843">            throw NumericException.INSTANCE;</span>
        }

<span class="pc bpc" id="L846" title="1 of 2 branches missed.">        boolean negative = sequence.charAt(0) == '-';</span>
<span class="fc" id="L847">        int i = 0;</span>
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">        if (negative) {</span>
<span class="nc" id="L849">            i++;</span>
        }

<span class="pc bpc" id="L852" title="1 of 2 branches missed.">        if (i &gt;= lim) {</span>
<span class="nc" id="L853">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L856">        int val = 0;</span>
        int r;
        EX:
<span class="fc bfc" id="L859" title="All 2 branches covered.">        for (; i &lt; lim; i++) {</span>
<span class="fc" id="L860">            int c = sequence.charAt(i);</span>
<span class="pc bpc" id="L861" title="1 of 4 branches missed.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">                if (i == lim - 1) {</span>
<span class="fc bfc" id="L863" title="All 3 branches covered.">                    switch (c) {</span>
                        case 'K':
                        case 'k':
<span class="fc" id="L866">                            r = val * 1024;</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L868">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L870">                            val = r;</span>
<span class="fc" id="L871">                            break EX;</span>
                        case 'M':
                        case 'm':
<span class="fc" id="L874">                            r = val * 1024 * 1024;</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">                            if (r &gt; val) {</span>
<span class="nc" id="L876">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L878">                            val = r;</span>
<span class="fc" id="L879">                            break EX;</span>
                        default:
                            break;
                    }
                }
<span class="fc" id="L884">                throw NumericException.INSTANCE;</span>
            }
            // val * 10 + (c - '0')
<span class="fc" id="L887">            r = (val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0');</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">            if (r &gt; val) {</span>
<span class="nc" id="L889">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L891">            val = r;</span>
        }

<span class="pc bpc" id="L894" title="1 of 4 branches missed.">        if (val == Integer.MIN_VALUE &amp;&amp; !negative) {</span>
<span class="fc" id="L895">            throw NumericException.INSTANCE;</span>
        }
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">        return negative ? val : -val;</span>
    }

    public static long parseLong(CharSequence sequence) throws NumericException {
<span class="fc bfc" id="L901" title="All 2 branches covered.">        if (sequence == null) {</span>
<span class="fc" id="L902">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L904">        return parseLong0(sequence, 0, sequence.length());</span>
    }

    public static long parseLong(CharSequence sequence, int p, int lim) throws NumericException {
<span class="fc bfc" id="L908" title="All 2 branches covered.">        if (sequence == null) {</span>
<span class="fc" id="L909">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L911">        return parseLong0(sequence, p, lim);</span>
    }

    public static long parseLong000000Greedy(CharSequence sequence, final int p, int lim) throws NumericException {
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">        if (lim == p) {</span>
<span class="nc" id="L916">            throw NumericException.INSTANCE;</span>
        }

<span class="pc bpc" id="L919" title="1 of 2 branches missed.">        boolean negative = sequence.charAt(p) == '-';</span>
<span class="fc" id="L920">        int i = p;</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">        if (negative) {</span>
<span class="nc" id="L922">            i++;</span>
        }

<span class="pc bpc" id="L925" title="2 of 4 branches missed.">        if (i &gt;= lim || notDigit(sequence.charAt(i))) {</span>
<span class="nc" id="L926">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L929">        int val = 0;</span>
<span class="fc bfc" id="L930" title="All 2 branches covered.">        for (; i &lt; lim; i++) {</span>
<span class="fc" id="L931">            char c = sequence.charAt(i);</span>

<span class="fc bfc" id="L933" title="All 2 branches covered.">            if (notDigit(c)) {</span>
<span class="fc" id="L934">                break;</span>
            }

            // val * 10 + (c - '0')
<span class="fc" id="L938">            int r = (val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0');</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">            if (r &gt; val) {</span>
<span class="nc" id="L940">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L942">            val = r;</span>
        }

<span class="fc" id="L945">        final int len = i - p;</span>

<span class="pc bpc" id="L947" title="4 of 6 branches missed.">        if (len &gt; 6 || val == Integer.MIN_VALUE &amp;&amp; !negative) {</span>
<span class="nc" id="L948">            throw NumericException.INSTANCE;</span>
        }

<span class="fc bfc" id="L951" title="All 2 branches covered.">        while (i - p &lt; 6) {</span>
<span class="fc" id="L952">            val *= 10;</span>
<span class="fc" id="L953">            i++;</span>
        }

<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        return encodeLowHighInts(negative ? val : -val, len);</span>
    }

    @NotNull
    public static Long256Impl parseLong256(CharSequence text, int len, Long256Impl long256) {
<span class="pc bpc" id="L961" title="1 of 4 branches missed.">        return extractLong256(text, len, long256) ? long256 : Long256Impl.NULL_LONG256;</span>
    }

    public static long parseLongDuration(CharSequence sequence) throws NumericException {
<span class="fc" id="L965">        final int lim = sequence.length();</span>
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">        if (lim == 0) {</span>
<span class="nc" id="L967">            throw NumericException.INSTANCE;</span>
        }

<span class="pc bpc" id="L970" title="1 of 2 branches missed.">        final boolean negative = sequence.charAt(0) == '-';</span>
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">        if (negative) {</span>
<span class="nc" id="L972">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L975">        long val = 0;</span>
        long r;
        EX:
<span class="fc bfc" id="L978" title="All 2 branches covered.">        for (int i = 0; i &lt; lim; i++) {</span>
<span class="fc" id="L979">            int c = sequence.charAt(i);</span>
<span class="pc bpc" id="L980" title="1 of 4 branches missed.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">                if (i == lim - 1) {</span>
<span class="pc bpc" id="L982" title="1 of 8 branches missed.">                    switch (c) {</span>
                        case 's':
<span class="fc" id="L984">                            r = val * Timestamps.SECOND_MICROS;</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L986">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L988">                            val = r;</span>
<span class="fc" id="L989">                            break EX;</span>
                        case 'm':
<span class="fc" id="L991">                            r = val * Timestamps.MINUTE_MICROS;</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L993">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L995">                            val = r;</span>
<span class="fc" id="L996">                            break EX;</span>
                        case 'h':
<span class="fc" id="L998">                            r = val * Timestamps.HOUR_MICROS;</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L1000">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L1002">                            val = r;</span>
<span class="fc" id="L1003">                            break EX;</span>
                        case 'd':
<span class="fc" id="L1005">                            r = val * Timestamps.DAY_MICROS;</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L1007">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L1009">                            val = r;</span>
<span class="fc" id="L1010">                            break EX;</span>
                        case 'w':
<span class="fc" id="L1012">                            r = val * Timestamps.WEEK_MICROS;</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L1014">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L1016">                            val = r;</span>
<span class="fc" id="L1017">                            break EX;</span>
                        case 'M':
<span class="fc" id="L1019">                            r = val * Timestamps.DAY_MICROS*30;</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L1021">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L1023">                            val = r;</span>
<span class="fc" id="L1024">                            break EX;</span>
                        case 'y':
<span class="fc" id="L1026">                            r = val * Timestamps.DAY_MICROS*365;</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L1028">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L1030">                            val = r;</span>
<span class="fc" id="L1031">                            break EX;</span>
                        default:
                            break;
                    }
                }
<span class="fc" id="L1036">                throw NumericException.INSTANCE;</span>
            }
            // val * 10 + (c - '0')
<span class="fc" id="L1039">            r = (val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0');</span>
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">            if (r &gt; val) {</span>
<span class="nc" id="L1041">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L1043">            val = r;</span>
        }

<span class="fc bfc" id="L1046" title="All 2 branches covered.">        if (val == Long.MIN_VALUE) {</span>
<span class="fc" id="L1047">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L1049">        return -val;</span>
    }

    public static long parseLongQuiet(CharSequence sequence) {
<span class="fc bfc" id="L1053" title="All 2 branches covered.">        if (sequence == null) {</span>
<span class="fc" id="L1054">            return Long.MIN_VALUE;</span>
        }
        try {
<span class="fc" id="L1057">            return parseLong0(sequence, 0, sequence.length());</span>
<span class="fc" id="L1058">        } catch (NumericException e) {</span>
<span class="fc" id="L1059">            return Long.MIN_VALUE;</span>
        }
    }

    public static long parseLongSize(CharSequence sequence) throws NumericException {
<span class="fc" id="L1064">        int lim = sequence.length();</span>

<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">        if (lim == 0) {</span>
<span class="nc" id="L1067">            throw NumericException.INSTANCE;</span>
        }

<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">        boolean negative = sequence.charAt(0) == '-';</span>
<span class="fc" id="L1071">        int i = 0;</span>
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">        if (negative) {</span>
<span class="nc" id="L1073">            i++;</span>
        }

<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">        if (i &gt;= lim) {</span>
<span class="nc" id="L1077">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L1080">        long val = 0;</span>
        long r;
        EX:
<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">        for (; i &lt; lim; i++) {</span>
<span class="fc" id="L1084">            int c = sequence.charAt(i);</span>
<span class="pc bpc" id="L1085" title="1 of 4 branches missed.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">                if (i == lim - 1) {</span>
<span class="pc bpc" id="L1087" title="1 of 4 branches missed.">                    switch (c) {</span>
                        case 'K':
                        case 'k':
<span class="fc" id="L1090">                            r = val * 1024L;</span>
<span class="fc bfc" id="L1091" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L1092">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L1094">                            val = r;</span>
<span class="fc" id="L1095">                            break EX;</span>
                        case 'M':
                        case 'm':
<span class="fc" id="L1098">                            r = val * 1024L * 1024L;</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L1100">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L1102">                            val = r;</span>
<span class="fc" id="L1103">                            break EX;</span>
                        case 'G':
                        case 'g':
<span class="fc" id="L1106">                            r = val * 1024L * 1024L * 1024L;</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">                            if (r &gt; val) {</span>
<span class="fc" id="L1108">                                throw NumericException.INSTANCE;</span>
                            }
<span class="fc" id="L1110">                            val = r;</span>
<span class="fc" id="L1111">                            break EX;</span>
                        default:
                            break;
                    }
                }
<span class="fc" id="L1116">                throw NumericException.INSTANCE;</span>
            }
            // val * 10 + (c - '0')
<span class="fc" id="L1119">            r = (val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0');</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">            if (r &gt; val) {</span>
<span class="fc" id="L1121">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L1123">            val = r;</span>
        }

<span class="pc bpc" id="L1126" title="3 of 4 branches missed.">        if (val == Long.MIN_VALUE &amp;&amp; !negative) {</span>
<span class="nc" id="L1127">            throw NumericException.INSTANCE;</span>
        }
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">        return negative ? val : -val;</span>
    }

    public static short parseShort(CharSequence sequence) throws NumericException {
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">        if (sequence == null) {</span>
<span class="nc" id="L1134">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L1136">        return parseShort0(sequence, 0, sequence.length());</span>
    }

    public static short parseShort(CharSequence sequence, int p, int lim) throws NumericException {
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">        if (sequence == null) {</span>
<span class="nc" id="L1141">            throw NumericException.INSTANCE;</span>
        }
<span class="fc" id="L1143">        return parseShort0(sequence, p, lim);</span>
    }

    public static double roundDown(double value, int scale) throws NumericException {
<span class="fc bfc" id="L1147" title="All 4 branches covered.">        if (scale &lt; pow10max &amp;&amp; scale &gt; -pow10max) {</span>
<span class="fc" id="L1148">            return roundDown0(value, scale);</span>
        }
<span class="fc" id="L1150">        throw NumericException.INSTANCE;</span>
    }

    public static double roundDownNegScale(double value, int scale) {
<span class="fc" id="L1154">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L1155">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L1156">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L1157">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundDown00NegScale(absValue, scale)) | signMask);</span>
    }

    public static double roundDownPosScale(double value, int scale) {
<span class="fc" id="L1161">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L1162">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L1163">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L1164">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundDown00PosScale(absValue, scale)) | signMask);</span>
    }

    public static double roundHalfDown(double value, int scale) throws NumericException {
<span class="pc bpc" id="L1168" title="2 of 4 branches missed.">        if (scale + 2 &lt; pow10max &amp;&amp; scale &gt; -pow10max) {</span>
<span class="fc bfc" id="L1169" title="All 2 branches covered.">            return value &gt; 0 ? roundHalfDown0(value, scale) : -roundHalfDown0(-value, scale);</span>
        }
<span class="nc" id="L1171">        throw NumericException.INSTANCE;</span>
    }

    public static double roundHalfEven(double value, int scale) throws NumericException {
<span class="fc bfc" id="L1175" title="All 4 branches covered.">        if (scale + 2 &lt; pow10max &amp;&amp; scale &gt; -pow10max) {</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">            return value &gt; 0 ? roundHalfEven0(value, scale) : -roundHalfEven0(-value, scale);</span>
        }
<span class="fc" id="L1178">        throw NumericException.INSTANCE;</span>
    }

    public static double roundHalfEven0NegScale(double value, int scale) {
<span class="fc" id="L1182">        long val = (long) (value * pow10dNeg[scale] * pow10[2] + TOLERANCE);</span>
<span class="fc" id="L1183">        long remainder = val % 100;</span>

<span class="fc bfc" id="L1185" title="All 2 branches covered.">        if (remainder &lt; 50) {</span>
<span class="fc" id="L1186">            return roundDown00NegScale(value, scale);</span>
        }

<span class="pc bpc" id="L1189" title="1 of 4 branches missed.">        if (remainder == 50 &amp;&amp; ((long) (value * pow10dNeg[scale]) &amp; 1) == 0) {</span>
<span class="fc" id="L1190">            return roundDown00NegScale(value, scale);</span>
        }

<span class="fc" id="L1193">        return roundUp00NegScale(value, scale);</span>
    }

    public static double roundHalfEven0PosScale(double value, int scale) {
<span class="fc" id="L1197">        long val = (long) (value * pow10[scale] * pow10[2] + TOLERANCE);</span>
<span class="fc" id="L1198">        long remainder = val % 100;</span>

<span class="fc bfc" id="L1200" title="All 2 branches covered.">        if (remainder &lt; 50) {</span>
<span class="fc" id="L1201">            return roundDown00PosScale(value, scale);</span>
        }

<span class="fc bfc" id="L1204" title="All 4 branches covered.">        if (remainder == 50 &amp;&amp; ((long) (value * pow10[scale]) &amp; 1) == 0) {</span>
<span class="fc" id="L1205">            return roundDown00PosScale(value, scale);</span>
        }

<span class="fc" id="L1208">        return roundUp00PosScale(value, scale);</span>
    }

    public static double roundHalfEvenNegScale(double value, int scale) {
<span class="fc bfc" id="L1212" title="All 2 branches covered.">        return value &gt; 0 ? roundHalfEven0NegScale(value, scale) : -roundHalfEven0NegScale(-value, scale);</span>
    }

    public static double roundHalfEvenPosScale(double value, int scale) {
<span class="fc bfc" id="L1216" title="All 2 branches covered.">        return value &gt; 0 ? roundHalfEven0PosScale(value, scale) : -roundHalfEven0PosScale(-value, scale);</span>
    }

    public static double roundHalfUp(double value, int scale) throws NumericException {
<span class="fc bfc" id="L1220" title="All 4 branches covered.">        if (scale + 2 &lt; pow10max &amp;&amp; scale &gt; -pow10max) {</span>
<span class="fc" id="L1221">            long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L1222">            long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L1223">            double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L1224">            return Double.longBitsToDouble(Double.doubleToRawLongBits(roundHalfUp0(absValue, scale)) | signMask);</span>
        }
<span class="fc" id="L1226">        throw NumericException.INSTANCE;</span>
    }

    public static double roundHalfUpNegScale(double value, int scale) {
<span class="fc" id="L1230">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L1231">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L1232">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L1233">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundHalfUp0NegScale(absValue, scale)) | signMask);</span>
    }

    public static double roundHalfUpPosScale(double value, int scale) {
<span class="fc" id="L1237">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L1238">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L1239">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L1240">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundHalfUp0PosScale(absValue, scale)) | signMask);</span>
    }

    public static double roundUp(double value, int scale) throws NumericException {
<span class="fc bfc" id="L1244" title="All 4 branches covered.">        if (scale &lt; pow10max &amp;&amp; scale &gt; -pow10max) {</span>
<span class="fc" id="L1245">            return roundUp0(value, scale);</span>
        }
<span class="fc" id="L1247">        throw NumericException.INSTANCE;</span>
    }

    public static double roundUpNegScale(double value, int scale) {
<span class="fc" id="L1251">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L1252">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L1253">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L1254">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundUp00NegScale(absValue, scale)) | signMask);</span>
    }

    public static double roundUpPosScale(double value, int scale) {
<span class="fc" id="L1258">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L1259">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L1260">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L1261">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundUp00PosScale(absValue, scale)) | signMask);</span>
    }

    public static long spreadBits(long v) {
<span class="fc" id="L1265">        v = (v | (v &lt;&lt; 16)) &amp; 0X0000FFFF0000FFFFL;</span>
<span class="fc" id="L1266">        v = (v | (v &lt;&lt; 8)) &amp; 0X00FF00FF00FF00FFL;</span>
<span class="fc" id="L1267">        v = (v | (v &lt;&lt; 4)) &amp; 0X0F0F0F0F0F0F0F0FL;</span>
<span class="fc" id="L1268">        v = (v | (v &lt;&lt; 2)) &amp; 0x3333333333333333L;</span>
<span class="fc" id="L1269">        v = (v | (v &lt;&lt; 1)) &amp; 0x5555555555555555L;</span>
<span class="fc" id="L1270">        return v;</span>
    }

    private static void appendDouble0(
            int binExp,
            long fractionBits,
            int significantBitCount,
            boolean negative,
            char[] digits,
            CharSink out,
            int outScale
    ) {
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">        assert fractionBits &gt; 0L;</span>
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">        assert (fractionBits &amp; FRACT_HOB) != 0L;</span>

<span class="fc" id="L1285">        final int tailZeroes = Long.numberOfTrailingZeros(fractionBits);</span>
<span class="fc" id="L1286">        final int fractBitCount = EXP_SHIFT + 1 - tailZeroes;</span>
        int decExp;
        int firstDigitIndex;
        int nDigits;

<span class="fc" id="L1291">        final int tinyBitCount = Math.max(0, fractBitCount - binExp - 1);</span>
<span class="fc bfc" id="L1292" title="All 10 branches covered.">        if (binExp &lt; MAX_SMALL_BIN_EXP + 1 &amp;&amp; binExp &gt; MIN_SMALL_BIN_EXP - 1 &amp;&amp; tinyBitCount &lt; LONG_5_POW.length &amp;&amp; fractBitCount + N_5_BITS[tinyBitCount] &lt; 64 &amp;&amp; tinyBitCount == 0) {</span>
            int insignificant;
<span class="fc bfc" id="L1294" title="All 2 branches covered.">            if (binExp &gt; significantBitCount) {</span>
<span class="fc" id="L1295">                insignificant = insignificantDigitsForPow2(binExp - significantBitCount - 1);</span>
            } else {
<span class="fc" id="L1297">                insignificant = 0;</span>
            }

<span class="fc bfc" id="L1300" title="All 2 branches covered.">            if (binExp &gt;= EXP_SHIFT) {</span>
<span class="fc" id="L1301">                fractionBits &lt;&lt;= binExp - EXP_SHIFT;</span>
            } else {
<span class="fc" id="L1303">                fractionBits &gt;&gt;&gt;= EXP_SHIFT - binExp;</span>
            }

            //
<span class="fc" id="L1307">            int binExp2 = 0;</span>
<span class="fc bfc" id="L1308" title="All 2 branches covered.">            if (insignificant != 0) {</span>
<span class="fc" id="L1309">                long pow10 = LONG_5_POW[insignificant] &lt;&lt; insignificant;</span>
<span class="fc" id="L1310">                long residue = fractionBits % pow10;</span>
<span class="fc" id="L1311">                fractionBits /= pow10;</span>
<span class="fc" id="L1312">                binExp2 += insignificant;</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">                if (residue &gt;= pow10 &gt;&gt; 1) {</span>
<span class="fc" id="L1314">                    ++fractionBits;</span>
                }
            }

<span class="fc" id="L1318">            int digitIndex = digits.length - 1;</span>
            int digit;
<span class="fc bfc" id="L1320" title="All 2 branches covered.">            if (fractionBits &lt;= Integer.MAX_VALUE) {</span>
<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">                assert fractionBits &gt; 0L : fractionBits;</span>

<span class="fc" id="L1323">                int fractRemaining = (int) fractionBits;</span>
<span class="fc" id="L1324">                digit = fractRemaining % 10;</span>

<span class="fc bfc" id="L1326" title="All 2 branches covered.">                for (fractRemaining /= 10; digit == 0; fractRemaining /= 10) {</span>
<span class="fc" id="L1327">                    ++binExp2;</span>
<span class="fc" id="L1328">                    digit = fractRemaining % 10;</span>
                }

<span class="fc bfc" id="L1331" title="All 2 branches covered.">                while (fractRemaining != 0) {</span>
<span class="fc" id="L1332">                    digits[digitIndex--] = (char) (digit + '0');</span>
<span class="fc" id="L1333">                    ++binExp2;</span>
<span class="fc" id="L1334">                    digit = fractRemaining % 10;</span>
<span class="fc" id="L1335">                    fractRemaining /= 10;</span>
                }

<span class="fc" id="L1338">            } else {</span>
<span class="fc" id="L1339">                digit = (int) (fractionBits % 10L);</span>

<span class="fc bfc" id="L1341" title="All 2 branches covered.">                for (fractionBits /= 10L; digit == 0; fractionBits /= 10L) {</span>
<span class="fc" id="L1342">                    ++binExp2;</span>
<span class="fc" id="L1343">                    digit = (int) (fractionBits % 10L);</span>
                }

<span class="fc bfc" id="L1346" title="All 2 branches covered.">                while (fractionBits != 0L) {</span>
<span class="fc" id="L1347">                    digits[digitIndex--] = (char) (digit + '0');</span>
<span class="fc" id="L1348">                    ++binExp2;</span>
<span class="fc" id="L1349">                    digit = (int) (fractionBits % 10L);</span>
<span class="fc" id="L1350">                    fractionBits /= 10L;</span>
                }

            }
<span class="fc" id="L1354">            digits[digitIndex] = (char) (digit + '0');</span>

<span class="fc" id="L1356">            decExp = binExp2 + 1;</span>
<span class="fc" id="L1357">            firstDigitIndex = digitIndex;</span>
<span class="fc" id="L1358">            nDigits = digits.length - digitIndex;</span>

            //
<span class="fc" id="L1361">        } else {</span>
<span class="fc" id="L1362">            int estDecExp = estimateDecExpDouble(fractionBits, binExp);</span>
<span class="fc" id="L1363">            int B5 = Math.max(0, -estDecExp);</span>
<span class="fc" id="L1364">            int B2 = B5 + tinyBitCount + binExp;</span>
<span class="fc" id="L1365">            int S5 = Math.max(0, estDecExp);</span>
<span class="fc" id="L1366">            int S2 = S5 + tinyBitCount;</span>
<span class="fc" id="L1367">            int M2 = B2 - significantBitCount;</span>
<span class="fc" id="L1368">            fractionBits &gt;&gt;&gt;= tailZeroes;</span>
<span class="fc" id="L1369">            B2 -= fractBitCount - 1;</span>
<span class="fc" id="L1370">            int common2factor = Math.min(B2, S2);</span>
<span class="fc" id="L1371">            B2 -= common2factor;</span>
<span class="fc" id="L1372">            S2 -= common2factor;</span>
<span class="fc" id="L1373">            M2 -= common2factor;</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">            if (fractBitCount == 1) {</span>
<span class="fc" id="L1375">                --M2;</span>
            }

<span class="fc bfc" id="L1378" title="All 2 branches covered.">            if (M2 &lt; 0) {</span>
<span class="fc" id="L1379">                B2 -= M2;</span>
<span class="fc" id="L1380">                S2 -= M2;</span>
<span class="fc" id="L1381">                M2 = 0;</span>
            }

<span class="fc bfc" id="L1384" title="All 2 branches covered.">            int bBits = fractBitCount + B2 + (B5 &lt; N_5_BITS.length ? N_5_BITS[B5] : B5 * 3);</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">            int tenBits = S2 + 1 + (S5 + 1 &lt; N_5_BITS.length ? N_5_BITS[S5 + 1] : (S5 + 1) * 3);</span>
            boolean low;
            boolean high;
            long lowDigitDifference;
            int q;
            int digitIndex;
<span class="fc bfc" id="L1391" title="All 4 branches covered.">            if (bBits &lt; 64 &amp;&amp; tenBits &lt; 64) {</span>
<span class="pc bpc" id="L1392" title="3 of 4 branches missed.">                if (bBits &lt; 32 &amp;&amp; tenBits &lt; 32) {</span>
<span class="nc" id="L1393">                    int b = (int) fractionBits * SMALL_5_POW[B5] &lt;&lt; B2;</span>
<span class="nc" id="L1394">                    int s = SMALL_5_POW[S5] &lt;&lt; S2;</span>
<span class="nc" id="L1395">                    int m = SMALL_5_POW[B5] &lt;&lt; M2;</span>
<span class="nc" id="L1396">                    int tens = s * 10;</span>
<span class="nc" id="L1397">                    digitIndex = 0;</span>
<span class="nc" id="L1398">                    q = b / s;</span>
<span class="nc" id="L1399">                    b = 10 * (b % s);</span>
<span class="nc" id="L1400">                    m *= 10;</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                    low = b &lt; m;</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">                    high = b + m &gt; tens;</span>

<span class="nc bnc" id="L1404" title="All 2 branches missed.">                    assert q &lt; 10 : q;</span>

<span class="nc bnc" id="L1406" title="All 4 branches missed.">                    if (q == 0 &amp;&amp; !high) {</span>
<span class="nc" id="L1407">                        --estDecExp;</span>
                    } else {
<span class="nc" id="L1409">                        digits[digitIndex++] = (char) ('0' + q);</span>
                    }

<span class="nc bnc" id="L1412" title="All 4 branches missed.">                    if (estDecExp &lt; -3 || estDecExp &gt;= 8) {</span>
<span class="nc" id="L1413">                        low = false;</span>
<span class="nc" id="L1414">                        high = false;</span>
                    }

<span class="nc bnc" id="L1417" title="All 4 branches missed.">                    for (; !low &amp;&amp; !high; digits[digitIndex++] = (char) ('0' + q)) {</span>
<span class="nc" id="L1418">                        q = b / s;</span>
<span class="nc" id="L1419">                        b = 10 * (b % s);</span>
<span class="nc" id="L1420">                        m *= 10;</span>

<span class="nc bnc" id="L1422" title="All 2 branches missed.">                        assert q &lt; 10 : q;</span>

<span class="nc bnc" id="L1424" title="All 2 branches missed.">                        if ((long) m &gt; 0L) {</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                            low = b &lt; m;</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">                            high = b + m &gt; tens;</span>
                        } else {
<span class="nc" id="L1428">                            low = true;</span>
<span class="nc" id="L1429">                            high = true;</span>
                        }
                    }

<span class="nc" id="L1433">                    lowDigitDifference = ((long) b &lt;&lt; 1) - tens;</span>
<span class="nc" id="L1434">                } else {</span>
<span class="fc" id="L1435">                    long b = fractionBits * LONG_5_POW[B5] &lt;&lt; B2;</span>
<span class="fc" id="L1436">                    long s = LONG_5_POW[S5] &lt;&lt; S2;</span>
<span class="fc" id="L1437">                    long m = LONG_5_POW[B5] &lt;&lt; M2;</span>
<span class="fc" id="L1438">                    long tens = s * 10L;</span>
<span class="fc" id="L1439">                    digitIndex = 0;</span>
<span class="fc" id="L1440">                    q = (int) (b / s);</span>
<span class="fc" id="L1441">                    b = 10L * (b % s);</span>
<span class="fc" id="L1442">                    m *= 10L;</span>
<span class="fc bfc" id="L1443" title="All 2 branches covered.">                    low = b &lt; m;</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">                    high = b + m &gt; tens;</span>

<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">                    assert q &lt; 10 : q;</span>

<span class="pc bpc" id="L1448" title="1 of 4 branches missed.">                    if (q == 0 &amp;&amp; !high) {</span>
<span class="fc" id="L1449">                        --estDecExp;</span>
                    } else {
<span class="fc" id="L1451">                        digits[digitIndex++] = (char) ('0' + q);</span>
                    }

<span class="pc bpc" id="L1454" title="1 of 4 branches missed.">                    if (estDecExp &lt; -3 || estDecExp &gt;= 8) {</span>
<span class="fc" id="L1455">                        low = false;</span>
<span class="fc" id="L1456">                        high = false;</span>
                    }

<span class="fc bfc" id="L1459" title="All 4 branches covered.">                    for (; !low &amp;&amp; !high; digits[digitIndex++] = (char) ('0' + q)) {</span>
<span class="fc" id="L1460">                        q = (int) (b / s);</span>
<span class="fc" id="L1461">                        b = 10L * (b % s);</span>
<span class="fc" id="L1462">                        m *= 10L;</span>

<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">                        assert q &lt; 10 : q;</span>

<span class="fc bfc" id="L1466" title="All 2 branches covered.">                        if (m &gt; 0L) {</span>
<span class="fc bfc" id="L1467" title="All 2 branches covered.">                            low = b &lt; m;</span>
<span class="fc bfc" id="L1468" title="All 2 branches covered.">                            high = b + m &gt; tens;</span>
                        } else {
<span class="fc" id="L1470">                            low = true;</span>
<span class="fc" id="L1471">                            high = true;</span>
                        }
                    }
<span class="fc" id="L1474">                    lowDigitDifference = (b &lt;&lt; 1) - tens;</span>
<span class="fc" id="L1475">                }</span>
            } else {
<span class="fc" id="L1477">                FDBigInteger sVal = FDBigInteger.valueOfPow52(S5, S2);</span>
<span class="fc" id="L1478">                final int shiftBias = sVal.getNormalizationBias();</span>
<span class="fc" id="L1479">                sVal = sVal.leftShift(shiftBias);</span>
<span class="fc" id="L1480">                FDBigInteger bVal = FDBigInteger.valueOfMulPow52(fractionBits, B5, B2 + shiftBias);</span>
<span class="fc" id="L1481">                FDBigInteger mVal = FDBigInteger.valueOfPow52(B5 + 1, M2 + shiftBias + 1);</span>
<span class="fc" id="L1482">                FDBigInteger tensVal = FDBigInteger.valueOfPow52(S5 + 1, S2 + shiftBias + 1);</span>
<span class="fc" id="L1483">                digitIndex = 0;</span>
<span class="fc" id="L1484">                q = bVal.quoRemIteration(sVal);</span>
<span class="fc bfc" id="L1485" title="All 2 branches covered.">                low = bVal.cmp(mVal) &lt; 0;</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">                high = tensVal.addAndCmp(bVal, mVal) &lt;= 0;</span>

<span class="pc bpc" id="L1488" title="1 of 2 branches missed.">                assert q &lt; 10 : q;</span>

<span class="fc bfc" id="L1490" title="All 4 branches covered.">                if (q == 0 &amp;&amp; !high) {</span>
<span class="fc" id="L1491">                    --estDecExp;</span>
                } else {
<span class="fc" id="L1493">                    digits[digitIndex++] = (char) ('0' + q);</span>
                }

<span class="fc bfc" id="L1496" title="All 4 branches covered.">                if (estDecExp &lt; -3 || estDecExp &gt;= 8) {</span>
<span class="fc" id="L1497">                    low = false;</span>
<span class="fc" id="L1498">                    high = false;</span>
                }

<span class="fc bfc" id="L1501" title="All 4 branches covered.">                while (!low &amp;&amp; !high) {</span>
<span class="fc" id="L1502">                    q = bVal.quoRemIteration(sVal);</span>

<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">                    assert q &lt; 10 : q;</span>

<span class="fc" id="L1506">                    mVal = mVal.multBy10();</span>
<span class="fc bfc" id="L1507" title="All 2 branches covered.">                    low = bVal.cmp(mVal) &lt; 0;</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">                    high = tensVal.addAndCmp(bVal, mVal) &lt;= 0;</span>
<span class="fc" id="L1509">                    digits[digitIndex++] = (char) ('0' + q);</span>
                }

<span class="fc bfc" id="L1512" title="All 4 branches covered.">                if (high &amp;&amp; low) {</span>
<span class="fc" id="L1513">                    bVal = bVal.leftShift(1);</span>
<span class="fc" id="L1514">                    lowDigitDifference = bVal.cmp(tensVal);</span>
                } else {
<span class="fc" id="L1516">                    lowDigitDifference = 0L;</span>
                }
            }

<span class="fc" id="L1520">            decExp = estDecExp + 1;</span>
<span class="fc" id="L1521">            firstDigitIndex = 0;</span>
<span class="fc" id="L1522">            nDigits = digitIndex;</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">            if (high) {</span>
<span class="fc bfc" id="L1524" title="All 2 branches covered.">                if (low) {</span>
<span class="fc bfc" id="L1525" title="All 2 branches covered.">                    if (lowDigitDifference == 0L) {</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">                        if ((digits[firstDigitIndex + nDigits - 1] &amp; 1) != 0) {</span>
<span class="pc bpc" id="L1527" title="1 of 2 branches missed.">                            if (roundupDouble(firstDigitIndex, digits, nDigits)) {</span>
<span class="nc" id="L1528">                                decExp++;</span>
                            }
                        }
<span class="fc bfc" id="L1531" title="All 2 branches covered.">                    } else if (lowDigitDifference &gt; 0L) {</span>
<span class="pc bpc" id="L1532" title="1 of 2 branches missed.">                        if (roundupDouble(firstDigitIndex, digits, nDigits)) {</span>
<span class="nc" id="L1533">                            decExp++;</span>
                        }
                    }
                } else {
<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">                    if (roundupDouble(firstDigitIndex, digits, nDigits)) {</span>
<span class="nc" id="L1538">                        decExp++;</span>
                    }
                }
            }
        }

<span class="fc" id="L1544">        appendDouble00(digits, firstDigitIndex, nDigits, negative, decExp, out, outScale);</span>
<span class="fc" id="L1545">    }</span>

    private static void appendDouble00(
            char[] digits,
            int firstDigitIndex,
            int nDigits,
            boolean isNegative,
            int decExp,
            CharSink sink,
            int outScale
    ) {
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">        assert nDigits &lt;= MAX_SCALE : nDigits;</span>
<span class="fc bfc" id="L1557" title="All 2 branches covered.">        if (isNegative) {</span>
<span class="fc" id="L1558">            sink.put('-');</span>
        }

        int exp;
<span class="fc bfc" id="L1562" title="All 4 branches covered.">        if (decExp &gt; 0 &amp;&amp; decExp &lt; 8) {</span>
<span class="fc" id="L1563">            exp = Math.min(nDigits, decExp);</span>
<span class="fc" id="L1564">            sink.put(digits, firstDigitIndex, exp);</span>
<span class="fc bfc" id="L1565" title="All 2 branches covered.">            if (exp &lt; decExp) {</span>
<span class="fc" id="L1566">                exp = decExp - exp;</span>
<span class="fc" id="L1567">                sink.fill('0', exp);</span>
<span class="fc" id="L1568">                sink.put('.');</span>
<span class="fc" id="L1569">                sink.put('0');</span>
            } else {
<span class="fc" id="L1571">                sink.put('.');</span>
<span class="fc bfc" id="L1572" title="All 2 branches covered.">                if (exp &lt; nDigits) {</span>
<span class="fc" id="L1573">                    sink.put(digits, firstDigitIndex + exp, Math.min(nDigits - exp, outScale));</span>
                } else {
<span class="fc" id="L1575">                    sink.put('0');</span>
                }
            }
<span class="fc bfc" id="L1578" title="All 4 branches covered.">        } else if (decExp &lt;= 0 &amp;&amp; decExp &gt; -3) {</span>
<span class="fc" id="L1579">            sink.put('0').put('.');</span>
<span class="fc bfc" id="L1580" title="All 2 branches covered.">            if (decExp != 0) {</span>
<span class="fc" id="L1581">                sink.fill('0', -decExp);</span>
            }

<span class="fc" id="L1584">            sink.put(digits, firstDigitIndex, Math.min(nDigits, outScale));</span>
        } else {
<span class="fc" id="L1586">            sink.put(digits[firstDigitIndex]);</span>
<span class="fc" id="L1587">            sink.put('.');</span>
<span class="pc bpc" id="L1588" title="1 of 2 branches missed.">            if (nDigits &gt; 1) {</span>
<span class="fc" id="L1589">                sink.put(digits, firstDigitIndex + 1, nDigits - 1);</span>
            } else {
<span class="nc" id="L1591">                sink.put('0');</span>
            }

<span class="fc" id="L1594">            sink.put('E');</span>
<span class="fc bfc" id="L1595" title="All 2 branches covered.">            if (decExp &lt;= 0) {</span>
<span class="fc" id="L1596">                sink.put('-');</span>
<span class="fc" id="L1597">                exp = -decExp + 1;</span>
            } else {
<span class="fc" id="L1599">                exp = decExp - 1;</span>
            }

<span class="fc bfc" id="L1602" title="All 2 branches covered.">            if (exp &lt; 10) {</span>
<span class="fc" id="L1603">                sink.put((char) (exp + '0'));</span>
<span class="fc bfc" id="L1604" title="All 2 branches covered.">            } else if (exp &lt; 100) {</span>
<span class="fc" id="L1605">                sink.put((char) (exp / 10 + '0'));</span>
<span class="fc" id="L1606">                sink.put((char) (exp % 10 + '0'));</span>
            } else {
<span class="fc" id="L1608">                sink.put((char) (exp / 100 + '0'));</span>
<span class="fc" id="L1609">                exp %= 100;</span>
<span class="fc" id="L1610">                sink.put((char) (exp / 10 + '0'));</span>
<span class="fc" id="L1611">                sink.put((char) (exp % 10 + '0'));</span>
            }
        }
<span class="fc" id="L1614">    }</span>

    private static void appendInt10(CharSink sink, int i) {
        int c;
<span class="fc" id="L1618">        sink.put((char) ('0' + i / 1000000000));</span>
<span class="fc" id="L1619">        sink.put((char) ('0' + (c = i % 1000000000) / 100000000));</span>
<span class="fc" id="L1620">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1621">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1622">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1623">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1624">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1625">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1626">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1627">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1628">    }</span>

    private static void appendInt2(CharSink sink, int i) {
<span class="fc" id="L1631">        sink.put((char) ('0' + i / 10));</span>
<span class="fc" id="L1632">        sink.put((char) ('0' + i % 10));</span>
<span class="fc" id="L1633">    }</span>

    private static void appendInt3(CharSink sink, int i) {
        int c;
<span class="fc" id="L1637">        sink.put((char) ('0' + i / 100));</span>
<span class="fc" id="L1638">        sink.put((char) ('0' + (c = i % 100) / 10));</span>
<span class="fc" id="L1639">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1640">    }</span>

    private static void appendInt4(CharSink sink, int i) {
        int c;
<span class="fc" id="L1644">        sink.put((char) ('0' + i / 1000));</span>
<span class="fc" id="L1645">        sink.put((char) ('0' + (c = i % 1000) / 100));</span>
<span class="fc" id="L1646">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1647">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1648">    }</span>

    private static void appendInt5(CharSink sink, int i) {
        int c;
<span class="fc" id="L1652">        sink.put((char) ('0' + i / 10000));</span>
<span class="fc" id="L1653">        sink.put((char) ('0' + (c = i % 10000) / 1000));</span>
<span class="fc" id="L1654">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1655">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1656">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1657">    }</span>

    private static void appendInt6(CharSink sink, int i) {
        int c;
<span class="fc" id="L1661">        sink.put((char) ('0' + i / 100000));</span>
<span class="fc" id="L1662">        sink.put((char) ('0' + (c = i % 100000) / 10000));</span>
<span class="fc" id="L1663">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1664">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1665">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1666">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1667">    }</span>

    private static void appendInt7(CharSink sink, int i) {
        int c;
<span class="fc" id="L1671">        sink.put((char) ('0' + i / 1000000));</span>
<span class="fc" id="L1672">        sink.put((char) ('0' + (c = i % 1000000) / 100000));</span>
<span class="fc" id="L1673">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1674">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1675">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1676">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1677">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1678">    }</span>

    private static void appendInt8(CharSink sink, int i) {
        int c;
<span class="fc" id="L1682">        sink.put((char) ('0' + i / 10000000));</span>
<span class="fc" id="L1683">        sink.put((char) ('0' + (c = i % 10000000) / 1000000));</span>
<span class="fc" id="L1684">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1685">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1686">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1687">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1688">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1689">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1690">    }</span>

    private static void appendInt9(CharSink sink, int i) {
        int c;
<span class="fc" id="L1694">        sink.put((char) ('0' + i / 100000000));</span>
<span class="fc" id="L1695">        sink.put((char) ('0' + (c = i % 100000000) / 10000000));</span>
<span class="fc" id="L1696">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1697">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1698">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1699">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1700">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1701">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1702">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1703">    }</span>

    private static void appendLong10(CharSink sink, long i) {
        long c;
<span class="fc" id="L1707">        sink.put((char) ('0' + i / 1000000000L));</span>
<span class="fc" id="L1708">        sink.put((char) ('0' + (c = i % 1000000000L) / 100000000));</span>
<span class="fc" id="L1709">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1710">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1711">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1712">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1713">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1714">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1715">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1716">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1717">    }</span>

    private static void appendLong11(CharSink sink, long i) {
        long c;
<span class="fc" id="L1721">        sink.put((char) ('0' + i / 10000000000L));</span>
<span class="fc" id="L1722">        sink.put((char) ('0' + (c = i % 10000000000L) / 1000000000));</span>
<span class="fc" id="L1723">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1724">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1725">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1726">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1727">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1728">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1729">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1730">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1731">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1732">    }</span>

    private static void appendLong12(CharSink sink, long i) {
        long c;
<span class="fc" id="L1736">        sink.put((char) ('0' + i / 100000000000L));</span>
<span class="fc" id="L1737">        sink.put((char) ('0' + (c = i % 100000000000L) / 10000000000L));</span>
<span class="fc" id="L1738">        sink.put((char) ('0' + (c %= 10000000000L) / 1000000000));</span>
<span class="fc" id="L1739">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1740">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1741">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1742">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1743">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1744">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1745">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1746">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1747">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1748">    }</span>

    private static void appendLong13(CharSink sink, long i) {
        long c;
<span class="fc" id="L1752">        sink.put((char) ('0' + i / 1000000000000L));</span>
<span class="fc" id="L1753">        sink.put((char) ('0' + (c = i % 1000000000000L) / 100000000000L));</span>
<span class="fc" id="L1754">        sink.put((char) ('0' + (c %= 100000000000L) / 10000000000L));</span>
<span class="fc" id="L1755">        sink.put((char) ('0' + (c %= 10000000000L) / 1000000000));</span>
<span class="fc" id="L1756">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1757">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1758">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1759">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1760">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1761">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1762">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1763">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1764">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1765">    }</span>

    private static void appendLong14(CharSink sink, long i) {
        long c;
<span class="fc" id="L1769">        sink.put((char) ('0' + i / 10000000000000L));</span>
<span class="fc" id="L1770">        sink.put((char) ('0' + (c = i % 10000000000000L) / 1000000000000L));</span>
<span class="fc" id="L1771">        sink.put((char) ('0' + (c %= 1000000000000L) / 100000000000L));</span>
<span class="fc" id="L1772">        sink.put((char) ('0' + (c %= 100000000000L) / 10000000000L));</span>
<span class="fc" id="L1773">        sink.put((char) ('0' + (c %= 10000000000L) / 1000000000));</span>
<span class="fc" id="L1774">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1775">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1776">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1777">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1778">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1779">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1780">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1781">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1782">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1783">    }</span>

    private static void appendLong15(CharSink sink, long i) {
        long c;
<span class="fc" id="L1787">        sink.put((char) ('0' + i / 100000000000000L));</span>
<span class="fc" id="L1788">        sink.put((char) ('0' + (c = i % 100000000000000L) / 10000000000000L));</span>
<span class="fc" id="L1789">        sink.put((char) ('0' + (c %= 10000000000000L) / 1000000000000L));</span>
<span class="fc" id="L1790">        sink.put((char) ('0' + (c %= 1000000000000L) / 100000000000L));</span>
<span class="fc" id="L1791">        sink.put((char) ('0' + (c %= 100000000000L) / 10000000000L));</span>
<span class="fc" id="L1792">        sink.put((char) ('0' + (c %= 10000000000L) / 1000000000));</span>
<span class="fc" id="L1793">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1794">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1795">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1796">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1797">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1798">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1799">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1800">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1801">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1802">    }</span>

    private static void appendLong16(CharSink sink, long i) {
        long c;
<span class="fc" id="L1806">        sink.put((char) ('0' + i / 1000000000000000L));</span>
<span class="fc" id="L1807">        sink.put((char) ('0' + (c = i % 1000000000000000L) / 100000000000000L));</span>
<span class="fc" id="L1808">        sink.put((char) ('0' + (c %= 100000000000000L) / 10000000000000L));</span>
<span class="fc" id="L1809">        sink.put((char) ('0' + (c %= 10000000000000L) / 1000000000000L));</span>
<span class="fc" id="L1810">        sink.put((char) ('0' + (c %= 1000000000000L) / 100000000000L));</span>
<span class="fc" id="L1811">        sink.put((char) ('0' + (c %= 100000000000L) / 10000000000L));</span>
<span class="fc" id="L1812">        sink.put((char) ('0' + (c %= 10000000000L) / 1000000000));</span>
<span class="fc" id="L1813">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1814">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1815">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1816">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1817">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1818">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1819">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1820">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1821">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1822">    }</span>

    private static void appendLong17(CharSink sink, long i) {
        long c;
<span class="fc" id="L1826">        sink.put((char) ('0' + i / 10000000000000000L));</span>
<span class="fc" id="L1827">        sink.put((char) ('0' + (c = i % 10000000000000000L) / 1000000000000000L));</span>
<span class="fc" id="L1828">        sink.put((char) ('0' + (c %= 1000000000000000L) / 100000000000000L));</span>
<span class="fc" id="L1829">        sink.put((char) ('0' + (c %= 100000000000000L) / 10000000000000L));</span>
<span class="fc" id="L1830">        sink.put((char) ('0' + (c %= 10000000000000L) / 1000000000000L));</span>
<span class="fc" id="L1831">        sink.put((char) ('0' + (c %= 1000000000000L) / 100000000000L));</span>
<span class="fc" id="L1832">        sink.put((char) ('0' + (c %= 100000000000L) / 10000000000L));</span>
<span class="fc" id="L1833">        sink.put((char) ('0' + (c %= 10000000000L) / 1000000000));</span>
<span class="fc" id="L1834">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1835">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1836">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1837">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1838">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1839">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1840">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1841">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1842">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1843">    }</span>

    private static void appendLong18(CharSink sink, long i) {
        long c;
<span class="fc" id="L1847">        sink.put((char) ('0' + i / 100000000000000000L));</span>
<span class="fc" id="L1848">        sink.put((char) ('0' + (c = i % 100000000000000000L) / 10000000000000000L));</span>
<span class="fc" id="L1849">        sink.put((char) ('0' + (c %= 10000000000000000L) / 1000000000000000L));</span>
<span class="fc" id="L1850">        sink.put((char) ('0' + (c %= 1000000000000000L) / 100000000000000L));</span>
<span class="fc" id="L1851">        sink.put((char) ('0' + (c %= 100000000000000L) / 10000000000000L));</span>
<span class="fc" id="L1852">        sink.put((char) ('0' + (c %= 10000000000000L) / 1000000000000L));</span>
<span class="fc" id="L1853">        sink.put((char) ('0' + (c %= 1000000000000L) / 100000000000L));</span>
<span class="fc" id="L1854">        sink.put((char) ('0' + (c %= 100000000000L) / 10000000000L));</span>
<span class="fc" id="L1855">        sink.put((char) ('0' + (c %= 10000000000L) / 1000000000));</span>
<span class="fc" id="L1856">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1857">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1858">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1859">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1860">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1861">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1862">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1863">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1864">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1865">    }</span>

    private static void appendLong19(CharSink sink, long i) {
        long c;
<span class="fc" id="L1869">        sink.put((char) ('0' + i / 1000000000000000000L));</span>
<span class="fc" id="L1870">        sink.put((char) ('0' + (c = i % 1000000000000000000L) / 100000000000000000L));</span>
<span class="fc" id="L1871">        sink.put((char) ('0' + (c %= 100000000000000000L) / 10000000000000000L));</span>
<span class="fc" id="L1872">        sink.put((char) ('0' + (c %= 10000000000000000L) / 1000000000000000L));</span>
<span class="fc" id="L1873">        sink.put((char) ('0' + (c %= 1000000000000000L) / 100000000000000L));</span>
<span class="fc" id="L1874">        sink.put((char) ('0' + (c %= 100000000000000L) / 10000000000000L));</span>
<span class="fc" id="L1875">        sink.put((char) ('0' + (c %= 10000000000000L) / 1000000000000L));</span>
<span class="fc" id="L1876">        sink.put((char) ('0' + (c %= 1000000000000L) / 100000000000L));</span>
<span class="fc" id="L1877">        sink.put((char) ('0' + (c %= 100000000000L) / 10000000000L));</span>
<span class="fc" id="L1878">        sink.put((char) ('0' + (c %= 10000000000L) / 1000000000));</span>
<span class="fc" id="L1879">        sink.put((char) ('0' + (c %= 1000000000) / 100000000));</span>
<span class="fc" id="L1880">        sink.put((char) ('0' + (c %= 100000000) / 10000000));</span>
<span class="fc" id="L1881">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1882">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1883">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1884">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1885">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1886">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1887">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1888">    }</span>

    private static void appendLong2(CharSink sink, long i) {
<span class="fc" id="L1891">        sink.put((char) ('0' + i / 10));</span>
<span class="fc" id="L1892">        sink.put((char) ('0' + i % 10));</span>
<span class="fc" id="L1893">    }</span>

    private static void appendLong256Four(long a, long b, long c, long d, CharSink sink) {
<span class="fc" id="L1896">        appendLong256Three(b, c, d, sink);</span>
<span class="fc" id="L1897">        appendHex(sink, a, true);</span>
<span class="fc" id="L1898">    }</span>

    private static void appendLong256Three(long a, long b, long c, CharSink sink) {
<span class="fc" id="L1901">        appendLong256Two(b, c, sink);</span>
<span class="fc" id="L1902">        appendHex(sink, a, true);</span>
<span class="fc" id="L1903">    }</span>

    private static void appendLong256Two(long a, long b, CharSink sink) {
<span class="fc" id="L1906">        appendHex(sink, b, false);</span>
<span class="fc" id="L1907">        appendHex(sink, a, true);</span>
<span class="fc" id="L1908">    }</span>

    private static void appendLong3(CharSink sink, long i) {
        long c;
<span class="fc" id="L1912">        sink.put((char) ('0' + i / 100));</span>
<span class="fc" id="L1913">        sink.put((char) ('0' + (c = i % 100) / 10));</span>
<span class="fc" id="L1914">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1915">    }</span>

    private static void appendLong4(CharSink sink, long i) {
        long c;
<span class="fc" id="L1919">        sink.put((char) ('0' + i / 1000));</span>
<span class="fc" id="L1920">        sink.put((char) ('0' + (c = i % 1000) / 100));</span>
<span class="fc" id="L1921">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1922">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1923">    }</span>

    private static void appendLong5(CharSink sink, long i) {
        long c;
<span class="fc" id="L1927">        sink.put((char) ('0' + i / 10000));</span>
<span class="fc" id="L1928">        sink.put((char) ('0' + (c = i % 10000) / 1000));</span>
<span class="fc" id="L1929">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1930">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1931">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1932">    }</span>

    private static void appendLong6(CharSink sink, long i) {
        long c;
<span class="fc" id="L1936">        sink.put((char) ('0' + i / 100000));</span>
<span class="fc" id="L1937">        sink.put((char) ('0' + (c = i % 100000) / 10000));</span>
<span class="fc" id="L1938">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1939">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1940">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1941">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1942">    }</span>

    private static void appendLong7(CharSink sink, long i) {
        long c;
<span class="fc" id="L1946">        sink.put((char) ('0' + i / 1000000));</span>
<span class="fc" id="L1947">        sink.put((char) ('0' + (c = i % 1000000) / 100000));</span>
<span class="fc" id="L1948">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1949">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1950">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1951">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1952">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1953">    }</span>

    private static void appendLong8(CharSink sink, long i) {
        long c;
<span class="fc" id="L1957">        sink.put((char) ('0' + i / 10000000));</span>
<span class="fc" id="L1958">        sink.put((char) ('0' + (c = i % 10000000) / 1000000));</span>
<span class="fc" id="L1959">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1960">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1961">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1962">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1963">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1964">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1965">    }</span>

    private static void appendLong9(CharSink sink, long i) {
        long c;
<span class="fc" id="L1969">        sink.put((char) ('0' + i / 100000000));</span>
<span class="fc" id="L1970">        sink.put((char) ('0' + (c = i % 100000000) / 10000000));</span>
<span class="fc" id="L1971">        sink.put((char) ('0' + (c %= 10000000) / 1000000));</span>
<span class="fc" id="L1972">        sink.put((char) ('0' + (c %= 1000000) / 100000));</span>
<span class="fc" id="L1973">        sink.put((char) ('0' + (c %= 100000) / 10000));</span>
<span class="fc" id="L1974">        sink.put((char) ('0' + (c %= 10000) / 1000));</span>
<span class="fc" id="L1975">        sink.put((char) ('0' + (c %= 1000) / 100));</span>
<span class="fc" id="L1976">        sink.put((char) ('0' + (c %= 100) / 10));</span>
<span class="fc" id="L1977">        sink.put((char) ('0' + (c % 10)));</span>
<span class="fc" id="L1978">    }</span>

    private static void appendLongHex12(CharSink sink, long value) {
<span class="fc" id="L1981">        appendLongHexPad(sink, hexDigits[(int) ((value &gt;&gt; 8) &amp; 0xf)]);</span>
<span class="fc" id="L1982">        appendLongHex8(sink, value);</span>
<span class="fc" id="L1983">    }</span>

    private static void appendLongHex12Pad64(CharSink sink, long value) {
<span class="fc" id="L1986">        sink.put(&quot;000000000000&quot;);</span>
<span class="fc" id="L1987">        appendLongHex12(sink, value);</span>
<span class="fc" id="L1988">    }</span>

    private static void appendLongHex16(CharSink sink, long value) {
<span class="fc" id="L1991">        sink.put(hexDigits[(int) ((value &gt;&gt; 12) &amp; 0xf)]);</span>
<span class="fc" id="L1992">        sink.put(hexDigits[(int) ((value &gt;&gt; 8) &amp; 0xf)]);</span>
<span class="fc" id="L1993">        appendLongHex8(sink, value);</span>
<span class="fc" id="L1994">    }</span>

    private static void appendLongHex16Pad64(CharSink sink, long value) {
<span class="fc" id="L1997">        sink.put(&quot;000000000000&quot;);</span>
<span class="fc" id="L1998">        appendLongHex16(sink, value);</span>
<span class="fc" id="L1999">    }</span>

    private static void appendLongHex20(CharSink sink, long value) {
<span class="fc" id="L2002">        appendLongHexPad(sink, hexDigits[(int) ((value &gt;&gt; 16) &amp; 0xf)]);</span>
<span class="fc" id="L2003">        appendLongHex16(sink, value);</span>
<span class="fc" id="L2004">    }</span>

    private static void appendLongHex20Pad64(CharSink sink, long value) {
<span class="fc" id="L2007">        sink.put(&quot;0000000000&quot;);</span>
<span class="fc" id="L2008">        appendLongHex20(sink, value);</span>
<span class="fc" id="L2009">    }</span>

    private static void appendLongHex24(CharSink sink, long value) {
<span class="fc" id="L2012">        sink.put(hexDigits[(int) ((value &gt;&gt; 20) &amp; 0xf)]);</span>
<span class="fc" id="L2013">        sink.put(hexDigits[(int) ((value &gt;&gt; 16) &amp; 0xf)]);</span>
<span class="fc" id="L2014">        appendLongHex16(sink, value);</span>
<span class="fc" id="L2015">    }</span>

    private static void appendLongHex24Pad64(CharSink sink, long value) {
<span class="nc" id="L2018">        sink.put(&quot;0000000000&quot;);</span>
<span class="nc" id="L2019">        appendLongHex24(sink, value);</span>
<span class="nc" id="L2020">    }</span>

    private static void appendLongHex28(CharSink sink, long value) {
<span class="fc" id="L2023">        appendLongHexPad(sink, hexDigits[(int) ((value &gt;&gt; 24) &amp; 0xf)]);</span>
<span class="fc" id="L2024">        appendLongHex24(sink, value);</span>
<span class="fc" id="L2025">    }</span>

    private static void appendLongHex28Pad64(CharSink sink, long value) {
<span class="nc" id="L2028">        sink.put(&quot;00000000&quot;);</span>
<span class="nc" id="L2029">        appendLongHex28(sink, value);</span>
<span class="nc" id="L2030">    }</span>

    private static void appendLongHex32(CharSink sink, long value) {
<span class="fc" id="L2033">        sink.put(hexDigits[(int) ((value &gt;&gt; 28) &amp; 0xf)]);</span>
<span class="fc" id="L2034">        sink.put(hexDigits[(int) ((value &gt;&gt; 24) &amp; 0xf)]);</span>
<span class="fc" id="L2035">        appendLongHex24(sink, value);</span>
<span class="fc" id="L2036">    }</span>

    private static void appendLongHex32Pad64(CharSink sink, long value) {
<span class="nc" id="L2039">        sink.put(&quot;00000000&quot;);</span>
<span class="nc" id="L2040">        appendLongHex32(sink, value);</span>
<span class="nc" id="L2041">    }</span>

    private static void appendLongHex36(CharSink sink, long value) {
<span class="fc" id="L2044">        appendLongHexPad(sink, hexDigits[(int) ((value &gt;&gt; 32) &amp; 0xf)]);</span>
<span class="fc" id="L2045">        appendLongHex32(sink, value);</span>
<span class="fc" id="L2046">    }</span>

    private static void appendLongHex36Pad64(CharSink sink, long value) {
<span class="nc" id="L2049">        sink.put(&quot;000000&quot;);</span>
<span class="nc" id="L2050">        appendLongHex36(sink, value);</span>
<span class="nc" id="L2051">    }</span>

    private static void appendLongHex4(CharSink sink, long value) {
<span class="fc" id="L2054">        appendLongHexPad(sink, hexDigits[(int) ((value) &amp; 0xf)]);</span>
<span class="fc" id="L2055">    }</span>

    private static void appendLongHex40(CharSink sink, long value) {
<span class="fc" id="L2058">        sink.put(hexDigits[(int) ((value &gt;&gt; 36) &amp; 0xf)]);</span>
<span class="fc" id="L2059">        sink.put(hexDigits[(int) ((value &gt;&gt; 32) &amp; 0xf)]);</span>
<span class="fc" id="L2060">        appendLongHex32(sink, value);</span>
<span class="fc" id="L2061">    }</span>

    private static void appendLongHex40Pad64(CharSink sink, long value) {
<span class="nc" id="L2064">        sink.put(&quot;000000&quot;);</span>
<span class="nc" id="L2065">        appendLongHex40(sink, value);</span>
<span class="nc" id="L2066">    }</span>

    private static void appendLongHex44(CharSink sink, long value) {
<span class="fc" id="L2069">        appendLongHexPad(sink, hexDigits[(int) ((value &gt;&gt; 40) &amp; 0xf)]);</span>
<span class="fc" id="L2070">        appendLongHex40(sink, value);</span>
<span class="fc" id="L2071">    }</span>

    private static void appendLongHex44Pad64(CharSink sink, long value) {
<span class="nc" id="L2074">        sink.put(&quot;0000&quot;);</span>
<span class="nc" id="L2075">        appendLongHex44(sink, value);</span>
<span class="nc" id="L2076">    }</span>

    private static void appendLongHex48(CharSink sink, long value) {
<span class="fc" id="L2079">        sink.put(hexDigits[(int) ((value &gt;&gt; 44) &amp; 0xf)]);</span>
<span class="fc" id="L2080">        sink.put(hexDigits[(int) ((value &gt;&gt; 40) &amp; 0xf)]);</span>
<span class="fc" id="L2081">        appendLongHex40(sink, value);</span>
<span class="fc" id="L2082">    }</span>

    private static void appendLongHex48Pad64(CharSink sink, long value) {
<span class="fc" id="L2085">        sink.put(&quot;0000&quot;);</span>
<span class="fc" id="L2086">        appendLongHex48(sink, value);</span>
<span class="fc" id="L2087">    }</span>

    private static void appendLongHex4Pad64(CharSink sink, long value) {
<span class="fc" id="L2090">        sink.put(&quot;00000000000000&quot;);</span>
<span class="fc" id="L2091">        appendLongHex4(sink, value);</span>
<span class="fc" id="L2092">    }</span>

    private static void appendLongHex52(CharSink sink, long value) {
<span class="fc" id="L2095">        appendLongHexPad(sink, hexDigits[(int) ((value &gt;&gt; 48) &amp; 0xf)]);</span>
<span class="fc" id="L2096">        appendLongHex48(sink, value);</span>
<span class="fc" id="L2097">    }</span>

    private static void appendLongHex52Pad64(CharSink sink, long value) {
<span class="fc" id="L2100">        sink.put(&quot;00&quot;);</span>
<span class="fc" id="L2101">        appendLongHex52(sink, value);</span>
<span class="fc" id="L2102">    }</span>

    private static void appendLongHex56(CharSink sink, long value) {
<span class="fc" id="L2105">        sink.put(hexDigits[(int) ((value &gt;&gt; 52) &amp; 0xf)]);</span>
<span class="fc" id="L2106">        sink.put(hexDigits[(int) ((value &gt;&gt; 48) &amp; 0xf)]);</span>
<span class="fc" id="L2107">        appendLongHex48(sink, value);</span>
<span class="fc" id="L2108">    }</span>

    private static void appendLongHex56Pad64(CharSink sink, long value) {
<span class="fc" id="L2111">        sink.put(&quot;00&quot;);</span>
<span class="fc" id="L2112">        appendLongHex56(sink, value);</span>
<span class="fc" id="L2113">    }</span>

    private static void appendLongHex60(CharSink sink, long value) {
<span class="fc" id="L2116">        appendLongHexPad(sink, hexDigits[(int) ((value &gt;&gt; 56) &amp; 0xf)]);</span>
<span class="fc" id="L2117">        appendLongHex56(sink, value);</span>
<span class="fc" id="L2118">    }</span>

    private static void appendLongHex64(CharSink sink, long value) {
<span class="fc" id="L2121">        sink.put(hexDigits[(int) ((value &gt;&gt; 60) &amp; 0xf)]);</span>
<span class="fc" id="L2122">        sink.put(hexDigits[(int) ((value &gt;&gt; 56) &amp; 0xf)]);</span>
<span class="fc" id="L2123">        appendLongHex56(sink, value);</span>
<span class="fc" id="L2124">    }</span>

    private static void appendLongHex8(CharSink sink, long value) {
<span class="fc" id="L2127">        sink.put(hexDigits[(int) ((value &gt;&gt; 4) &amp; 0xf)]);</span>
<span class="fc" id="L2128">        sink.put(hexDigits[(int) ((value) &amp; 0xf)]);</span>
<span class="fc" id="L2129">    }</span>

    private static void appendLongHex8Pad64(CharSink sink, long value) {
<span class="fc" id="L2132">        sink.put(&quot;00000000000000&quot;);</span>
<span class="fc" id="L2133">        appendLongHex8(sink, value);</span>
<span class="fc" id="L2134">    }</span>

    private static void appendLongHexPad(CharSink sink, char hexDigit) {
<span class="fc" id="L2137">        sink.put('0');</span>
<span class="fc" id="L2138">        sink.put(hexDigit);</span>
<span class="fc" id="L2139">    }</span>

    private static int estimateDecExpDouble(long fractBits, int binExp) {
<span class="fc" id="L2142">        double d2 = Double.longBitsToDouble(EXP_ONE | fractBits &amp; SIGNIF_BIT_MASK);</span>
<span class="fc" id="L2143">        double d = (d2 - 1.5D) * 0.289529654D + 0.176091259D + (double) binExp * 0.301029995663981D;</span>
<span class="fc" id="L2144">        long dBits = Double.doubleToRawLongBits(d);</span>
<span class="fc" id="L2145">        int exponent = (int) ((dBits &amp; EXP_BIT_MASK) &gt;&gt; EXP_SHIFT) - EXP_BIAS;</span>
<span class="fc bfc" id="L2146" title="All 2 branches covered.">        final boolean isNegative = (dBits &amp; SIGN_BIT_MASK) != 0L;</span>
<span class="pc bpc" id="L2147" title="1 of 4 branches missed.">        if (exponent &gt; -1 &amp;&amp; exponent &lt; 52) {</span>
<span class="fc" id="L2148">            final long mask = SIGNIF_BIT_MASK &gt;&gt; exponent;</span>
<span class="fc" id="L2149">            final int r = (int) ((dBits &amp; SIGNIF_BIT_MASK | FRACT_HOB) &gt;&gt; EXP_SHIFT - exponent);</span>
<span class="pc bpc" id="L2150" title="1 of 4 branches missed.">            return isNegative ? ((mask &amp; dBits) == 0L ? -r : -r - 1) : r;</span>
<span class="pc bpc" id="L2151" title="1 of 2 branches missed.">        } else if (exponent &lt; 0) {</span>
<span class="pc bpc" id="L2152" title="1 of 4 branches missed.">            return (dBits &amp; ~SIGN_BIT_MASK) == 0L ? 0 : (isNegative ? -1 : 0);</span>
        } else {
<span class="nc" id="L2154">            return (int) d;</span>
        }
    }

    private static int insignificantDigitsForPow2(int p2) {
<span class="pc bpc" id="L2159" title="2 of 4 branches missed.">        return p2 &gt; 1 &amp;&amp; p2 &lt; insignificantDigitsNumber.length ? insignificantDigitsNumber[p2] : 0;</span>
    }

    private static int parseInt0(CharSequence sequence, final int p, int lim) throws NumericException {

<span class="fc bfc" id="L2164" title="All 2 branches covered.">        if (lim == p) {</span>
<span class="fc" id="L2165">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L2168">        final char sign = sequence.charAt(p);</span>
<span class="fc bfc" id="L2169" title="All 2 branches covered.">        final boolean negative = sign == '-';</span>
<span class="fc" id="L2170">        int i = p;</span>
<span class="fc bfc" id="L2171" title="All 4 branches covered.">        if (negative || sign == '+') {</span>
<span class="fc" id="L2172">            i++;</span>
        }

<span class="fc bfc" id="L2175" title="All 2 branches covered.">        if (i &gt;= lim) {</span>
<span class="fc" id="L2176">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L2179">        int val = 0;</span>
<span class="fc bfc" id="L2180" title="All 2 branches covered.">        for (; i &lt; lim; i++) {</span>
<span class="fc" id="L2181">            char c = sequence.charAt(i);</span>
<span class="fc bfc" id="L2182" title="All 4 branches covered.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="fc" id="L2183">                throw NumericException.INSTANCE;</span>
            }
            // val * 10 + (c - '0')
<span class="fc bfc" id="L2186" title="All 2 branches covered.">            if (val &lt; (Integer.MIN_VALUE / 10)) {</span>
<span class="fc" id="L2187">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L2189">            int r = (val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0');</span>
<span class="fc bfc" id="L2190" title="All 2 branches covered.">            if (r &gt; val) {</span>
<span class="fc" id="L2191">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L2193">            val = r;</span>
        }

<span class="fc bfc" id="L2196" title="All 4 branches covered.">        if (val == Integer.MIN_VALUE &amp;&amp; !negative) {</span>
<span class="fc" id="L2197">            throw NumericException.INSTANCE;</span>
        }
<span class="fc bfc" id="L2199" title="All 2 branches covered.">        return negative ? val : -val;</span>
    }

    private static long parseLong0(CharSequence sequence, final int p, int lim) throws NumericException {

<span class="fc bfc" id="L2204" title="All 2 branches covered.">        if (lim == p) {</span>
<span class="fc" id="L2205">            throw NumericException.INSTANCE;</span>
        }

<span class="fc bfc" id="L2208" title="All 2 branches covered.">        boolean negative = sequence.charAt(p) == '-';</span>

<span class="fc" id="L2210">        int i = p;</span>
<span class="fc bfc" id="L2211" title="All 2 branches covered.">        if (negative) {</span>
<span class="fc" id="L2212">            i++;</span>
        }

<span class="fc bfc" id="L2215" title="All 2 branches covered.">        if (i &gt;= lim) {</span>
<span class="fc" id="L2216">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L2219">        long val = 0;</span>
<span class="fc bfc" id="L2220" title="All 2 branches covered.">        for (; i &lt; lim; i++) {</span>
<span class="fc" id="L2221">            int c = sequence.charAt(i);</span>
<span class="fc bfc" id="L2222" title="All 4 branches covered.">            if (c == 'L' || c == 'l') {</span>
<span class="fc bfc" id="L2223" title="All 4 branches covered.">                if (i == 0 || i + 1 &lt; lim) {</span>
<span class="fc" id="L2224">                    throw NumericException.INSTANCE;</span>
                }
                break;
            }
<span class="fc bfc" id="L2228" title="All 4 branches covered.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="fc" id="L2229">                throw NumericException.INSTANCE;</span>
            }
            // val * 10 + (c - '0')
<span class="fc" id="L2232">            long r = (val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0');</span>
<span class="fc bfc" id="L2233" title="All 2 branches covered.">            if (r &gt; val) {</span>
<span class="fc" id="L2234">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L2236">            val = r;</span>
        }

<span class="fc bfc" id="L2239" title="All 4 branches covered.">        if (val == Long.MIN_VALUE &amp;&amp; !negative) {</span>
<span class="fc" id="L2240">            throw NumericException.INSTANCE;</span>
        }
<span class="fc bfc" id="L2242" title="All 2 branches covered.">        return negative ? val : -val;</span>
    }

    private static short parseShort0(CharSequence sequence, final int p, int lim) throws NumericException {

<span class="fc bfc" id="L2247" title="All 2 branches covered.">        if (lim == p) {</span>
<span class="fc" id="L2248">            throw NumericException.INSTANCE;</span>
        }

<span class="fc bfc" id="L2251" title="All 2 branches covered.">        boolean negative = sequence.charAt(p) == '-';</span>
<span class="fc" id="L2252">        int i = p;</span>
<span class="fc bfc" id="L2253" title="All 2 branches covered.">        if (negative) {</span>
<span class="fc" id="L2254">            i++;</span>
        }

<span class="pc bpc" id="L2257" title="1 of 2 branches missed.">        if (i &gt;= lim) {</span>
<span class="nc" id="L2258">            throw NumericException.INSTANCE;</span>
        }

<span class="fc" id="L2261">        short val = 0;</span>
<span class="fc bfc" id="L2262" title="All 2 branches covered.">        for (; i &lt; lim; i++) {</span>
<span class="fc" id="L2263">            char c = sequence.charAt(i);</span>
<span class="pc bpc" id="L2264" title="1 of 4 branches missed.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="fc" id="L2265">                throw NumericException.INSTANCE;</span>
            }
            // val * 10 + (c - '0')
<span class="fc bfc" id="L2268" title="All 2 branches covered.">            if (val &lt; (Short.MIN_VALUE / 10)) {</span>
<span class="fc" id="L2269">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L2271">            short r = (short) ((val &lt;&lt; 3) + (val &lt;&lt; 1) - (c - '0'));</span>
<span class="fc bfc" id="L2272" title="All 2 branches covered.">            if (r &gt; val) {</span>
<span class="fc" id="L2273">                throw NumericException.INSTANCE;</span>
            }
<span class="fc" id="L2275">            val = r;</span>
        }

<span class="pc bpc" id="L2278" title="1 of 4 branches missed.">        if (val == Short.MIN_VALUE &amp;&amp; !negative) {</span>
<span class="fc" id="L2279">            throw NumericException.INSTANCE;</span>
        }
<span class="fc bfc" id="L2281" title="All 2 branches covered.">        return negative ? val : (short) -val;</span>
    }

    private static double roundDown0(double value, int scale) {
<span class="fc" id="L2285">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L2286">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L2287">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L2288">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundDown00(absValue, scale)) | signMask);</span>
    }

    private static double roundDown00(double value, int scale) {
<span class="fc bfc" id="L2292" title="All 2 branches covered.">        return scale &lt; 0 ? roundDown00NegScale(value, -scale) : roundDown00PosScale(value, scale);</span>
    }

    private static double roundDown00NegScale(double value, int scale) {
<span class="fc" id="L2296">        long powten = pow10[scale];</span>
<span class="fc" id="L2297">        double powtenNeg = pow10dNeg[scale];</span>
<span class="fc" id="L2298">        return ((double) (long) ((value + TOLERANCE) * powtenNeg)) * powten;</span>
    }

    private static double roundDown00PosScale(double value, int scale) {
<span class="fc" id="L2302">        long powten = pow10[scale];</span>
<span class="fc" id="L2303">        double powtenNeg = pow10dNeg[scale];</span>
<span class="fc" id="L2304">        return ((double) (long) ((value + TOLERANCE) * powten)) * powtenNeg;</span>
    }

    private static double roundDown0NegScale(double value, int scale) {
<span class="fc" id="L2308">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L2309">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L2310">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L2311">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundDown00NegScale(absValue, scale)) | signMask);</span>
    }

    private static double roundHalfDown0(double value, int scale) {
<span class="fc" id="L2315">        long val = (long) (value * pow10[scale + 2] + TOLERANCE);</span>
<span class="fc bfc" id="L2316" title="All 2 branches covered.">        return val % 100 &gt; 50 ? roundUp0(value, scale) : roundDown0(value, scale);</span>
    }

    private static double roundHalfEven0(double value, int scale) {
<span class="fc bfc" id="L2320" title="All 2 branches covered.">        return scale &gt; 0 ? roundHalfEven0PosScale(value, scale) : roundHalfEven0NegScale(value, -scale);</span>
    }

    private static double roundHalfUp0(double value, int scale) {
<span class="fc bfc" id="L2324" title="All 2 branches covered.">        return scale &gt; 0 ? roundHalfUp0PosScale(value, scale) : roundHalfUp0NegScale(value, -scale);</span>
    }

    private static double roundHalfUp0NegScale(double value, int scale) {
<span class="fc" id="L2328">        long val = (long) (value * pow10dNeg[scale] * pow10[2] + TOLERANCE);</span>
<span class="fc bfc" id="L2329" title="All 2 branches covered.">        return val % 100 &lt; 50 ? roundDown0NegScale(value, scale) : roundUp0NegScale(value, scale);</span>
    }

    private static double roundHalfUp0PosScale(double value, int scale) {
<span class="fc" id="L2333">        long val = (long) ((value + TOLERANCE) * pow10[scale + 2]);</span>
<span class="fc bfc" id="L2334" title="All 2 branches covered.">        return val % 100 &lt; 50 ? roundDown00PosScale(value, scale) : roundUp00PosScale(value, scale);</span>
    }

    private static double roundUp0(double value, int scale) {
<span class="fc" id="L2338">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L2339">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L2340">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L2341">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundUp00(absValue, scale)) | signMask);</span>
    }

    private static double roundUp00(double value, int scale) {
<span class="fc bfc" id="L2345" title="All 2 branches covered.">        return scale &lt; 0 ? roundUp00NegScale(value, -scale) : roundUp00PosScale(value, scale);</span>
    }

    private static double roundUp00NegScale(double value, int scale) {
<span class="fc" id="L2349">        long powten = pow10[scale];</span>
<span class="fc" id="L2350">        double powtenNeg = pow10dNeg[scale];</span>
<span class="fc" id="L2351">        return ((double) (long) (value * powtenNeg + 1 - TOLERANCE)) * powten;</span>
    }

    private static double roundUp00PosScale(double value, int scale) {
<span class="fc" id="L2355">        long powten = pow10[scale];</span>
<span class="fc" id="L2356">        double powtenNeg = pow10dNeg[scale];</span>
<span class="fc" id="L2357">        return ((double) (long) (value * powten + 1 - TOLERANCE)) * powtenNeg;</span>
    }

    private static double roundUp0NegScale(double value, int scale) {
<span class="fc" id="L2361">        long valueBits = Double.doubleToRawLongBits(value);</span>
<span class="fc" id="L2362">        long signMask = valueBits &amp; Numbers.SIGN_BIT_MASK;</span>
<span class="fc" id="L2363">        double absValue = Double.longBitsToDouble(valueBits &amp; ~Numbers.SIGN_BIT_MASK);</span>
<span class="fc" id="L2364">        return Double.longBitsToDouble(Double.doubleToRawLongBits(roundUp00NegScale(absValue, scale)) | signMask);</span>
    }

    private static boolean roundupDouble(int firstDigitIndex, char[] digits, int nDigits) {
<span class="fc" id="L2368">        int charIndex = firstDigitIndex + nDigits - 1;</span>
<span class="fc" id="L2369">        char c = digits[charIndex];</span>
<span class="fc bfc" id="L2370" title="All 2 branches covered.">        if (c == '9') {</span>
            while (true) {
<span class="pc bpc" id="L2372" title="1 of 4 branches missed.">                if (c != '9' || charIndex &lt;= firstDigitIndex) {</span>
<span class="pc bpc" id="L2373" title="1 of 2 branches missed.">                    if (c == '9') {</span>
<span class="nc" id="L2374">                        digits[firstDigitIndex] = '1';</span>
<span class="nc" id="L2375">                        return true;</span>
                    }
                    break;
                }

<span class="fc" id="L2380">                digits[charIndex] = '0';</span>
<span class="fc" id="L2381">                --charIndex;</span>
<span class="fc" id="L2382">                c = digits[charIndex];</span>
            }
        }

<span class="fc" id="L2386">        digits[charIndex] = (char) (c + 1);</span>
<span class="fc" id="L2387">        return false;</span>
    }

    @FunctionalInterface
    private interface LongHexAppender {
        void append(CharSink sink, long value);
    }

    //#if jdk.version!=8
    static {
<span class="fc" id="L2397">        Module currentModule = Numbers.class.getModule();</span>
<span class="fc" id="L2398">        Unsafe.addExports(Unsafe.JAVA_BASE_MODULE, currentModule, &quot;jdk.internal.math&quot;);</span>
    }
    //#endif

    // @formatter:on
    static {
<span class="fc" id="L2404">        pow10 = new long[20];</span>
<span class="fc" id="L2405">        pow10max = 18;</span>
<span class="fc" id="L2406">        pow10[0] = 1;</span>
<span class="fc bfc" id="L2407" title="All 2 branches covered.">        for (int i = 1; i &lt; pow10.length; i++) {</span>
<span class="fc" id="L2408">            pow10[i] = pow10[i - 1] * 10;</span>
        }

<span class="fc" id="L2411">        hexNumbers = new int[128];</span>
<span class="fc" id="L2412">        Arrays.fill(hexNumbers, -1);</span>
<span class="fc" id="L2413">        hexNumbers['0'] = 0;</span>
<span class="fc" id="L2414">        hexNumbers['1'] = 1;</span>
<span class="fc" id="L2415">        hexNumbers['2'] = 2;</span>
<span class="fc" id="L2416">        hexNumbers['3'] = 3;</span>
<span class="fc" id="L2417">        hexNumbers['4'] = 4;</span>
<span class="fc" id="L2418">        hexNumbers['5'] = 5;</span>
<span class="fc" id="L2419">        hexNumbers['6'] = 6;</span>
<span class="fc" id="L2420">        hexNumbers['7'] = 7;</span>
<span class="fc" id="L2421">        hexNumbers['8'] = 8;</span>
<span class="fc" id="L2422">        hexNumbers['9'] = 9;</span>
<span class="fc" id="L2423">        hexNumbers['A'] = 10;</span>
<span class="fc" id="L2424">        hexNumbers['a'] = 10;</span>
<span class="fc" id="L2425">        hexNumbers['B'] = 11;</span>
<span class="fc" id="L2426">        hexNumbers['b'] = 11;</span>
<span class="fc" id="L2427">        hexNumbers['C'] = 12;</span>
<span class="fc" id="L2428">        hexNumbers['c'] = 12;</span>
<span class="fc" id="L2429">        hexNumbers['D'] = 13;</span>
<span class="fc" id="L2430">        hexNumbers['d'] = 13;</span>
<span class="fc" id="L2431">        hexNumbers['E'] = 14;</span>
<span class="fc" id="L2432">        hexNumbers['e'] = 14;</span>
<span class="fc" id="L2433">        hexNumbers['F'] = 15;</span>
<span class="fc" id="L2434">        hexNumbers['f'] = 15;</span>
    }

    static {
<span class="fc" id="L2438">        final LongHexAppender a4 = Numbers::appendLongHex4;</span>
<span class="fc" id="L2439">        longHexAppender[0] = a4;</span>
<span class="fc" id="L2440">        longHexAppender[1] = a4;</span>
<span class="fc" id="L2441">        longHexAppender[2] = a4;</span>
<span class="fc" id="L2442">        longHexAppender[3] = a4;</span>
<span class="fc" id="L2443">        longHexAppender[4] = a4;</span>

<span class="fc" id="L2445">        final LongHexAppender a8 = Numbers::appendLongHex8;</span>
<span class="fc" id="L2446">        longHexAppender[5] = a8;</span>
<span class="fc" id="L2447">        longHexAppender[6] = a8;</span>
<span class="fc" id="L2448">        longHexAppender[7] = a8;</span>
<span class="fc" id="L2449">        longHexAppender[8] = a8;</span>

<span class="fc" id="L2451">        LongHexAppender a12 = Numbers::appendLongHex12;</span>
<span class="fc" id="L2452">        longHexAppender[9] = a12;</span>
<span class="fc" id="L2453">        longHexAppender[10] = a12;</span>
<span class="fc" id="L2454">        longHexAppender[11] = a12;</span>
<span class="fc" id="L2455">        longHexAppender[12] = a12;</span>

<span class="fc" id="L2457">        LongHexAppender a16 = Numbers::appendLongHex16;</span>
<span class="fc" id="L2458">        longHexAppender[13] = a16;</span>
<span class="fc" id="L2459">        longHexAppender[14] = a16;</span>
<span class="fc" id="L2460">        longHexAppender[15] = a16;</span>
<span class="fc" id="L2461">        longHexAppender[16] = a16;</span>

<span class="fc" id="L2463">        LongHexAppender a20 = Numbers::appendLongHex20;</span>
<span class="fc" id="L2464">        longHexAppender[17] = a20;</span>
<span class="fc" id="L2465">        longHexAppender[18] = a20;</span>
<span class="fc" id="L2466">        longHexAppender[19] = a20;</span>
<span class="fc" id="L2467">        longHexAppender[20] = a20;</span>

<span class="fc" id="L2469">        LongHexAppender a24 = Numbers::appendLongHex24;</span>
<span class="fc" id="L2470">        longHexAppender[21] = a24;</span>
<span class="fc" id="L2471">        longHexAppender[22] = a24;</span>
<span class="fc" id="L2472">        longHexAppender[23] = a24;</span>
<span class="fc" id="L2473">        longHexAppender[24] = a24;</span>

<span class="fc" id="L2475">        LongHexAppender a28 = Numbers::appendLongHex28;</span>
<span class="fc" id="L2476">        longHexAppender[25] = a28;</span>
<span class="fc" id="L2477">        longHexAppender[26] = a28;</span>
<span class="fc" id="L2478">        longHexAppender[27] = a28;</span>
<span class="fc" id="L2479">        longHexAppender[28] = a28;</span>

<span class="fc" id="L2481">        LongHexAppender a32 = Numbers::appendLongHex32;</span>
<span class="fc" id="L2482">        longHexAppender[29] = a32;</span>
<span class="fc" id="L2483">        longHexAppender[30] = a32;</span>
<span class="fc" id="L2484">        longHexAppender[31] = a32;</span>
<span class="fc" id="L2485">        longHexAppender[32] = a32;</span>

<span class="fc" id="L2487">        LongHexAppender a36 = Numbers::appendLongHex36;</span>
<span class="fc" id="L2488">        longHexAppender[33] = a36;</span>
<span class="fc" id="L2489">        longHexAppender[34] = a36;</span>
<span class="fc" id="L2490">        longHexAppender[35] = a36;</span>
<span class="fc" id="L2491">        longHexAppender[36] = a36;</span>

<span class="fc" id="L2493">        LongHexAppender a40 = Numbers::appendLongHex40;</span>
<span class="fc" id="L2494">        longHexAppender[37] = a40;</span>
<span class="fc" id="L2495">        longHexAppender[38] = a40;</span>
<span class="fc" id="L2496">        longHexAppender[39] = a40;</span>
<span class="fc" id="L2497">        longHexAppender[40] = a40;</span>

<span class="fc" id="L2499">        LongHexAppender a44 = Numbers::appendLongHex44;</span>
<span class="fc" id="L2500">        longHexAppender[41] = a44;</span>
<span class="fc" id="L2501">        longHexAppender[42] = a44;</span>
<span class="fc" id="L2502">        longHexAppender[43] = a44;</span>
<span class="fc" id="L2503">        longHexAppender[44] = a44;</span>

<span class="fc" id="L2505">        LongHexAppender a48 = Numbers::appendLongHex48;</span>
<span class="fc" id="L2506">        longHexAppender[45] = a48;</span>
<span class="fc" id="L2507">        longHexAppender[46] = a48;</span>
<span class="fc" id="L2508">        longHexAppender[47] = a48;</span>
<span class="fc" id="L2509">        longHexAppender[48] = a48;</span>

<span class="fc" id="L2511">        LongHexAppender a52 = Numbers::appendLongHex52;</span>
<span class="fc" id="L2512">        longHexAppender[49] = a52;</span>
<span class="fc" id="L2513">        longHexAppender[50] = a52;</span>
<span class="fc" id="L2514">        longHexAppender[51] = a52;</span>
<span class="fc" id="L2515">        longHexAppender[52] = a52;</span>

<span class="fc" id="L2517">        LongHexAppender a56 = Numbers::appendLongHex56;</span>
<span class="fc" id="L2518">        longHexAppender[53] = a56;</span>
<span class="fc" id="L2519">        longHexAppender[54] = a56;</span>
<span class="fc" id="L2520">        longHexAppender[55] = a56;</span>
<span class="fc" id="L2521">        longHexAppender[56] = a56;</span>

<span class="fc" id="L2523">        LongHexAppender a60 = Numbers::appendLongHex60;</span>
<span class="fc" id="L2524">        longHexAppender[57] = a60;</span>
<span class="fc" id="L2525">        longHexAppender[58] = a60;</span>
<span class="fc" id="L2526">        longHexAppender[59] = a60;</span>
<span class="fc" id="L2527">        longHexAppender[60] = a60;</span>

<span class="fc" id="L2529">        LongHexAppender a64 = Numbers::appendLongHex64;</span>
<span class="fc" id="L2530">        longHexAppender[61] = a64;</span>
<span class="fc" id="L2531">        longHexAppender[62] = a64;</span>
<span class="fc" id="L2532">        longHexAppender[63] = a64;</span>
<span class="fc" id="L2533">        longHexAppender[64] = a64;</span>
    }

    static {
<span class="fc" id="L2537">        final LongHexAppender a4 = Numbers::appendLongHex4Pad64;</span>
<span class="fc" id="L2538">        longHexAppenderPad64[0] = a4;</span>
<span class="fc" id="L2539">        longHexAppenderPad64[1] = a4;</span>
<span class="fc" id="L2540">        longHexAppenderPad64[2] = a4;</span>
<span class="fc" id="L2541">        longHexAppenderPad64[3] = a4;</span>
<span class="fc" id="L2542">        longHexAppenderPad64[4] = a4;</span>

<span class="fc" id="L2544">        final LongHexAppender a8 = Numbers::appendLongHex8Pad64;</span>
<span class="fc" id="L2545">        longHexAppenderPad64[5] = a8;</span>
<span class="fc" id="L2546">        longHexAppenderPad64[6] = a8;</span>
<span class="fc" id="L2547">        longHexAppenderPad64[7] = a8;</span>
<span class="fc" id="L2548">        longHexAppenderPad64[8] = a8;</span>

<span class="fc" id="L2550">        LongHexAppender a12 = Numbers::appendLongHex12Pad64;</span>
<span class="fc" id="L2551">        longHexAppenderPad64[9] = a12;</span>
<span class="fc" id="L2552">        longHexAppenderPad64[10] = a12;</span>
<span class="fc" id="L2553">        longHexAppenderPad64[11] = a12;</span>
<span class="fc" id="L2554">        longHexAppenderPad64[12] = a12;</span>

<span class="fc" id="L2556">        LongHexAppender a16 = Numbers::appendLongHex16Pad64;</span>
<span class="fc" id="L2557">        longHexAppenderPad64[13] = a16;</span>
<span class="fc" id="L2558">        longHexAppenderPad64[14] = a16;</span>
<span class="fc" id="L2559">        longHexAppenderPad64[15] = a16;</span>
<span class="fc" id="L2560">        longHexAppenderPad64[16] = a16;</span>

<span class="fc" id="L2562">        LongHexAppender a20 = Numbers::appendLongHex20Pad64;</span>
<span class="fc" id="L2563">        longHexAppenderPad64[17] = a20;</span>
<span class="fc" id="L2564">        longHexAppenderPad64[18] = a20;</span>
<span class="fc" id="L2565">        longHexAppenderPad64[19] = a20;</span>
<span class="fc" id="L2566">        longHexAppenderPad64[20] = a20;</span>

<span class="fc" id="L2568">        LongHexAppender a24 = Numbers::appendLongHex24Pad64;</span>
<span class="fc" id="L2569">        longHexAppenderPad64[21] = a24;</span>
<span class="fc" id="L2570">        longHexAppenderPad64[22] = a24;</span>
<span class="fc" id="L2571">        longHexAppenderPad64[23] = a24;</span>
<span class="fc" id="L2572">        longHexAppenderPad64[24] = a24;</span>

<span class="fc" id="L2574">        LongHexAppender a28 = Numbers::appendLongHex28Pad64;</span>
<span class="fc" id="L2575">        longHexAppenderPad64[25] = a28;</span>
<span class="fc" id="L2576">        longHexAppenderPad64[26] = a28;</span>
<span class="fc" id="L2577">        longHexAppenderPad64[27] = a28;</span>
<span class="fc" id="L2578">        longHexAppenderPad64[28] = a28;</span>

<span class="fc" id="L2580">        LongHexAppender a32 = Numbers::appendLongHex32Pad64;</span>
<span class="fc" id="L2581">        longHexAppenderPad64[29] = a32;</span>
<span class="fc" id="L2582">        longHexAppenderPad64[30] = a32;</span>
<span class="fc" id="L2583">        longHexAppenderPad64[31] = a32;</span>
<span class="fc" id="L2584">        longHexAppenderPad64[32] = a32;</span>

<span class="fc" id="L2586">        LongHexAppender a36 = Numbers::appendLongHex36Pad64;</span>
<span class="fc" id="L2587">        longHexAppenderPad64[33] = a36;</span>
<span class="fc" id="L2588">        longHexAppenderPad64[34] = a36;</span>
<span class="fc" id="L2589">        longHexAppenderPad64[35] = a36;</span>
<span class="fc" id="L2590">        longHexAppenderPad64[36] = a36;</span>

<span class="fc" id="L2592">        LongHexAppender a40 = Numbers::appendLongHex40Pad64;</span>
<span class="fc" id="L2593">        longHexAppenderPad64[37] = a40;</span>
<span class="fc" id="L2594">        longHexAppenderPad64[38] = a40;</span>
<span class="fc" id="L2595">        longHexAppenderPad64[39] = a40;</span>
<span class="fc" id="L2596">        longHexAppenderPad64[40] = a40;</span>

<span class="fc" id="L2598">        LongHexAppender a44 = Numbers::appendLongHex44Pad64;</span>
<span class="fc" id="L2599">        longHexAppenderPad64[41] = a44;</span>
<span class="fc" id="L2600">        longHexAppenderPad64[42] = a44;</span>
<span class="fc" id="L2601">        longHexAppenderPad64[43] = a44;</span>
<span class="fc" id="L2602">        longHexAppenderPad64[44] = a44;</span>

<span class="fc" id="L2604">        LongHexAppender a48 = Numbers::appendLongHex48Pad64;</span>
<span class="fc" id="L2605">        longHexAppenderPad64[45] = a48;</span>
<span class="fc" id="L2606">        longHexAppenderPad64[46] = a48;</span>
<span class="fc" id="L2607">        longHexAppenderPad64[47] = a48;</span>
<span class="fc" id="L2608">        longHexAppenderPad64[48] = a48;</span>

<span class="fc" id="L2610">        LongHexAppender a52 = Numbers::appendLongHex52Pad64;</span>
<span class="fc" id="L2611">        longHexAppenderPad64[49] = a52;</span>
<span class="fc" id="L2612">        longHexAppenderPad64[50] = a52;</span>
<span class="fc" id="L2613">        longHexAppenderPad64[51] = a52;</span>
<span class="fc" id="L2614">        longHexAppenderPad64[52] = a52;</span>

<span class="fc" id="L2616">        LongHexAppender a56 = Numbers::appendLongHex56Pad64;</span>
<span class="fc" id="L2617">        longHexAppenderPad64[53] = a56;</span>
<span class="fc" id="L2618">        longHexAppenderPad64[54] = a56;</span>
<span class="fc" id="L2619">        longHexAppenderPad64[55] = a56;</span>
<span class="fc" id="L2620">        longHexAppenderPad64[56] = a56;</span>

<span class="fc" id="L2622">        LongHexAppender a60 = Numbers::appendLongHex60;</span>
<span class="fc" id="L2623">        longHexAppenderPad64[57] = a60;</span>
<span class="fc" id="L2624">        longHexAppenderPad64[58] = a60;</span>
<span class="fc" id="L2625">        longHexAppenderPad64[59] = a60;</span>
<span class="fc" id="L2626">        longHexAppenderPad64[60] = a60;</span>

<span class="fc" id="L2628">        LongHexAppender a64 = Numbers::appendLongHex64;</span>
<span class="fc" id="L2629">        longHexAppenderPad64[61] = a64;</span>
<span class="fc" id="L2630">        longHexAppenderPad64[62] = a64;</span>
<span class="fc" id="L2631">        longHexAppenderPad64[63] = a64;</span>
<span class="fc" id="L2632">        longHexAppenderPad64[64] = a64;</span>
<span class="fc" id="L2633">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>