<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonQueryProcessorState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cutlass.http.processors</a> &gt; <span class="el_source">JsonQueryProcessorState.java</span></div><h1>JsonQueryProcessorState.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cutlass.http.processors;

import io.questdb.cairo.ColumnType;
import io.questdb.cairo.GeoHashes;
import io.questdb.cairo.sql.Record;
import io.questdb.cairo.sql.*;
import io.questdb.cutlass.http.HttpChunkedResponseSocket;
import io.questdb.cutlass.http.HttpConnectionContext;
import io.questdb.cutlass.http.HttpRequestHeader;
import io.questdb.cutlass.text.TextUtil;
import io.questdb.cutlass.text.Utf8Exception;
import io.questdb.griffin.SqlException;
import io.questdb.griffin.SqlExecutionContextImpl;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.log.LogRecord;
import io.questdb.mp.SCSequence;
import io.questdb.network.PeerDisconnectedException;
import io.questdb.network.PeerIsSlowToReadException;
import io.questdb.std.*;
import io.questdb.std.str.CharSink;
import io.questdb.std.str.DirectByteCharSequence;
import io.questdb.std.str.StringSink;

import java.io.Closeable;

public class JsonQueryProcessorState implements Mutable, Closeable {
    static final int QUERY_METADATA = 2;
    static final int QUERY_METADATA_SUFFIX = 3;
    static final int QUERY_PREFIX = 1;
    static final int QUERY_RECORD = 5;
    static final int QUERY_RECORD_PREFIX = 9;
    static final int QUERY_RECORD_START = 4;
    static final int QUERY_RECORD_SUFFIX = 6;
    static final int QUERY_SETUP_FIRST_RECORD = 8;
    static final int QUERY_SUFFIX = 7;
<span class="fc" id="L61">    private static final Log LOG = LogFactory.getLog(JsonQueryProcessorState.class);</span>
<span class="fc" id="L62">    private final ObjList&lt;String&gt; columnNames = new ObjList&lt;&gt;();</span>
    private int queryTimestampIndex;
<span class="fc" id="L64">    private final IntList columnSkewList = new IntList();</span>
<span class="fc" id="L65">    private final IntList columnTypesAndFlags = new IntList();</span>
<span class="fc" id="L66">    private final StringSink columnsQueryParameter = new StringSink();</span>
    private final int doubleScale;
<span class="fc" id="L68">    private final SCSequence eventSubSequence = new SCSequence();</span>
    private final int floatScale;
    private final HttpConnectionContext httpConnectionContext;
    private final NanosecondClock nanosecondClock;
<span class="fc" id="L72">    private final StringSink query = new StringSink();</span>
<span class="fc" id="L73">    private final ObjList&lt;StateResumeAction&gt; resumeActions = new ObjList&lt;&gt;();</span>
    private final long statementTimeout;
    private int columnCount;
    private int columnIndex;
    private long compilerNanos;
    private long count;
<span class="fc" id="L79">    private boolean countRows = false;</span>
    private RecordCursor cursor;
    private long executeStartNanos;
<span class="fc" id="L82">    private boolean explain = false;</span>
<span class="fc" id="L83">    private boolean noMeta = false;</span>
    private OperationFuture operationFuture;
<span class="fc" id="L85">    private boolean pausedQuery = false;</span>
<span class="fc" id="L86">    private boolean queryCacheable = false;</span>
<span class="fc" id="L87">    private boolean queryJitCompiled = false;</span>
<span class="fc" id="L88">    private int queryState = QUERY_PREFIX;</span>
    private short queryType;
<span class="fc" id="L90">    private boolean quoteLargeNum = false;</span>
    private Record record;
    private long recordCountNanos;
    private RecordCursorFactory recordCursorFactory;
    private Rnd rnd;
    private long skip;
    private long stop;
<span class="fc" id="L97">    private boolean timings = false;</span>

    public JsonQueryProcessorState(
            HttpConnectionContext httpConnectionContext,
            NanosecondClock nanosecondClock,
            int floatScale,
            int doubleScale
<span class="fc" id="L104">    ) {</span>
<span class="fc" id="L105">        this.httpConnectionContext = httpConnectionContext;</span>
<span class="fc" id="L106">        resumeActions.extendAndSet(QUERY_PREFIX, this::onQueryPrefix);</span>
<span class="fc" id="L107">        resumeActions.extendAndSet(QUERY_METADATA, this::onQueryMetadata);</span>
<span class="fc" id="L108">        resumeActions.extendAndSet(QUERY_METADATA_SUFFIX, this::onQueryMetadataSuffix);</span>
<span class="fc" id="L109">        resumeActions.extendAndSet(QUERY_SETUP_FIRST_RECORD, this::doFirstRecordLoop);</span>
<span class="fc" id="L110">        resumeActions.extendAndSet(QUERY_RECORD_PREFIX, this::onQueryRecordPrefix);</span>
<span class="fc" id="L111">        resumeActions.extendAndSet(QUERY_RECORD, this::onQueryRecord);</span>
<span class="fc" id="L112">        resumeActions.extendAndSet(QUERY_RECORD_SUFFIX, this::onQueryRecordSuffix);</span>
<span class="fc" id="L113">        resumeActions.extendAndSet(QUERY_SUFFIX, this::doQuerySuffix);</span>

<span class="fc" id="L115">        this.nanosecondClock = nanosecondClock;</span>
<span class="fc" id="L116">        this.floatScale = floatScale;</span>
<span class="fc" id="L117">        this.doubleScale = doubleScale;</span>
<span class="fc" id="L118">        this.statementTimeout = httpConnectionContext.getRequestHeader().getStatementTimeout();</span>
<span class="fc" id="L119">    }</span>

    @Override
    public void clear() {
<span class="fc" id="L123">        columnCount = 0;</span>
<span class="fc" id="L124">        columnSkewList.clear();</span>
<span class="fc" id="L125">        columnTypesAndFlags.clear();</span>
<span class="fc" id="L126">        columnNames.clear();</span>
<span class="fc" id="L127">        queryTimestampIndex = -1;</span>
<span class="fc" id="L128">        cursor = Misc.free(cursor);</span>
<span class="fc" id="L129">        record = null;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (recordCursorFactory != null) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            if (queryCacheable) {</span>
<span class="fc" id="L132">                QueryCache.getThreadLocalInstance().push(query, recordCursorFactory);</span>
            } else {
<span class="fc" id="L134">                recordCursorFactory.close();</span>
            }
<span class="fc" id="L136">            recordCursorFactory = null;</span>
        }
<span class="fc" id="L138">        query.clear();</span>
<span class="fc" id="L139">        columnsQueryParameter.clear();</span>
<span class="fc" id="L140">        queryState = QUERY_PREFIX;</span>
<span class="fc" id="L141">        columnIndex = 0;</span>
<span class="fc" id="L142">        countRows = false;</span>
<span class="fc" id="L143">        explain = false;</span>
<span class="fc" id="L144">        noMeta = false;</span>
<span class="fc" id="L145">        timings = false;</span>
<span class="fc" id="L146">        pausedQuery = false;</span>
<span class="fc" id="L147">        quoteLargeNum = false;</span>
<span class="fc" id="L148">        queryJitCompiled = false;</span>
<span class="fc" id="L149">        operationFuture = Misc.free(operationFuture);</span>
<span class="fc" id="L150">        skip = 0;</span>
<span class="fc" id="L151">        count = 0;</span>
<span class="fc" id="L152">        stop = 0;</span>
<span class="fc" id="L153">    }</span>

    @Override
    public void close() {
<span class="fc" id="L157">        cursor = Misc.free(cursor);</span>
<span class="fc" id="L158">        recordCursorFactory = Misc.free(recordCursorFactory);</span>
<span class="fc" id="L159">        freeAsyncOperation();</span>
<span class="fc" id="L160">    }</span>

    public void configure(
            HttpRequestHeader request,
            DirectByteCharSequence query,
            long skip,
            long stop
    ) throws Utf8Exception {
<span class="fc" id="L168">        this.query.clear();</span>
<span class="fc" id="L169">        TextUtil.utf8Decode(query.getLo(), query.getHi(), this.query);</span>
<span class="fc" id="L170">        this.skip = skip;</span>
<span class="fc" id="L171">        this.stop = stop;</span>
<span class="fc" id="L172">        count = 0L;</span>
<span class="fc" id="L173">        noMeta = Chars.equalsNc(&quot;true&quot;, request.getUrlParam(&quot;nm&quot;));</span>
<span class="fc" id="L174">        countRows = Chars.equalsNc(&quot;true&quot;, request.getUrlParam(&quot;count&quot;));</span>
<span class="fc" id="L175">        timings = Chars.equalsNc(&quot;true&quot;, request.getUrlParam(&quot;timings&quot;));</span>
<span class="fc" id="L176">        explain = Chars.equalsNc(&quot;true&quot;, request.getUrlParam(&quot;explain&quot;));</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        quoteLargeNum = Chars.equalsNc(&quot;true&quot;, request.getUrlParam(&quot;quoteLargeNum&quot;))</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                || Chars.equalsNc(&quot;con&quot;, request.getUrlParam(&quot;src&quot;));</span>
<span class="fc" id="L179">    }</span>

    public LogRecord critical() {
<span class="fc" id="L182">        return LOG.critical().$('[').$(getFd()).$(&quot;] &quot;);</span>
    }

    public LogRecord error() {
<span class="fc" id="L186">        return LOG.error().$('[').$(getFd()).$(&quot;] &quot;);</span>
    }

    public void freeAsyncOperation() {
<span class="fc" id="L190">        operationFuture = Misc.free(operationFuture);</span>
<span class="fc" id="L191">    }</span>

    public SCSequence getEventSubSequence() {
<span class="fc" id="L194">        return eventSubSequence;</span>
    }

    public long getExecutionTimeNanos() {
<span class="fc" id="L198">        return nanosecondClock.getTicks() - this.executeStartNanos;</span>
    }

    public HttpConnectionContext getHttpConnectionContext() {
<span class="fc" id="L202">        return httpConnectionContext;</span>
    }

    public OperationFuture getOperationFuture() {
<span class="fc" id="L206">        return operationFuture;</span>
    }

    public CharSequence getQuery() {
<span class="fc" id="L210">        return query;</span>
    }

    public short getQueryType() {
<span class="nc" id="L214">        return queryType;</span>
    }

    public Rnd getRnd() {
<span class="fc" id="L218">        return rnd;</span>
    }

    public long getStatementTimeout() {
<span class="fc" id="L222">        return statementTimeout;</span>
    }

    public LogRecord info() {
<span class="fc" id="L226">        return LOG.info().$('[').$(getFd()).$(&quot;] &quot;);</span>
    }

    public boolean isPausedQuery() {
<span class="fc" id="L230">        return pausedQuery;</span>
    }

    public void logBufferTooSmall() {
<span class="nc" id="L234">        info().$(&quot;Response buffer is too small, state=&quot;).$(queryState).$();</span>
<span class="nc" id="L235">    }</span>

    public void logExecuteCached() {
<span class="fc" id="L238">        info().$(&quot;execute-cached [skip: &quot;).$(skip)</span>
<span class="fc" id="L239">                .$(&quot;, stop: &quot;).$(stop).I$();</span>
<span class="fc" id="L240">    }</span>

    public void logExecuteNew() {
<span class="fc" id="L243">        info().$(&quot;execute-new [skip: &quot;).$(skip)</span>
<span class="fc" id="L244">                .$(&quot;, stop: &quot;).$(stop).I$();</span>
<span class="fc" id="L245">    }</span>

    public void logSqlError(FlyweightMessageContainer container) {
<span class="fc" id="L248">        info().$(&quot;sql error [q=`&quot;).utf8(query)</span>
<span class="fc" id="L249">                .$(&quot;`, at=&quot;).$(container.getPosition())</span>
<span class="fc" id="L250">                .$(&quot;, message=`&quot;).utf8(container.getFlyweightMessage()).$('`').$(']').$();</span>
<span class="fc" id="L251">    }</span>

    public void logTimings() {
<span class="fc" id="L254">        info().$(&quot;timings &quot;)</span>
<span class="fc" id="L255">                .$(&quot;[compiler: &quot;).$(compilerNanos)</span>
<span class="fc" id="L256">                .$(&quot;, count: &quot;).$(recordCountNanos)</span>
<span class="fc" id="L257">                .$(&quot;, execute: &quot;).$(nanosecondClock.getTicks() - executeStartNanos)</span>
<span class="fc" id="L258">                .$(&quot;, q=`&quot;).utf8(query)</span>
<span class="fc" id="L259">                .$(&quot;`]&quot;).$();</span>
<span class="fc" id="L260">    }</span>

    public void setCompilerNanos(long compilerNanos) {
<span class="fc" id="L263">        this.compilerNanos = compilerNanos;</span>
<span class="fc" id="L264">    }</span>

    public void setOperationFuture(OperationFuture fut) {
<span class="fc" id="L267">        operationFuture = fut;</span>
<span class="fc" id="L268">    }</span>

    public void setPausedQuery(boolean pausedQuery) {
<span class="fc" id="L271">        this.pausedQuery = pausedQuery;</span>
<span class="fc" id="L272">    }</span>

    public void setQueryType(short type) {
<span class="fc" id="L275">        queryType = type;</span>
<span class="fc" id="L276">    }</span>

    public void setRnd(Rnd rnd) {
<span class="fc" id="L279">        this.rnd = rnd;</span>
<span class="fc" id="L280">    }</span>

    public void startExecutionTimer() {
<span class="fc" id="L283">        this.executeStartNanos = nanosecondClock.getTicks();</span>
<span class="fc" id="L284">    }</span>

    private static void putBooleanValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L287">        socket.put(rec.getBool(col));</span>
<span class="fc" id="L288">    }</span>

    private static void putByteValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L291">        socket.put(rec.getByte(col));</span>
<span class="fc" id="L292">    }</span>

    private static void putCharValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L295">        char c = rec.getChar(col);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (c == 0) {</span>
<span class="fc" id="L297">            socket.put(&quot;\&quot;\&quot;&quot;);</span>
        } else {
<span class="fc" id="L299">            socket.put('&quot;').putUtf8(c).put('&quot;');</span>
        }
<span class="fc" id="L301">    }</span>

    private static void putDateValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L304">        final long d = rec.getDate(col);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (d == Long.MIN_VALUE) {</span>
<span class="fc" id="L306">            socket.put(&quot;null&quot;);</span>
<span class="fc" id="L307">            return;</span>
        }
<span class="fc" id="L309">        socket.put('&quot;').putISODateMillis(d).put('&quot;');</span>
<span class="fc" id="L310">    }</span>

    private static void putGeoHashStringByteValue(HttpChunkedResponseSocket socket, Record rec, int col, int bitFlags) {
<span class="fc" id="L313">        byte l = rec.getGeoByte(col);</span>
<span class="fc" id="L314">        putGeoHashStringValue(socket, l, bitFlags);</span>
<span class="fc" id="L315">    }</span>

    private static void putGeoHashStringIntValue(HttpChunkedResponseSocket socket, Record rec, int col, int bitFlags) {
<span class="fc" id="L318">        int l = rec.getGeoInt(col);</span>
<span class="fc" id="L319">        putGeoHashStringValue(socket, l, bitFlags);</span>
<span class="fc" id="L320">    }</span>

    private static void putGeoHashStringLongValue(HttpChunkedResponseSocket socket, Record rec, int col, int bitFlags) {
<span class="fc" id="L323">        long l = rec.getGeoLong(col);</span>
<span class="fc" id="L324">        putGeoHashStringValue(socket, l, bitFlags);</span>
<span class="fc" id="L325">    }</span>

    private static void putGeoHashStringShortValue(HttpChunkedResponseSocket socket, Record rec, int col, int bitFlags) {
<span class="fc" id="L328">        short l = rec.getGeoShort(col);</span>
<span class="fc" id="L329">        putGeoHashStringValue(socket, l, bitFlags);</span>
<span class="fc" id="L330">    }</span>

    private static void putGeoHashStringValue(HttpChunkedResponseSocket socket, long value, int bitFlags) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (value == GeoHashes.NULL) {</span>
<span class="fc" id="L334">            socket.put(&quot;null&quot;);</span>
        } else {
<span class="fc" id="L336">            socket.put('\&quot;');</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            if (bitFlags &lt; 0) {</span>
<span class="fc" id="L338">                GeoHashes.appendCharsUnsafe(value, -bitFlags, socket);</span>
            } else {
<span class="fc" id="L340">                GeoHashes.appendBinaryStringUnsafe(value, bitFlags, socket);</span>
            }
<span class="fc" id="L342">            socket.put('\&quot;');</span>
        }
<span class="fc" id="L344">    }</span>

    private static void putIntValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L347">        final int i = rec.getInt(col);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (i == Integer.MIN_VALUE) {</span>
<span class="fc" id="L349">            socket.put(&quot;null&quot;);</span>
        } else {
<span class="fc" id="L351">            Numbers.append(socket, i);</span>
        }
<span class="fc" id="L353">    }</span>

    private static void putLong256Value(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L356">        socket.put('&quot;');</span>
<span class="fc" id="L357">        rec.getLong256(col, socket);</span>
<span class="fc" id="L358">        socket.put('&quot;');</span>
<span class="fc" id="L359">    }</span>

    private static void putLongValue(HttpChunkedResponseSocket socket, Record rec, int col, boolean quoteLargeNum) {
<span class="fc" id="L362">        final long l = rec.getLong(col);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (l == Long.MIN_VALUE) {</span>
<span class="fc" id="L364">            socket.put(&quot;null&quot;);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        } else if (quoteLargeNum) {</span>
<span class="fc" id="L366">            socket.put('&quot;').put(l).put('&quot;');</span>
        } else {
<span class="fc" id="L368">            socket.put(l);</span>
        }
<span class="fc" id="L370">    }</span>

    private static void putRecValue(HttpChunkedResponseSocket socket) {
<span class="fc" id="L373">        putStringOrNull(socket, null);</span>
<span class="fc" id="L374">    }</span>

    private static void putShortValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L377">        socket.put(rec.getShort(col));</span>
<span class="fc" id="L378">    }</span>

    private static void putStrValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L381">        putStringOrNull(socket, rec.getStr(col));</span>
<span class="fc" id="L382">    }</span>

    private static void putStringOrNull(CharSink r, CharSequence str) {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L386">            r.put(&quot;null&quot;);</span>
        } else {
<span class="fc" id="L388">            r.encodeUtf8AndQuote(str);</span>
        }
<span class="fc" id="L390">    }</span>

    private static void putSymValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L393">        putStringOrNull(socket, rec.getSym(col));</span>
<span class="fc" id="L394">    }</span>

    private static void putTimestampValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L397">        final long t = rec.getTimestamp(col);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (t == Long.MIN_VALUE) {</span>
<span class="fc" id="L399">            socket.put(&quot;null&quot;);</span>
<span class="fc" id="L400">            return;</span>
        }
<span class="fc" id="L402">        socket.put('&quot;').putISODate(t).put('&quot;');</span>
<span class="fc" id="L403">    }</span>

    private static void putUuidValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L406">        long lo = rec.getLong128Lo(col);</span>
<span class="fc" id="L407">        long hi = rec.getLong128Hi(col);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (Uuid.isNull(lo, hi)) {</span>
<span class="fc" id="L409">            socket.put(&quot;null&quot;);</span>
<span class="fc" id="L410">            return;</span>
        }
<span class="fc" id="L412">        socket.put('&quot;');</span>
<span class="fc" id="L413">        Numbers.appendUuid(lo, hi, socket);</span>
<span class="fc" id="L414">        socket.put('&quot;');</span>
<span class="fc" id="L415">    }</span>

    private boolean addColumnToOutput(
            RecordMetadata metadata,
            CharSequence columnNames,
            int start,
            int hi
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (start == hi) {</span>
<span class="fc" id="L424">            info().$(&quot;empty column in list '&quot;).$(columnNames).$('\'').$();</span>
<span class="fc" id="L425">            HttpChunkedResponseSocket socket = getHttpConnectionContext().getChunkedResponseSocket();</span>
<span class="fc" id="L426">            JsonQueryProcessor.header(socket, &quot;&quot;, 400);</span>
<span class="fc" id="L427">            socket.put('{')</span>
<span class="fc" id="L428">                    .putQuoted(&quot;query&quot;).put(':').encodeUtf8AndQuote(query).put(',')</span>
<span class="fc" id="L429">                    .putQuoted(&quot;error&quot;).put(':').putQuoted(&quot;empty column in list&quot;)</span>
<span class="fc" id="L430">                    .put('}');</span>
<span class="fc" id="L431">            socket.sendChunk(true);</span>
<span class="fc" id="L432">            return true;</span>
        }

<span class="fc" id="L435">        int columnIndex = metadata.getColumnIndexQuiet(columnNames, start, hi);</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (columnIndex == RecordMetadata.COLUMN_NOT_FOUND) {</span>
<span class="fc" id="L437">            info().$(&quot;invalid column in list: '&quot;).$(columnNames, start, hi).$('\'').$();</span>
<span class="fc" id="L438">            HttpChunkedResponseSocket socket = getHttpConnectionContext().getChunkedResponseSocket();</span>
<span class="fc" id="L439">            JsonQueryProcessor.header(socket, &quot;&quot;, 400);</span>
<span class="fc" id="L440">            socket.put('{')</span>
<span class="fc" id="L441">                    .putQuoted(&quot;query&quot;).put(':').encodeUtf8AndQuote(query).put(',')</span>
<span class="fc" id="L442">                    .putQuoted(&quot;error&quot;).put(':').put('\'').put(&quot;invalid column in list: &quot;).put(columnNames, start, hi).put('\'')</span>
<span class="fc" id="L443">                    .put('}');</span>
<span class="fc" id="L444">            socket.sendChunk(true);</span>
<span class="fc" id="L445">            return true;</span>
        }

<span class="fc" id="L448">        addColumnTypeAndName(metadata, columnIndex);</span>
<span class="fc" id="L449">        this.columnSkewList.add(columnIndex);</span>
<span class="fc" id="L450">        return false;</span>
    }

    private void addColumnTypeAndName(RecordMetadata metadata, int i) {
<span class="fc" id="L454">        int columnType = metadata.getColumnType(i);</span>
<span class="fc" id="L455">        int flags = GeoHashes.getBitFlags(columnType);</span>
<span class="fc" id="L456">        this.columnTypesAndFlags.add(columnType);</span>
<span class="fc" id="L457">        this.columnTypesAndFlags.add(flags);</span>
<span class="fc" id="L458">        this.columnNames.add(metadata.getColumnName(i));</span>
<span class="fc" id="L459">    }</span>

    private void doFirstRecordLoop(
            HttpChunkedResponseSocket socket,
            int columnCount
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if (onQuerySetupFirstRecord()) {</span>
<span class="fc" id="L466">            doRecordFetchLoop(socket, columnCount);</span>
        } else {
<span class="fc" id="L468">            doQuerySuffix(socket, columnCount);</span>
        }
<span class="fc" id="L470">    }</span>

    private void doNextRecordLoop(
            HttpChunkedResponseSocket socket,
            int columnCount
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        if (doQueryNextRecord()) {</span>
<span class="fc" id="L477">            doRecordFetchLoop(socket, columnCount);</span>
        } else {
<span class="nc" id="L479">            doQuerySuffix(socket, columnCount);</span>
        }
<span class="fc" id="L481">    }</span>

    private void doQueryMetadata(HttpChunkedResponseSocket socket, int columnCount) {
<span class="fc" id="L484">        queryState = QUERY_METADATA;</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        for (; columnIndex &lt; columnCount; columnIndex++) {</span>
<span class="fc" id="L486">            socket.bookmark();</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">            if (columnIndex &gt; 0) {</span>
<span class="fc" id="L488">                socket.put(',');</span>
            }
<span class="fc" id="L490">            int columnType = columnTypesAndFlags.getQuick(2 * columnIndex);</span>
<span class="fc" id="L491">            socket.put('{')</span>
<span class="fc" id="L492">                    .putQuoted(&quot;name&quot;).put(':').encodeUtf8AndQuote(columnNames.getQuick(columnIndex))</span>
<span class="fc" id="L493">                    .put(',')</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                    .putQuoted(&quot;type&quot;).put(':').putQuoted(ColumnType.nameOf(columnType == ColumnType.NULL ? ColumnType.STRING : columnType))</span>
<span class="fc" id="L495">                    .put('}');</span>
        }
<span class="fc" id="L497">    }</span>

    private void doQueryMetadataSuffix(HttpChunkedResponseSocket socket) {
<span class="fc" id="L500">        queryState = QUERY_METADATA_SUFFIX;</span>
<span class="fc" id="L501">        socket.bookmark();</span>
<span class="fc" id="L502">        socket.put(&quot;],\&quot;dataset\&quot;:[&quot;);</span>
<span class="fc" id="L503">    }</span>

    private boolean doQueryNextRecord() {
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (cursor.hasNext()) {</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">            if (count &lt; stop) {</span>
<span class="fc" id="L508">                return true;</span>
            } else {
<span class="fc" id="L510">                onNoMoreData();</span>
            }
        }
<span class="fc" id="L513">        return false;</span>
    }

    private boolean doQueryPrefix(HttpChunkedResponseSocket socket) {
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (noMeta) {</span>
<span class="fc" id="L518">            socket.bookmark();</span>
<span class="fc" id="L519">            socket.put('{').putQuoted(&quot;dataset&quot;).put(&quot;:[&quot;);</span>
<span class="fc" id="L520">            return false;</span>
        }
<span class="fc" id="L522">        socket.bookmark();</span>
<span class="fc" id="L523">        socket.put('{')</span>
<span class="fc" id="L524">                .putQuoted(&quot;query&quot;).put(':').encodeUtf8AndQuote(query)</span>
<span class="fc" id="L525">                .put(',').putQuoted(&quot;columns&quot;).put(':').put('[');</span>
<span class="fc" id="L526">        columnIndex = 0;</span>
<span class="fc" id="L527">        return true;</span>
    }

    private void doQueryRecord(HttpChunkedResponseSocket socket, int columnCount) {
<span class="fc" id="L531">        queryState = QUERY_RECORD;</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        for (; columnIndex &lt; columnCount; columnIndex++) {</span>
<span class="fc" id="L533">            socket.bookmark();</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">            if (columnIndex &gt; 0) {</span>
<span class="fc" id="L535">                socket.put(',');</span>
            }

<span class="fc bfc" id="L538" title="All 2 branches covered.">            int columnIdx = columnSkewList.size() &gt; 0 ? columnSkewList.getQuick(columnIndex) : columnIndex;</span>
<span class="fc" id="L539">            int columnType = columnTypesAndFlags.getQuick(2 * columnIndex);</span>
<span class="pc bpc" id="L540" title="2 of 23 branches missed.">            switch (ColumnType.tagOf(columnType)) {</span>
                case ColumnType.BOOLEAN:
<span class="fc" id="L542">                    putBooleanValue(socket, record, columnIdx);</span>
<span class="fc" id="L543">                    break;</span>
                case ColumnType.BYTE:
<span class="fc" id="L545">                    putByteValue(socket, record, columnIdx);</span>
<span class="fc" id="L546">                    break;</span>
                case ColumnType.DOUBLE:
<span class="fc" id="L548">                    putDoubleValue(socket, record, columnIdx);</span>
<span class="fc" id="L549">                    break;</span>
                case ColumnType.FLOAT:
<span class="fc" id="L551">                    putFloatValue(socket, record, columnIdx);</span>
<span class="fc" id="L552">                    break;</span>
                case ColumnType.INT:
<span class="fc" id="L554">                    putIntValue(socket, record, columnIdx);</span>
<span class="fc" id="L555">                    break;</span>
                case ColumnType.LONG:
<span class="fc" id="L557">                    putLongValue(socket, record, columnIdx, quoteLargeNum);</span>
<span class="fc" id="L558">                    break;</span>
                case ColumnType.DATE:
<span class="fc" id="L560">                    putDateValue(socket, record, columnIdx);</span>
<span class="fc" id="L561">                    break;</span>
                case ColumnType.TIMESTAMP:
<span class="fc" id="L563">                    putTimestampValue(socket, record, columnIdx);</span>
<span class="fc" id="L564">                    break;</span>
                case ColumnType.SHORT:
<span class="fc" id="L566">                    putShortValue(socket, record, columnIdx);</span>
<span class="fc" id="L567">                    break;</span>
                case ColumnType.CHAR:
<span class="fc" id="L569">                    putCharValue(socket, record, columnIdx);</span>
<span class="fc" id="L570">                    break;</span>
                case ColumnType.STRING:
<span class="fc" id="L572">                    putStrValue(socket, record, columnIdx);</span>
<span class="fc" id="L573">                    break;</span>
                case ColumnType.SYMBOL:
<span class="fc" id="L575">                    putSymValue(socket, record, columnIdx);</span>
<span class="fc" id="L576">                    break;</span>
                case ColumnType.BINARY:
<span class="fc" id="L578">                    putBinValue(socket);</span>
<span class="fc" id="L579">                    break;</span>
                case ColumnType.LONG256:
<span class="fc" id="L581">                    putLong256Value(socket, record, columnIdx);</span>
<span class="fc" id="L582">                    break;</span>
                case ColumnType.GEOBYTE:
<span class="fc" id="L584">                    putGeoHashStringByteValue(socket, record, columnIdx, columnTypesAndFlags.getQuick(2 * columnIndex + 1));</span>
<span class="fc" id="L585">                    break;</span>
                case ColumnType.GEOSHORT:
<span class="fc" id="L587">                    putGeoHashStringShortValue(socket, record, columnIdx, columnTypesAndFlags.getQuick(2 * columnIndex + 1));</span>
<span class="fc" id="L588">                    break;</span>
                case ColumnType.GEOINT:
<span class="fc" id="L590">                    putGeoHashStringIntValue(socket, record, columnIdx, columnTypesAndFlags.getQuick(2 * columnIndex + 1));</span>
<span class="fc" id="L591">                    break;</span>
                case ColumnType.GEOLONG:
<span class="fc" id="L593">                    putGeoHashStringLongValue(socket, record, columnIdx, columnTypesAndFlags.getQuick(2 * columnIndex + 1));</span>
<span class="fc" id="L594">                    break;</span>
                case ColumnType.RECORD:
<span class="fc" id="L596">                    putRecValue(socket);</span>
<span class="fc" id="L597">                    break;</span>
                case ColumnType.NULL:
<span class="fc" id="L599">                    socket.put(&quot;null&quot;);</span>
<span class="fc" id="L600">                    break;</span>
                case ColumnType.LONG128:
<span class="nc" id="L602">                    throw new UnsupportedOperationException();</span>
                case ColumnType.UUID:
<span class="fc" id="L604">                    putUuidValue(socket, record, columnIdx);</span>
<span class="fc" id="L605">                    break;</span>
                default:
<span class="nc" id="L607">                    assert false : &quot;Not supported type in output &quot; + ColumnType.nameOf(columnType);</span>
<span class="nc" id="L608">                    socket.put(&quot;null&quot;); // To make JSON valid</span>
                    break;
            }
        }
<span class="fc" id="L612">    }</span>

    private void doQueryRecordPrefix(HttpChunkedResponseSocket socket) {
<span class="fc" id="L615">        queryState = QUERY_RECORD_PREFIX;</span>
<span class="fc" id="L616">        socket.bookmark();</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (count &gt; skip) {</span>
<span class="fc" id="L618">            socket.put(',');</span>
        }
<span class="fc" id="L620">        socket.put('[');</span>
<span class="fc" id="L621">        columnIndex = 0;</span>
<span class="fc" id="L622">        count++;</span>
<span class="fc" id="L623">    }</span>

    private void doQueryRecordSuffix(HttpChunkedResponseSocket socket) {
<span class="fc" id="L626">        queryState = QUERY_RECORD_SUFFIX;</span>
<span class="fc" id="L627">        socket.bookmark();</span>
<span class="fc" id="L628">        socket.put(']');</span>
<span class="fc" id="L629">    }</span>

    private void doQuerySuffix(
            HttpChunkedResponseSocket socket,
            int columnCount
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L635">        queryState = QUERY_SUFFIX;</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">        if (count &gt; -1) {</span>
<span class="fc" id="L637">            logTimings();</span>
<span class="fc" id="L638">            socket.bookmark();</span>
<span class="fc" id="L639">            socket.put(']');</span>
<span class="fc" id="L640">            socket.put(',').putQuoted(&quot;timestamp&quot;).put(':').put(queryTimestampIndex);</span>
<span class="fc" id="L641">            socket.put(',').putQuoted(&quot;count&quot;).put(':').put(count);</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">            if (timings) {</span>
<span class="nc" id="L643">                socket.put(',').putQuoted(&quot;timings&quot;).put(':')</span>
<span class="nc" id="L644">                        .put('{')</span>
<span class="nc" id="L645">                        .putQuoted(&quot;compiler&quot;).put(':').put(compilerNanos).put(',')</span>
<span class="nc" id="L646">                        .putQuoted(&quot;execute&quot;).put(':').put(nanosecondClock.getTicks() - executeStartNanos).put(',')</span>
<span class="nc" id="L647">                        .putQuoted(&quot;count&quot;).put(':').put(recordCountNanos)</span>
<span class="nc" id="L648">                        .put('}');</span>
            }
<span class="fc bfc" id="L650" title="All 2 branches covered.">            if (explain) {</span>
<span class="fc" id="L651">                socket.put(',').putQuoted(&quot;explain&quot;).put(':')</span>
<span class="fc" id="L652">                        .put('{')</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">                        .putQuoted(&quot;jitCompiled&quot;).put(':').put(queryJitCompiled ? &quot;true&quot; : &quot;false&quot;)</span>
<span class="fc" id="L654">                        .put('}');</span>
            }
<span class="fc" id="L656">            socket.put('}');</span>
<span class="fc" id="L657">            count = -1;</span>
<span class="fc" id="L658">            socket.sendChunk(true);</span>
<span class="fc" id="L659">            return;</span>
        }
<span class="nc" id="L661">        socket.done();</span>
<span class="nc" id="L662">    }</span>

    private void doRecordFetchLoop(
            HttpChunkedResponseSocket socket,
            int columnCount
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
        do {
<span class="fc" id="L669">            doQueryRecordPrefix(socket);</span>
<span class="fc" id="L670">            doQueryRecord(socket, columnCount);</span>
<span class="fc" id="L671">            doQueryRecordSuffix(socket);</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">        } while (doQueryNextRecord());</span>
<span class="fc" id="L673">        doQuerySuffix(socket, columnCount);</span>
<span class="fc" id="L674">    }</span>

    private int getFd() {
<span class="fc" id="L677">        return httpConnectionContext.getFd();</span>
    }

    private void onNoMoreData() {
<span class="fc" id="L681">        long nanos = nanosecondClock.getTicks();</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (countRows) {</span>
            // this is the tail end of the cursor
            // we don't need to read records, just round up record count
<span class="fc" id="L685">            final RecordCursor cursor = this.cursor;</span>
<span class="fc" id="L686">            final long size = cursor.size();</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">            if (size &lt; 0) {</span>
<span class="fc" id="L688">                LOG.info().$(&quot;counting&quot;).$();</span>
<span class="fc" id="L689">                long count = 1;</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">                while (cursor.hasNext()) {</span>
<span class="fc" id="L691">                    count++;</span>
                }
<span class="fc" id="L693">                this.count += count;</span>
<span class="fc" id="L694">            } else {</span>
<span class="fc" id="L695">                this.count = size;</span>
            }
        }
<span class="fc" id="L698">        recordCountNanos = nanosecondClock.getTicks() - nanos;</span>
<span class="fc" id="L699">    }</span>

    private void onQueryMetadata(
            HttpChunkedResponseSocket socket,
            int columnCount
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L705">        doQueryMetadata(socket, columnCount);</span>
<span class="nc" id="L706">        onQueryMetadataSuffix(socket, columnCount);</span>
<span class="nc" id="L707">    }</span>

    private void onQueryMetadataSuffix(
            HttpChunkedResponseSocket socket,
            int columnCount
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L713">        doQueryMetadataSuffix(socket);</span>
<span class="nc" id="L714">        doFirstRecordLoop(socket, columnCount);</span>
<span class="nc" id="L715">    }</span>

    private void onQueryPrefix(HttpChunkedResponseSocket socket, int columnCount) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (doQueryPrefix(socket)) {</span>
<span class="fc" id="L719">            doQueryMetadata(socket, columnCount);</span>
<span class="fc" id="L720">            doQueryMetadataSuffix(socket);</span>
        }
<span class="fc" id="L722">        doFirstRecordLoop(socket, columnCount);</span>
<span class="fc" id="L723">    }</span>

    private void onQueryRecord(HttpChunkedResponseSocket socket, int columnCount) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L726">        doQueryRecord(socket, columnCount);</span>
<span class="fc" id="L727">        onQueryRecordSuffix(socket, columnCount);</span>
<span class="fc" id="L728">    }</span>

    private void onQueryRecordPrefix(
            HttpChunkedResponseSocket socket,
            int columnCount
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L734">        doQueryRecordPrefix(socket);</span>
<span class="nc" id="L735">        onQueryRecord(socket, columnCount);</span>
<span class="nc" id="L736">    }</span>

    private void onQueryRecordSuffix(
            HttpChunkedResponseSocket socket,
            int columnCount
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L742">        doQueryRecordSuffix(socket);</span>
<span class="fc" id="L743">        doNextRecordLoop(socket, columnCount);</span>
<span class="fc" id="L744">    }</span>

    private boolean onQuerySetupFirstRecord() {
<span class="fc bfc" id="L747" title="All 2 branches covered.">        if (skip &gt; 0) {</span>
<span class="fc" id="L748">            final RecordCursor cursor = this.cursor;</span>
<span class="fc" id="L749">            long target = skip + 1;</span>
<span class="fc bfc" id="L750" title="All 4 branches covered.">            while (target &gt; 0 &amp;&amp; cursor.hasNext()) {</span>
<span class="fc" id="L751">                target--;</span>
            }
<span class="fc bfc" id="L753" title="All 2 branches covered.">            if (target &gt; 0) {</span>
<span class="fc" id="L754">                return false;</span>
            }
<span class="fc" id="L756">            count = skip;</span>
<span class="fc" id="L757">        } else {</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">            if (!cursor.hasNext()) {</span>
<span class="fc" id="L759">                return false;</span>
            }
        }

<span class="fc" id="L763">        columnIndex = 0;</span>
<span class="fc" id="L764">        record = cursor.getRecord();</span>
<span class="fc" id="L765">        return true;</span>
    }

    private void putBinValue(HttpChunkedResponseSocket socket) {
<span class="fc" id="L769">        socket.put('[');</span>
<span class="fc" id="L770">        socket.put(']');</span>
<span class="fc" id="L771">    }</span>

    private void putDoubleValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L774">        socket.put(rec.getDouble(col), doubleScale);</span>
<span class="fc" id="L775">    }</span>

    private void putFloatValue(HttpChunkedResponseSocket socket, Record rec, int col) {
<span class="fc" id="L778">        socket.put(rec.getFloat(col), floatScale);</span>
<span class="fc" id="L779">    }</span>

    static void prepareExceptionJson(
            HttpChunkedResponseSocket socket,
            int position,
            CharSequence message,
            CharSequence query
    ) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L787">        socket.put('{')</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">                .putQuoted(&quot;query&quot;).put(':').encodeUtf8AndQuote(query == null ? &quot;&quot; : query).put(',')</span>
<span class="fc" id="L789">                .putQuoted(&quot;error&quot;).put(':').encodeUtf8AndQuote(message).put(',')</span>
<span class="fc" id="L790">                .putQuoted(&quot;position&quot;).put(':').put(position)</span>
<span class="fc" id="L791">                .put('}');</span>
<span class="fc" id="L792">        socket.sendChunk(true);</span>
<span class="fc" id="L793">    }</span>

    boolean noCursor() {
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">        return cursor == null;</span>
    }

    boolean of(
            RecordCursorFactory factory,
            SqlExecutionContextImpl sqlExecutionContext
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, SqlException {
<span class="fc" id="L803">        return of(factory, true, sqlExecutionContext);</span>
    }

    boolean of(
            RecordCursorFactory factory,
            boolean queryCacheable,
            SqlExecutionContextImpl sqlExecutionContext
    ) throws PeerDisconnectedException, PeerIsSlowToReadException, SqlException {
<span class="fc" id="L811">        this.recordCursorFactory = factory;</span>
<span class="fc" id="L812">        this.queryCacheable = queryCacheable;</span>
<span class="fc" id="L813">        this.queryJitCompiled = factory.usesCompiledFilter();</span>
        // Enable column pre-touch in REST API only when LIMIT K,N is not specified since when limit is defined
        // we do a no-op loop over the cursor to calculate the total row count and pre-touch only slows things down.
<span class="fc bfc" id="L816" title="All 2 branches covered.">        sqlExecutionContext.setColumnPreTouchEnabled(stop == Long.MAX_VALUE);</span>
<span class="fc" id="L817">        this.cursor = factory.getCursor(sqlExecutionContext);</span>
<span class="fc" id="L818">        final RecordMetadata metadata = factory.getMetadata();</span>
<span class="fc" id="L819">        this.queryTimestampIndex = metadata.getTimestampIndex();</span>
<span class="fc" id="L820">        HttpRequestHeader header = httpConnectionContext.getRequestHeader();</span>
<span class="fc" id="L821">        DirectByteCharSequence columnNames = header.getUrlParam(&quot;cols&quot;);</span>
        int columnCount;
<span class="fc" id="L823">        columnSkewList.clear();</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">        if (columnNames != null) {</span>
<span class="fc" id="L825">            columnsQueryParameter.clear();</span>
            try {
<span class="fc" id="L827">                TextUtil.utf8Decode(columnNames.getLo(), columnNames.getHi(), columnsQueryParameter);</span>
<span class="fc" id="L828">            } catch (Utf8Exception e) {</span>
<span class="fc" id="L829">                info().$(&quot;utf8 error when decoding column list '&quot;).$(columnNames).$('\'').$();</span>
<span class="fc" id="L830">                HttpChunkedResponseSocket socket = getHttpConnectionContext().getChunkedResponseSocket();</span>
<span class="fc" id="L831">                JsonQueryProcessor.header(socket, &quot;&quot;, 400);</span>
<span class="fc" id="L832">                socket.put('{')</span>
<span class="fc" id="L833">                        .putQuoted(&quot;error&quot;).put(':').putQuoted(&quot;utf8 error in column list&quot;)</span>
<span class="fc" id="L834">                        .put('}');</span>
<span class="fc" id="L835">                socket.sendChunk(true);</span>
<span class="fc" id="L836">                return false;</span>
<span class="fc" id="L837">            }</span>

<span class="fc" id="L839">            columnCount = 1;</span>
<span class="fc" id="L840">            int start = 0;</span>
<span class="fc" id="L841">            int comma = 0;</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">            while (comma &gt; -1) {</span>
<span class="fc" id="L843">                comma = Chars.indexOf(columnsQueryParameter, start, ',');</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">                if (comma &gt; -1) {</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">                    if (addColumnToOutput(metadata, columnsQueryParameter, start, comma)) {</span>
<span class="fc" id="L846">                        return false;</span>
                    }
<span class="fc" id="L848">                    start = comma + 1;</span>
<span class="fc" id="L849">                    columnCount++;</span>
                } else {
<span class="fc" id="L851">                    int hi = columnsQueryParameter.length();</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">                    if (addColumnToOutput(metadata, columnsQueryParameter, start, hi)) {</span>
<span class="fc" id="L853">                        return false;</span>
                    }
<span class="fc" id="L855">                }</span>
            }
<span class="fc" id="L857">        } else {</span>
<span class="fc" id="L858">            columnCount = metadata.getColumnCount();</span>
<span class="fc bfc" id="L859" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L860">                addColumnTypeAndName(metadata, i);</span>
            }
        }
<span class="fc" id="L863">        this.columnCount = columnCount;</span>
<span class="fc" id="L864">        return true;</span>
    }

    void resume(HttpChunkedResponseSocket socket) throws PeerDisconnectedException, PeerIsSlowToReadException {
<span class="fc" id="L868">        resumeActions.getQuick(queryState).onResume(socket, columnCount);</span>
<span class="fc" id="L869">    }</span>

    void setQueryCacheable(boolean queryCacheable) {
<span class="fc" id="L872">        this.queryCacheable = queryCacheable;</span>
<span class="fc" id="L873">    }</span>

    @FunctionalInterface
    interface StateResumeAction {
        void onResume(
                HttpChunkedResponseSocket socket,
                int columnCount
        ) throws PeerDisconnectedException, PeerIsSlowToReadException;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>