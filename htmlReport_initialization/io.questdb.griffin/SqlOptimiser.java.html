<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlOptimiser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin</a> &gt; <span class="el_source">SqlOptimiser.java</span></div><h1>SqlOptimiser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin;

import io.questdb.cairo.*;
import io.questdb.cairo.pool.ex.EntryLockedException;
import io.questdb.cairo.sql.Function;
import io.questdb.cairo.sql.RecordMetadata;
import io.questdb.cairo.sql.TableRecordMetadata;
import io.questdb.cairo.sql.TableReferenceOutOfDateException;
import io.questdb.griffin.model.*;
import io.questdb.std.*;
import io.questdb.std.str.FlyweightCharSequence;
import io.questdb.std.str.Path;
import io.questdb.std.str.StringSink;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayDeque;

import static io.questdb.griffin.model.ExpressionNode.*;

class SqlOptimiser {

    private static final int JOIN_OP_AND = 2;
    private static final int JOIN_OP_EQUAL = 1;
    private static final int JOIN_OP_OR = 3;
    private static final int JOIN_OP_REGEX = 4;
    private static final int NOT_OP_AND = 2;
    private static final int NOT_OP_EQUAL = 8;
    private static final int NOT_OP_GREATER = 4;
    private static final int NOT_OP_GREATER_EQ = 5;
    private static final int NOT_OP_LESS = 6;
    private static final int NOT_OP_LESS_EQ = 7;
    private static final int NOT_OP_NOT = 1;
    private static final int NOT_OP_NOT_EQ = 9;
    private static final int NOT_OP_OR = 3;
<span class="fc" id="L60">    private static final IntHashSet flexColumnModelTypes = new IntHashSet();</span>
    //list of join types that don't support all optimisations (e.g. pushing table-specific predicates to both left and right table)
    private final static IntHashSet joinBarriers;
<span class="fc" id="L63">    private static final CharSequenceIntHashMap joinOps = new CharSequenceIntHashMap();</span>
<span class="fc" id="L64">    private static final boolean[] joinsRequiringTimestamp = {false, false, false, false, true, true, true};</span>
<span class="fc" id="L65">    private static final CharSequenceIntHashMap notOps = new CharSequenceIntHashMap();</span>
<span class="fc" id="L66">    private final static CharSequenceHashSet nullConstants = new CharSequenceHashSet();</span>
    private final CharacterStore characterStore;
<span class="fc" id="L68">    private final IntList clausesToSteal = new IntList();</span>
<span class="fc" id="L69">    private final ColumnPrefixEraser columnPrefixEraser = new ColumnPrefixEraser();</span>
<span class="fc" id="L70">    private final CharSequenceIntHashMap constNameToIndex = new CharSequenceIntHashMap();</span>
<span class="fc" id="L71">    private final CharSequenceObjHashMap&lt;ExpressionNode&gt; constNameToNode = new CharSequenceObjHashMap&lt;&gt;();</span>
<span class="fc" id="L72">    private final CharSequenceObjHashMap&lt;CharSequence&gt; constNameToToken = new CharSequenceObjHashMap&lt;&gt;();</span>
    private final ObjectPool&lt;JoinContext&gt; contextPool;
<span class="fc" id="L74">    private final IntHashSet deletedContexts = new IntHashSet();</span>
    private final ObjectPool&lt;ExpressionNode&gt; expressionNodePool;
    private final FunctionParser functionParser;
<span class="fc" id="L77">    private final ObjList&lt;Function&gt; functionsInFlight = new ObjList&lt;&gt;();</span>
<span class="fc" id="L78">    private final ObjectPool&lt;IntHashSet&gt; intHashSetPool = new ObjectPool&lt;&gt;(IntHashSet::new, 16);</span>
<span class="fc" id="L79">    private final ObjList&lt;JoinContext&gt; joinClausesSwap1 = new ObjList&lt;&gt;();</span>
<span class="fc" id="L80">    private final ObjList&lt;JoinContext&gt; joinClausesSwap2 = new ObjList&lt;&gt;();</span>
<span class="fc" id="L81">    private final LiteralCheckingVisitor literalCheckingVisitor = new LiteralCheckingVisitor();</span>
<span class="fc" id="L82">    private final LiteralCollector literalCollector = new LiteralCollector();</span>
<span class="fc" id="L83">    private final IntHashSet literalCollectorAIndexes = new IntHashSet();</span>
<span class="fc" id="L84">    private final ObjList&lt;CharSequence&gt; literalCollectorANames = new ObjList&lt;&gt;();</span>
<span class="fc" id="L85">    private final IntHashSet literalCollectorBIndexes = new IntHashSet();</span>
<span class="fc" id="L86">    private final ObjList&lt;CharSequence&gt; literalCollectorBNames = new ObjList&lt;&gt;();</span>
<span class="fc" id="L87">    private final LiteralRewritingVisitor literalRewritingVisitor = new LiteralRewritingVisitor();</span>
<span class="fc" id="L88">    private final ObjList&lt;ExpressionNode&gt; orderByAdvice = new ObjList&lt;&gt;();</span>
<span class="fc" id="L89">    private final IntPriorityQueue orderingStack = new IntPriorityQueue();</span>
    private final Path path;
<span class="fc" id="L91">    private final IntHashSet postFilterRemoved = new IntHashSet();</span>
<span class="fc" id="L92">    private final ObjList&lt;IntHashSet&gt; postFilterTableRefs = new ObjList&lt;&gt;();</span>
    private final ObjectPool&lt;QueryColumn&gt; queryColumnPool;
    private final ObjectPool&lt;QueryModel&gt; queryModelPool;
<span class="fc" id="L95">    private final ArrayDeque&lt;ExpressionNode&gt; sqlNodeStack = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L96">    private final FlyweightCharSequence tableLookupSequence = new FlyweightCharSequence();</span>
<span class="fc" id="L97">    private final IntHashSet tablesSoFar = new IntHashSet();</span>
<span class="fc" id="L98">    private final IntList tempCrossIndexes = new IntList();</span>
<span class="fc" id="L99">    private final IntList tempCrosses = new IntList();</span>
<span class="fc" id="L100">    private final IntList tempList = new IntList();</span>
<span class="fc" id="L101">    private final LowerCaseCharSequenceObjHashMap&lt;QueryColumn&gt; tmpCursorAliases = new LowerCaseCharSequenceObjHashMap&lt;&gt;();</span>
    private final PostOrderTreeTraversalAlgo traversalAlgo;
<span class="fc" id="L103">    private int defaultAliasCount = 0;</span>
    private ObjList&lt;JoinContext&gt; emittedJoinClauses;

    SqlOptimiser(
            CairoConfiguration configuration,
            CharacterStore characterStore,
            ObjectPool&lt;ExpressionNode&gt; expressionNodePool,
            ObjectPool&lt;QueryColumn&gt; queryColumnPool,
            ObjectPool&lt;QueryModel&gt; queryModelPool,
            PostOrderTreeTraversalAlgo traversalAlgo,
            FunctionParser functionParser,
            Path path
<span class="fc" id="L115">    ) {</span>
<span class="fc" id="L116">        this.expressionNodePool = expressionNodePool;</span>
<span class="fc" id="L117">        this.characterStore = characterStore;</span>
<span class="fc" id="L118">        this.traversalAlgo = traversalAlgo;</span>
<span class="fc" id="L119">        this.queryModelPool = queryModelPool;</span>
<span class="fc" id="L120">        this.queryColumnPool = queryColumnPool;</span>
<span class="fc" id="L121">        this.functionParser = functionParser;</span>
<span class="fc" id="L122">        this.contextPool = new ObjectPool&lt;&gt;(JoinContext.FACTORY, configuration.getSqlJoinContextPoolCapacity());</span>
<span class="fc" id="L123">        this.path = path;</span>
<span class="fc" id="L124">    }</span>

    private static void linkDependencies(QueryModel model, int parent, int child) {
<span class="fc" id="L127">        model.getJoinModels().getQuick(parent).addDependency(child);</span>
<span class="fc" id="L128">    }</span>

    private static boolean modelIsFlex(QueryModel model) {
<span class="pc bpc" id="L131" title="1 of 4 branches missed.">        return model != null &amp;&amp; flexColumnModelTypes.contains(model.getSelectModelType());</span>
    }

    private static void unlinkDependencies(QueryModel model, int parent, int child) {
<span class="fc" id="L135">        model.getJoinModels().getQuick(parent).removeDependency(child);</span>
<span class="fc" id="L136">    }</span>

    /*
     * Uses validating model to determine if column name exists and non-ambiguous in case of using joins.
     */
    private void addColumnToTranslatingModel(
            QueryColumn column,
            QueryModel translatingModel,
            QueryModel validatingModel
    ) throws SqlException {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (validatingModel != null) {</span>
<span class="fc" id="L147">            CharSequence refColumn = column.getAst().token;</span>
<span class="fc" id="L148">            final int dot = Chars.indexOf(refColumn, '.');</span>
<span class="fc" id="L149">            validateColumnAndGetModelIndex(validatingModel, refColumn, dot, column.getAst().position);</span>
            // when we have only one model, e.g. this is not a join
            // and there is table alias to lookup column
            // we will remove this alias as unneeded
<span class="fc bfc" id="L153" title="All 4 branches covered.">            if (dot != -1 &amp;&amp; validatingModel.getJoinModels().size() == 1) {</span>
<span class="fc" id="L154">                ExpressionNode base = column.getAst();</span>
<span class="fc" id="L155">                column.of(</span>
<span class="fc" id="L156">                        column.getAlias(),</span>
<span class="fc" id="L157">                        expressionNodePool.next().of(</span>
                                base.type,
<span class="fc" id="L159">                                base.token.subSequence(dot + 1, base.token.length()),</span>
                                base.precedence,
                                base.position
                        )
                );
            }
        }
<span class="fc" id="L166">        translatingModel.addBottomUpColumn(column);</span>
<span class="fc" id="L167">    }</span>

    private QueryColumn addCursorFunctionAsCrossJoin(
            ExpressionNode node,
            @Nullable CharSequence alias,
            QueryModel cursorModel,
            @Nullable QueryModel innerVirtualModel,
            QueryModel translatingModel,
            QueryModel baseModel,
            SqlExecutionContext sqlExecutionContext
    ) throws SqlException {
<span class="fc" id="L178">        QueryColumn qc = cursorModel.findBottomUpColumnByAst(node);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (qc == null) {</span>

            // we are about to add new column as a join model to the base model
            // the name of this column must not clash with any name of the base mode
            CharSequence baseAlias;
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (alias != null) {</span>
<span class="fc" id="L185">                baseAlias = createColumnAlias(alias, baseModel);</span>
            } else {
<span class="fc" id="L187">                baseAlias = createColumnAlias(node, baseModel);</span>
            }

            // add to temp aliases so that two cursors cannot use the same alias!
<span class="fc" id="L191">            baseAlias = SqlUtil.createColumnAlias(characterStore, baseAlias, -1, tmpCursorAliases);</span>

<span class="fc" id="L193">            final QueryColumn crossColumn = queryColumnPool.next().of(baseAlias, node);</span>

<span class="fc" id="L195">            final QueryModel cross = queryModelPool.next();</span>
<span class="fc" id="L196">            cross.setJoinType(QueryModel.JOIN_CROSS);</span>
<span class="fc" id="L197">            cross.setSelectModelType(QueryModel.SELECT_MODEL_CURSOR);</span>
<span class="fc" id="L198">            cross.setAlias(makeJoinAlias());</span>

<span class="fc" id="L200">            final QueryModel crossInner = queryModelPool.next();</span>
<span class="fc" id="L201">            crossInner.setTableNameExpr(node);</span>
<span class="fc" id="L202">            parseFunctionAndEnumerateColumns(crossInner, sqlExecutionContext);</span>
<span class="fc" id="L203">            cross.setNestedModel(crossInner);</span>

<span class="fc" id="L205">            cross.addBottomUpColumn(crossColumn);</span>
<span class="fc" id="L206">            baseModel.addJoinModel(cross);</span>

            // keep track of duplicates
<span class="fc" id="L209">            tmpCursorAliases.put(baseAlias, crossColumn);</span>

            // now we need to make alias in the translating column

            CharSequence translatingAlias;
<span class="fc" id="L214">            translatingAlias = createColumnAlias(baseAlias, translatingModel);</span>

            // add trackable expression to cursor model
<span class="fc" id="L217">            cursorModel.addBottomUpColumn(queryColumnPool.next().of(baseAlias, node));</span>

<span class="fc" id="L219">            qc = queryColumnPool.next().of(translatingAlias, nextLiteral(baseAlias));</span>
<span class="fc" id="L220">            translatingModel.addBottomUpColumn(qc);</span>

<span class="fc" id="L222">        } else {</span>
<span class="fc" id="L223">            final CharSequence al = translatingModel.getColumnNameToAliasMap().get(qc.getAlias());</span>
<span class="fc bfc" id="L224" title="All 4 branches covered.">            if (alias != null &amp;&amp; !Chars.equals(al, alias)) {</span>
<span class="fc" id="L225">                QueryColumn existing = translatingModel.getAliasToColumnMap().get(alias);</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">                if (existing == null) {</span>
                    // create new column
<span class="fc" id="L228">                    qc = nextColumn(alias, al);</span>
<span class="fc" id="L229">                    translatingModel.addBottomUpColumn(qc);</span>

<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                    if (innerVirtualModel != null) {</span>
<span class="fc" id="L232">                        innerVirtualModel.addBottomUpColumn(qc);</span>
                    }

<span class="fc" id="L235">                    return qc;</span>
                }

<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (ExpressionNode.compareNodesExact(node, existing.getAst())) {</span>
<span class="nc" id="L239">                    return existing;</span>
                }

<span class="nc" id="L242">                throw SqlException.invalidColumn(node.position, &quot;duplicate alias&quot;);</span>
            }

            // check if column is in inner virtual model as requested
<span class="fc" id="L246">            qc = translatingModel.getAliasToColumnMap().get(al);</span>
        }
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (innerVirtualModel != null) {</span>
<span class="fc" id="L249">            innerVirtualModel.addBottomUpColumn(qc);</span>
        }
<span class="fc" id="L251">        return qc;</span>
    }

    private void addFilterOrEmitJoin(QueryModel parent, int idx, int ai, CharSequence an, ExpressionNode ao, int bi, CharSequence bn, ExpressionNode bo) {
<span class="fc bfc" id="L255" title="All 4 branches covered.">        if (ai == bi &amp;&amp; Chars.equals(an, bn)) {</span>
<span class="fc" id="L256">            deletedContexts.add(idx);</span>
<span class="fc" id="L257">            return;</span>
        }

<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (ai == bi) {</span>
            // (same table)
<span class="fc" id="L262">            ExpressionNode node = expressionNodePool.next().of(ExpressionNode.OPERATION, &quot;=&quot;, 0, 0);</span>
<span class="fc" id="L263">            node.paramCount = 2;</span>
<span class="fc" id="L264">            node.lhs = ao;</span>
<span class="fc" id="L265">            node.rhs = bo;</span>
<span class="fc" id="L266">            addWhereNode(parent, ai, node);</span>
<span class="fc" id="L267">        } else {</span>
            // (different tables)
<span class="fc" id="L269">            JoinContext jc = contextPool.next();</span>
<span class="fc" id="L270">            jc.aIndexes.add(ai);</span>
<span class="fc" id="L271">            jc.aNames.add(an);</span>
<span class="fc" id="L272">            jc.aNodes.add(ao);</span>
<span class="fc" id="L273">            jc.bIndexes.add(bi);</span>
<span class="fc" id="L274">            jc.bNames.add(bn);</span>
<span class="fc" id="L275">            jc.bNodes.add(bo);</span>
<span class="fc" id="L276">            jc.slaveIndex = Math.max(ai, bi);</span>
<span class="fc" id="L277">            jc.parents.add(Math.min(ai, bi));</span>
<span class="fc" id="L278">            emittedJoinClauses.add(jc);</span>
        }

<span class="fc" id="L281">        deletedContexts.add(idx);</span>
<span class="fc" id="L282">    }</span>

    private void addFunction(
            QueryColumn qc,
            QueryModel validatingModel,
            QueryModel translatingModel,
            QueryModel innerModel,
            QueryModel analyticModel,
            QueryModel groupByModel,
            QueryModel outerModel,
            QueryModel distinctModel
    ) throws SqlException {
        // there were no aggregation functions emitted therefore
        // this is just a function that goes into virtual model
<span class="fc" id="L296">        innerModel.addBottomUpColumn(qc);</span>

        // we also create column that references this inner layer from outer layer,
        // for example when we have:
        // select a, b+c ...
        // it should translate to:
        // select a, x from (select a, b+c x from (select a,b,c ...))
<span class="fc" id="L303">        final QueryColumn innerColumn = nextColumn(qc.getAlias());</span>

        // pull literals only into translating model
<span class="fc" id="L306">        emitLiterals(qc.getAst(), translatingModel, null, validatingModel, false);</span>
<span class="fc" id="L307">        groupByModel.addBottomUpColumn(innerColumn);</span>
<span class="fc" id="L308">        analyticModel.addBottomUpColumn(innerColumn);</span>
<span class="fc" id="L309">        outerModel.addBottomUpColumn(innerColumn);</span>
<span class="fc" id="L310">        distinctModel.addBottomUpColumn(innerColumn);</span>
<span class="fc" id="L311">    }</span>

    private void addJoinContext(QueryModel parent, JoinContext context) {
<span class="fc" id="L314">        QueryModel jm = parent.getJoinModels().getQuick(context.slaveIndex);</span>
<span class="fc" id="L315">        JoinContext other = jm.getContext();</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (other == null) {</span>
<span class="fc" id="L317">            jm.setContext(context);</span>
        } else {
<span class="fc" id="L319">            jm.setContext(mergeContexts(parent, other, context));</span>
        }
<span class="fc" id="L321">    }</span>

    private void addOuterJoinExpression(QueryModel model, ExpressionNode node) {
<span class="fc" id="L324">        model.setOuterJoinExpressionClause(concatFilters(model.getOuterJoinExpressionClause(), node));</span>
<span class="fc" id="L325">    }</span>

    private void addPostJoinWhereClause(QueryModel model, ExpressionNode node) {
<span class="fc" id="L328">        model.setPostJoinWhereClause(concatFilters(model.getPostJoinWhereClause(), node));</span>
<span class="fc" id="L329">    }</span>

    private void addTopDownColumn(@Transient ExpressionNode node, QueryModel model) {
<span class="pc bpc" id="L332" title="1 of 4 branches missed.">        if (node != null &amp;&amp; node.type == LITERAL) {</span>
<span class="fc" id="L333">            final CharSequence columnName = node.token;</span>
<span class="fc" id="L334">            final int dotIndex = Chars.indexOf(columnName, '.');</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">            if (dotIndex == -1) {</span>
                // When there is no dot in column name it is still possible that column comes from
                // one of the join models. What we need to do here is to assign column to that model
                // which already have this column in alias map
<span class="fc" id="L339">                addTopDownColumn(columnName, model);</span>
            } else {
<span class="fc" id="L341">                int modelIndex = model.getModelAliasIndex(node.token, 0, dotIndex);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                if (modelIndex &lt; 0) {</span>
                    // alias cannot be resolved, we will trust that the calling side will handle this
                    // in this context we do not have model that is able to resolve table alias
<span class="fc" id="L345">                    return;</span>
                }

<span class="fc" id="L348">                addTopDownColumn0(</span>
                        node,
<span class="fc" id="L350">                        model.getJoinModels().getQuick(modelIndex),</span>
<span class="fc" id="L351">                        node.token.subSequence(dotIndex + 1, node.token.length())</span>
                );
            }
        }
<span class="fc" id="L355">    }</span>

    private void addTopDownColumn(CharSequence columnName, QueryModel model) {
<span class="fc" id="L358">        final ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc" id="L359">        final int joinCount = joinModels.size();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (int i = 0; i &lt; joinCount; i++) {</span>
<span class="fc" id="L361">            final QueryModel m = joinModels.getQuick(i);</span>
<span class="fc" id="L362">            final QueryColumn column = m.getAliasToColumnMap().get(columnName);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (column != null) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">                if (m.getSelectModelType() == QueryModel.SELECT_MODEL_NONE) {</span>
<span class="fc" id="L365">                    m.addTopDownColumn(</span>
<span class="fc" id="L366">                            queryColumnPool.next().of(</span>
                                    columnName,
<span class="fc" id="L368">                                    nextLiteral(columnName)</span>
                            ),
                            columnName
                    );
                } else {
<span class="fc" id="L373">                    m.addTopDownColumn(column, columnName);</span>
                }
<span class="fc" id="L375">                break;</span>
            }
        }
<span class="fc" id="L378">    }</span>

    private void addTopDownColumn0(@Transient ExpressionNode node, QueryModel model, CharSequence name) {
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (model.isTopDownNameMissing(name)) {</span>
<span class="fc" id="L382">            model.addTopDownColumn(</span>
<span class="fc" id="L383">                    queryColumnPool.next().of(name, expressionNodePool.next().of(node.type, name, node.precedence, node.position))</span>
                    , name
            );
        }
<span class="fc" id="L387">    }</span>

    /**
     * Adds filters derived from transitivity of equals operation, for example
     * if there is filter:
     * &lt;p&gt;
     * a.x = b.x and b.x = 10
     * &lt;p&gt;
     * derived filter would be:
     * &lt;p&gt;
     * a.x = 10
     * &lt;p&gt;
     * this filter is not explicitly mentioned, but it might help pre-filtering record sources
     * before hashing.
     */
    private void addTransitiveFilters(QueryModel model) {
<span class="fc" id="L403">        ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        for (int i = 0, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L405">            JoinContext jc = joinModels.getQuick(i).getContext();</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">            if (jc != null) {</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                for (int k = 0, kn = jc.bNames.size(); k &lt; kn; k++) {</span>
<span class="fc" id="L408">                    CharSequence name = jc.bNames.getQuick(k);</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">                    if (constNameToIndex.get(name) == jc.bIndexes.getQuick(k)) {</span>
<span class="fc" id="L410">                        ExpressionNode node = expressionNodePool.next().of(ExpressionNode.OPERATION, constNameToToken.get(name), 0, 0);</span>
<span class="fc" id="L411">                        node.lhs = jc.aNodes.getQuick(k);</span>
<span class="fc" id="L412">                        node.rhs = constNameToNode.get(name);</span>
<span class="fc" id="L413">                        node.paramCount = 2;</span>
<span class="fc" id="L414">                        addWhereNode(model, jc.slaveIndex, node);</span>
                    }
                }
            }
        }
<span class="fc" id="L419">    }</span>

    private void addWhereNode(QueryModel model, int joinModelIndex, ExpressionNode node) {
<span class="fc" id="L422">        addWhereNode(model.getJoinModels().getQuick(joinModelIndex), node);</span>
<span class="fc" id="L423">    }</span>

    private void addWhereNode(QueryModel model, ExpressionNode node) {
<span class="fc" id="L426">        model.setWhereClause(concatFilters(model.getWhereClause(), node));</span>
<span class="fc" id="L427">    }</span>

    /**
     * Move fields that belong to slave table to left and parent fields
     * to right of equals operator.
     */
    private void alignJoinClauses(QueryModel parent) {
<span class="fc" id="L434">        ObjList&lt;QueryModel&gt; joinModels = parent.getJoinModels();</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        for (int i = 0, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L436">            JoinContext jc = joinModels.getQuick(i).getContext();</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (jc != null) {</span>
<span class="fc" id="L438">                int index = jc.slaveIndex;</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">                for (int k = 0, kc = jc.aIndexes.size(); k &lt; kc; k++) {</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">                    if (jc.aIndexes.getQuick(k) != index) {</span>
<span class="fc" id="L441">                        int idx = jc.aIndexes.getQuick(k);</span>
<span class="fc" id="L442">                        CharSequence name = jc.aNames.getQuick(k);</span>
<span class="fc" id="L443">                        ExpressionNode node = jc.aNodes.getQuick(k);</span>

<span class="fc" id="L445">                        jc.aIndexes.setQuick(k, jc.bIndexes.getQuick(k));</span>
<span class="fc" id="L446">                        jc.aNames.setQuick(k, jc.bNames.getQuick(k));</span>
<span class="fc" id="L447">                        jc.aNodes.setQuick(k, jc.bNodes.getQuick(k));</span>

<span class="fc" id="L449">                        jc.bIndexes.setQuick(k, idx);</span>
<span class="fc" id="L450">                        jc.bNames.setQuick(k, name);</span>
<span class="fc" id="L451">                        jc.bNodes.setQuick(k, node);</span>
                    }
                }
            }
        }
<span class="fc" id="L456">    }</span>

    //checks join equality condition and pushes it to optimal join contexts (could be a different join context) 
    //NOTE on LEFT JOIN : 
    // - left join condition MUST remain as is otherwise it'll produce wrong results 
    // - only predicates relating to LEFT table may be pushed down
    // - predicates on both or right table may be added to post join clause as long as they're marked properly (via ExpressionNode.isOuterJoinPredicate)  
    private void analyseEquals(QueryModel parent, ExpressionNode node, boolean innerPredicate, QueryModel joinModel) throws SqlException {
<span class="fc" id="L464">        traverseNamesAndIndices(parent, node);</span>
<span class="fc" id="L465">        int aSize = literalCollectorAIndexes.size();</span>
<span class="fc" id="L466">        int bSize = literalCollectorBIndexes.size();</span>

        JoinContext jc;
<span class="fc" id="L469">        boolean canMovePredicate = joinBarriers.excludes(joinModel.getJoinType());</span>
<span class="fc" id="L470">        int joinIdx = parent.getJoinModels().indexOf(joinModel);</span>

        //switch code below assumes expression are simple column references  
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (literalCollector.functionCount &gt; 0) {</span>
<span class="fc" id="L474">            node.innerPredicate = innerPredicate;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">            if (canMovePredicate) {</span>
<span class="fc" id="L476">                parent.addParsedWhereNode(node, innerPredicate);</span>
            } else {
<span class="fc" id="L478">                addOuterJoinExpression(joinModel, node);</span>
            }
<span class="fc" id="L480">            return;</span>
        }

<span class="pc bpc" id="L483" title="1 of 3 branches missed.">        switch (aSize) {</span>
            case 0:
<span class="fc bfc" id="L485" title="All 2 branches covered.">                if (!canMovePredicate) {</span>
<span class="fc" id="L486">                    addOuterJoinExpression(joinModel, node);</span>
<span class="fc" id="L487">                    break;</span>
                }
<span class="pc bpc" id="L489" title="1 of 4 branches missed.">                if (bSize == 1</span>
                        &amp;&amp; literalCollector.nullCount == 0
                        // table must not be OUTER or ASOF joined
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">                        &amp;&amp; joinBarriers.excludes(parent.getJoinModels().get(literalCollectorBIndexes.get(0)).getJoinType())</span>
                ) {
                    // single table reference + constant
<span class="fc" id="L495">                    jc = contextPool.next();</span>
<span class="fc" id="L496">                    jc.slaveIndex = literalCollectorBIndexes.get(0);</span>

<span class="fc" id="L498">                    addWhereNode(parent, jc.slaveIndex, node);</span>
<span class="fc" id="L499">                    addJoinContext(parent, jc);</span>

<span class="fc" id="L501">                    CharSequence cs = literalCollectorBNames.getQuick(0);</span>
<span class="fc" id="L502">                    constNameToIndex.put(cs, jc.slaveIndex);</span>
<span class="fc" id="L503">                    constNameToNode.put(cs, node.lhs);</span>
<span class="fc" id="L504">                    constNameToToken.put(cs, node.token);</span>
<span class="fc" id="L505">                } else {</span>
<span class="fc" id="L506">                    parent.addParsedWhereNode(node, innerPredicate);</span>
                }
<span class="fc" id="L508">                break;</span>
            case 1:
<span class="fc" id="L510">                jc = contextPool.next();</span>
<span class="fc" id="L511">                int lhi = literalCollectorAIndexes.get(0);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">                if (bSize == 1) {</span>
<span class="fc" id="L513">                    int rhi = literalCollectorBIndexes.get(0);</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">                    if (lhi == rhi) {</span>
                        // single table reference
<span class="fc" id="L516">                        jc.slaveIndex = lhi;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                        if (canMovePredicate) {</span>
<span class="fc" id="L518">                            addWhereNode(parent, lhi, node);</span>
                        }
<span class="fc bfc" id="L520" title="All 2 branches covered.">                    } else if (lhi &lt; rhi) {</span>
                        // we must align &quot;a&quot; nodes with slave index
                        // compiler will always be checking &quot;a&quot; columns
                        // against metadata of the slave the context is assigned to
<span class="fc" id="L524">                        jc.aNodes.add(node.lhs);</span>
<span class="fc" id="L525">                        jc.bNodes.add(node.rhs);</span>
<span class="fc" id="L526">                        jc.aNames.add(literalCollectorANames.getQuick(0));</span>
<span class="fc" id="L527">                        jc.bNames.add(literalCollectorBNames.getQuick(0));</span>
<span class="fc" id="L528">                        jc.aIndexes.add(lhi);</span>
<span class="fc" id="L529">                        jc.bIndexes.add(rhi);</span>
<span class="fc" id="L530">                        jc.slaveIndex = rhi;</span>
<span class="fc" id="L531">                        jc.parents.add(lhi);</span>
                    } else {
<span class="fc" id="L533">                        jc.aNodes.add(node.rhs);</span>
<span class="fc" id="L534">                        jc.bNodes.add(node.lhs);</span>
<span class="fc" id="L535">                        jc.aNames.add(literalCollectorBNames.getQuick(0));</span>
<span class="fc" id="L536">                        jc.bNames.add(literalCollectorANames.getQuick(0));</span>
<span class="fc" id="L537">                        jc.aIndexes.add(rhi);</span>
<span class="fc" id="L538">                        jc.bIndexes.add(lhi);</span>
<span class="fc" id="L539">                        jc.slaveIndex = lhi;</span>
<span class="fc" id="L540">                        jc.parents.add(rhi);</span>
                    }

<span class="fc bfc" id="L543" title="All 4 branches covered.">                    if (canMovePredicate || jc.slaveIndex == joinIdx) {</span>
                        //we can't push anything into other left join
<span class="fc bfc" id="L545" title="All 4 branches covered.">                        if (jc.slaveIndex != joinIdx &amp;&amp; joinBarriers.contains(parent.getJoinModels().get(jc.slaveIndex).getJoinType())) {</span>
<span class="fc" id="L546">                            addPostJoinWhereClause(parent.getJoinModels().getQuick(jc.slaveIndex), node);</span>
                        } else {
<span class="fc" id="L548">                            addJoinContext(parent, jc);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                            if (lhi != rhi) {</span>
<span class="fc" id="L550">                                linkDependencies(parent, Math.min(lhi, rhi), Math.max(lhi, rhi));</span>
                            }
                        }
                    } else {
<span class="fc" id="L554">                        addOuterJoinExpression(joinModel, node);</span>
                    }
<span class="pc bpc" id="L556" title="1 of 4 branches missed.">                } else if (bSize == 0</span>
                        &amp;&amp; literalCollector.nullCount == 0
<span class="fc bfc" id="L558" title="All 2 branches covered.">                        &amp;&amp; joinBarriers.excludes(parent.getJoinModels().get(literalCollectorAIndexes.get(0)).getJoinType())) {</span>
                    // single table reference + constant
<span class="fc bfc" id="L560" title="All 2 branches covered.">                    if (!canMovePredicate) {</span>
<span class="fc" id="L561">                        addOuterJoinExpression(joinModel, node);</span>
<span class="fc" id="L562">                        break;</span>
                    }
<span class="fc" id="L564">                    jc.slaveIndex = lhi;</span>
<span class="fc" id="L565">                    addWhereNode(parent, lhi, node);</span>
<span class="fc" id="L566">                    addJoinContext(parent, jc);</span>

<span class="fc" id="L568">                    CharSequence cs = literalCollectorANames.getQuick(0);</span>
<span class="fc" id="L569">                    constNameToIndex.put(cs, lhi);</span>
<span class="fc" id="L570">                    constNameToNode.put(cs, node.rhs);</span>
<span class="fc" id="L571">                    constNameToToken.put(cs, node.token);</span>
<span class="fc" id="L572">                } else {</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">                    if (canMovePredicate) {</span>
<span class="fc" id="L574">                        parent.addParsedWhereNode(node, innerPredicate);</span>
                    } else {
<span class="fc" id="L576">                        addOuterJoinExpression(joinModel, node);</span>
                    }
                }
<span class="fc" id="L579">                break;</span>
            default:
<span class="nc bnc" id="L581" title="All 2 branches missed.">                if (canMovePredicate) {</span>
<span class="nc" id="L582">                    node.innerPredicate = innerPredicate;</span>
<span class="nc" id="L583">                    parent.addParsedWhereNode(node, innerPredicate);</span>
                } else {
<span class="nc" id="L585">                    addOuterJoinExpression(joinModel, node);</span>
                }

                break;
        }
<span class="fc" id="L590">    }</span>

    private void analyseRegex(QueryModel parent, ExpressionNode node) throws SqlException {
<span class="fc" id="L593">        traverseNamesAndIndices(parent, node);</span>

<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (literalCollector.nullCount == 0) {</span>
<span class="fc" id="L596">            int aSize = literalCollectorAIndexes.size();</span>
<span class="fc" id="L597">            int bSize = literalCollectorBIndexes.size();</span>
<span class="pc bpc" id="L598" title="2 of 4 branches missed.">            if (aSize == 1 &amp;&amp; bSize == 0) {</span>
<span class="fc" id="L599">                CharSequence name = literalCollectorANames.getQuick(0);</span>
<span class="fc" id="L600">                constNameToIndex.put(name, literalCollectorAIndexes.get(0));</span>
<span class="fc" id="L601">                constNameToNode.put(name, node.rhs);</span>
<span class="fc" id="L602">                constNameToToken.put(name, node.token);</span>
            }
        }
<span class="fc" id="L605">    }</span>

    private void assignFilters(QueryModel parent) throws SqlException {
<span class="fc" id="L608">        tablesSoFar.clear();</span>
<span class="fc" id="L609">        postFilterRemoved.clear();</span>
<span class="fc" id="L610">        postFilterTableRefs.clear();</span>

<span class="fc" id="L612">        literalCollector.withModel(parent);</span>
<span class="fc" id="L613">        ObjList&lt;ExpressionNode&gt; filterNodes = parent.getParsedWhere();</span>
        // collect table indexes from each part of global filter
<span class="fc" id="L615">        int pc = filterNodes.size();</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">        for (int i = 0; i &lt; pc; i++) {</span>
<span class="fc" id="L617">            IntHashSet indexes = intHashSetPool.next();</span>
<span class="fc" id="L618">            literalCollector.resetCounts();</span>
<span class="fc" id="L619">            traversalAlgo.traverse(filterNodes.getQuick(i), literalCollector.to(indexes));</span>
<span class="fc" id="L620">            postFilterTableRefs.add(indexes);</span>
        }

<span class="fc" id="L623">        IntList ordered = parent.getOrderedJoinModels();</span>
        // match table references to set of table in join order
<span class="fc bfc" id="L625" title="All 2 branches covered.">        for (int i = 0, n = ordered.size(); i &lt; n; i++) {</span>
<span class="fc" id="L626">            int index = ordered.getQuick(i);</span>
<span class="fc" id="L627">            tablesSoFar.add(index);</span>

<span class="fc bfc" id="L629" title="All 2 branches covered.">            for (int k = 0; k &lt; pc; k++) {</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">                if (postFilterRemoved.contains(k)) {</span>
<span class="fc" id="L631">                    continue;</span>
                }

<span class="fc" id="L634">                final ExpressionNode node = filterNodes.getQuick(k);</span>

<span class="fc" id="L636">                IntHashSet refs = postFilterTableRefs.getQuick(k);</span>
<span class="fc" id="L637">                int rs = refs.size();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">                if (rs == 0) {</span>
                    // condition has no table references
                    // must evaluate as constant
<span class="fc" id="L641">                    postFilterRemoved.add(k);</span>
<span class="fc" id="L642">                    parent.setConstWhereClause(concatFilters(parent.getConstWhereClause(), node));</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">                } else if (rs == 1 &amp;&amp; // single table reference and this table is not joined via OUTER or ASOF</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">                        joinBarriers.excludes(parent.getJoinModels().getQuick(refs.get(0)).getJoinType())) {</span>
                    // get single table reference out of the way right away
                    // we don't have to wait until &quot;our&quot; table comes along
<span class="fc" id="L647">                    addWhereNode(parent, refs.get(0), node);</span>
<span class="fc" id="L648">                    postFilterRemoved.add(k);</span>
                } else {
<span class="fc" id="L650">                    boolean qualifies = true;</span>
                    // check if filter references table processed so far
<span class="fc bfc" id="L652" title="All 2 branches covered.">                    for (int y = 0; y &lt; rs; y++) {</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">                        if (tablesSoFar.excludes(refs.get(y))) {</span>
<span class="fc" id="L654">                            qualifies = false;</span>
<span class="fc" id="L655">                            break;</span>
                        }
                    }
<span class="fc bfc" id="L658" title="All 2 branches covered.">                    if (qualifies) {</span>
<span class="fc" id="L659">                        postFilterRemoved.add(k);</span>
<span class="fc" id="L660">                        QueryModel m = parent.getJoinModels().getQuick(index);</span>
                        // it is possible that filter references only top query via alias
                        // we will need to strip these aliases before assigning filter
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">                        if (index == 0) {</span>
<span class="nc" id="L664">                            traversalAlgo.traverse(node, literalRewritingVisitor.of(m.getAliasToColumnNameMap()));</span>
                        }
<span class="fc" id="L666">                        m.setPostJoinWhereClause(concatFilters(m.getPostJoinWhereClause(), node));</span>
                    }
                }
            }
        }
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        assert postFilterRemoved.size() == pc;</span>
<span class="fc" id="L672">    }</span>

    // The model for the following SQL:
    // select * from t1 union all select * from t2 order by x
    // will have &quot;order by&quot; clause on the last model of the union linked list.
    // Semantically, order by must be executed after union. To get there, we will
    // create outer model(s) for the union block and move &quot;order by&quot; there.
    private QueryModel bubbleUpOrderByAndLimitFromUnion(QueryModel model) throws SqlException {
<span class="fc" id="L680">        QueryModel m = model.getUnionModel();</span>
<span class="fc" id="L681">        QueryModel nested = model.getNestedModel();</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L683">            QueryModel _n = bubbleUpOrderByAndLimitFromUnion(nested);</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">            if (_n != nested) {</span>
<span class="fc" id="L685">                model.setNestedModel(_n);</span>
            }
        }

<span class="fc bfc" id="L689" title="All 2 branches covered.">        if (m != null) {</span>
            // find order by clauses
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">            if (m.getNestedModel() != null) {</span>
<span class="fc" id="L692">                final QueryModel m1 = bubbleUpOrderByAndLimitFromUnion(m.getNestedModel());</span>
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">                if (m1 != m) {</span>
<span class="fc" id="L694">                    m.setNestedModel(m1);</span>
                }
            }

            do {
<span class="fc bfc" id="L699" title="All 2 branches covered.">                if (m.getUnionModel() == null) {</span>
                    // last model in the linked list
<span class="fc" id="L701">                    QueryModel un = m.getNestedModel();</span>
<span class="fc" id="L702">                    int n = un.getOrderBy().size();</span>
                    // order by clause is on the nested model
<span class="fc" id="L704">                    final ObjList&lt;ExpressionNode&gt; orderBy = un.getOrderBy();</span>
<span class="fc" id="L705">                    final IntList orderByDirection = un.getOrderByDirection();</span>
                    // limit is on the parent model
<span class="fc" id="L707">                    final ExpressionNode limitLo = m.getLimitLo();</span>
<span class="fc" id="L708">                    final ExpressionNode limitHi = m.getLimitHi();</span>

<span class="pc bpc" id="L710" title="1 of 6 branches missed.">                    if (n &gt; 0 || limitHi != null || limitLo != null) {</span>
                        // we have some order by clauses to move
<span class="fc" id="L712">                        QueryModel _nested = queryModelPool.next();</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">                        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L714">                            _nested.addOrderBy(orderBy.getQuick(i), orderByDirection.getQuick(i));</span>
                        }
<span class="fc" id="L716">                        orderBy.clear();</span>
<span class="fc" id="L717">                        orderByDirection.clear();</span>

<span class="fc" id="L719">                        m.setLimit(null, null);</span>

<span class="fc" id="L721">                        _nested.setNestedModel(model);</span>
<span class="fc" id="L722">                        QueryModel _model = queryModelPool.next();</span>
<span class="fc" id="L723">                        _model.setNestedModel(_nested);</span>
<span class="fc" id="L724">                        SqlUtil.addSelectStar(_model, queryColumnPool, expressionNodePool);</span>
<span class="fc" id="L725">                        _model.setLimit(limitLo, limitHi);</span>
<span class="fc" id="L726">                        return _model;</span>
                    }
                    break;
                }

<span class="fc" id="L731">                m = m.getUnionModel();</span>
<span class="fc" id="L732">            } while (true);</span>
        }
<span class="fc" id="L734">        return model;</span>
    }

    //pushing predicates to sample by model is only allowed for sample by fill none align to calendar and expressions on non-timestamp columns
    //pushing for other fill options or sample by first observation could alter result 
    private boolean canPushToSampleBy(final QueryModel model, ObjList&lt;CharSequence&gt; expressionColumns) {
<span class="fc" id="L740">        ObjList&lt;ExpressionNode&gt; fill = model.getSampleByFill();</span>
<span class="fc" id="L741">        int fillCount = fill.size();</span>
<span class="pc bpc" id="L742" title="1 of 6 branches missed.">        boolean isFillNone = fillCount == 0 || (fillCount == 1 &amp;&amp; SqlKeywords.isNoneKeyword(fill.getQuick(0).token));</span>

<span class="fc bfc" id="L744" title="All 4 branches covered.">        if (!isFillNone || model.getSampleByOffset() == null) {</span>
<span class="fc" id="L745">            return false;</span>
        }

<span class="fc" id="L748">        CharSequence timestamp = findTimestamp(model);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        if (timestamp == null) {</span>
<span class="fc" id="L750">            return true;</span>
        }

<span class="fc bfc" id="L753" title="All 2 branches covered.">        for (int i = 0, n = expressionColumns.size(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            if (Chars.equalsIgnoreCase(expressionColumns.get(i), timestamp)) {</span>
<span class="fc" id="L755">                return false;</span>
            }
        }

<span class="fc" id="L759">        return true;</span>
    }

    private boolean checkForAggregates(ExpressionNode node) {
<span class="fc" id="L763">        sqlNodeStack.clear();</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        while (node != null) {</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">            if (node.rhs != null) {</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">                if (functionParser.getFunctionFactoryCache().isGroupBy(node.rhs.token)) {</span>
<span class="fc" id="L767">                    return true;</span>
                }
<span class="fc" id="L769">                this.sqlNodeStack.push(node.rhs);</span>
            }

<span class="fc bfc" id="L772" title="All 2 branches covered.">            if (node.lhs != null) {</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">                if (functionParser.getFunctionFactoryCache().isGroupBy(node.lhs.token)) {</span>
<span class="fc" id="L774">                    return true;</span>
                }
<span class="fc" id="L776">                node = node.lhs;</span>
            } else {
<span class="fc bfc" id="L778" title="All 2 branches covered.">                if (!sqlNodeStack.isEmpty()) {</span>
<span class="fc" id="L779">                    node = this.sqlNodeStack.poll();</span>
                } else {
<span class="fc" id="L781">                    node = null;</span>
                }
            }
        }

<span class="fc" id="L786">        return false;</span>
    }

    private void collectModelAlias(QueryModel parent, int modelIndex, QueryModel model) throws SqlException {
<span class="fc bfc" id="L790" title="All 2 branches covered.">        final ExpressionNode alias = model.getAlias() != null ? model.getAlias() : model.getTableNameExpr();</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (parent.addModelAliasIndex(alias, modelIndex)) {</span>
<span class="fc" id="L792">            return;</span>
        }
<span class="fc" id="L794">        throw SqlException.position(alias.position).put(&quot;Duplicate table or alias: &quot;).put(alias.token);</span>
    }

    private ExpressionNode concatFilters(ExpressionNode old, ExpressionNode filter) {
<span class="fc bfc" id="L798" title="All 2 branches covered.">        if (old == null) {</span>
<span class="fc" id="L799">            return filter;</span>
        } else {
<span class="fc" id="L801">            ExpressionNode n = expressionNodePool.next().of(ExpressionNode.OPERATION, &quot;and&quot;, 0, filter.position);</span>
<span class="fc" id="L802">            n.paramCount = 2;</span>
<span class="fc" id="L803">            n.lhs = old;</span>
<span class="fc" id="L804">            n.rhs = filter;</span>
<span class="fc" id="L805">            return n;</span>
        }
    }

    private void copyColumnTypesFromMetadata(QueryModel model, TableRecordMetadata m) {
        // TODO: optimise by copying column indexes, types of the columns used in SET clause in the UPDATE only
<span class="fc bfc" id="L811" title="All 2 branches covered.">        for (int i = 0, k = m.getColumnCount(); i &lt; k; i++) {</span>
<span class="fc" id="L812">            model.addUpdateTableColumnMetadata(m.getColumnType(i), m.getColumnName(i));</span>
        }
<span class="fc" id="L814">    }</span>

    private void copyColumnsFromMetadata(QueryModel model, RecordMetadata m, boolean cleanColumnNames) throws SqlException {
        // column names are not allowed to have a dot

<span class="fc bfc" id="L819" title="All 2 branches covered.">        for (int i = 0, k = m.getColumnCount(); i &lt; k; i++) {</span>
<span class="fc" id="L820">            CharSequence columnName = createColumnAlias(m.getColumnName(i), model, cleanColumnNames);</span>
<span class="fc" id="L821">            QueryColumn column = queryColumnPool.next().of(columnName, expressionNodePool.next().of(LITERAL, columnName, 0, 0), true, m.getColumnType(i));</span>
<span class="fc" id="L822">            model.addField(column);</span>
        }

        // validate explicitly defined timestamp, if it exists
<span class="fc" id="L826">        ExpressionNode timestamp = model.getTimestamp();</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">        if (timestamp == null) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (m.getTimestampIndex() != -1) {</span>
<span class="fc" id="L829">                model.setTimestamp(expressionNodePool.next().of(LITERAL, m.getColumnName(m.getTimestampIndex()), 0, 0));</span>
            }
        } else {
<span class="fc" id="L832">            int index = m.getColumnIndexQuiet(timestamp.token);</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">            if (index == -1) {</span>
<span class="fc" id="L834">                throw SqlException.invalidColumn(timestamp.position, timestamp.token);</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">            } else if (!ColumnType.isTimestamp(m.getColumnType(index))) {</span>
<span class="fc" id="L836">                throw SqlException.$(timestamp.position, &quot;not a TIMESTAMP&quot;);</span>
            }
        }
<span class="fc" id="L839">    }</span>

    private CharSequence createColumnAlias(CharSequence name, QueryModel model, boolean cleanColumnNames) {
<span class="fc" id="L842">        return SqlUtil.createColumnAlias(characterStore, name, -1, model.getAliasToColumnMap(), cleanColumnNames);</span>
    }

    private CharSequence createColumnAlias(CharSequence name, QueryModel model) {
<span class="fc" id="L846">        return SqlUtil.createColumnAlias(characterStore, name, -1, model.getAliasToColumnMap());</span>
    }

    private CharSequence createColumnAlias(ExpressionNode node, QueryModel model) {
<span class="fc" id="L850">        return SqlUtil.createColumnAlias(characterStore, node.token, Chars.indexOf(node.token, '.'), model.getAliasToColumnMap());</span>
    }

    /**
     * Creates dependencies via implied columns, typically timestamp.
     * Dependencies like that are not explicitly expressed in SQL query and
     * therefore are not created by analyzing &quot;where&quot; clause.
     * &lt;p&gt;
     * Explicit dependencies however are required for table ordering.
     *
     * @param parent the parent model
     */
    private void createImpliedDependencies(QueryModel parent) {
<span class="fc" id="L863">        ObjList&lt;QueryModel&gt; models = parent.getJoinModels();</span>
        JoinContext jc;
<span class="fc bfc" id="L865" title="All 2 branches covered.">        for (int i = 0, n = models.size(); i &lt; n; i++) {</span>
<span class="fc" id="L866">            QueryModel m = models.getQuick(i);</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">            if (joinsRequiringTimestamp[m.getJoinType()]) {</span>
<span class="fc" id="L868">                linkDependencies(parent, 0, i);</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">                if (m.getContext() == null) {</span>
<span class="fc" id="L870">                    m.setContext(jc = contextPool.next());</span>
<span class="fc" id="L871">                    jc.parents.add(0);</span>
<span class="fc" id="L872">                    jc.slaveIndex = i;</span>
                }
            }
        }
<span class="fc" id="L876">    }</span>

    // order hash is used to determine redundant order when parsing analytic function definition
    private void createOrderHash(QueryModel model) {
<span class="fc" id="L880">        LowerCaseCharSequenceIntHashMap hash = model.getOrderHash();</span>
<span class="fc" id="L881">        hash.clear();</span>

<span class="fc" id="L883">        final ObjList&lt;ExpressionNode&gt; orderBy = model.getOrderBy();</span>
<span class="fc" id="L884">        final int n = orderBy.size();</span>
<span class="fc" id="L885">        final QueryModel nestedModel = model.getNestedModel();</span>

<span class="fc bfc" id="L887" title="All 2 branches covered.">        if (n &gt; 0) {</span>
<span class="fc" id="L888">            final IntList orderByDirection = model.getOrderByDirection();</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
                // if a column appears multiple times in the ORDER BY clause then we use only the first occurrence.
                // why? consider this clause: ORDER BY A DESC, A ASC. In this case we want to order to be &quot;A DESC&quot; only.
                // why? &quot;A ASC&quot; is a lower in priority, and it's applicable if and only if the items within first clause
                // are equal. but if the items are already equal then there is no point in ordering by the same column again.
                // unconditional put() would be a bug as a lower priority ordering would replace ordering with a higher priority.
<span class="fc" id="L895">                hash.putIfAbsent(orderBy.getQuick(i).token, orderByDirection.getQuick(i));</span>
            }
        }

<span class="fc bfc" id="L899" title="All 2 branches covered.">        if (nestedModel != null) {</span>
<span class="fc" id="L900">            createOrderHash(nestedModel);</span>
        }

<span class="fc" id="L903">        final ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">        for (int i = 1, z = joinModels.size(); i &lt; z; i++) {</span>
<span class="fc" id="L905">            createOrderHash(joinModels.getQuick(i));</span>
        }

<span class="fc" id="L908">        final QueryModel union = model.getUnionModel();</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">        if (union != null) {</span>
<span class="fc" id="L910">            createOrderHash(union);</span>
        }
<span class="fc" id="L912">    }</span>

    private void createSelectColumn(
            CharSequence columnName,
            ExpressionNode columnAst,
            boolean hasSeenWildcardExpression,
            QueryModel validatingModel,
            QueryModel translatingModel,
            QueryModel innerModel,
            QueryModel analyticModel,
            QueryModel groupByModel,
            QueryModel outerModel,
            QueryModel distinctModel
    ) throws SqlException {
        // add duplicate column names only to group-by model
        // taking into account that column is pre-aliased, e.g.
        // &quot;col, col&quot; will look like &quot;col, col col1&quot;

<span class="fc" id="L930">        LowerCaseCharSequenceObjHashMap&lt;CharSequence&gt; translatingAliasMap = translatingModel.getColumnNameToAliasMap();</span>
<span class="fc" id="L931">        int index = translatingAliasMap.keyIndex(columnAst.token);</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc bfc" id="L933" title="All 4 branches covered.">            if (hasSeenWildcardExpression &amp;&amp; translatingModel.getAliasToColumnMap().contains(columnName)) {</span>
<span class="fc" id="L934">                throw SqlException.duplicateColumn(columnAst.position, columnName);</span>
            }
            // column is already being referenced by translating model
<span class="fc" id="L937">            final CharSequence translatedColumnName = translatingAliasMap.valueAtQuick(index);</span>
<span class="fc" id="L938">            final CharSequence innerAlias = createColumnAlias(columnName, groupByModel);</span>
<span class="fc" id="L939">            final QueryColumn translatedColumn = nextColumn(innerAlias, translatedColumnName);</span>
<span class="fc" id="L940">            innerModel.addBottomUpColumn(columnAst.position, translatedColumn, true);</span>
<span class="fc" id="L941">            groupByModel.addBottomUpColumn(translatedColumn);</span>

            // analytic model is used together with inner model
<span class="fc" id="L944">            final CharSequence analyticAlias = createColumnAlias(innerAlias, analyticModel);</span>
<span class="fc" id="L945">            final QueryColumn analyticColumn = nextColumn(analyticAlias, innerAlias);</span>
<span class="fc" id="L946">            analyticModel.addBottomUpColumn(analyticColumn);</span>
<span class="fc" id="L947">            outerModel.addBottomUpColumn(translatedColumn);</span>
<span class="fc" id="L948">            distinctModel.addBottomUpColumn(translatedColumn);</span>
<span class="fc" id="L949">        } else {</span>
<span class="fc" id="L950">            final CharSequence alias = createColumnAlias(columnName, translatingModel);</span>
<span class="fc" id="L951">            addColumnToTranslatingModel(</span>
<span class="fc" id="L952">                    queryColumnPool.next().of(</span>
                            alias,
                            columnAst
                    ),
                    translatingModel,
                    validatingModel
            );

<span class="fc" id="L960">            final QueryColumn translatedColumn = nextColumn(alias);</span>

            // create column that references inner alias we just created
<span class="fc" id="L963">            innerModel.addBottomUpColumn(translatedColumn);</span>
<span class="fc" id="L964">            analyticModel.addBottomUpColumn(translatedColumn);</span>
<span class="fc" id="L965">            groupByModel.addBottomUpColumn(translatedColumn);</span>
<span class="fc" id="L966">            outerModel.addBottomUpColumn(translatedColumn);</span>
<span class="fc" id="L967">            distinctModel.addBottomUpColumn(translatedColumn);</span>
        }
<span class="fc" id="L969">    }</span>

    private void createSelectColumn0(
            CharSequence columnName,
            ExpressionNode columnAst,
            QueryModel validatingModel,
            QueryModel translatingModel,
            QueryModel innerModel,
            QueryModel analyticModel
    ) throws SqlException {
        // add duplicate column names only to group-by model
        // taking into account that column is pre-aliased, e.g.
        // &quot;col, col&quot; will look like &quot;col, col col1&quot;

<span class="fc" id="L983">        LowerCaseCharSequenceObjHashMap&lt;CharSequence&gt; translatingAliasMap = translatingModel.getColumnNameToAliasMap();</span>
<span class="fc" id="L984">        int index = translatingAliasMap.keyIndex(columnAst.token);</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">        if (index &lt; 0) {</span>
            // column is already being referenced by translating model
<span class="fc" id="L987">            final CharSequence translatedColumnName = translatingAliasMap.valueAtQuick(index);</span>
<span class="fc" id="L988">            final CharSequence innerAlias = createColumnAlias(columnName, innerModel);</span>
<span class="fc" id="L989">            final QueryColumn translatedColumn = nextColumn(innerAlias, translatedColumnName);</span>
<span class="fc" id="L990">            innerModel.addBottomUpColumn(translatedColumn);</span>

            // analytic model is used together with inner model
<span class="fc" id="L993">            final CharSequence analyticAlias = createColumnAlias(innerAlias, analyticModel);</span>
<span class="fc" id="L994">            final QueryColumn analyticColumn = nextColumn(analyticAlias, innerAlias);</span>
<span class="fc" id="L995">            analyticModel.addBottomUpColumn(analyticColumn);</span>
<span class="fc" id="L996">        } else {</span>
<span class="fc" id="L997">            final CharSequence alias = createColumnAlias(columnName, translatingModel);</span>
<span class="fc" id="L998">            addColumnToTranslatingModel(</span>
<span class="fc" id="L999">                    queryColumnPool.next().of(</span>
                            alias,
                            columnAst
                    ),
                    translatingModel,
                    validatingModel
            );

<span class="fc" id="L1007">            final QueryColumn translatedColumn = nextColumn(alias);</span>

            // create column that references inner alias we just created
<span class="fc" id="L1010">            innerModel.addBottomUpColumn(translatedColumn);</span>
<span class="fc" id="L1011">            analyticModel.addBottomUpColumn(translatedColumn);</span>
        }
<span class="fc" id="L1013">    }</span>

    private void createSelectColumnsForWildcard(
            QueryColumn qc,
            boolean hasJoins,
            QueryModel baseModel,
            QueryModel translatingModel,
            QueryModel innerModel,
            QueryModel analyticModel,
            QueryModel groupByModel,
            QueryModel outerModel,
            QueryModel distinctModel
    ) throws SqlException {
        // this could be a wildcard, such as '*' or 'a.*'
<span class="fc" id="L1027">        int dot = Chars.indexOf(qc.getAst().token, '.');</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">        if (dot &gt; -1) {</span>
<span class="fc" id="L1029">            int index = baseModel.getModelAliasIndex(qc.getAst().token, 0, dot);</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">            if (index == -1) {</span>
<span class="fc" id="L1031">                throw SqlException.$(qc.getAst().position, &quot;invalid table alias&quot;);</span>
            }

            // we are targeting single table
<span class="fc" id="L1035">            createSelectColumnsForWildcard0(</span>
<span class="fc" id="L1036">                    baseModel.getJoinModels().getQuick(index),</span>
                    hasJoins,
<span class="fc" id="L1038">                    qc.getAst().position,</span>
                    translatingModel,
                    innerModel,
                    analyticModel,
                    groupByModel,
                    outerModel,
                    distinctModel
            );
<span class="fc" id="L1046">        } else {</span>
<span class="fc" id="L1047">            ObjList&lt;QueryModel&gt; models = baseModel.getJoinModels();</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            for (int j = 0, z = models.size(); j &lt; z; j++) {</span>
<span class="fc" id="L1049">                createSelectColumnsForWildcard0(</span>
<span class="fc" id="L1050">                        models.getQuick(j),</span>
                        hasJoins,
<span class="fc" id="L1052">                        qc.getAst().position,</span>
                        translatingModel,
                        innerModel,
                        analyticModel,
                        groupByModel,
                        outerModel,
                        distinctModel
                );
            }
        }
<span class="fc" id="L1062">    }</span>

    private void createSelectColumnsForWildcard0(
            QueryModel srcModel,
            boolean hasJoins,
            int wildcardPosition,
            QueryModel translatingModel,
            QueryModel innerModel,
            QueryModel analyticModel,
            QueryModel groupByModel,
            QueryModel outerModel,
            QueryModel distinctModel
    ) throws SqlException {
<span class="fc" id="L1075">        createSelectColumnsForWildcardFromColumnNames(</span>
                srcModel,
                hasJoins,
                wildcardPosition,
                translatingModel,
                innerModel,
                analyticModel,
                groupByModel,
                outerModel,
                distinctModel
        );
<span class="fc" id="L1086">    }</span>

    private void createSelectColumnsForWildcardFromColumnNames(
            QueryModel srcModel,
            boolean hasJoins,
            int wildcardPosition,
            QueryModel translatingModel,
            QueryModel innerModel,
            QueryModel analyticModel,
            QueryModel groupByModel,
            QueryModel outerModel,
            QueryModel distinctModel
    ) throws SqlException {
<span class="fc" id="L1099">        final ObjList&lt;CharSequence&gt; columnNames = srcModel.getBottomUpColumnNames();</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">        for (int j = 0, z = columnNames.size(); j &lt; z; j++) {</span>
<span class="fc" id="L1101">            CharSequence name = columnNames.getQuick(j);</span>
            // this is a check to see if column has to be added to wildcard list
<span class="fc" id="L1103">            QueryColumn qc = srcModel.getAliasToColumnMap().get(name);</span>
<span class="fc bfc" id="L1104" title="All 2 branches covered.">            if (qc.isIncludeIntoWildcard()) {</span>
                CharSequence token;
<span class="fc bfc" id="L1106" title="All 2 branches covered.">                if (hasJoins) {</span>
<span class="fc" id="L1107">                    CharacterStoreEntry characterStoreEntry = characterStore.newEntry();</span>
<span class="fc" id="L1108">                    characterStoreEntry.put(srcModel.getName());</span>
<span class="fc" id="L1109">                    characterStoreEntry.put('.');</span>
<span class="fc" id="L1110">                    characterStoreEntry.put(name);</span>
<span class="fc" id="L1111">                    token = characterStoreEntry.toImmutable();</span>
<span class="fc" id="L1112">                } else {</span>
<span class="fc" id="L1113">                    token = name;</span>
                }
<span class="fc" id="L1115">                createSelectColumn(</span>
                        name,
<span class="fc" id="L1117">                        nextLiteral(token, wildcardPosition),</span>
                        true,
                        null, // do not validate
                        translatingModel,
                        innerModel,
                        analyticModel,
                        groupByModel,
                        outerModel,
                        distinctModel
                );
            }
        }
<span class="fc" id="L1129">    }</span>

    private int doReorderTables(QueryModel parent, IntList ordered) {
<span class="fc" id="L1132">        tempCrossIndexes.clear();</span>
<span class="fc" id="L1133">        ordered.clear();</span>
<span class="fc" id="L1134">        this.orderingStack.clear();</span>
<span class="fc" id="L1135">        ObjList&lt;QueryModel&gt; joinModels = parent.getJoinModels();</span>

<span class="fc" id="L1137">        int cost = 0;</span>

<span class="fc bfc" id="L1139" title="All 2 branches covered.">        for (int i = 0, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1140">            QueryModel q = joinModels.getQuick(i);</span>
<span class="pc bpc" id="L1141" title="1 of 6 branches missed.">            if (q.getJoinType() == QueryModel.JOIN_CROSS || q.getContext() == null || q.getContext().parents.size() == 0) {</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">                if (q.getDependencies().size() &gt; 0) {</span>
<span class="fc" id="L1143">                    orderingStack.push(i);</span>
                } else {
<span class="fc" id="L1145">                    tempCrossIndexes.add(i);</span>
                }
            } else {
<span class="fc" id="L1148">                q.getContext().inCount = q.getContext().parents.size();</span>
            }
        }

<span class="fc bfc" id="L1152" title="All 2 branches covered.">        while (orderingStack.notEmpty()) {</span>
            //remove a node n from orderingStack
<span class="fc" id="L1154">            int index = orderingStack.pop();</span>

<span class="fc" id="L1156">            ordered.add(index);</span>

<span class="fc" id="L1158">            QueryModel m = joinModels.getQuick(index);</span>

<span class="fc bfc" id="L1160" title="All 2 branches covered.">            if (m.getJoinType() == QueryModel.JOIN_CROSS) {</span>
<span class="fc" id="L1161">                cost += 10;</span>
            } else {
<span class="fc" id="L1163">                cost += 5;</span>
            }

<span class="fc" id="L1166">            IntHashSet dependencies = m.getDependencies();</span>

            //for each node m with an edge e from n to m do
<span class="fc bfc" id="L1169" title="All 2 branches covered.">            for (int i = 0, k = dependencies.size(); i &lt; k; i++) {</span>
<span class="fc" id="L1170">                int depIndex = dependencies.get(i);</span>
<span class="fc" id="L1171">                JoinContext jc = joinModels.getQuick(depIndex).getContext();</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">                if (--jc.inCount == 0) {</span>
<span class="fc" id="L1173">                    orderingStack.push(depIndex);</span>
                }
            }
<span class="fc" id="L1176">        }</span>

        //Check to see if all edges are removed
<span class="fc bfc" id="L1179" title="All 2 branches covered.">        for (int i = 0, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1180">            QueryModel m = joinModels.getQuick(i);</span>
<span class="pc bpc" id="L1181" title="1 of 4 branches missed.">            if (m.getContext() != null &amp;&amp; m.getContext().inCount &gt; 0) {</span>
<span class="nc" id="L1182">                return Integer.MAX_VALUE;</span>
            }
        }

        // add pure crosses at end of ordered table list
<span class="fc bfc" id="L1187" title="All 2 branches covered.">        for (int i = 0, n = tempCrossIndexes.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1188">            ordered.add(tempCrossIndexes.getQuick(i));</span>
        }

<span class="fc" id="L1191">        return cost;</span>
    }

    private ExpressionNode doReplaceLiteral(
            @Transient ExpressionNode node,
            QueryModel translatingModel,
            @Nullable QueryModel innerModel,
            QueryModel validatingModel,
            boolean analyticCall
    ) throws SqlException {
<span class="fc bfc" id="L1201" title="All 2 branches covered.">        if (analyticCall) {</span>
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">            assert innerModel != null;</span>
<span class="fc" id="L1203">            ExpressionNode n = doReplaceLiteral0(node, translatingModel, null, validatingModel);</span>
<span class="fc" id="L1204">            LowerCaseCharSequenceObjHashMap&lt;CharSequence&gt; map = innerModel.getColumnNameToAliasMap();</span>
<span class="fc" id="L1205">            int index = map.keyIndex(n.token);</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">            if (index &gt; -1) {</span>
                // column is not referenced by inner model
<span class="fc" id="L1208">                CharSequence alias = createColumnAlias(n.token, innerModel);</span>
<span class="fc" id="L1209">                innerModel.addBottomUpColumn(queryColumnPool.next().of(alias, n));</span>
                // when alias is not the same as token, e.g. column aliases as &quot;token&quot; is already on the list
                // we have to create a new expression node that uses this alias
<span class="fc bfc" id="L1212" title="All 2 branches covered.">                if (alias != n.token) {</span>
<span class="fc" id="L1213">                    return nextLiteral(alias);</span>
                } else {
<span class="fc" id="L1215">                    return n;</span>
                }
            } else {
                // column is already referenced
<span class="fc" id="L1219">                return nextLiteral(map.valueAt(index));</span>
            }
        }
<span class="fc" id="L1222">        return doReplaceLiteral0(node, translatingModel, innerModel, validatingModel);</span>
    }

    private ExpressionNode doReplaceLiteral0(
            ExpressionNode node,
            QueryModel translatingModel,
            @Nullable QueryModel innerModel,
            QueryModel validatingModel
    ) throws SqlException {

<span class="fc" id="L1232">        final LowerCaseCharSequenceObjHashMap&lt;CharSequence&gt; map = translatingModel.getColumnNameToAliasMap();</span>
<span class="fc" id="L1233">        int index = map.keyIndex(node.token);</span>
        final CharSequence alias;
<span class="fc bfc" id="L1235" title="All 2 branches covered.">        if (index &gt; -1) {</span>
            // there is a possibility that column references join table, but in a different way
            // for example. main column could be tab1.y and the &quot;missing&quot; one just &quot;y&quot;
            // which is the same thing.
            // To disambiguate this situation we need to go over all join tables and see if the
            // column matches any of join tables unambiguously.

<span class="fc" id="L1242">            final int joinCount = validatingModel.getJoinModels().size();</span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">            if (joinCount &gt; 1) {</span>
<span class="fc" id="L1244">                boolean found = false;</span>
<span class="fc" id="L1245">                final StringSink sink = Misc.getThreadLocalBuilder();</span>
<span class="fc bfc" id="L1246" title="All 2 branches covered.">                for (int i = 0; i &lt; joinCount; i++) {</span>
<span class="fc" id="L1247">                    final QueryModel jm = validatingModel.getJoinModels().getQuick(i);</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">                    if (jm.getAliasToColumnMap().keyIndex(node.token) &lt; 0) {</span>
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">                        if (found) {</span>
<span class="nc" id="L1250">                            throw SqlException.ambiguousColumn(node.position, node.token);</span>
                        }
<span class="fc bfc" id="L1252" title="All 2 branches covered.">                        if (jm.getAlias() != null) {</span>
<span class="fc" id="L1253">                            sink.put(jm.getAlias().token);</span>
                        } else {
<span class="fc" id="L1255">                            sink.put(jm.getTableName());</span>
                        }

<span class="fc" id="L1258">                        sink.put('.');</span>
<span class="fc" id="L1259">                        sink.put(node.token);</span>

<span class="fc bfc" id="L1261" title="All 2 branches covered.">                        if ((index = map.keyIndex(sink)) &lt; 0) {</span>
<span class="fc" id="L1262">                            found = true;</span>
                        }
                    }
                }

<span class="fc bfc" id="L1267" title="All 2 branches covered.">                if (found) {</span>
<span class="fc" id="L1268">                    return nextLiteral(map.valueAtQuick(index), node.position);</span>
                }
            }

            // this is the first time we see this column and must create alias
<span class="fc" id="L1273">            alias = createColumnAlias(node, translatingModel);</span>
<span class="fc" id="L1274">            QueryColumn column = queryColumnPool.next().of(alias, node);</span>
            // add column to both models
<span class="fc" id="L1276">            addColumnToTranslatingModel(column, translatingModel, validatingModel);</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">            if (innerModel != null) {</span>
<span class="fc" id="L1278">                innerModel.addBottomUpColumn(column);</span>
            }
<span class="fc" id="L1280">        } else {</span>
            // It might be the case that we previously added the column to
            // the translating model, but not to the inner one.
<span class="fc" id="L1283">            alias = map.valueAtQuick(index);</span>
<span class="fc bfc" id="L1284" title="All 4 branches covered.">            if (innerModel != null &amp;&amp; innerModel.getColumnNameToAliasMap().excludes(alias)) {</span>
<span class="fc" id="L1285">                QueryColumn column = translatingModel.getAliasToColumnMap().get(alias);</span>
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">                assert column != null;</span>
                // but equally, column may already be referenced by translating model
<span class="fc" id="L1288">                innerModel.addBottomUpColumn(column, true);</span>
            }
        }
<span class="fc" id="L1291">        return nextLiteral(alias, node.position);</span>
    }

    private void doRewriteOrderByPositionForUnionModels(QueryModel model, QueryModel parent, QueryModel next) throws SqlException {
<span class="fc" id="L1295">        final int columnCount = model.getBottomUpColumns().size();</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">        while (next != null) {</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">            if (next.getBottomUpColumns().size() != columnCount) {</span>
<span class="fc" id="L1298">                throw SqlException.$(next.getModelPosition(), &quot;queries have different number of columns&quot;);</span>
            }
<span class="fc" id="L1300">            parent.setUnionModel(rewriteOrderByPosition(next));</span>
<span class="fc" id="L1301">            parent = next;</span>
<span class="fc" id="L1302">            next = next.getUnionModel();</span>
        }
<span class="fc" id="L1304">    }</span>

    private boolean emitAggregates(@Transient ExpressionNode node, QueryModel model) throws SqlException {

<span class="fc" id="L1308">        boolean replaced = false;</span>
<span class="fc" id="L1309">        this.sqlNodeStack.clear();</span>

        // pre-order iterative tree traversal
        // see: http://en.wikipedia.org/wiki/Tree_traversal

<span class="fc bfc" id="L1314" title="All 4 branches covered.">        while (!this.sqlNodeStack.isEmpty() || node != null) {</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">            if (node != null) {</span>

<span class="fc bfc" id="L1317" title="All 2 branches covered.">                if (node.rhs != null) {</span>
<span class="fc" id="L1318">                    ExpressionNode n = replaceIfAggregate(node.rhs, model);</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">                    if (node.rhs == n) {</span>
<span class="fc" id="L1320">                        this.sqlNodeStack.push(node.rhs);</span>
                    } else {
<span class="fc" id="L1322">                        replaced = true;</span>
<span class="fc" id="L1323">                        node.rhs = n;</span>
                    }
                }

<span class="fc" id="L1327">                ExpressionNode n = replaceIfAggregate(node.lhs, model);</span>
<span class="fc bfc" id="L1328" title="All 2 branches covered.">                if (n == node.lhs) {</span>
<span class="fc" id="L1329">                    node = node.lhs;</span>
                } else {
<span class="fc" id="L1331">                    replaced = true;</span>
<span class="fc" id="L1332">                    node.lhs = n;</span>
<span class="fc" id="L1333">                    node = null;</span>
                }
<span class="fc" id="L1335">            } else {</span>
<span class="fc" id="L1336">                node = this.sqlNodeStack.poll();</span>
            }
        }
<span class="fc" id="L1339">        return replaced;</span>
    }

    private void emitColumnLiteralsTopDown(ObjList&lt;QueryColumn&gt; columns, QueryModel target) {
<span class="fc bfc" id="L1343" title="All 2 branches covered.">        for (int i = 0, n = columns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1344">            final QueryColumn qc = columns.getQuick(i);</span>
<span class="fc" id="L1345">            emitLiteralsTopDown(qc.getAst(), target);</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">            if (qc instanceof AnalyticColumn) {</span>
<span class="fc" id="L1347">                final AnalyticColumn ac = (AnalyticColumn) qc;</span>
<span class="fc" id="L1348">                emitLiteralsTopDown(ac.getPartitionBy(), target);</span>
<span class="fc" id="L1349">                emitLiteralsTopDown(ac.getOrderBy(), target);</span>
            }
        }
<span class="fc" id="L1352">    }</span>

    // This method will create CROSS join models in the &quot;baseModel&quot; for all unique cursor
    // function it finds on the node. The &quot;translatingModel&quot; is used to ensure uniqueness
    private boolean emitCursors(
            @Transient ExpressionNode node,
            QueryModel cursorModel,
            @Nullable QueryModel innerVirtualModel,
            QueryModel translatingModel,
            QueryModel baseModel,
            SqlExecutionContext sqlExecutionContext
    ) throws SqlException {

<span class="fc" id="L1365">        boolean replaced = false;</span>
<span class="fc" id="L1366">        this.sqlNodeStack.clear();</span>

        // pre-order iterative tree traversal
        // see: http://en.wikipedia.org/wiki/Tree_traversal

<span class="fc bfc" id="L1371" title="All 4 branches covered.">        while (!this.sqlNodeStack.isEmpty() || node != null) {</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">            if (node != null) {</span>

<span class="fc bfc" id="L1374" title="All 2 branches covered.">                if (node.rhs != null) {</span>
<span class="fc" id="L1375">                    final ExpressionNode n = replaceIfCursor(</span>
                            node.rhs,
                            cursorModel,
                            innerVirtualModel,
                            translatingModel,
                            baseModel,
                            sqlExecutionContext
                    );
<span class="pc bpc" id="L1383" title="1 of 2 branches missed.">                    if (node.rhs == n) {</span>
<span class="fc" id="L1384">                        this.sqlNodeStack.push(node.rhs);</span>
                    } else {
<span class="nc" id="L1386">                        node.rhs = n;</span>
<span class="nc" id="L1387">                        replaced = true;</span>
                    }
                }

<span class="fc" id="L1391">                final ExpressionNode n = replaceIfCursor(</span>
                        node.lhs,
                        cursorModel,
                        innerVirtualModel,
                        translatingModel,
                        baseModel,
                        sqlExecutionContext
                );
<span class="fc bfc" id="L1399" title="All 2 branches covered.">                if (n == node.lhs) {</span>
<span class="fc" id="L1400">                    node = node.lhs;</span>
                } else {
<span class="fc" id="L1402">                    node.lhs = n;</span>
<span class="fc" id="L1403">                    node = null;</span>
<span class="fc" id="L1404">                    replaced = true;</span>
                }
<span class="fc" id="L1406">            } else {</span>
<span class="fc" id="L1407">                node = this.sqlNodeStack.poll();</span>
            }
        }
<span class="fc" id="L1410">        return replaced;</span>
    }

    private void emitLiterals(
            @Transient ExpressionNode node,
            QueryModel translatingModel,
            QueryModel innerModel,
            QueryModel validatingModel,
            boolean analyticCall
    ) throws SqlException {

<span class="fc" id="L1421">        this.sqlNodeStack.clear();</span>

        // pre-order iterative tree traversal
        // see: http://en.wikipedia.org/wiki/Tree_traversal

<span class="fc bfc" id="L1426" title="All 4 branches covered.">        while (!this.sqlNodeStack.isEmpty() || node != null) {</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">            if (node != null) {</span>
<span class="fc bfc" id="L1428" title="All 2 branches covered.">                if (node.paramCount &lt; 3) {</span>
<span class="fc bfc" id="L1429" title="All 2 branches covered.">                    if (node.rhs != null) {</span>
<span class="fc" id="L1430">                        ExpressionNode n = replaceLiteral(node.rhs, translatingModel, innerModel, validatingModel, analyticCall);</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">                        if (node.rhs == n) {</span>
<span class="fc" id="L1432">                            this.sqlNodeStack.push(node.rhs);</span>
                        } else {
<span class="fc" id="L1434">                            node.rhs = n;</span>
                        }
                    }

<span class="fc" id="L1438">                    ExpressionNode n = replaceLiteral(node.lhs, translatingModel, innerModel, validatingModel, analyticCall);</span>
<span class="fc bfc" id="L1439" title="All 2 branches covered.">                    if (n == node.lhs) {</span>
<span class="fc" id="L1440">                        node = node.lhs;</span>
                    } else {
<span class="fc" id="L1442">                        node.lhs = n;</span>
<span class="fc" id="L1443">                        node = null;</span>
                    }
<span class="fc" id="L1445">                } else {</span>
<span class="fc bfc" id="L1446" title="All 2 branches covered.">                    for (int i = 1, k = node.paramCount; i &lt; k; i++) {</span>
<span class="fc" id="L1447">                        ExpressionNode e = node.args.getQuick(i);</span>
<span class="fc" id="L1448">                        ExpressionNode n = replaceLiteral(e, translatingModel, innerModel, validatingModel, analyticCall);</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">                        if (e == n) {</span>
<span class="fc" id="L1450">                            this.sqlNodeStack.push(e);</span>
                        } else {
<span class="fc" id="L1452">                            node.args.setQuick(i, n);</span>
                        }
                    }

<span class="fc" id="L1456">                    ExpressionNode e = node.args.getQuick(0);</span>
<span class="fc" id="L1457">                    ExpressionNode n = replaceLiteral(e, translatingModel, innerModel, validatingModel, analyticCall);</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">                    if (e == n) {</span>
<span class="fc" id="L1459">                        node = e;</span>
                    } else {
<span class="fc" id="L1461">                        node.args.setQuick(0, n);</span>
<span class="fc" id="L1462">                        node = null;</span>
                    }
<span class="fc" id="L1464">                }</span>
            } else {
<span class="fc" id="L1466">                node = this.sqlNodeStack.poll();</span>
            }
        }
<span class="fc" id="L1469">    }</span>

    private void emitLiteralsTopDown(@Transient ExpressionNode node, QueryModel model) {
<span class="fc" id="L1472">        this.sqlNodeStack.clear();</span>

        // pre-order iterative tree traversal
        // see: http://en.wikipedia.org/wiki/Tree_traversal

<span class="fc" id="L1477">        addTopDownColumn(node, model);</span>

<span class="fc bfc" id="L1479" title="All 4 branches covered.">        while (!this.sqlNodeStack.isEmpty() || node != null) {</span>
<span class="fc bfc" id="L1480" title="All 2 branches covered.">            if (node != null) {</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">                if (node.paramCount &lt; 3) {</span>
<span class="fc bfc" id="L1482" title="All 2 branches covered.">                    if (node.rhs != null) {</span>
<span class="fc" id="L1483">                        addTopDownColumn(node.rhs, model);</span>
<span class="fc" id="L1484">                        this.sqlNodeStack.push(node.rhs);</span>
                    }

<span class="fc bfc" id="L1487" title="All 2 branches covered.">                    if (node.lhs != null) {</span>
<span class="fc" id="L1488">                        addTopDownColumn(node.lhs, model);</span>
                    }
<span class="fc" id="L1490">                    node = node.lhs;</span>
                } else {
<span class="fc bfc" id="L1492" title="All 2 branches covered.">                    for (int i = 1, k = node.paramCount; i &lt; k; i++) {</span>
<span class="fc" id="L1493">                        ExpressionNode e = node.args.getQuick(i);</span>
<span class="fc" id="L1494">                        addTopDownColumn(e, model);</span>
<span class="fc" id="L1495">                        this.sqlNodeStack.push(e);</span>
                    }

<span class="fc" id="L1498">                    final ExpressionNode e = node.args.getQuick(0);</span>
<span class="fc" id="L1499">                    addTopDownColumn(e, model);</span>
<span class="fc" id="L1500">                    node = e;</span>
<span class="fc" id="L1501">                }</span>
            } else {
<span class="fc" id="L1503">                node = this.sqlNodeStack.poll();</span>
            }
        }
<span class="fc" id="L1506">    }</span>

    private void emitLiteralsTopDown(ObjList&lt;ExpressionNode&gt; list, QueryModel nested) {
<span class="fc bfc" id="L1509" title="All 2 branches covered.">        for (int i = 0, m = list.size(); i &lt; m; i++) {</span>
<span class="fc" id="L1510">            emitLiteralsTopDown(list.getQuick(i), nested);</span>
        }
<span class="fc" id="L1512">    }</span>

    private QueryColumn ensureAliasUniqueness(QueryModel groupByModel, QueryColumn qc) {
<span class="fc" id="L1515">        CharSequence alias = createColumnAlias(qc.getAlias(), groupByModel);</span>
<span class="fc bfc" id="L1516" title="All 2 branches covered.">        if (alias != qc.getAlias()) {</span>
<span class="fc" id="L1517">            qc = queryColumnPool.next().of(alias, qc.getAst());</span>
        }
<span class="fc" id="L1519">        return qc;</span>
    }

    private void enumerateColumns(QueryModel model, TableRecordMetadata metadata) throws SqlException {
<span class="fc" id="L1523">        model.setTableVersion(metadata.getStructureVersion());</span>
<span class="fc" id="L1524">        model.setTableId(metadata.getTableId());</span>
<span class="fc" id="L1525">        copyColumnsFromMetadata(model, metadata, false);</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">        if (model.isUpdate()) {</span>
<span class="fc" id="L1527">            copyColumnTypesFromMetadata(model, metadata);</span>
        }
<span class="fc" id="L1529">    }</span>

    private void enumerateTableColumns(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L1532">        final ObjList&lt;QueryModel&gt; jm = model.getJoinModels();</span>

        // we have plain tables and possibly joins
        // deal with _this_ model first, it will always be the first element in join model list
<span class="fc" id="L1536">        final ExpressionNode tableNameExpr = model.getTableNameExpr();</span>
<span class="fc bfc" id="L1537" title="All 2 branches covered.">        if (tableNameExpr != null) {</span>
<span class="fc bfc" id="L1538" title="All 2 branches covered.">            if (tableNameExpr.type == ExpressionNode.FUNCTION) {</span>
<span class="fc" id="L1539">                parseFunctionAndEnumerateColumns(model, executionContext);</span>
            } else {
<span class="fc" id="L1541">                openReaderAndEnumerateColumns(executionContext, model);</span>
            }
        } else {
<span class="fc" id="L1544">            final QueryModel nested = model.getNestedModel();</span>
<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">            if (nested != null) {</span>
<span class="fc" id="L1546">                enumerateTableColumns(nested, executionContext);</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">                if (model.isUpdate()) {</span>
<span class="fc" id="L1548">                    model.copyUpdateTableMetadata(nested);</span>
                }
            }
        }
<span class="fc bfc" id="L1552" title="All 2 branches covered.">        for (int i = 1, n = jm.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1553">            enumerateTableColumns(jm.getQuick(i), executionContext);</span>
        }

<span class="fc bfc" id="L1556" title="All 2 branches covered.">        if (model.getUnionModel() != null) {</span>
<span class="fc" id="L1557">            enumerateTableColumns(model.getUnionModel(), executionContext);</span>
        }
<span class="fc" id="L1559">    }</span>

    private void eraseColumnPrefixInWhereClauses(QueryModel model) throws SqlException {

<span class="fc" id="L1563">        ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">        for (int i = 0, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1565">            QueryModel m = joinModels.getQuick(i);</span>
<span class="fc" id="L1566">            ExpressionNode where = m.getWhereClause();</span>

            // join models can have &quot;where&quot; clause
            // although in context of SQL where is executed after joins, this model
            // always localises &quot;where&quot; to a single table and therefore &quot;where&quot; is
            // applied before join. Please see post-join-where for filters that
            // executed in line with standard SQL behaviour.

<span class="fc bfc" id="L1574" title="All 2 branches covered.">            if (where != null) {</span>
<span class="fc bfc" id="L1575" title="All 2 branches covered.">                if (where.type == LITERAL) {</span>
<span class="fc" id="L1576">                    m.setWhereClause(columnPrefixEraser.rewrite(where));</span>
                } else {
<span class="fc" id="L1578">                    traversalAlgo.traverse(where, columnPrefixEraser);</span>
                }
            }

<span class="fc" id="L1582">            QueryModel nested = m.getNestedModel();</span>
<span class="fc bfc" id="L1583" title="All 2 branches covered.">            if (nested != null) {</span>
<span class="fc" id="L1584">                eraseColumnPrefixInWhereClauses(nested);</span>
            }

<span class="fc" id="L1587">            nested = m.getUnionModel();</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">            if (nested != null) {</span>
<span class="fc" id="L1589">                eraseColumnPrefixInWhereClauses(nested);</span>
            }
        }
<span class="fc" id="L1592">    }</span>

    private CharSequence findTimestamp(QueryModel model) {
<span class="pc bpc" id="L1595" title="1 of 2 branches missed.">        if (model != null) {</span>
            CharSequence timestamp;
<span class="fc bfc" id="L1597" title="All 2 branches covered.">            if (model.getTimestamp() != null) {</span>
<span class="fc" id="L1598">                timestamp = model.getTimestamp().token;</span>
            } else {
<span class="fc" id="L1600">                timestamp = findTimestamp(model.getNestedModel());</span>
            }

<span class="pc bpc" id="L1603" title="1 of 2 branches missed.">            if (timestamp != null) {</span>
<span class="fc" id="L1604">                return model.getColumnNameToAliasMap().get(timestamp);</span>
            }
        }
<span class="nc" id="L1607">        return null;</span>
    }

    private ObjList&lt;ExpressionNode&gt; getOrderByAdvice(QueryModel model) {
<span class="fc" id="L1611">        orderByAdvice.clear();</span>
<span class="fc" id="L1612">        final ObjList&lt;ExpressionNode&gt; orderBy = model.getOrderBy();</span>
<span class="fc" id="L1613">        final int len = orderBy.size();</span>
<span class="fc bfc" id="L1614" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L1615">            return orderByAdvice;</span>
        }

<span class="fc" id="L1618">        LowerCaseCharSequenceObjHashMap&lt;QueryColumn&gt; map = model.getAliasToColumnMap();</span>
<span class="fc bfc" id="L1619" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1620">            QueryColumn queryColumn = map.get(orderBy.getQuick(i).token);</span>
<span class="fc bfc" id="L1621" title="All 2 branches covered.">            if (queryColumn.getAst().type == LITERAL) {</span>
<span class="fc" id="L1622">                orderByAdvice.add(queryColumn.getAst());</span>
            } else {
<span class="fc" id="L1624">                orderByAdvice.clear();</span>
<span class="fc" id="L1625">                break;</span>
            }
        }
<span class="fc" id="L1628">        return orderByAdvice;</span>
    }

    private boolean hasAggregates(ExpressionNode node) {

<span class="fc" id="L1633">        this.sqlNodeStack.clear();</span>

        // pre-order iterative tree traversal
        // see: http://en.wikipedia.org/wiki/Tree_traversal

<span class="fc bfc" id="L1638" title="All 4 branches covered.">        while (!this.sqlNodeStack.isEmpty() || node != null) {</span>
<span class="fc bfc" id="L1639" title="All 2 branches covered.">            if (node != null) {</span>
<span class="fc bfc" id="L1640" title="All 3 branches covered.">                switch (node.type) {</span>
                    case LITERAL:
<span class="fc" id="L1642">                        node = null;</span>
<span class="fc" id="L1643">                        continue;</span>
                    case ExpressionNode.FUNCTION:
<span class="fc bfc" id="L1645" title="All 2 branches covered.">                        if (functionParser.getFunctionFactoryCache().isGroupBy(node.token)) {</span>
<span class="fc" id="L1646">                            return true;</span>
                        }
                        break;
                    default:
<span class="fc bfc" id="L1650" title="All 2 branches covered.">                        if (node.rhs != null) {</span>
<span class="fc" id="L1651">                            this.sqlNodeStack.push(node.rhs);</span>
                        }
                        break;
                }

<span class="fc" id="L1656">                node = node.lhs;</span>
            } else {
<span class="fc" id="L1658">                node = this.sqlNodeStack.poll();</span>
            }
        }
<span class="fc" id="L1661">        return false;</span>
    }

    private void homogenizeCrossJoins(QueryModel parent) {
<span class="fc" id="L1665">        ObjList&lt;QueryModel&gt; joinModels = parent.getJoinModels();</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">        for (int i = 0, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1667">            QueryModel m = joinModels.getQuick(i);</span>
<span class="fc" id="L1668">            JoinContext c = m.getContext();</span>

<span class="fc bfc" id="L1670" title="All 2 branches covered.">            if (m.getJoinType() == QueryModel.JOIN_CROSS) {</span>
<span class="fc bfc" id="L1671" title="All 4 branches covered.">                if (c != null &amp;&amp; c.parents.size() &gt; 0) {</span>
<span class="fc" id="L1672">                    m.setJoinType(QueryModel.JOIN_INNER);</span>
                }
<span class="fc bfc" id="L1674" title="All 4 branches covered.">            } else if (m.getJoinType() == QueryModel.JOIN_OUTER &amp;&amp;</span>
                    c == null &amp;&amp;
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">                    m.getJoinCriteria() != null) {</span>
<span class="fc" id="L1677">                m.setJoinType(QueryModel.JOIN_CROSS_LEFT);</span>
<span class="fc bfc" id="L1678" title="All 2 branches covered.">            } else if (m.getJoinType() != QueryModel.JOIN_ASOF &amp;&amp;</span>
<span class="fc bfc" id="L1679" title="All 4 branches covered.">                    m.getJoinType() != QueryModel.JOIN_SPLICE &amp;&amp;</span>
<span class="fc bfc" id="L1680" title="All 2 branches covered.">                    (c == null || c.parents.size() == 0)</span>
            ) {
<span class="fc" id="L1682">                m.setJoinType(QueryModel.JOIN_CROSS);</span>
            }
        }
<span class="fc" id="L1685">    }</span>

    private boolean isEffectivelyConstantExpression(ExpressionNode node) {
<span class="fc" id="L1688">        sqlNodeStack.clear();</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">        while (null != node) {</span>
<span class="fc bfc" id="L1690" title="All 2 branches covered.">            if (node.type == ExpressionNode.OPERATION) {</span>
<span class="fc" id="L1691">                sqlNodeStack.push(node.rhs);</span>
<span class="fc" id="L1692">                node = node.lhs;</span>
            }

<span class="fc bfc" id="L1695" title="All 6 branches covered.">            if (!(node.type == ExpressionNode.CONSTANT || (node.type == ExpressionNode.FUNCTION &amp;&amp; functionParser.getFunctionFactoryCache().isRuntimeConstant(node.token)))) {</span>
<span class="fc" id="L1696">                return false;</span>
            }

<span class="fc bfc" id="L1699" title="All 2 branches covered.">            if (sqlNodeStack.isEmpty()) {</span>
<span class="fc" id="L1700">                node = null;</span>
            } else {
<span class="fc" id="L1702">                node = sqlNodeStack.poll();</span>
            }
        }

<span class="fc" id="L1706">        return true;</span>
    }

    private boolean isIntegerConstant(ExpressionNode n) {
<span class="fc bfc" id="L1710" title="All 2 branches covered.">        if (n.type != CONSTANT) {</span>
<span class="fc" id="L1711">            return false;</span>
        }

        try {
<span class="fc" id="L1715">            Numbers.parseLong(n.token);</span>
<span class="fc" id="L1716">            return true;</span>
<span class="fc" id="L1717">        } catch (NumericException ne) {</span>
<span class="fc" id="L1718">            return false;</span>
        }
    }

    private boolean isSimpleIntegerColumn(ExpressionNode n, QueryModel model) {
<span class="fc bfc" id="L1723" title="All 2 branches covered.">        if (n.type != LITERAL) {</span>
<span class="fc" id="L1724">            return false;</span>
        }
<span class="fc" id="L1726">        QueryColumn qc = model.getAliasToColumnMap().get(n.token);</span>
<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">        return qc != null &amp;&amp;</span>
<span class="pc bpc" id="L1728" title="1 of 2 branches missed.">                (qc.getColumnType() == ColumnType.BYTE ||</span>
<span class="pc bpc" id="L1729" title="1 of 2 branches missed.">                        qc.getColumnType() == ColumnType.SHORT ||</span>
<span class="fc bfc" id="L1730" title="All 2 branches covered.">                        qc.getColumnType() == ColumnType.INT ||</span>
<span class="fc bfc" id="L1731" title="All 2 branches covered.">                        qc.getColumnType() == ColumnType.LONG);</span>
    }

    private ExpressionNode makeJoinAlias() {
<span class="fc" id="L1735">        CharacterStoreEntry characterStoreEntry = characterStore.newEntry();</span>
<span class="fc" id="L1736">        characterStoreEntry.put(QueryModel.SUB_QUERY_ALIAS_PREFIX).put(defaultAliasCount++);</span>
<span class="fc" id="L1737">        return nextLiteral(characterStoreEntry.toImmutable());</span>
    }

    private ExpressionNode makeModelAlias(CharSequence modelAlias, ExpressionNode node) {
<span class="fc" id="L1741">        CharacterStoreEntry characterStoreEntry = characterStore.newEntry();</span>
<span class="fc" id="L1742">        characterStoreEntry.put(modelAlias).put('.').put(node.token);</span>
<span class="fc" id="L1743">        return nextLiteral(characterStoreEntry.toImmutable(), node.position);</span>
    }

    private ExpressionNode makeOperation(CharSequence token, ExpressionNode lhs, ExpressionNode rhs) {
<span class="fc" id="L1747">        ExpressionNode expr = expressionNodePool.next().of(ExpressionNode.OPERATION, token, 0, 0);</span>
<span class="fc" id="L1748">        expr.paramCount = 2;</span>
<span class="fc" id="L1749">        expr.lhs = lhs;</span>
<span class="fc" id="L1750">        expr.rhs = rhs;</span>
<span class="fc" id="L1751">        return expr;</span>
    }

    private JoinContext mergeContexts(QueryModel parent, JoinContext a, JoinContext b) {
<span class="pc bpc" id="L1755" title="1 of 2 branches missed.">        assert a.slaveIndex == b.slaveIndex;</span>

<span class="fc" id="L1757">        deletedContexts.clear();</span>
<span class="fc" id="L1758">        JoinContext r = contextPool.next();</span>
        // check if we are merging a.x = b.x to a.y = b.y
        // or a.x = b.x to a.x = b.y, e.g. one of columns in the same table
<span class="fc bfc" id="L1761" title="All 2 branches covered.">        for (int i = 0, n = b.aNames.size(); i &lt; n; i++) {</span>

<span class="fc" id="L1763">            CharSequence ban = b.aNames.getQuick(i);</span>
<span class="fc" id="L1764">            int bai = b.aIndexes.getQuick(i);</span>
<span class="fc" id="L1765">            ExpressionNode bao = b.aNodes.getQuick(i);</span>

<span class="fc" id="L1767">            CharSequence bbn = b.bNames.getQuick(i);</span>
<span class="fc" id="L1768">            int bbi = b.bIndexes.getQuick(i);</span>
<span class="fc" id="L1769">            ExpressionNode bbo = b.bNodes.getQuick(i);</span>

<span class="fc bfc" id="L1771" title="All 2 branches covered.">            for (int k = 0, z = a.aNames.size(); k &lt; z; k++) {</span>
<span class="fc" id="L1772">                final CharSequence aan = a.aNames.getQuick(k);</span>
<span class="fc" id="L1773">                final int aai = a.aIndexes.getQuick(k);</span>
<span class="fc" id="L1774">                final ExpressionNode aao = a.aNodes.getQuick(k);</span>
<span class="fc" id="L1775">                final CharSequence abn = a.bNames.getQuick(k);</span>
<span class="fc" id="L1776">                final int abi = a.bIndexes.getQuick(k);</span>
<span class="fc" id="L1777">                final ExpressionNode abo = a.bNodes.getQuick(k);</span>

<span class="fc bfc" id="L1779" title="All 4 branches covered.">                if (aai == bai &amp;&amp; Chars.equals(aan, ban)) {</span>
                    // a.x = ?.x
                    //  |     ?
                    // a.x = ?.y
<span class="fc" id="L1783">                    addFilterOrEmitJoin(parent, k, abi, abn, abo, bbi, bbn, bbo);</span>
<span class="fc" id="L1784">                    break;</span>
<span class="pc bpc" id="L1785" title="1 of 4 branches missed.">                } else if (abi == bai &amp;&amp; Chars.equals(abn, ban)) {</span>
                    // a.y = b.x
                    //    /
                    // b.x = a.x
<span class="fc" id="L1789">                    addFilterOrEmitJoin(parent, k, aai, aan, aao, bbi, bbn, bbo);</span>
<span class="fc" id="L1790">                    break;</span>
<span class="pc bpc" id="L1791" title="3 of 4 branches missed.">                } else if (aai == bbi &amp;&amp; Chars.equals(aan, bbn)) {</span>
                    // a.x = b.x
                    //     \
                    // b.y = a.x
<span class="nc" id="L1795">                    addFilterOrEmitJoin(parent, k, abi, abn, abo, bai, ban, bao);</span>
<span class="nc" id="L1796">                    break;</span>
<span class="pc bpc" id="L1797" title="1 of 4 branches missed.">                } else if (abi == bbi &amp;&amp; Chars.equals(abn, bbn)) {</span>
                    // a.x = b.x
                    //        |
                    // a.y = b.x
<span class="fc" id="L1801">                    addFilterOrEmitJoin(parent, k, aai, aan, aao, bai, ban, bao);</span>
<span class="fc" id="L1802">                    break;</span>
                }
            }
<span class="fc" id="L1805">            r.aIndexes.add(bai);</span>
<span class="fc" id="L1806">            r.aNames.add(ban);</span>
<span class="fc" id="L1807">            r.aNodes.add(bao);</span>
<span class="fc" id="L1808">            r.bIndexes.add(bbi);</span>
<span class="fc" id="L1809">            r.bNames.add(bbn);</span>
<span class="fc" id="L1810">            r.bNodes.add(bbo);</span>
<span class="fc" id="L1811">            int max = Math.max(bai, bbi);</span>
<span class="fc" id="L1812">            int min = Math.min(bai, bbi);</span>
<span class="fc" id="L1813">            r.slaveIndex = max;</span>
<span class="fc" id="L1814">            r.parents.add(min);</span>
<span class="fc" id="L1815">            linkDependencies(parent, min, max);</span>
        }

        // add remaining a nodes
<span class="fc bfc" id="L1819" title="All 2 branches covered.">        for (int i = 0, n = a.aNames.size(); i &lt; n; i++) {</span>
            int aai, abi, min, max;

<span class="fc" id="L1822">            aai = a.aIndexes.getQuick(i);</span>
<span class="fc" id="L1823">            abi = a.bIndexes.getQuick(i);</span>

<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">            if (aai &lt; abi) {</span>
<span class="fc" id="L1826">                min = aai;</span>
<span class="fc" id="L1827">                max = abi;</span>
            } else {
<span class="nc" id="L1829">                min = abi;</span>
<span class="nc" id="L1830">                max = aai;</span>
            }

<span class="fc bfc" id="L1833" title="All 2 branches covered.">            if (deletedContexts.contains(i)) {</span>
<span class="fc bfc" id="L1834" title="All 2 branches covered.">                if (r.parents.excludes(min)) {</span>
<span class="fc" id="L1835">                    unlinkDependencies(parent, min, max);</span>
                }
            } else {
<span class="fc" id="L1838">                r.aNames.add(a.aNames.getQuick(i));</span>
<span class="fc" id="L1839">                r.bNames.add(a.bNames.getQuick(i));</span>
<span class="fc" id="L1840">                r.aIndexes.add(aai);</span>
<span class="fc" id="L1841">                r.bIndexes.add(abi);</span>
<span class="fc" id="L1842">                r.aNodes.add(a.aNodes.getQuick(i));</span>
<span class="fc" id="L1843">                r.bNodes.add(a.bNodes.getQuick(i));</span>

<span class="fc" id="L1845">                r.parents.add(min);</span>
<span class="fc" id="L1846">                r.slaveIndex = max;</span>
<span class="fc" id="L1847">                linkDependencies(parent, min, max);</span>
            }
        }
<span class="fc" id="L1850">        return r;</span>
    }

    private JoinContext moveClauses(QueryModel parent, JoinContext from, JoinContext to, IntList positions) {
<span class="fc" id="L1854">        int p = 0;</span>
<span class="fc" id="L1855">        int m = positions.size();</span>

<span class="fc" id="L1857">        JoinContext result = contextPool.next();</span>
<span class="fc" id="L1858">        result.slaveIndex = from.slaveIndex;</span>

<span class="fc bfc" id="L1860" title="All 2 branches covered.">        for (int i = 0, n = from.aIndexes.size(); i &lt; n; i++) {</span>
            // logically those clauses we move away from &quot;from&quot; context
            // should no longer exist in &quot;from&quot;, but instead of implementing
            // &quot;delete&quot; function, which would be manipulating underlying array
            // on every invocation, we copy retained clauses to new context,
            // which is &quot;result&quot;.
            // hence, whenever exists in &quot;positions&quot; we copy clause to &quot;to&quot;
            // otherwise copy to &quot;result&quot;
<span class="pc bpc" id="L1868" title="1 of 4 branches missed.">            JoinContext t = p &lt; m &amp;&amp; i == positions.getQuick(p) ? to : result;</span>
<span class="fc" id="L1869">            int ai = from.aIndexes.getQuick(i);</span>
<span class="fc" id="L1870">            int bi = from.bIndexes.getQuick(i);</span>
<span class="fc" id="L1871">            t.aIndexes.add(ai);</span>
<span class="fc" id="L1872">            t.aNames.add(from.aNames.getQuick(i));</span>
<span class="fc" id="L1873">            t.aNodes.add(from.aNodes.getQuick(i));</span>
<span class="fc" id="L1874">            t.bIndexes.add(bi);</span>
<span class="fc" id="L1875">            t.bNames.add(from.bNames.getQuick(i));</span>
<span class="fc" id="L1876">            t.bNodes.add(from.bNodes.getQuick(i));</span>

            // either ai or bi is definitely belongs to this context
<span class="fc bfc" id="L1879" title="All 2 branches covered.">            if (ai != t.slaveIndex) {</span>
<span class="fc" id="L1880">                t.parents.add(ai);</span>
<span class="fc" id="L1881">                linkDependencies(parent, ai, bi);</span>
            } else {
<span class="fc" id="L1883">                t.parents.add(bi);</span>
<span class="fc" id="L1884">                linkDependencies(parent, bi, ai);</span>
            }
        }

<span class="fc" id="L1888">        return result;</span>
    }

    private QueryModel moveOrderByFunctionsIntoOuterSelect(QueryModel model) {
        // at this point order by should be on the nested model of this model :)
<span class="fc" id="L1893">        QueryModel unionModel = model.getUnionModel();</span>
<span class="fc bfc" id="L1894" title="All 2 branches covered.">        if (unionModel != null) {</span>
<span class="fc" id="L1895">            model.setUnionModel(moveOrderByFunctionsIntoOuterSelect(unionModel));</span>
        }

<span class="fc" id="L1898">        QueryModel nested = model.getNestedModel();</span>
<span class="pc bpc" id="L1899" title="1 of 2 branches missed.">        if (nested != null) {</span>
<span class="fc bfc" id="L1900" title="All 2 branches covered.">            for (int jm = 0, jmn = nested.getJoinModels().size(); jm &lt; jmn; jm++) {</span>
<span class="fc" id="L1901">                QueryModel joinModel = nested.getJoinModels().getQuick(jm);</span>
<span class="fc bfc" id="L1902" title="All 4 branches covered.">                if (joinModel != nested &amp;&amp; joinModel.getNestedModel() != null) {</span>
<span class="fc" id="L1903">                    joinModel.setNestedModel(moveOrderByFunctionsIntoOuterSelect(joinModel.getNestedModel()));</span>
                }
            }

<span class="fc" id="L1907">            QueryModel nestedNested = nested.getNestedModel();</span>
<span class="fc bfc" id="L1908" title="All 2 branches covered.">            if (nestedNested != null) {</span>
<span class="fc" id="L1909">                nested.setNestedModel(moveOrderByFunctionsIntoOuterSelect(nestedNested));</span>
            }

<span class="fc" id="L1912">            final ObjList&lt;ExpressionNode&gt; orderBy = nested.getOrderBy();</span>
<span class="fc" id="L1913">            final int n = orderBy.size();</span>
<span class="fc" id="L1914">            final int columnCount = model.getBottomUpColumns().size();</span>
<span class="fc" id="L1915">            boolean moved = false;</span>
<span class="fc bfc" id="L1916" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1917">                ExpressionNode node = orderBy.getQuick(i);</span>
<span class="fc bfc" id="L1918" title="All 4 branches covered.">                if (node.type == FUNCTION || node.type == OPERATION) {</span>
                    // add this function to bottom-up columns and replace this expression with index
<span class="fc" id="L1920">                    CharSequence alias = SqlUtil.createColumnAlias(characterStore, node.token, Chars.indexOf(node.token, '.'), model.getAliasToColumnMap(), true);</span>
<span class="fc" id="L1921">                    QueryColumn qc = queryColumnPool.next().of(</span>
                            alias,
                            node,
                            false
                    );
<span class="fc" id="L1926">                    model.getAliasToColumnMap().put(alias, qc);</span>
<span class="fc" id="L1927">                    model.getBottomUpColumns().add(qc);</span>
<span class="fc" id="L1928">                    orderBy.setQuick(i, nextLiteral(alias));</span>
<span class="fc" id="L1929">                    moved = true;</span>
                }
            }

<span class="fc bfc" id="L1933" title="All 2 branches covered.">            if (moved) {</span>
                // these are early stages of model processing
                // to create outer query, we will need a pair of models
<span class="fc" id="L1936">                QueryModel _model = queryModelPool.next();</span>
<span class="fc" id="L1937">                QueryModel _nested = queryModelPool.next();</span>

                // nest them
<span class="fc" id="L1940">                _model.setNestedModel(_nested);</span>
<span class="fc" id="L1941">                _nested.setNestedModel(model);</span>

                // then create columns on the outermost model
<span class="fc bfc" id="L1944" title="All 2 branches covered.">                for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L1945">                    QueryColumn qcFrom = model.getBottomUpColumns().getQuick(i);</span>
<span class="fc" id="L1946">                    QueryColumn qcTo = queryColumnPool.next().of(</span>
<span class="fc" id="L1947">                            qcFrom.getAlias(),</span>
<span class="fc" id="L1948">                            nextLiteral(qcFrom.getAlias())</span>
                    );
<span class="fc" id="L1950">                    _model.getBottomUpColumns().add(qcTo);</span>
                }

<span class="fc" id="L1953">                return _model;</span>
            }
        }
<span class="fc" id="L1956">        return model;</span>
    }

    private void moveTimestampToChooseModel(QueryModel model) {
<span class="fc" id="L1960">        QueryModel nested = model.getNestedModel();</span>
<span class="fc bfc" id="L1961" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L1962">            moveTimestampToChooseModel(nested);</span>
<span class="fc" id="L1963">            ExpressionNode timestamp = nested.getTimestamp();</span>
<span class="fc bfc" id="L1964" title="All 2 branches covered.">            if (</span>
                    timestamp != null
<span class="fc bfc" id="L1966" title="All 2 branches covered.">                            &amp;&amp; nested.getSelectModelType() == QueryModel.SELECT_MODEL_NONE</span>
<span class="fc bfc" id="L1967" title="All 2 branches covered.">                            &amp;&amp; nested.getTableName() == null</span>
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">                            &amp;&amp; nested.getTableNameFunction() == null</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">                            &amp;&amp; nested.getLatestBy().size() == 0</span>
            ) {
<span class="fc" id="L1971">                model.setTimestamp(timestamp);</span>
<span class="fc" id="L1972">                nested.setTimestamp(null);</span>
            }
        }

<span class="fc" id="L1976">        final ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc bfc" id="L1977" title="All 2 branches covered.">        if (joinModels.size() &gt; 1) {</span>
<span class="fc bfc" id="L1978" title="All 2 branches covered.">            for (int i = 1, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1979">                moveTimestampToChooseModel(joinModels.getQuick(i));</span>
            }
        }

<span class="fc" id="L1983">        nested = model.getUnionModel();</span>
<span class="fc bfc" id="L1984" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L1985">            moveTimestampToChooseModel(nested);</span>
        }
<span class="fc" id="L1987">    }</span>

    private void moveWhereInsideSubQueries(QueryModel model) throws SqlException {
<span class="fc bfc" id="L1990" title="All 2 branches covered.">        if (model.getSelectModelType() != QueryModel.SELECT_MODEL_DISTINCT) {</span>
<span class="fc" id="L1991">            model.getParsedWhere().clear();</span>
<span class="fc" id="L1992">            final ObjList&lt;ExpressionNode&gt; nodes = model.parseWhereClause();</span>
<span class="fc" id="L1993">            model.setWhereClause(null);</span>

<span class="fc" id="L1995">            final int n = nodes.size();</span>
<span class="fc bfc" id="L1996" title="All 2 branches covered.">            if (n &gt; 0) {</span>
<span class="fc bfc" id="L1997" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1998">                    final ExpressionNode node = nodes.getQuick(i);</span>
                    // collect table references this where clause element
<span class="fc" id="L2000">                    literalCollectorAIndexes.clear();</span>
<span class="fc" id="L2001">                    literalCollectorANames.clear();</span>
<span class="fc" id="L2002">                    literalCollector.withModel(model);</span>
<span class="fc" id="L2003">                    literalCollector.resetCounts();</span>
<span class="fc" id="L2004">                    traversalAlgo.traverse(node, literalCollector.lhs());</span>

<span class="fc" id="L2006">                    tempList.clear();</span>
<span class="fc bfc" id="L2007" title="All 2 branches covered.">                    for (int j = 0; j &lt; literalCollectorAIndexes.size(); j++) {</span>
<span class="fc" id="L2008">                        int tableExpressionReference = literalCollectorAIndexes.get(j);</span>
<span class="fc" id="L2009">                        int position = tempList.binarySearchUniqueList(tableExpressionReference);</span>
<span class="pc bpc" id="L2010" title="1 of 2 branches missed.">                        if (position &lt; 0) {</span>
<span class="fc" id="L2011">                            tempList.insert(-(position + 1), tableExpressionReference);</span>
                        }
                    }

<span class="fc" id="L2015">                    int distinctIndexes = tempList.size();</span>

                    // at this point we must not have constant conditions in where clause
                    // this could be either referencing constant of a sub-query
<span class="fc bfc" id="L2019" title="All 2 branches covered.">                    if (literalCollectorAIndexes.size() == 0) {</span>
                        // keep condition with this model
<span class="fc" id="L2021">                        addWhereNode(model, node);</span>
<span class="fc" id="L2022">                        continue;</span>
<span class="fc bfc" id="L2023" title="All 2 branches covered.">                    } else if (distinctIndexes &gt; 1) {</span>
<span class="fc" id="L2024">                        int greatest = tempList.get(distinctIndexes - 1);</span>
<span class="fc" id="L2025">                        final QueryModel m = model.getJoinModels().get(greatest);</span>
<span class="fc" id="L2026">                        m.setPostJoinWhereClause(concatFilters(m.getPostJoinWhereClause(), nodes.getQuick(i)));</span>
<span class="fc" id="L2027">                        continue;</span>
                    }

                    // by now all where clause must reference single table only and all column references have to be valid
                    // they would have been rewritten and validated as join analysis stage
<span class="fc" id="L2032">                    final int tableIndex = literalCollectorAIndexes.get(0);</span>
<span class="fc" id="L2033">                    final QueryModel parent = model.getJoinModels().getQuick(tableIndex);</span>

                    // Do not move where clauses inside outer join models because that'd change result
<span class="fc" id="L2036">                    int joinType = parent.getJoinType();</span>
<span class="fc bfc" id="L2037" title="All 2 branches covered.">                    if (tableIndex &gt; 0</span>
<span class="fc bfc" id="L2038" title="All 2 branches covered.">                            &amp;&amp; (joinBarriers.contains(joinType))</span>
                    ) {
<span class="fc" id="L2040">                        QueryModel joinModel = model.getJoinModels().getQuick(tableIndex);</span>
<span class="fc" id="L2041">                        joinModel.setPostJoinWhereClause(concatFilters(joinModel.getPostJoinWhereClause(), node));</span>
<span class="fc" id="L2042">                        continue;</span>
                    }

<span class="fc" id="L2045">                    final QueryModel nested = parent.getNestedModel();</span>
<span class="fc bfc" id="L2046" title="All 2 branches covered.">                    if (nested == null</span>
<span class="fc bfc" id="L2047" title="All 2 branches covered.">                            || nested.getLatestBy().size() &gt; 0</span>
<span class="fc bfc" id="L2048" title="All 2 branches covered.">                            || nested.getLimitLo() != null</span>
<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">                            || nested.getLimitHi() != null</span>
<span class="fc bfc" id="L2050" title="All 2 branches covered.">                            || nested.getUnionModel() != null</span>
<span class="fc bfc" id="L2051" title="All 4 branches covered.">                            || (nested.getSampleBy() != null &amp;&amp; !canPushToSampleBy(nested, literalCollectorANames))</span>
                    ) {
                        // there is no nested model for this table, keep where clause element with this model
<span class="fc" id="L2054">                        addWhereNode(parent, node);</span>
                    } else {
                        // now that we have identified sub-query we have to rewrite our where clause
                        // to potentially replace all column references with actual literals used inside
                        // sub-query, for example:
                        // (select a x, b from T) where x = 10
                        // we can't move &quot;x&quot; inside sub-query because it is not a field.
                        // Instead, we have to translate &quot;x&quot; to actual column expression, which is &quot;a&quot;:
                        // select a x, b from T where a = 10

                        // because we are rewriting SqlNode in-place we need to make sure that
                        // none of expression literals reference non-literals in nested query, e.g.
                        // (select a+b x from T) where x &gt; 10
                        // does not warrant inlining of &quot;x &gt; 10&quot; because &quot;x&quot; is not a column
                        //
                        // at this step we would throw exception if one of our literals hits non-literal
                        // in sub-query

                        try {
<span class="fc" id="L2073">                            traversalAlgo.traverse(node, literalCheckingVisitor.of(parent.getAliasToColumnMap()));</span>

                            // go ahead and rewrite expression
<span class="fc" id="L2076">                            traversalAlgo.traverse(node, literalRewritingVisitor.of(parent.getAliasToColumnNameMap()));</span>

                            // whenever nested model has explicitly defined columns it must also
                            // have its own nested model, where we assign new &quot;where&quot; clauses
<span class="fc" id="L2080">                            addWhereNode(nested, node);</span>
                            // we do not have to deal with &quot;union&quot; models here
                            // because &quot;where&quot; clause is made to apply to the result of the union
<span class="fc" id="L2083">                        } catch (NonLiteralException ignore) {</span>
                            // keep node where it is
<span class="fc" id="L2085">                            addWhereNode(parent, node);</span>
<span class="fc" id="L2086">                        }</span>
                    }
                }
<span class="fc" id="L2089">                model.getParsedWhere().clear();</span>
            }
        }

<span class="fc" id="L2093">        QueryModel nested = model.getNestedModel();</span>
<span class="fc bfc" id="L2094" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L2095">            moveWhereInsideSubQueries(nested);</span>
        }

<span class="fc" id="L2098">        ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc bfc" id="L2099" title="All 2 branches covered.">        for (int i = 1, m = joinModels.size(); i &lt; m; i++) {</span>
<span class="fc" id="L2100">            nested = joinModels.getQuick(i);</span>
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">            if (nested != model) {</span>
<span class="fc" id="L2102">                moveWhereInsideSubQueries(nested);</span>
            }
        }

<span class="fc" id="L2106">        nested = model.getUnionModel();</span>
<span class="fc bfc" id="L2107" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L2108">            moveWhereInsideSubQueries(nested);</span>
        }
<span class="fc" id="L2110">    }</span>

    private QueryColumn nextColumn(CharSequence name) {
<span class="fc" id="L2113">        return SqlUtil.nextColumn(queryColumnPool, expressionNodePool, name, name);</span>
    }

    private QueryColumn nextColumn(CharSequence alias, CharSequence column) {
<span class="fc" id="L2117">        return SqlUtil.nextColumn(queryColumnPool, expressionNodePool, alias, column);</span>
    }

    private ExpressionNode nextLiteral(CharSequence token, int position) {
<span class="fc" id="L2121">        return SqlUtil.nextLiteral(expressionNodePool, token, position);</span>
    }

    private ExpressionNode nextLiteral(CharSequence token) {
<span class="fc" id="L2125">        return nextLiteral(token, 0);</span>
    }

    private void openReaderAndEnumerateColumns(SqlExecutionContext executionContext, QueryModel model) throws SqlException {
<span class="fc" id="L2129">        final ExpressionNode tableNameExpr = model.getTableNameExpr();</span>

        // table name must not contain quotes by now
<span class="fc" id="L2132">        final CharSequence tableName = tableNameExpr.token;</span>
<span class="fc" id="L2133">        final int tableNamePosition = tableNameExpr.position;</span>

<span class="fc" id="L2135">        int lo = 0;</span>
<span class="fc" id="L2136">        int hi = tableName.length();</span>
<span class="fc bfc" id="L2137" title="All 2 branches covered.">        if (Chars.startsWith(tableName, QueryModel.NO_ROWID_MARKER)) {</span>
<span class="fc" id="L2138">            lo += QueryModel.NO_ROWID_MARKER.length();</span>
        }

<span class="fc bfc" id="L2141" title="All 2 branches covered.">        if (lo == hi) {</span>
<span class="fc" id="L2142">            throw SqlException.$(tableNamePosition, &quot;come on, where is table name?&quot;);</span>
        }

<span class="fc" id="L2145">        final TableToken tableToken = executionContext.getTableTokenIfExists(tableName, lo, hi);</span>
<span class="fc" id="L2146">        int status = executionContext.getStatus(path, tableToken);</span>

<span class="fc bfc" id="L2148" title="All 2 branches covered.">        if (status == TableUtils.TABLE_DOES_NOT_EXIST) {</span>
            try {
<span class="fc" id="L2150">                model.getTableNameExpr().type = ExpressionNode.FUNCTION;</span>
<span class="fc" id="L2151">                parseFunctionAndEnumerateColumns(model, executionContext);</span>
<span class="fc" id="L2152">                return;</span>
<span class="fc" id="L2153">            } catch (SqlException e) {</span>
<span class="fc" id="L2154">                throw SqlException.$(tableNamePosition, &quot;table does not exist [table=&quot;).put(tableName).put(']');</span>
            }
        }

<span class="pc bpc" id="L2158" title="1 of 2 branches missed.">        if (status == TableUtils.TABLE_RESERVED) {</span>
<span class="nc" id="L2159">            throw SqlException.$(tableNamePosition, &quot;table directory is of unknown format&quot;);</span>
        }

<span class="fc bfc" id="L2162" title="All 4 branches covered.">        if (model.isUpdate() &amp;&amp; !executionContext.isWalApplication()) {</span>
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">            assert lo == 0;</span>
<span class="fc" id="L2164">            try (TableRecordMetadata metadata = executionContext.getMetadata(tableToken)) {</span>
<span class="fc" id="L2165">                enumerateColumns(model, metadata);</span>
<span class="nc" id="L2166">            } catch (CairoException e) {</span>
<span class="nc" id="L2167">                throw SqlException.position(tableNamePosition).put(e);</span>
<span class="fc" id="L2168">            }</span>
        } else {
<span class="fc" id="L2170">            try (TableReader reader = executionContext.getReader(tableToken)) {</span>
<span class="fc" id="L2171">                enumerateColumns(model, reader.getMetadata());</span>
<span class="fc" id="L2172">            } catch (EntryLockedException e) {</span>
<span class="fc" id="L2173">                throw SqlException.position(tableNamePosition).put(&quot;table is locked: &quot;).put(tableToken.getTableName());</span>
<span class="fc" id="L2174">            } catch (CairoException e) {</span>
<span class="fc" id="L2175">                throw SqlException.position(tableNamePosition).put(e);</span>
<span class="fc" id="L2176">            }</span>
        }
<span class="fc" id="L2178">    }</span>

    private ExpressionNode optimiseBooleanNot(final ExpressionNode node, boolean reverse) {
<span class="fc bfc" id="L2181" title="All 2 branches covered.">        if (node.token != null) {</span>
<span class="fc bfc" id="L2182" title="All 10 branches covered.">            switch (notOps.get(node.token)) {</span>
                case NOT_OP_NOT:
<span class="fc bfc" id="L2184" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2185">                        return optimiseBooleanNot(node.rhs, false);</span>
                    } else {
<span class="fc bfc" id="L2187" title="All 2 branches covered.">                        switch (node.rhs.type) {</span>
                            case LITERAL:
                            case ExpressionNode.CONSTANT:
<span class="fc" id="L2190">                                break;</span>
                            default:
<span class="fc" id="L2192">                                return optimiseBooleanNot(node.rhs, true);</span>
                        }
                    }
                    break;
                case NOT_OP_AND:
<span class="fc bfc" id="L2197" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2198">                        node.token = &quot;or&quot;;</span>
                    }
<span class="fc" id="L2200">                    node.lhs = optimiseBooleanNot(node.lhs, reverse);</span>
<span class="fc" id="L2201">                    node.rhs = optimiseBooleanNot(node.rhs, reverse);</span>
<span class="fc" id="L2202">                    break;</span>
                case NOT_OP_OR:
<span class="fc bfc" id="L2204" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2205">                        node.token = &quot;and&quot;;</span>
                    }
<span class="fc" id="L2207">                    node.lhs = optimiseBooleanNot(node.lhs, reverse);</span>
<span class="fc" id="L2208">                    node.rhs = optimiseBooleanNot(node.rhs, reverse);</span>
<span class="fc" id="L2209">                    break;</span>
                case NOT_OP_GREATER:
<span class="fc bfc" id="L2211" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2212">                        node.token = &quot;&lt;=&quot;;</span>
                    }
                    break;
                case NOT_OP_GREATER_EQ:
<span class="fc bfc" id="L2216" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2217">                        node.token = &quot;&lt;&quot;;</span>
                    }
                    break;
                case NOT_OP_LESS:
<span class="fc bfc" id="L2221" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2222">                        node.token = &quot;&gt;=&quot;;</span>
                    }
                    break;
                case NOT_OP_LESS_EQ:
<span class="fc bfc" id="L2226" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2227">                        node.token = &quot;&gt;&quot;;</span>
                    }
                    break;
                case NOT_OP_EQUAL:
<span class="fc bfc" id="L2231" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2232">                        node.token = &quot;!=&quot;;</span>
                    }
                    break;
                case NOT_OP_NOT_EQ:
<span class="fc bfc" id="L2236" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2237">                        node.token = &quot;=&quot;;</span>
                    } else {
<span class="fc" id="L2239">                        node.token = &quot;!=&quot;;</span>
                    }
<span class="fc" id="L2241">                    break;</span>
                default:
<span class="fc bfc" id="L2243" title="All 2 branches covered.">                    if (reverse) {</span>
<span class="fc" id="L2244">                        ExpressionNode n = expressionNodePool.next();</span>
<span class="fc" id="L2245">                        n.token = &quot;not&quot;;</span>
<span class="fc" id="L2246">                        n.paramCount = 1;</span>
<span class="fc" id="L2247">                        n.rhs = node;</span>
<span class="fc" id="L2248">                        n.type = ExpressionNode.OPERATION;</span>
<span class="fc" id="L2249">                        return n;</span>
                    }
                    break;
            }
        }
<span class="fc" id="L2254">        return node;</span>
    }

    private void optimiseBooleanNot(QueryModel model) {
<span class="fc" id="L2258">        ExpressionNode where = model.getWhereClause();</span>
<span class="fc bfc" id="L2259" title="All 2 branches covered.">        if (where != null) {</span>
<span class="fc" id="L2260">            model.setWhereClause(optimiseBooleanNot(where, false));</span>
        }

<span class="fc bfc" id="L2263" title="All 2 branches covered.">        if (model.getNestedModel() != null) {</span>
<span class="fc" id="L2264">            optimiseBooleanNot(model.getNestedModel());</span>
        }

<span class="fc" id="L2267">        ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc bfc" id="L2268" title="All 2 branches covered.">        for (int i = 1, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2269">            optimiseBooleanNot(joinModels.getQuick(i));</span>
        }

<span class="fc bfc" id="L2272" title="All 2 branches covered.">        if (model.getUnionModel() != null) {</span>
<span class="fc" id="L2273">            optimiseBooleanNot(model.getNestedModel());</span>
        }
<span class="fc" id="L2275">    }</span>

    private void optimiseExpressionModels(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2278">        ObjList&lt;ExpressionNode&gt; expressionModels = model.getExpressionModels();</span>
<span class="fc" id="L2279">        final int n = expressionModels.size();</span>
<span class="fc bfc" id="L2280" title="All 2 branches covered.">        if (n &gt; 0) {</span>
<span class="fc bfc" id="L2281" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2282">                final ExpressionNode node = expressionModels.getQuick(i);</span>
                // for expression models that have been converted to
                // the joins, the query model will be set to null.
<span class="pc bpc" id="L2285" title="1 of 2 branches missed.">                if (node.queryModel != null) {</span>
<span class="fc" id="L2286">                    QueryModel optimised = optimise(node.queryModel, executionContext);</span>
<span class="pc bpc" id="L2287" title="1 of 2 branches missed.">                    if (optimised != node.queryModel) {</span>
<span class="fc" id="L2288">                        node.queryModel = optimised;</span>
                    }
                }
            }
        }

<span class="fc bfc" id="L2294" title="All 2 branches covered.">        if (model.getNestedModel() != null) {</span>
<span class="fc" id="L2295">            optimiseExpressionModels(model.getNestedModel(), executionContext);</span>
        }

<span class="fc" id="L2298">        final ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc" id="L2299">        final int m = joinModels.size();</span>
        // as usual, we already optimised self (index=0), now optimised others
<span class="fc bfc" id="L2301" title="All 2 branches covered.">        if (m &gt; 1) {</span>
<span class="fc bfc" id="L2302" title="All 2 branches covered.">            for (int i = 1; i &lt; m; i++) {</span>
<span class="fc" id="L2303">                optimiseExpressionModels(joinModels.getQuick(i), executionContext);</span>
            }
        }

        // call out to union models
<span class="fc bfc" id="L2308" title="All 2 branches covered.">        if (model.getUnionModel() != null) {</span>
<span class="fc" id="L2309">            optimiseExpressionModels(model.getUnionModel(), executionContext);</span>
        }
<span class="fc" id="L2311">    }</span>

    private void optimiseJoins(QueryModel model) throws SqlException {
<span class="fc" id="L2314">        ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>

<span class="fc" id="L2316">        int n = joinModels.size();</span>
<span class="fc bfc" id="L2317" title="All 2 branches covered.">        if (n &gt; 1) {</span>
<span class="fc" id="L2318">            emittedJoinClauses = joinClausesSwap1;</span>
<span class="fc" id="L2319">            emittedJoinClauses.clear();</span>

            // for sake of clarity, &quot;model&quot; model is the first in the list of
            // joinModels, e.g. joinModels.get(0) == model
            // only &quot;model&quot; model is allowed to have &quot;where&quot; clause,
            // so we can assume that &quot;where&quot; clauses of joinModel elements are all null (except for element 0).
            // in case one of joinModels is suburb, its entire query model will be set as
            // nestedModel, e.g. &quot;where&quot; clause is still null there as well

<span class="fc" id="L2328">            ExpressionNode where = model.getWhereClause();</span>

            // clear where clause of model so that
            // optimiser can assign there correct nodes

<span class="fc" id="L2333">            model.setWhereClause(null);</span>
<span class="fc" id="L2334">            processJoinConditions(model, where, false, model);</span>

<span class="fc bfc" id="L2336" title="All 2 branches covered.">            for (int i = 1; i &lt; n; i++) {</span>
<span class="fc" id="L2337">                processJoinConditions(model, joinModels.getQuick(i).getJoinCriteria(), true, joinModels.getQuick(i));</span>
            }

<span class="fc" id="L2340">            processEmittedJoinClauses(model);</span>
<span class="fc" id="L2341">            createImpliedDependencies(model);</span>
<span class="fc" id="L2342">            homogenizeCrossJoins(model);</span>
<span class="fc" id="L2343">            reorderTables(model);</span>
<span class="fc" id="L2344">            assignFilters(model);</span>
<span class="fc" id="L2345">            alignJoinClauses(model);</span>
<span class="fc" id="L2346">            addTransitiveFilters(model);</span>
        }

<span class="fc bfc" id="L2349" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2350">            QueryModel m = model.getJoinModels().getQuick(i).getNestedModel();</span>
<span class="fc bfc" id="L2351" title="All 2 branches covered.">            if (m != null) {</span>
<span class="fc" id="L2352">                optimiseJoins(m);</span>
            }

<span class="fc" id="L2355">            m = model.getJoinModels().getQuick(i).getUnionModel();</span>
<span class="fc bfc" id="L2356" title="All 2 branches covered.">            if (m != null) {</span>
<span class="fc" id="L2357">                optimiseJoins(m);</span>
            }
        }
<span class="fc" id="L2360">    }</span>

    // removes redundant order by clauses from sub-queries (only those that don't force materialization of other order by clauses )
    private void optimiseOrderBy(QueryModel model, int topLevelOrderByMnemonic) {
<span class="fc" id="L2364">        ObjList&lt;QueryColumn&gt; columns = model.getBottomUpColumns();</span>
        int orderByMnemonic;
<span class="fc" id="L2366">        int n = columns.size();</span>

        //limit x,y forces order materialization; we can't push order by past it and need to discover actual nested ordering
<span class="fc bfc" id="L2369" title="All 2 branches covered.">        if (model.getLimitLo() != null) {</span>
<span class="fc" id="L2370">            topLevelOrderByMnemonic = OrderByMnemonic.ORDER_BY_UNKNOWN;</span>
        }

        // determine if ordering is required
<span class="fc bfc" id="L2374" title="All 3 branches covered.">        switch (topLevelOrderByMnemonic) {</span>
            case OrderByMnemonic.ORDER_BY_UNKNOWN:
                // we have sample by, so expect sub-query has to be ordered
<span class="fc bfc" id="L2377" title="All 4 branches covered.">                if (model.getOrderBy().size() &gt; 0 &amp;&amp; model.getSampleBy() == null) {</span>
<span class="fc" id="L2378">                    orderByMnemonic = OrderByMnemonic.ORDER_BY_INVARIANT;</span>
                } else {
<span class="fc" id="L2380">                    orderByMnemonic = OrderByMnemonic.ORDER_BY_REQUIRED;</span>
                }
<span class="fc bfc" id="L2382" title="All 2 branches covered.">                if (model.getSampleBy() == null) {</span>
<span class="fc bfc" id="L2383" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2384">                        QueryColumn col = columns.getQuick(i);</span>
<span class="fc bfc" id="L2385" title="All 2 branches covered.">                        if (hasAggregates(col.getAst())) {</span>
<span class="fc" id="L2386">                            orderByMnemonic = OrderByMnemonic.ORDER_BY_INVARIANT;</span>
<span class="fc" id="L2387">                            break;</span>
                        }
                    }
                }
                break;
            case OrderByMnemonic.ORDER_BY_REQUIRED:
                // parent requires order
                // if this model forces ordering - sub-query ordering is not needed
<span class="fc bfc" id="L2395" title="All 2 branches covered.">                if (model.getOrderBy().size() &gt; 0) {</span>
<span class="fc" id="L2396">                    orderByMnemonic = OrderByMnemonic.ORDER_BY_INVARIANT;</span>
                } else {
<span class="fc" id="L2398">                    orderByMnemonic = OrderByMnemonic.ORDER_BY_REQUIRED;</span>
                }
<span class="fc" id="L2400">                break;</span>
            default:
                // sub-query ordering is not needed
<span class="fc" id="L2403">                model.getOrderBy().clear();</span>
<span class="fc bfc" id="L2404" title="All 2 branches covered.">                if (model.getSampleBy() != null) {</span>
<span class="fc" id="L2405">                    orderByMnemonic = OrderByMnemonic.ORDER_BY_REQUIRED;</span>
                } else {
<span class="fc" id="L2407">                    orderByMnemonic = OrderByMnemonic.ORDER_BY_INVARIANT;</span>
                }
                break;
        }

<span class="fc" id="L2412">        final ObjList&lt;ExpressionNode&gt; orderByAdvice = getOrderByAdvice(model);</span>
<span class="fc" id="L2413">        final IntList orderByDirectionAdvice = model.getOrderByDirection();</span>
<span class="fc" id="L2414">        final ObjList&lt;QueryModel&gt; jm = model.getJoinModels();</span>
<span class="fc bfc" id="L2415" title="All 2 branches covered.">        for (int i = 0, k = jm.size(); i &lt; k; i++) {</span>
<span class="fc" id="L2416">            QueryModel qm = jm.getQuick(i).getNestedModel();</span>
<span class="fc bfc" id="L2417" title="All 2 branches covered.">            if (qm != null) {</span>
<span class="fc" id="L2418">                qm.setOrderByAdviceMnemonic(orderByMnemonic);</span>
<span class="fc" id="L2419">                qm.copyOrderByAdvice(orderByAdvice);</span>
<span class="fc" id="L2420">                qm.copyOrderByDirectionAdvice(orderByDirectionAdvice);</span>
<span class="fc" id="L2421">                optimiseOrderBy(qm, orderByMnemonic);</span>
            }
        }

<span class="fc" id="L2425">        final QueryModel union = model.getUnionModel();</span>
<span class="fc bfc" id="L2426" title="All 2 branches covered.">        if (union != null) {</span>
<span class="fc" id="L2427">            union.copyOrderByAdvice(orderByAdvice);</span>
<span class="fc" id="L2428">            union.copyOrderByDirectionAdvice(orderByDirectionAdvice);</span>
<span class="fc" id="L2429">            union.setOrderByAdviceMnemonic(orderByMnemonic);</span>
<span class="fc" id="L2430">            optimiseOrderBy(union, orderByMnemonic);</span>
        }
<span class="fc" id="L2432">    }</span>

    private void parseFunctionAndEnumerateColumns(@NotNull QueryModel model, @NotNull SqlExecutionContext executionContext) throws SqlException {
<span class="pc bpc" id="L2435" title="1 of 2 branches missed.">        assert model.getTableNameFunction() == null;</span>
<span class="fc" id="L2436">        final Function function = TableUtils.createCursorFunction(functionParser, model, executionContext);</span>
<span class="fc" id="L2437">        model.setTableNameFunction(function);</span>
<span class="fc" id="L2438">        functionsInFlight.add(function);</span>
<span class="fc" id="L2439">        copyColumnsFromMetadata(model, function.getRecordCursorFactory().getMetadata(), true);</span>
<span class="fc" id="L2440">    }</span>

    private void processEmittedJoinClauses(QueryModel model) {
        // pick up join clauses emitted at initial analysis stage
        // as we merge contexts at this level no more clauses is to be emitted
<span class="fc bfc" id="L2445" title="All 2 branches covered.">        for (int i = 0, k = emittedJoinClauses.size(); i &lt; k; i++) {</span>
<span class="fc" id="L2446">            addJoinContext(model, emittedJoinClauses.getQuick(i));</span>
        }
<span class="fc" id="L2448">    }</span>

    /**
     * Splits &quot;where&quot; clauses into &quot;and&quot; concatenated list of boolean expressions.
     *
     * @param node expression n
     */
    private void processJoinConditions(QueryModel parent, ExpressionNode node, boolean innerPredicate, QueryModel joinModel) throws SqlException {
<span class="fc" id="L2456">        ExpressionNode n = node;</span>
        // pre-order traversal
<span class="fc" id="L2458">        sqlNodeStack.clear();</span>
<span class="fc bfc" id="L2459" title="All 4 branches covered.">        while (!sqlNodeStack.isEmpty() || n != null) {</span>
<span class="fc bfc" id="L2460" title="All 2 branches covered.">            if (n != null) {</span>
<span class="fc bfc" id="L2461" title="All 4 branches covered.">                switch (joinOps.get(n.token)) {</span>
                    case JOIN_OP_EQUAL:
<span class="fc" id="L2463">                        analyseEquals(parent, n, innerPredicate, joinModel);</span>
<span class="fc" id="L2464">                        n = null;</span>
<span class="fc" id="L2465">                        break;</span>
                    case JOIN_OP_AND:
<span class="pc bpc" id="L2467" title="1 of 2 branches missed.">                        if (n.rhs != null) {</span>
<span class="fc" id="L2468">                            sqlNodeStack.push(n.rhs);</span>
                        }
<span class="fc" id="L2470">                        n = n.lhs;</span>
<span class="fc" id="L2471">                        break;</span>
                    case JOIN_OP_REGEX:
<span class="fc" id="L2473">                        analyseRegex(parent, n);</span>
<span class="fc bfc" id="L2474" title="All 2 branches covered.">                        if (joinBarriers.contains(joinModel.getJoinType())) {</span>
<span class="fc" id="L2475">                            addOuterJoinExpression(joinModel, n);</span>
                        } else {
<span class="fc" id="L2477">                            parent.addParsedWhereNode(n, innerPredicate);</span>
                        }
<span class="fc" id="L2479">                        n = null;</span>
<span class="fc" id="L2480">                        break;</span>
                    default:
<span class="fc bfc" id="L2482" title="All 2 branches covered.">                        if (joinBarriers.contains(joinModel.getJoinType())) {</span>
<span class="fc" id="L2483">                            addOuterJoinExpression(joinModel, n);</span>
                        } else {
<span class="fc" id="L2485">                            parent.addParsedWhereNode(n, innerPredicate);</span>
                        }
<span class="fc" id="L2487">                        n = null;</span>
<span class="fc" id="L2488">                        break;</span>
                }
            } else {
<span class="fc" id="L2491">                n = sqlNodeStack.poll();</span>
            }
        }
<span class="fc" id="L2494">    }</span>

    private void propagateTopDownColumns(QueryModel model, boolean allowColumnChange) {
<span class="fc" id="L2497">        propagateTopDownColumns0(model, true, null, allowColumnChange);</span>
<span class="fc" id="L2498">    }</span>

    /*
        Pushes columns from top to bottom models .

        Adding or removing columns to/from union, except, intersect should not happen!
        UNION/INTERSECT/EXCEPT-ed columns MUST be exactly as specified in the query, otherwise they might produce different result, e.g.

        select a from (
            select 1 as a, 'b' as status
            union
            select 1 as a, 'c' as status
        )

        Now if we push a top-to-bottom and remove b from union column list then we'll get a single '1' but we should get two !
        Same thing applies to INTERSECT &amp; EXCEPT
        The only thing that'd be safe to add SET models is a constant literal (but what's the point?) .
        Column/expression pushdown should (probably) ONLY happen for UNION with ALL!

        allowColumnsChange - determines whether changing columns of given model is acceptable.
        It is not for columns used in distinct, except, intersect, union (even transitively for the latter three!).
    */
    private void propagateTopDownColumns0(QueryModel model, boolean topLevel, @Nullable QueryModel papaModel, boolean allowColumnsChange) {
        //copy columns to 'protect' column list that shouldn't be modified
<span class="pc bpc" id="L2522" title="1 of 4 branches missed.">        if (!allowColumnsChange &amp;&amp; model.getBottomUpColumns().size() &gt; 0) {</span>
<span class="fc" id="L2523">            model.copyBottomToTopColumns();</span>
        }

        // skip over NONE model that does not have table name
<span class="fc" id="L2527">        final QueryModel nested = skipNoneTypeModels(model.getNestedModel());</span>
<span class="fc" id="L2528">        model.setNestedModel(nested);</span>
<span class="fc" id="L2529">        final boolean nestedIsFlex = modelIsFlex(nested);</span>
<span class="fc bfc" id="L2530" title="All 4 branches covered.">        final boolean nestedAllowsColumnChange = nested != null &amp;&amp; nested.allowsColumnsChange();</span>

<span class="fc" id="L2532">        final QueryModel union = skipNoneTypeModels(model.getUnionModel());</span>

<span class="fc bfc" id="L2534" title="All 4 branches covered.">        if (!topLevel &amp;&amp; modelIsFlex(union)) {</span>
<span class="fc" id="L2535">            emitColumnLiteralsTopDown(model.getColumns(), union);</span>
        }

        // process join models and their join conditions
<span class="fc" id="L2539">        final ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc bfc" id="L2540" title="All 2 branches covered.">        for (int i = 1, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2541">            final QueryModel jm = joinModels.getQuick(i);</span>
<span class="fc" id="L2542">            final JoinContext jc = jm.getContext();</span>
<span class="fc bfc" id="L2543" title="All 4 branches covered.">            if (jc != null &amp;&amp; jc.aIndexes.size() &gt; 0) {</span>
                // join clause
<span class="fc bfc" id="L2545" title="All 2 branches covered.">                for (int k = 0, z = jc.aIndexes.size(); k &lt; z; k++) {</span>
<span class="fc" id="L2546">                    emitLiteralsTopDown(jc.aNodes.getQuick(k), model);</span>
<span class="fc" id="L2547">                    emitLiteralsTopDown(jc.bNodes.getQuick(k), model);</span>

<span class="pc bpc" id="L2549" title="1 of 2 branches missed.">                    if (papaModel != null) {</span>
<span class="nc" id="L2550">                        emitLiteralsTopDown(jc.aNodes.getQuick(k), papaModel);</span>
<span class="nc" id="L2551">                        emitLiteralsTopDown(jc.bNodes.getQuick(k), papaModel);</span>
                    }
                }
            }

            // process post-join-where
<span class="fc" id="L2557">            final ExpressionNode postJoinWhere = jm.getPostJoinWhereClause();</span>
<span class="fc bfc" id="L2558" title="All 2 branches covered.">            if (postJoinWhere != null) {</span>
<span class="fc" id="L2559">                emitLiteralsTopDown(postJoinWhere, jm);</span>
<span class="fc" id="L2560">                emitLiteralsTopDown(postJoinWhere, model);</span>
            }

<span class="fc" id="L2563">            final ExpressionNode leftJoinWhere = jm.getOuterJoinExpressionClause();</span>
<span class="fc bfc" id="L2564" title="All 2 branches covered.">            if (leftJoinWhere != null) {</span>
<span class="fc" id="L2565">                emitLiteralsTopDown(leftJoinWhere, jm);</span>
<span class="fc" id="L2566">                emitLiteralsTopDown(leftJoinWhere, model);</span>
            }

<span class="fc" id="L2569">            propagateTopDownColumns0(jm, false, model, true);</span>
        }

        // If this is group by model we need to add all non-selected keys, only if this is sub-query
        // For top level models top-down column list will be empty
<span class="fc bfc" id="L2574" title="All 4 branches covered.">        if (model.getSelectModelType() == QueryModel.SELECT_MODEL_GROUP_BY &amp;&amp; model.getTopDownColumns().size() &gt; 0) {</span>
<span class="fc" id="L2575">            final ObjList&lt;QueryColumn&gt; bottomUpColumns = model.getBottomUpColumns();</span>
<span class="fc bfc" id="L2576" title="All 2 branches covered.">            for (int i = 0, n = bottomUpColumns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2577">                QueryColumn qc = bottomUpColumns.getQuick(i);</span>
<span class="pc bpc" id="L2578" title="1 of 4 branches missed.">                if (qc.getAst().type != FUNCTION || !functionParser.getFunctionFactoryCache().isGroupBy(qc.getAst().token)) {</span>
<span class="fc" id="L2579">                    model.addTopDownColumn(qc, qc.getAlias());</span>
                }
            }
        }

        // latest by
<span class="fc bfc" id="L2585" title="All 2 branches covered.">        if (model.getLatestBy().size() &gt; 0) {</span>
<span class="fc" id="L2586">            emitLiteralsTopDown(model.getLatestBy(), model);</span>
        }

        // propagate explicit timestamp declaration
<span class="fc" id="L2590">        if (</span>
<span class="fc bfc" id="L2591" title="All 6 branches covered.">                model.getTimestamp() != null &amp;&amp;</span>
                        nestedIsFlex &amp;&amp;
                        nestedAllowsColumnChange
        ) {
<span class="fc" id="L2595">            emitLiteralsTopDown(model.getTimestamp(), nested);</span>

<span class="fc" id="L2597">            QueryModel unionModel = nested.getUnionModel();</span>
<span class="fc bfc" id="L2598" title="All 2 branches covered.">            while (unionModel != null) {</span>
<span class="fc" id="L2599">                emitLiteralsTopDown(model.getTimestamp(), unionModel);</span>
<span class="fc" id="L2600">                unionModel = unionModel.getUnionModel();</span>
            }
        }

<span class="fc bfc" id="L2604" title="All 2 branches covered.">        if (model.getWhereClause() != null) {</span>
<span class="fc bfc" id="L2605" title="All 2 branches covered.">            if (allowColumnsChange) {</span>
<span class="fc" id="L2606">                emitLiteralsTopDown(model.getWhereClause(), model);</span>
            }
<span class="fc bfc" id="L2608" title="All 4 branches covered.">            if (nested != null &amp;&amp; nestedAllowsColumnChange) {</span>
<span class="fc" id="L2609">                emitLiteralsTopDown(model.getWhereClause(), nested);</span>

<span class="fc" id="L2611">                QueryModel unionModel = nested.getUnionModel();</span>
<span class="fc bfc" id="L2612" title="All 2 branches covered.">                while (unionModel != null) {</span>
<span class="fc" id="L2613">                    emitLiteralsTopDown(model.getWhereClause(), unionModel);</span>
<span class="fc" id="L2614">                    unionModel = unionModel.getUnionModel();</span>
                }
            }
        }

        // propagate 'order by'
<span class="fc bfc" id="L2620" title="All 2 branches covered.">        if (!topLevel) {</span>
<span class="fc" id="L2621">            emitLiteralsTopDown(model.getOrderBy(), model);</span>
        }

<span class="fc bfc" id="L2624" title="All 4 branches covered.">        if (nestedIsFlex &amp;&amp; nestedAllowsColumnChange) {</span>
<span class="fc" id="L2625">            emitColumnLiteralsTopDown(model.getColumns(), nested);</span>

<span class="fc" id="L2627">            final IntList unionColumnIndexes = tempList;</span>
<span class="fc" id="L2628">            unionColumnIndexes.clear();</span>
<span class="fc" id="L2629">            ObjList&lt;QueryColumn&gt; nestedTopDownColumns = nested.getTopDownColumns();</span>
<span class="fc bfc" id="L2630" title="All 2 branches covered.">            for (int i = 0, n = nestedTopDownColumns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2631">                unionColumnIndexes.add(nested.getColumnAliasIndex(nestedTopDownColumns.getQuick(i).getAlias()));</span>
            }

<span class="fc" id="L2634">            QueryModel unionModel = nested.getUnionModel();</span>
<span class="fc bfc" id="L2635" title="All 2 branches covered.">            while (unionModel != null) {</span>
                // promote bottom-up columns to top-down columns, which
                // indexes correspond to the chosen columns in the &quot;nested&quot; model
<span class="fc" id="L2638">                ObjList&lt;QueryColumn&gt; cols = unionModel.getBottomUpColumns();</span>
<span class="fc bfc" id="L2639" title="All 2 branches covered.">                for (int i = 0, n = unionColumnIndexes.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2640">                    QueryColumn qc = cols.getQuick(unionColumnIndexes.getQuick(i));</span>
<span class="fc" id="L2641">                    unionModel.addTopDownColumn(qc, qc.getAlias());</span>
                }
<span class="fc" id="L2643">                unionModel = unionModel.getUnionModel();</span>
<span class="fc" id="L2644">            }</span>
        }

        // go down the nested path
<span class="fc bfc" id="L2648" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L2649">            propagateTopDownColumns0(nested, false, null, nestedAllowsColumnChange);</span>
        }

<span class="fc" id="L2652">        final QueryModel unionModel = model.getUnionModel();</span>
<span class="fc bfc" id="L2653" title="All 2 branches covered.">        if (unionModel != null) {</span>
            //we've to use this value because union-ed models don't have a back-reference and might not know they participate in set operation
<span class="fc" id="L2655">            propagateTopDownColumns(unionModel, allowColumnsChange);</span>
        }
<span class="fc" id="L2657">    }</span>

    private ExpressionNode pushOperationOutsideAgg(ExpressionNode agg, ExpressionNode op, ExpressionNode column, ExpressionNode constant, QueryModel model) {
<span class="fc bfc" id="L2660" title="All 2 branches covered.">        if (!isSimpleIntegerColumn(column, model)) {</span>
<span class="fc" id="L2661">            return agg;</span>
        }

<span class="fc" id="L2664">        agg.rhs = column;</span>

<span class="fc" id="L2666">        ExpressionNode count = expressionNodePool.next();</span>
<span class="fc" id="L2667">        count.paramCount = 1;</span>
<span class="fc" id="L2668">        count.token = &quot;COUNT&quot;;</span>
<span class="fc" id="L2669">        count.type = FUNCTION;</span>
<span class="fc" id="L2670">        count.rhs = column;</span>
<span class="fc" id="L2671">        count.position = agg.position;</span>

<span class="fc" id="L2673">        ExpressionNode mul = expressionNodePool.next();</span>
<span class="fc" id="L2674">        mul.token = &quot;*&quot;;</span>
<span class="fc" id="L2675">        mul.type = OPERATION;</span>
<span class="fc" id="L2676">        mul.position = agg.position;</span>
<span class="fc" id="L2677">        mul.paramCount = 2;</span>
<span class="fc" id="L2678">        mul.precedence = 3;</span>
<span class="fc" id="L2679">        mul.lhs = count;</span>
<span class="fc" id="L2680">        mul.rhs = constant;</span>

<span class="fc bfc" id="L2682" title="All 2 branches covered.">        if (op.lhs == column) {//maintain order for subtraction</span>
<span class="fc" id="L2683">            op.lhs = agg;</span>
<span class="fc" id="L2684">            op.rhs = mul;</span>
        } else {
<span class="fc" id="L2686">            op.lhs = mul;</span>
<span class="fc" id="L2687">            op.rhs = agg;</span>
        }

<span class="fc" id="L2690">        return op;</span>
    }

    /**
     * Identify joined tables without join clause and try to find other reversible join clauses
     * that may be applied to it. For example when these tables joined&quot;
     * &lt;p&gt;
     * from a
     * join b on c.x = b.x
     * join c on c.y = a.y
     * &lt;p&gt;
     * the system that prefers child table with the lowest index will attribute c.x = b.x clause to
     * table &quot;c&quot; leaving &quot;b&quot; without clauses.
     */
    @SuppressWarnings({&quot;StatementWithEmptyBody&quot;})
    private void reorderTables(QueryModel model) {
<span class="fc" id="L2706">        ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc" id="L2707">        int n = joinModels.size();</span>

<span class="fc" id="L2709">        tempCrosses.clear();</span>
        // collect crosses
<span class="fc bfc" id="L2711" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2712">            QueryModel q = joinModels.getQuick(i);</span>
<span class="fc bfc" id="L2713" title="All 4 branches covered.">            if (q.getContext() == null || q.getContext().parents.size() == 0) {</span>
<span class="fc" id="L2714">                tempCrosses.add(i);</span>
            }
        }

<span class="fc" id="L2718">        int cost = Integer.MAX_VALUE;</span>
<span class="fc" id="L2719">        int root = -1;</span>

        // analyse state of tree for each set of n-1 crosses
<span class="fc bfc" id="L2722" title="All 2 branches covered.">        for (int z = 0, zc = tempCrosses.size(); z &lt; zc; z++) {</span>
<span class="fc bfc" id="L2723" title="All 2 branches covered.">            for (int i = 0; i &lt; zc; i++) {</span>
<span class="fc bfc" id="L2724" title="All 2 branches covered.">                if (z != i) {</span>
<span class="fc" id="L2725">                    int to = tempCrosses.getQuick(i);</span>
<span class="fc" id="L2726">                    final JoinContext jc = joinModels.getQuick(to).getContext();</span>
                    // look above i up to OUTER join
<span class="fc bfc" id="L2728" title="All 4 branches covered.">                    for (int k = i - 1; k &gt; -1 &amp;&amp; swapJoinOrder(model, to, k, jc); k--) ;</span>
                    // look below i for up to OUTER join
<span class="fc bfc" id="L2730" title="All 4 branches covered.">                    for (int k = i + 1; k &lt; n &amp;&amp; swapJoinOrder(model, to, k, jc); k++) ;</span>
                }
            }

<span class="fc" id="L2734">            IntList ordered = model.nextOrderedJoinModels();</span>
<span class="fc" id="L2735">            int thisCost = doReorderTables(model, ordered);</span>

            // we have to have root, even if it is expensive
            // so the first iteration sets the root regardless
            // the following iterations might improve it
<span class="pc bpc" id="L2740" title="1 of 4 branches missed.">            if (thisCost &lt; cost || root == -1) {</span>
<span class="fc" id="L2741">                root = z;</span>
<span class="fc" id="L2742">                cost = thisCost;</span>
<span class="fc" id="L2743">                model.setOrderedJoinModels(ordered);</span>
            }
        }

<span class="pc bpc" id="L2747" title="1 of 2 branches missed.">        assert root != -1;</span>
<span class="fc" id="L2748">    }</span>

    private ExpressionNode replaceIfAggregate(@Transient ExpressionNode node, QueryModel model) throws SqlException {
<span class="fc bfc" id="L2751" title="All 4 branches covered.">        if (node != null &amp;&amp; functionParser.getFunctionFactoryCache().isGroupBy(node.token)) {</span>
<span class="fc" id="L2752">            QueryColumn c = model.findBottomUpColumnByAst(node);</span>
<span class="fc bfc" id="L2753" title="All 2 branches covered.">            if (c == null) {</span>
<span class="fc" id="L2754">                c = queryColumnPool.next().of(createColumnAlias(node, model), node);</span>
<span class="fc" id="L2755">                model.addBottomUpColumn(c);</span>
            }
<span class="fc" id="L2757">            return nextLiteral(c.getAlias());</span>
        }
<span class="fc" id="L2759">        return node;</span>
    }

    private ExpressionNode replaceIfCursor(
            @Transient ExpressionNode node,
            QueryModel cursorModel,
            @Nullable QueryModel innerVirtualModel,
            QueryModel translatingModel,
            QueryModel baseModel,
            SqlExecutionContext sqlExecutionContext
    ) throws SqlException {
<span class="fc bfc" id="L2770" title="All 4 branches covered.">        if (node != null &amp;&amp; functionParser.getFunctionFactoryCache().isCursor(node.token)) {</span>
<span class="fc" id="L2771">            return nextLiteral(</span>
<span class="fc" id="L2772">                    addCursorFunctionAsCrossJoin(</span>
                            node,
                            null,
                            cursorModel,
                            innerVirtualModel,
                            translatingModel,
                            baseModel,
                            sqlExecutionContext
<span class="fc" id="L2780">                    ).getAlias()</span>
            );
        }
<span class="fc" id="L2783">        return node;</span>
    }

    private ExpressionNode replaceLiteral(
            @Transient ExpressionNode node,
            QueryModel translatingModel,
            @Nullable QueryModel innerModel,
            QueryModel validatingModel,
            boolean analyticCall
    ) throws SqlException {
<span class="fc bfc" id="L2793" title="All 4 branches covered.">        if (node != null &amp;&amp; node.type == LITERAL) {</span>
            try {
<span class="fc" id="L2795">                return doReplaceLiteral(node, translatingModel, innerModel, validatingModel, analyticCall);</span>
<span class="fc" id="L2796">            } catch (SqlException e) {</span>
<span class="fc bfc" id="L2797" title="All 2 branches covered.">                if (functionParser.findNoArgFunction(node)) {</span>
<span class="fc" id="L2798">                    node.type = FUNCTION;</span>
                } else {
<span class="fc" id="L2800">                    throw e;</span>
                }
            }
        }
<span class="fc" id="L2804">        return node;</span>
    }

    private void replaceLiteralList(QueryModel innerVirtualModel, QueryModel translatingModel, QueryModel baseModel, ObjList&lt;ExpressionNode&gt; list) throws SqlException {
<span class="fc bfc" id="L2808" title="All 2 branches covered.">        for (int j = 0, n = list.size(); j &lt; n; j++) {</span>
<span class="fc" id="L2809">            final ExpressionNode node = list.getQuick(j);</span>
<span class="fc" id="L2810">            emitLiterals(node, translatingModel, innerVirtualModel, baseModel, true);</span>
<span class="fc" id="L2811">            list.setQuick(j, replaceLiteral(node, translatingModel, innerVirtualModel, baseModel, true));</span>
        }
<span class="fc" id="L2813">    }</span>

    private void resolveJoinColumns(QueryModel model) throws SqlException {
<span class="fc" id="L2816">        ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc" id="L2817">        final int size = joinModels.size();</span>
<span class="fc" id="L2818">        final CharSequence modelAlias = setAndGetModelAlias(model);</span>
        // collect own alias
<span class="fc" id="L2820">        collectModelAlias(model, 0, model);</span>
<span class="fc bfc" id="L2821" title="All 2 branches covered.">        if (size &gt; 1) {</span>
<span class="fc bfc" id="L2822" title="All 2 branches covered.">            for (int i = 1; i &lt; size; i++) {</span>
<span class="fc" id="L2823">                final QueryModel jm = joinModels.getQuick(i);</span>
<span class="fc" id="L2824">                final ObjList&lt;ExpressionNode&gt; jc = jm.getJoinColumns();</span>
<span class="fc" id="L2825">                final int joinColumnsSize = jc.size();</span>

<span class="fc bfc" id="L2827" title="All 2 branches covered.">                if (joinColumnsSize &gt; 0) {</span>
<span class="fc" id="L2828">                    final CharSequence jmAlias = setAndGetModelAlias(jm);</span>
<span class="fc" id="L2829">                    ExpressionNode joinCriteria = jm.getJoinCriteria();</span>
<span class="fc bfc" id="L2830" title="All 2 branches covered.">                    for (int j = 0; j &lt; joinColumnsSize; j++) {</span>
<span class="fc" id="L2831">                        ExpressionNode node = jc.getQuick(j);</span>
<span class="fc" id="L2832">                        ExpressionNode eq = makeOperation(&quot;=&quot;, makeModelAlias(modelAlias, node), makeModelAlias(jmAlias, node));</span>
<span class="fc bfc" id="L2833" title="All 2 branches covered.">                        if (joinCriteria == null) {</span>
<span class="fc" id="L2834">                            joinCriteria = eq;</span>
                        } else {
<span class="fc" id="L2836">                            joinCriteria = makeOperation(&quot;and&quot;, joinCriteria, eq);</span>
                        }
                    }
<span class="fc" id="L2839">                    jm.setJoinCriteria(joinCriteria);</span>
                }
<span class="fc" id="L2841">                resolveJoinColumns(jm);</span>
<span class="fc" id="L2842">                collectModelAlias(model, i, jm);</span>
            }
        }

<span class="fc bfc" id="L2846" title="All 2 branches covered.">        if (model.getNestedModel() != null) {</span>
<span class="fc" id="L2847">            resolveJoinColumns(model.getNestedModel());</span>
        }

        // and union models too
<span class="fc bfc" id="L2851" title="All 2 branches covered.">        if (model.getUnionModel() != null) {</span>
<span class="fc" id="L2852">            resolveJoinColumns(model.getUnionModel());</span>
        }
<span class="fc" id="L2854">    }</span>

    //Rewrite:
    // sum(x*10) into sum(x) * 10, etc.
    // sum(x+10) into sum(x) + count(x)*10
    // sum(x-10) into sum(x) - count(x)*10
    private ExpressionNode rewriteAggregate(ExpressionNode agg, QueryModel model) {
<span class="pc bpc" id="L2861" title="1 of 2 branches missed.">        if (agg == null) {</span>
<span class="nc" id="L2862">            return null;</span>
        }

<span class="fc" id="L2865">        ExpressionNode op = agg.rhs;</span>

<span class="pc bpc" id="L2867" title="1 of 2 branches missed.">        if (agg.type == FUNCTION &amp;&amp;</span>
<span class="pc bpc" id="L2868" title="1 of 2 branches missed.">                functionParser.getFunctionFactoryCache().isGroupBy(agg.token) &amp;&amp;</span>
<span class="fc bfc" id="L2869" title="All 4 branches covered.">                Chars.equalsIgnoreCase(&quot;sum&quot;, agg.token) &amp;&amp;</span>
                op.type == OPERATION) {
<span class="fc bfc" id="L2871" title="All 2 branches covered.">            if (Chars.equals(op.token, '*')) { //sum(x*10) == sum(x)*10</span>
<span class="fc bfc" id="L2872" title="All 4 branches covered.">                if (isIntegerConstant(op.rhs) &amp;&amp; isSimpleIntegerColumn(op.lhs, model)) {</span>
<span class="fc" id="L2873">                    agg.rhs = op.lhs;</span>
<span class="fc" id="L2874">                    op.lhs = agg;</span>
<span class="fc" id="L2875">                    return op;</span>
<span class="fc bfc" id="L2876" title="All 4 branches covered.">                } else if (isIntegerConstant(op.lhs) &amp;&amp; isSimpleIntegerColumn(op.rhs, model)) {</span>
<span class="fc" id="L2877">                    agg.rhs = op.rhs;</span>
<span class="fc" id="L2878">                    op.rhs = agg;</span>
<span class="fc" id="L2879">                    return op;</span>
                }
<span class="fc bfc" id="L2881" title="All 4 branches covered.">            } else if (Chars.equals(op.token, '+') || Chars.equals(op.token, '-')) {//sum(x+10) == sum(x)+count(x)*10 , sum(x-10) == sum(x)-count(x)*10 </span>
<span class="fc bfc" id="L2882" title="All 2 branches covered.">                if (isIntegerConstant(op.rhs)) {</span>
<span class="fc" id="L2883">                    return pushOperationOutsideAgg(agg, op, op.lhs, op.rhs, model);</span>
<span class="fc bfc" id="L2884" title="All 2 branches covered.">                } else if (isIntegerConstant(op.lhs)) {</span>
<span class="fc" id="L2885">                    return pushOperationOutsideAgg(agg, op, op.rhs, op.lhs, model);</span>
                }
            }
        }

<span class="fc" id="L2890">        return agg;</span>
    }

    /**
     * Rewrites order by clause to achieve simple column resolution for model parser.
     * Order by must never reference column that doesn't exist in its own select list.
     * &lt;p&gt;
     * Because order by clause logically executes after &quot;select&quot; it must be able to
     * reference results of arithmetic expression, aggregation function results, arithmetic with
     * aggregation results and analytic functions. Somewhat contradictory to this order by must
     * also be able to reference columns of table or sub-query that are not even in select clause.
     *
     * @param model inbound model
     * @return outbound model
     * @throws SqlException when column names are ambiguous or not found at all.
     */
    private QueryModel rewriteOrderBy(QueryModel model) throws SqlException {
        // find base model and check if there is &quot;group-by&quot; model in between
        // when we are dealing with &quot;group by&quot; model some implicit &quot;order by&quot; columns have to be dropped,
        // for example:
        // select a, sum(b) from T order by c
        //
        // above is valid but sorting on &quot;c&quot; would be redundant. However, in the following example
        //
        // select a, b from T order by c
        //
        // ordering is does affect query result
<span class="fc" id="L2917">        QueryModel result = model;</span>
<span class="fc" id="L2918">        QueryModel base = model;</span>
<span class="fc" id="L2919">        QueryModel baseParent = model;</span>
<span class="fc" id="L2920">        QueryModel wrapper = null;</span>
<span class="fc" id="L2921">        QueryModel limitModel = model;//bottom-most model which contains limit, order by can't be moved past it</span>
<span class="fc" id="L2922">        final int modelColumnCount = model.getBottomUpColumns().size();</span>
<span class="fc" id="L2923">        boolean groupByOrDistinct = false;</span>

<span class="pc bpc" id="L2925" title="1 of 4 branches missed.">        while (base.getBottomUpColumns().size() &gt; 0 &amp;&amp; !base.isNestedModelIsSubQuery()) {</span>
<span class="fc" id="L2926">            baseParent = base;</span>
<span class="fc" id="L2927">            base = base.getNestedModel();</span>
<span class="pc bpc" id="L2928" title="1 of 2 branches missed.">            if (base.getLimitLo() != null) {</span>
<span class="nc" id="L2929">                limitModel = base;</span>
            }
<span class="fc" id="L2931">            final int selectModelType = baseParent.getSelectModelType();</span>
<span class="fc bfc" id="L2932" title="All 6 branches covered.">            groupByOrDistinct = groupByOrDistinct</span>
                    || selectModelType == QueryModel.SELECT_MODEL_GROUP_BY
                    || selectModelType == QueryModel.SELECT_MODEL_DISTINCT;
<span class="fc" id="L2935">        }</span>

        // find out how &quot;order by&quot; columns are referenced
<span class="fc" id="L2938">        ObjList&lt;ExpressionNode&gt; orderByNodes = base.getOrderBy();</span>
<span class="fc" id="L2939">        int sz = orderByNodes.size();</span>
<span class="fc bfc" id="L2940" title="All 2 branches covered.">        if (sz &gt; 0) {</span>
            // for each order by column check how deep we need to go between &quot;model&quot; and &quot;base&quot;
<span class="fc bfc" id="L2942" title="All 2 branches covered.">            for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc" id="L2943">                final ExpressionNode orderBy = orderByNodes.getQuick(i);</span>
<span class="fc" id="L2944">                final CharSequence column = orderBy.token;</span>
<span class="fc" id="L2945">                final int dot = Chars.indexOf(column, '.');</span>
                // is this a table reference?
<span class="fc bfc" id="L2947" title="All 4 branches covered.">                if (dot &gt; -1 || model.getAliasToColumnMap().excludes(column)) {</span>
                    // validate column
<span class="fc" id="L2949">                    validateColumnAndGetModelIndex(base, column, dot, orderBy.position);</span>
                    // good news, our column matched base model
                    // this condition is to ignore order by columns that are not in select and behind group by
<span class="pc bpc" id="L2952" title="1 of 2 branches missed.">                    if (base != model) {</span>
                        // check if column is aliased as either
                        // &quot;x y&quot; or &quot;tab.x y&quot; or &quot;t.x y&quot;, where &quot;t&quot; is alias of table &quot;tab&quot;
<span class="fc" id="L2955">                        final LowerCaseCharSequenceObjHashMap&lt;CharSequence&gt; map = baseParent.getColumnNameToAliasMap();</span>
<span class="fc" id="L2956">                        CharSequence alias = null;</span>
<span class="fc" id="L2957">                        int index = map.keyIndex(column);</span>
<span class="fc bfc" id="L2958" title="All 4 branches covered.">                        if (index &gt; -1 &amp;&amp; dot &gt; -1) {</span>
                            // we have the following that are true:
                            // 1. column does have table alias, e.g. tab.x
                            // 2. column definitely exists
                            // 3. column is _not_ referenced as select tab.x from tab
                            //
                            // lets check if column is referenced as select x from tab
                            // this will determine is column is referenced by select at all
<span class="fc" id="L2966">                            index = map.keyIndex(column, dot + 1, column.length());</span>
                        }

<span class="fc bfc" id="L2969" title="All 2 branches covered.">                        if (index &lt; 0) {</span>
                            // we have found alias, rewrite order by column
<span class="fc" id="L2971">                            orderBy.token = map.valueAtQuick(index);</span>
                        } else {
<span class="fc bfc" id="L2973" title="All 2 branches covered.">                            if (dot &gt; -1) {</span>
<span class="fc" id="L2974">                                throw SqlException.invalidColumn(orderBy.position, column);</span>
                            }

                            // we must attempt to ascend order by column
                            // when we have group-by or distinct model, ascent is not possible
<span class="fc bfc" id="L2979" title="All 2 branches covered.">                            if (groupByOrDistinct) {</span>
<span class="fc" id="L2980">                                throw SqlException.position(orderBy.position)</span>
<span class="fc" id="L2981">                                        .put(&quot;ORDER BY expressions must appear in select list. &quot;)</span>
<span class="fc" id="L2982">                                        .put(&quot;Invalid column: &quot;)</span>
<span class="fc" id="L2983">                                        .put(column);</span>
                            } else {
<span class="fc bfc" id="L2985" title="All 2 branches covered.">                                if (baseParent.getSelectModelType() != QueryModel.SELECT_MODEL_CHOOSE) {</span>
<span class="fc" id="L2986">                                    QueryModel synthetic = queryModelPool.next();</span>
<span class="fc" id="L2987">                                    synthetic.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);</span>
<span class="fc bfc" id="L2988" title="All 2 branches covered.">                                    for (int j = 0, z = baseParent.getBottomUpColumns().size(); j &lt; z; j++) {</span>
<span class="fc" id="L2989">                                        QueryColumn qc = baseParent.getBottomUpColumns().getQuick(j);</span>
<span class="pc bpc" id="L2990" title="2 of 4 branches missed.">                                        if (qc.getAst().type == ExpressionNode.FUNCTION || qc.getAst().type == ExpressionNode.OPERATION) {</span>
<span class="fc" id="L2991">                                            emitLiterals(qc.getAst(), synthetic, null, baseParent.getNestedModel(), false);</span>
                                        } else {
<span class="nc" id="L2993">                                            synthetic.addBottomUpColumn(qc);</span>
                                        }
                                    }
<span class="fc" id="L2996">                                    synthetic.setNestedModel(base);</span>
<span class="fc" id="L2997">                                    baseParent.setNestedModel(synthetic);</span>
<span class="fc" id="L2998">                                    baseParent = synthetic;</span>

                                    // the column may appear in the list after literals from expressions have been emitted
<span class="fc" id="L3001">                                    index = synthetic.getColumnNameToAliasMap().keyIndex(column);</span>

<span class="pc bpc" id="L3003" title="1 of 2 branches missed.">                                    if (index &lt; 0) {</span>
<span class="fc" id="L3004">                                        alias = synthetic.getColumnNameToAliasMap().valueAtQuick(index);</span>
                                    }
                                }

<span class="fc bfc" id="L3008" title="All 2 branches covered.">                                if (alias == null) {</span>
<span class="fc" id="L3009">                                    alias = SqlUtil.createColumnAlias(characterStore, column, dot, baseParent.getAliasToColumnMap());</span>
<span class="fc" id="L3010">                                    baseParent.addBottomUpColumn(nextColumn(alias, column));</span>
                                }

                                // do we have more than one parent model?
<span class="fc bfc" id="L3014" title="All 2 branches covered.">                                if (model != baseParent) {</span>
<span class="fc" id="L3015">                                    QueryModel m = model;</span>
                                    do {
<span class="fc" id="L3017">                                        m.addBottomUpColumn(nextColumn(alias));</span>
<span class="fc" id="L3018">                                        m = m.getNestedModel();</span>
<span class="pc bpc" id="L3019" title="1 of 2 branches missed.">                                    } while (m != baseParent);</span>
                                }

<span class="fc" id="L3022">                                orderBy.token = alias;</span>

<span class="pc bpc" id="L3024" title="1 of 2 branches missed.">                                if (wrapper == null) {</span>
<span class="fc" id="L3025">                                    wrapper = queryModelPool.next();</span>
<span class="fc" id="L3026">                                    wrapper.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);</span>
<span class="fc bfc" id="L3027" title="All 2 branches covered.">                                    for (int j = 0; j &lt; modelColumnCount; j++) {</span>
<span class="fc" id="L3028">                                        wrapper.addBottomUpColumn(nextColumn(model.getBottomUpColumns().getQuick(j).getAlias()));</span>
                                    }
<span class="fc" id="L3030">                                    result = wrapper;</span>
<span class="fc" id="L3031">                                    wrapper.setNestedModel(model);</span>
                                }
                            }
                        }
                    }
                }
                //order by can't be pushed through limit clause because it'll produce bad results
<span class="pc bpc" id="L3038" title="2 of 4 branches missed.">                if (base != baseParent &amp;&amp; base != limitModel) {</span>
<span class="fc" id="L3039">                    limitModel.addOrderBy(orderBy, base.getOrderByDirection().getQuick(i));</span>
                }
            }

<span class="pc bpc" id="L3043" title="2 of 4 branches missed.">            if (base != model &amp;&amp; base != limitModel) {</span>
<span class="fc" id="L3044">                base.clearOrderBy();</span>
            }
        }

<span class="fc" id="L3048">        final QueryModel nested = base.getNestedModel();</span>
<span class="fc bfc" id="L3049" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L3050">            final QueryModel rewritten = rewriteOrderBy(nested);</span>
<span class="fc bfc" id="L3051" title="All 2 branches covered.">            if (rewritten != nested) {</span>
<span class="fc" id="L3052">                base.setNestedModel(rewritten);</span>
            }
        }

<span class="fc" id="L3056">        final QueryModel union = base.getUnionModel();</span>
<span class="pc bpc" id="L3057" title="1 of 2 branches missed.">        if (union != null) {</span>
<span class="nc" id="L3058">            final QueryModel rewritten = rewriteOrderBy(union);</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">            if (rewritten != union) {</span>
<span class="nc" id="L3060">                base.setUnionModel(rewritten);</span>
            }
        }

<span class="fc" id="L3064">        ObjList&lt;QueryModel&gt; joinModels = base.getJoinModels();</span>
<span class="fc bfc" id="L3065" title="All 2 branches covered.">        for (int i = 1, n = joinModels.size(); i &lt; n; i++) {</span>
            // we can ignore result of order by rewrite for because
            // 1. when join model is not a sub-query it will always have all the fields, so order by wouldn't
            //    introduce synthetic model (no column needs to be hidden)
            // 2. when join model is a sub-query it will have nested model, which can be rewritten. Parent model
            //    would remain the same again.
<span class="fc" id="L3071">            rewriteOrderBy(joinModels.getQuick(i));</span>
        }

<span class="fc" id="L3074">        return result;</span>
    }

    private QueryModel rewriteOrderByPosition(QueryModel model) throws SqlException {
<span class="fc" id="L3078">        QueryModel base = model;</span>
<span class="fc" id="L3079">        QueryModel baseParent = model;</span>

<span class="fc bfc" id="L3081" title="All 2 branches covered.">        while (base.getBottomUpColumns().size() &gt; 0) {</span>
            // Check if the model contains the full list of selected columns and, thus, can be used as the parent.
<span class="fc bfc" id="L3083" title="All 2 branches covered.">            if (!base.isSelectTranslation()) {</span>
<span class="fc" id="L3084">                baseParent = base;</span>
            }
<span class="fc" id="L3086">            base = base.getNestedModel();</span>
        }

<span class="fc" id="L3089">        ObjList&lt;ExpressionNode&gt; orderByNodes = base.getOrderBy();</span>
<span class="fc" id="L3090">        int sz = orderByNodes.size();</span>
<span class="fc bfc" id="L3091" title="All 2 branches covered.">        if (sz &gt; 0) {</span>
<span class="fc" id="L3092">            final ObjList&lt;QueryColumn&gt; columns = baseParent.getBottomUpColumns();</span>
<span class="fc" id="L3093">            final int columnCount = columns.size();</span>
<span class="fc bfc" id="L3094" title="All 2 branches covered.">            for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc" id="L3095">                final ExpressionNode orderBy = orderByNodes.getQuick(i);</span>
<span class="fc" id="L3096">                final CharSequence column = orderBy.token;</span>

<span class="fc" id="L3098">                char first = column.charAt(0);</span>
<span class="pc bpc" id="L3099" title="1 of 4 branches missed.">                if (first &lt; '0' || first &gt; '9') {</span>
<span class="fc" id="L3100">                    continue;</span>
                }

                try {
<span class="fc" id="L3104">                    final int position = Numbers.parseInt(column);</span>
<span class="fc bfc" id="L3105" title="All 4 branches covered.">                    if (position &lt; 1 || position &gt; columnCount) {</span>
<span class="fc" id="L3106">                        throw SqlException.$(orderBy.position, &quot;order column position is out of range [max=&quot;).put(columnCount).put(']');</span>
                    }
<span class="fc" id="L3108">                    orderByNodes.setQuick(</span>
                            i,
<span class="fc" id="L3110">                            expressionNodePool.next().of(</span>
                                    LITERAL,
<span class="fc" id="L3112">                                    columns.get(position - 1).getName(),</span>
                                    -1,
                                    orderBy.position
                            )
                    );
<span class="fc" id="L3117">                } catch (NumericException e) {</span>
<span class="fc" id="L3118">                    throw SqlException.invalidColumn(orderBy.position, column);</span>
<span class="fc" id="L3119">                }</span>
            }
        }

<span class="fc" id="L3123">        QueryModel nested = base.getNestedModel();</span>
<span class="fc bfc" id="L3124" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L3125">            rewriteOrderByPosition(nested);</span>
        }

<span class="fc" id="L3128">        ObjList&lt;QueryModel&gt; joinModels = base.getJoinModels();</span>
<span class="fc bfc" id="L3129" title="All 2 branches covered.">        for (int i = 1, n = joinModels.size(); i &lt; n; i++) {</span>
            // we can ignore result of order by rewrite for because
            // 1. when join model is not a sub-query it will always have all the fields, so order by wouldn't
            //    introduce synthetic model (no column needs to be hidden)
            // 2. when join model is a sub-query it will have nested model, which can be rewritten. Parent model
            //    would remain the same again.
<span class="fc" id="L3135">            rewriteOrderByPosition(joinModels.getQuick(i));</span>
        }

<span class="fc" id="L3138">        return model;</span>
    }

    private QueryModel rewriteOrderByPositionForUnionModels(QueryModel model) throws SqlException {
<span class="fc" id="L3142">        QueryModel next = model.getUnionModel();</span>
<span class="fc bfc" id="L3143" title="All 2 branches covered.">        if (next != null) {</span>
<span class="fc" id="L3144">            doRewriteOrderByPositionForUnionModels(model, model, next);</span>
        }

<span class="fc" id="L3147">        next = model.getNestedModel();</span>
<span class="fc bfc" id="L3148" title="All 2 branches covered.">        if (next != null) {</span>
<span class="fc" id="L3149">            rewriteOrderByPositionForUnionModels(next);</span>
        }
<span class="fc" id="L3151">        return model;</span>
    }

    // flatParent = true means that parent model does not have selected columns
    private QueryModel rewriteSelectClause(QueryModel model, boolean flatParent, SqlExecutionContext sqlExecutionContext) throws SqlException {

<span class="fc bfc" id="L3157" title="All 2 branches covered.">        if (model.getUnionModel() != null) {</span>
<span class="fc" id="L3158">            QueryModel rewrittenUnionModel = rewriteSelectClause(model.getUnionModel(), true, sqlExecutionContext);</span>
<span class="pc bpc" id="L3159" title="1 of 2 branches missed.">            if (rewrittenUnionModel != model.getUnionModel()) {</span>
<span class="fc" id="L3160">                model.setUnionModel(rewrittenUnionModel);</span>
            }
        }

<span class="fc" id="L3164">        ObjList&lt;QueryModel&gt; models = model.getJoinModels();</span>
<span class="fc bfc" id="L3165" title="All 2 branches covered.">        for (int i = 0, n = models.size(); i &lt; n; i++) {</span>
<span class="fc" id="L3166">            final QueryModel m = models.getQuick(i);</span>
<span class="fc bfc" id="L3167" title="All 2 branches covered.">            final boolean flatModel = m.getBottomUpColumns().size() == 0;</span>
<span class="fc" id="L3168">            final QueryModel nestedModel = m.getNestedModel();</span>
<span class="fc bfc" id="L3169" title="All 2 branches covered.">            if (nestedModel != null) {</span>
<span class="fc" id="L3170">                QueryModel rewritten = rewriteSelectClause(nestedModel, flatModel, sqlExecutionContext);</span>
<span class="fc bfc" id="L3171" title="All 2 branches covered.">                if (rewritten != nestedModel) {</span>
<span class="fc" id="L3172">                    m.setNestedModel(rewritten);</span>
                    // since we have rewritten nested model we also have to update column hash
<span class="fc" id="L3174">                    m.copyColumnsFrom(rewritten, queryColumnPool, expressionNodePool);</span>
                }
            }

<span class="fc bfc" id="L3178" title="All 2 branches covered.">            if (flatModel) {</span>
<span class="pc bpc" id="L3179" title="3 of 4 branches missed.">                if (flatParent &amp;&amp; m.getSampleBy() != null) {</span>
<span class="nc" id="L3180">                    throw SqlException.$(m.getSampleBy().position, &quot;'sample by' must be used with 'select' clause, which contains aggregate expression(s)&quot;);</span>
                }
            } else {
<span class="fc" id="L3183">                model.replaceJoinModel(i, rewriteSelectClause0(m, sqlExecutionContext));</span>
            }
        }

        // &quot;model&quot; is always first in its own list of join models
<span class="fc" id="L3188">        return models.getQuick(0);</span>
    }

    @NotNull
    private QueryModel rewriteSelectClause0(final QueryModel model, SqlExecutionContext sqlExecutionContext) throws SqlException {
<span class="pc bpc" id="L3193" title="1 of 2 branches missed.">        assert model.getNestedModel() != null;</span>

<span class="fc" id="L3195">        final QueryModel groupByModel = queryModelPool.next();</span>
<span class="fc" id="L3196">        groupByModel.setSelectModelType(QueryModel.SELECT_MODEL_GROUP_BY);</span>
<span class="fc" id="L3197">        final QueryModel distinctModel = queryModelPool.next();</span>
<span class="fc" id="L3198">        distinctModel.setSelectModelType(QueryModel.SELECT_MODEL_DISTINCT);</span>
<span class="fc" id="L3199">        final QueryModel outerVirtualModel = queryModelPool.next();</span>
<span class="fc" id="L3200">        outerVirtualModel.setSelectModelType(QueryModel.SELECT_MODEL_VIRTUAL);</span>
<span class="fc" id="L3201">        final QueryModel innerVirtualModel = queryModelPool.next();</span>
<span class="fc" id="L3202">        innerVirtualModel.setSelectModelType(QueryModel.SELECT_MODEL_VIRTUAL);</span>
<span class="fc" id="L3203">        final QueryModel analyticModel = queryModelPool.next();</span>
<span class="fc" id="L3204">        analyticModel.setSelectModelType(QueryModel.SELECT_MODEL_ANALYTIC);</span>
<span class="fc" id="L3205">        final QueryModel translatingModel = queryModelPool.next();</span>
<span class="fc" id="L3206">        translatingModel.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);</span>
        // this is dangling model, which isn't chained with any other
        // we use it to ensure expression and alias uniqueness
<span class="fc" id="L3209">        final QueryModel cursorModel = queryModelPool.next();</span>

<span class="fc" id="L3211">        boolean useInnerModel = false;</span>
<span class="fc" id="L3212">        boolean useAnalyticModel = false;</span>
<span class="fc" id="L3213">        boolean useGroupByModel = false;</span>
<span class="fc" id="L3214">        boolean useOuterModel = false;</span>
<span class="fc" id="L3215">        final boolean useDistinctModel = model.isDistinct();</span>

<span class="fc" id="L3217">        final ObjList&lt;QueryColumn&gt; columns = model.getBottomUpColumns();</span>
<span class="fc" id="L3218">        final QueryModel baseModel = model.getNestedModel();</span>
<span class="fc bfc" id="L3219" title="All 2 branches covered.">        final boolean hasJoins = baseModel.getJoinModels().size() &gt; 1;</span>

        // sample by clause should be promoted to all the models as well as validated
<span class="fc" id="L3222">        final ExpressionNode sampleBy = baseModel.getSampleBy();</span>
<span class="fc bfc" id="L3223" title="All 2 branches covered.">        if (sampleBy != null) {</span>
            // move sample by to group by model
<span class="fc" id="L3225">            groupByModel.moveSampleByFrom(baseModel);</span>
        }

<span class="fc bfc" id="L3228" title="All 2 branches covered.">        if (baseModel.getGroupBy().size() &gt; 0) {</span>
<span class="fc" id="L3229">            groupByModel.moveGroupByFrom(baseModel);</span>
        }

        // cursor model should have all columns that base model has to properly resolve duplicate names
<span class="fc" id="L3233">        cursorModel.getAliasToColumnMap().putAll(baseModel.getAliasToColumnMap());</span>
        // create virtual columns from select list

<span class="fc bfc" id="L3236" title="All 2 branches covered.">        for (int i = 0, k = columns.size(); i &lt; k; i++) {</span>
<span class="fc" id="L3237">            QueryColumn qc = columns.getQuick(i);</span>
<span class="fc" id="L3238">            final boolean analytic = qc instanceof AnalyticColumn;</span>

            // fail-fast if this is an arithmetic expression where we expect analytic function
<span class="fc bfc" id="L3241" title="All 4 branches covered.">            if (analytic &amp;&amp; qc.getAst().type != ExpressionNode.FUNCTION) {</span>
<span class="fc" id="L3242">                throw SqlException.$(qc.getAst().position, &quot;Analytic function expected&quot;);</span>
            }

<span class="fc bfc" id="L3245" title="All 2 branches covered.">            if (qc.getAst().type == ExpressionNode.BIND_VARIABLE) {</span>
<span class="fc" id="L3246">                useInnerModel = true;</span>
<span class="fc bfc" id="L3247" title="All 2 branches covered.">            } else if (qc.getAst().type != LITERAL) {</span>
<span class="fc bfc" id="L3248" title="All 2 branches covered.">                if (qc.getAst().type == ExpressionNode.FUNCTION) {</span>
<span class="fc bfc" id="L3249" title="All 2 branches covered.">                    if (analytic) {</span>
<span class="fc" id="L3250">                        useAnalyticModel = true;</span>
<span class="fc" id="L3251">                        continue;</span>
<span class="fc bfc" id="L3252" title="All 2 branches covered.">                    } else if (functionParser.getFunctionFactoryCache().isGroupBy(qc.getAst().token)) {</span>
<span class="fc" id="L3253">                        useGroupByModel = true;</span>

<span class="fc bfc" id="L3255" title="All 2 branches covered.">                        if (groupByModel.getSampleByFill().size() &gt; 0) {//file breaks if column is de-duplicated</span>
<span class="fc" id="L3256">                            continue;</span>
                        }

<span class="fc" id="L3259">                        ExpressionNode repl = rewriteAggregate(qc.getAst(), baseModel);</span>
<span class="fc bfc" id="L3260" title="All 2 branches covered.">                        if (repl == qc.getAst()) {//no rewrite</span>
<span class="fc bfc" id="L3261" title="All 2 branches covered.">                            if (!useOuterModel) {//so try to push duplicate aggregates to nested model    </span>
<span class="fc bfc" id="L3262" title="All 2 branches covered.">                                for (int j = i + 1; j &lt; k; j++) {</span>
<span class="fc bfc" id="L3263" title="All 2 branches covered.">                                    if (ExpressionNode.compareNodesExact(qc.getAst(), columns.get(j).getAst())) {</span>
<span class="fc" id="L3264">                                        useOuterModel = true;</span>
<span class="fc" id="L3265">                                        break;</span>
                                    }
                                }
                            }
                            continue;
                        }

<span class="fc" id="L3272">                        useOuterModel = true;</span>
<span class="fc" id="L3273">                        qc.of(qc.getAlias(), repl);</span>
<span class="fc bfc" id="L3274" title="All 2 branches covered.">                    } else if (functionParser.getFunctionFactoryCache().isCursor(qc.getAst().token)) {</span>
<span class="fc" id="L3275">                        continue;</span>
                    }
                }

<span class="fc bfc" id="L3279" title="All 2 branches covered.">                if (checkForAggregates(qc.getAst())) {</span>
<span class="fc" id="L3280">                    useGroupByModel = true;</span>
<span class="fc" id="L3281">                    useOuterModel = true;</span>
                } else {
<span class="fc" id="L3283">                    useInnerModel = true;</span>
                }
            }
        }

<span class="fc" id="L3288">        boolean outerVirtualIsSelectChoose = true;</span>

        // create virtual columns from select list
<span class="fc" id="L3291">        boolean hasSeenWildcardExpression = false;</span>
<span class="fc bfc" id="L3292" title="All 2 branches covered.">        for (int i = 0, k = columns.size(); i &lt; k; i++) {</span>
<span class="fc" id="L3293">            QueryColumn qc = columns.getQuick(i);</span>
<span class="fc" id="L3294">            final boolean analytic = qc instanceof AnalyticColumn;</span>

<span class="fc bfc" id="L3296" title="All 2 branches covered.">            if (qc.getAst().type == LITERAL) {</span>
<span class="fc bfc" id="L3297" title="All 2 branches covered.">                if (Chars.endsWith(qc.getAst().token, '*')) {</span>
                    // in general sense we need to create new column in case
                    // there is change of alias, for example we may have something as simple as
                    // select a.f, b.f from ....
<span class="fc" id="L3301">                    createSelectColumnsForWildcard(</span>
                            qc,
                            hasJoins,
                            baseModel,
                            translatingModel,
                            innerVirtualModel,
                            analyticModel,
                            groupByModel,
                            outerVirtualModel,
                            distinctModel
                    );
<span class="fc" id="L3312">                    hasSeenWildcardExpression = true;</span>
                } else {
<span class="fc" id="L3314">                    createSelectColumn(</span>
<span class="fc" id="L3315">                            qc.getAlias(),</span>
<span class="fc" id="L3316">                            qc.getAst(),</span>
                            hasSeenWildcardExpression,
                            baseModel,
                            translatingModel,
                            innerVirtualModel,
                            analyticModel,
                            groupByModel,
                            outerVirtualModel,
                            distinctModel
                    );
                }
<span class="fc bfc" id="L3327" title="All 2 branches covered.">            } else if (qc.getAst().type == ExpressionNode.BIND_VARIABLE) {</span>
<span class="fc" id="L3328">                addFunction(</span>
                        qc,
                        baseModel,
                        translatingModel,
                        innerVirtualModel,
                        analyticModel,
                        groupByModel,
                        outerVirtualModel,
                        distinctModel
                );
            } else {
                // when column is direct call to aggregation function, such as
                // select sum(x) ...
                // we can add it to group-by model right away
<span class="fc bfc" id="L3342" title="All 2 branches covered.">                if (qc.getAst().type == ExpressionNode.FUNCTION) {</span>
<span class="fc bfc" id="L3343" title="All 2 branches covered.">                    if (analytic) {</span>
<span class="fc" id="L3344">                        analyticModel.addBottomUpColumn(qc);</span>
                        // ensure literals referenced by analytic column are present in nested models
<span class="fc" id="L3346">                        emitLiterals(qc.getAst(), translatingModel, innerVirtualModel, baseModel, true);</span>
<span class="fc" id="L3347">                        continue;</span>
<span class="fc bfc" id="L3348" title="All 2 branches covered.">                    } else if (functionParser.getFunctionFactoryCache().isGroupBy(qc.getAst().token)) {</span>
<span class="fc" id="L3349">                        QueryColumn matchingCol = groupByModel.findBottomUpColumnByAst(qc.getAst());</span>
                        //reuse existing aggregate column in group by model
<span class="fc bfc" id="L3351" title="All 4 branches covered.">                        if (useOuterModel &amp;&amp; matchingCol != null) {</span>
<span class="fc" id="L3352">                            QueryColumn ref = nextColumn(qc.getAlias(), matchingCol.getAlias());</span>
<span class="fc" id="L3353">                            ref = ensureAliasUniqueness(outerVirtualModel, ref);</span>
<span class="fc" id="L3354">                            outerVirtualModel.addBottomUpColumn(ref);</span>
<span class="fc" id="L3355">                            distinctModel.addBottomUpColumn(ref);</span>
<span class="fc" id="L3356">                            emitLiterals(qc.getAst(), translatingModel, innerVirtualModel, baseModel, false);</span>
<span class="fc" id="L3357">                            continue;</span>
                        }

<span class="fc" id="L3360">                        qc = ensureAliasUniqueness(groupByModel, qc);</span>
<span class="fc" id="L3361">                        groupByModel.addBottomUpColumn(qc);</span>
                        // group-by column references might be needed when we have
                        // outer model supporting arithmetic such as:
                        // select sum(a)+sum(b) ....
<span class="fc" id="L3365">                        QueryColumn ref = nextColumn(qc.getAlias());</span>
<span class="fc" id="L3366">                        outerVirtualModel.addBottomUpColumn(ref);</span>
<span class="fc" id="L3367">                        distinctModel.addBottomUpColumn(ref);</span>
                        // pull out literals
<span class="fc" id="L3369">                        emitLiterals(qc.getAst(), translatingModel, innerVirtualModel, baseModel, false);</span>
<span class="fc" id="L3370">                        continue;</span>
<span class="fc bfc" id="L3371" title="All 2 branches covered.">                    } else if (functionParser.getFunctionFactoryCache().isCursor(qc.getAst().token)) {</span>
<span class="fc" id="L3372">                        addCursorFunctionAsCrossJoin(</span>
<span class="fc" id="L3373">                                qc.getAst(),</span>
<span class="fc" id="L3374">                                qc.getAlias(),</span>
                                cursorModel,
                                innerVirtualModel,
                                translatingModel,
                                baseModel,
                                sqlExecutionContext
                        );
<span class="fc" id="L3381">                        continue;</span>
                    }
                }

                // this is not a direct call to aggregation function, in which case
                // we emit aggregation function into group-by model and leave the
                // rest in outer model
<span class="fc" id="L3388">                final int beforeSplit = groupByModel.getBottomUpColumns().size();</span>
<span class="fc bfc" id="L3389" title="All 2 branches covered.">                if (emitAggregates(qc.getAst(), groupByModel)) {</span>
<span class="fc" id="L3390">                    emitCursors(qc.getAst(), cursorModel, innerVirtualModel, translatingModel, baseModel, sqlExecutionContext);</span>
<span class="fc" id="L3391">                    qc = ensureAliasUniqueness(outerVirtualModel, qc);</span>
<span class="fc" id="L3392">                    outerVirtualModel.addBottomUpColumn(qc);</span>
<span class="fc" id="L3393">                    distinctModel.addBottomUpColumn(nextColumn(qc.getAlias()));</span>

                    // pull literals from newly created group-by columns into both of underlying models
<span class="fc bfc" id="L3396" title="All 2 branches covered.">                    for (int j = beforeSplit, n = groupByModel.getBottomUpColumns().size(); j &lt; n; j++) {</span>
<span class="fc" id="L3397">                        emitLiterals(groupByModel.getBottomUpColumns().getQuick(j).getAst(), translatingModel, innerVirtualModel, baseModel, false);</span>
                    }
                } else {
<span class="fc bfc" id="L3400" title="All 2 branches covered.">                    if (emitCursors(qc.getAst(), cursorModel, null, translatingModel, baseModel, sqlExecutionContext)) {</span>
<span class="fc" id="L3401">                        qc = ensureAliasUniqueness(innerVirtualModel, qc);</span>
                    }
<span class="fc bfc" id="L3403" title="All 2 branches covered.">                    if (useGroupByModel) {</span>
<span class="fc bfc" id="L3404" title="All 2 branches covered.">                        if (isEffectivelyConstantExpression(qc.getAst())) {</span>
<span class="fc" id="L3405">                            outerVirtualIsSelectChoose = false;</span>
<span class="fc" id="L3406">                            outerVirtualModel.addBottomUpColumn(qc);</span>
<span class="fc" id="L3407">                            distinctModel.addBottomUpColumn(qc);</span>
<span class="fc" id="L3408">                            continue;</span>
                        }
                    }

<span class="fc" id="L3412">                    addFunction(</span>
                            qc,
                            baseModel,
                            translatingModel,
                            innerVirtualModel,
                            analyticModel,
                            groupByModel,
                            outerVirtualModel,
                            distinctModel
                    );
                }
            }
        }

        // fail if we have both analytic and group-by models
<span class="fc bfc" id="L3427" title="All 4 branches covered.">        if (useAnalyticModel &amp;&amp; useGroupByModel) {</span>
<span class="fc" id="L3428">            throw SqlException.$(0, &quot;Analytic function is not allowed in context of aggregation. Use sub-query.&quot;);</span>
        }

<span class="fc bfc" id="L3431" title="All 2 branches covered.">        if (useAnalyticModel) {</span>
            // We need one more pass for analytic model to emit potentially missing columns.
            // For example, 'SELECT row_number() over (partition by col_c order by col_c), col_a, col_b FROM tab'
            // needs col_c to be emitted.
<span class="fc bfc" id="L3435" title="All 2 branches covered.">            for (int i = 0, k = columns.size(); i &lt; k; i++) {</span>
<span class="fc" id="L3436">                QueryColumn qc = columns.getQuick(i);</span>
<span class="fc" id="L3437">                final boolean analytic = qc instanceof AnalyticColumn;</span>

<span class="fc bfc" id="L3439" title="All 4 branches covered.">                if (analytic &amp; qc.getAst().type == ExpressionNode.FUNCTION) {</span>
                    // Analytic model can be after either translation model directly
                    // or after inner virtual model, which can be sandwiched between
                    // translation model and analytic model.
                    // To make sure columns, referenced by the analytic model
                    // are rendered correctly we will emit them into a dedicated
                    // translation model for the analytic model.
                    // When we're able to determine which combination of models precedes the
                    // analytic model, we can copy columns from analytic_translation model to
                    // either only to translation model or both translation model and the
                    // inner virtual models.
<span class="fc" id="L3450">                    final AnalyticColumn ac = (AnalyticColumn) qc;</span>
<span class="fc" id="L3451">                    replaceLiteralList(innerVirtualModel, translatingModel, baseModel, ac.getPartitionBy());</span>
<span class="fc" id="L3452">                    replaceLiteralList(innerVirtualModel, translatingModel, baseModel, ac.getOrderBy());</span>
                }
            }
        }

<span class="fc bfc" id="L3457" title="All 2 branches covered.">        if (useInnerModel) {</span>
<span class="fc" id="L3458">            final ObjList&lt;QueryColumn&gt; innerColumns = innerVirtualModel.getBottomUpColumns();</span>
<span class="fc" id="L3459">            useInnerModel = false;</span>
<span class="fc bfc" id="L3460" title="All 2 branches covered.">            for (int i = 0, k = innerColumns.size(); i &lt; k; i++) {</span>
<span class="fc" id="L3461">                QueryColumn qc = innerColumns.getQuick(i);</span>
<span class="fc bfc" id="L3462" title="All 2 branches covered.">                if (qc.getAst().type != LITERAL) {</span>
<span class="fc" id="L3463">                    useInnerModel = true;</span>
<span class="fc" id="L3464">                    break;</span>
                }
            }
        }

        // check if translating model is redundant, e.g.
        // that it neither chooses between tables nor renames columns
<span class="fc bfc" id="L3471" title="All 6 branches covered.">        boolean translationIsRedundant = useInnerModel || useGroupByModel || useAnalyticModel;</span>
<span class="fc bfc" id="L3472" title="All 2 branches covered.">        if (translationIsRedundant) {</span>
<span class="fc bfc" id="L3473" title="All 2 branches covered.">            for (int i = 0, n = translatingModel.getBottomUpColumns().size(); i &lt; n; i++) {</span>
<span class="fc" id="L3474">                QueryColumn column = translatingModel.getBottomUpColumns().getQuick(i);</span>
<span class="fc bfc" id="L3475" title="All 2 branches covered.">                if (!column.getAst().token.equals(column.getAlias())) {</span>
<span class="fc" id="L3476">                    translationIsRedundant = false;</span>
<span class="fc" id="L3477">                    break;</span>
                }
            }
        }

<span class="fc bfc" id="L3482" title="All 4 branches covered.">        if (sampleBy != null &amp;&amp; baseModel.getTimestamp() != null) {</span>
<span class="fc" id="L3483">            CharSequence timestamp = baseModel.getTimestamp().token;</span>
            // does model already select timestamp column?
<span class="fc bfc" id="L3485" title="All 2 branches covered.">            if (innerVirtualModel.getColumnNameToAliasMap().excludes(timestamp)) {</span>
                // no, do we rename columns? does model select timestamp under a new name?
<span class="fc bfc" id="L3487" title="All 2 branches covered.">                if (translationIsRedundant) {</span>
                    // columns were not renamed
<span class="fc" id="L3489">                    createSelectColumn0(</span>
<span class="fc" id="L3490">                            baseModel.getTimestamp().token,</span>
<span class="fc" id="L3491">                            baseModel.getTimestamp(),</span>
                            baseModel,
                            translatingModel,
                            innerVirtualModel,
                            analyticModel
                    );
                } else {
                    // columns were renamed,
<span class="fc bfc" id="L3499" title="All 2 branches covered.">                    if (translatingModel.getColumnNameToAliasMap().excludes(timestamp)) {</span>
                        // make alias name
<span class="fc" id="L3501">                        CharacterStoreEntry e = characterStore.newEntry();</span>
<span class="fc" id="L3502">                        e.put(baseModel.getName()).put('.').put(timestamp);</span>
<span class="fc bfc" id="L3503" title="All 2 branches covered.">                        if (translatingModel.getColumnNameToAliasMap().excludes(e.toImmutable())) {</span>
<span class="fc" id="L3504">                            createSelectColumn0(</span>
<span class="fc" id="L3505">                                    baseModel.getTimestamp().token,</span>
<span class="fc" id="L3506">                                    baseModel.getTimestamp(),</span>
                                    baseModel,
                                    translatingModel,
                                    innerVirtualModel,
                                    analyticModel
                            );
                        }
                    }
                }
            }
        }

        QueryModel root;
        QueryModel limitSource;

<span class="fc bfc" id="L3521" title="All 2 branches covered.">        if (translationIsRedundant) {</span>
<span class="fc" id="L3522">            root = baseModel;</span>
<span class="fc" id="L3523">            limitSource = model;</span>
        } else {
<span class="fc" id="L3525">            root = translatingModel;</span>
<span class="fc" id="L3526">            limitSource = translatingModel;</span>
<span class="fc" id="L3527">            translatingModel.setNestedModel(baseModel);</span>

            // translating model has limits to ensure clean factory separation
            // during code generation. However, in some cases limit could also
            // be implemented by nested model. Nested model must not implement limit
            // when parent model is order by or join
<span class="fc bfc" id="L3533" title="All 4 branches covered.">            if (baseModel.getOrderBy().size() == 0 &amp;&amp; baseModel.getJoinModels().size() &lt; 2) {</span>
<span class="fc" id="L3534">                baseModel.setLimitAdvice(model.getLimitLo(), model.getLimitHi());</span>
            }

<span class="fc" id="L3537">            translatingModel.moveLimitFrom(model);</span>
<span class="fc" id="L3538">            translatingModel.moveJoinAliasFrom(model);</span>
<span class="fc" id="L3539">            translatingModel.setSelectTranslation(true);</span>
        }

<span class="fc bfc" id="L3542" title="All 2 branches covered.">        if (useInnerModel) {</span>
<span class="fc" id="L3543">            innerVirtualModel.setNestedModel(root);</span>
<span class="fc" id="L3544">            innerVirtualModel.moveLimitFrom(limitSource);</span>
<span class="fc" id="L3545">            innerVirtualModel.moveJoinAliasFrom(limitSource);</span>
<span class="fc" id="L3546">            root = innerVirtualModel;</span>
<span class="fc" id="L3547">            limitSource = innerVirtualModel;</span>
        }

<span class="fc bfc" id="L3550" title="All 2 branches covered.">        if (useAnalyticModel) {</span>
<span class="fc" id="L3551">            analyticModel.setNestedModel(root);</span>
<span class="fc" id="L3552">            analyticModel.moveLimitFrom(limitSource);</span>
<span class="fc" id="L3553">            analyticModel.moveJoinAliasFrom(limitSource);</span>
<span class="fc" id="L3554">            root = analyticModel;</span>
<span class="fc" id="L3555">            limitSource = analyticModel;</span>
<span class="fc bfc" id="L3556" title="All 2 branches covered.">        } else if (useGroupByModel) {</span>
<span class="fc" id="L3557">            groupByModel.setNestedModel(root);</span>
<span class="fc" id="L3558">            groupByModel.moveLimitFrom(limitSource);</span>
<span class="fc" id="L3559">            groupByModel.moveJoinAliasFrom(limitSource);</span>
<span class="fc" id="L3560">            root = groupByModel;</span>
<span class="fc" id="L3561">            limitSource = groupByModel;</span>
        }

<span class="fc bfc" id="L3564" title="All 2 branches covered.">        if (useOuterModel) {</span>
<span class="fc" id="L3565">            outerVirtualModel.setNestedModel(root);</span>
<span class="fc" id="L3566">            outerVirtualModel.moveLimitFrom(limitSource);</span>
<span class="fc" id="L3567">            outerVirtualModel.moveJoinAliasFrom(limitSource);</span>
<span class="fc" id="L3568">            root = outerVirtualModel;</span>
<span class="pc bpc" id="L3569" title="1 of 4 branches missed.">        } else if (root != outerVirtualModel &amp;&amp; root.getBottomUpColumns().size() &lt; outerVirtualModel.getBottomUpColumns().size()) {</span>
<span class="fc" id="L3570">            outerVirtualModel.setNestedModel(root);</span>
<span class="fc" id="L3571">            outerVirtualModel.moveLimitFrom(limitSource);</span>
<span class="fc" id="L3572">            outerVirtualModel.moveJoinAliasFrom(limitSource);</span>
<span class="fc bfc" id="L3573" title="All 2 branches covered.">            outerVirtualModel.setSelectModelType(outerVirtualIsSelectChoose ? QueryModel.SELECT_MODEL_CHOOSE : QueryModel.SELECT_MODEL_VIRTUAL);</span>
<span class="fc" id="L3574">            root = outerVirtualModel;</span>
        }

<span class="fc bfc" id="L3577" title="All 2 branches covered.">        if (useDistinctModel) {</span>
<span class="fc" id="L3578">            distinctModel.setNestedModel(root);</span>
<span class="fc" id="L3579">            distinctModel.moveLimitFrom(root);</span>
<span class="fc" id="L3580">            root = distinctModel;</span>
        }

<span class="fc bfc" id="L3583" title="All 4 branches covered.">        if (!useGroupByModel &amp;&amp; groupByModel.getSampleBy() != null) {</span>
<span class="fc" id="L3584">            throw SqlException.$(groupByModel.getSampleBy().position, &quot;at least one aggregation function must be present in 'select' clause&quot;);</span>
        }

<span class="pc bpc" id="L3587" title="1 of 2 branches missed.">        if (model != root) {</span>
<span class="fc" id="L3588">            root.setUnionModel(model.getUnionModel());</span>
<span class="fc" id="L3589">            root.setSetOperationType(model.getSetOperationType());</span>
<span class="fc" id="L3590">            root.setModelPosition(model.getModelPosition());</span>
<span class="fc bfc" id="L3591" title="All 2 branches covered.">            if (model.isUpdate()) {</span>
<span class="fc" id="L3592">                root.setIsUpdate(true);</span>
<span class="fc" id="L3593">                root.copyUpdateTableMetadata(model);</span>
            }
        }
<span class="pc bpc" id="L3596" title="1 of 2 branches missed.">        return root;</span>
    }

    // the intent is to either validate top-level columns in select columns or replace them with function calls
    // if columns do not exist
    private void rewriteTopLevelLiteralsToFunctions(QueryModel model) {
<span class="fc" id="L3602">        final QueryModel nested = model.getNestedModel();</span>
<span class="fc bfc" id="L3603" title="All 2 branches covered.">        if (nested != null) {</span>
<span class="fc" id="L3604">            rewriteTopLevelLiteralsToFunctions(nested);</span>
<span class="fc" id="L3605">            final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</span>
<span class="fc" id="L3606">            final int n = columns.size();</span>
<span class="fc bfc" id="L3607" title="All 2 branches covered.">            if (n &gt; 0) {</span>
<span class="fc bfc" id="L3608" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L3609">                    final QueryColumn qc = columns.getQuick(i);</span>
<span class="fc" id="L3610">                    final ExpressionNode node = qc.getAst();</span>
<span class="fc bfc" id="L3611" title="All 2 branches covered.">                    if (node.type == LITERAL) {</span>
<span class="fc bfc" id="L3612" title="All 2 branches covered.">                        if (nested.getAliasToColumnMap().contains(node.token)) {</span>
<span class="fc" id="L3613">                            continue;</span>
                        }

<span class="fc bfc" id="L3616" title="All 2 branches covered.">                        if (functionParser.getFunctionFactoryCache().isValidNoArgFunction(node)) {</span>
<span class="fc" id="L3617">                            node.type = FUNCTION;</span>
                        }
                    } else {
<span class="fc" id="L3620">                        model.addField(qc);</span>
                    }
                }
            } else {
<span class="fc" id="L3624">                model.copyColumnsFrom(nested, queryColumnPool, expressionNodePool);</span>
            }
        }
<span class="fc" id="L3627">    }</span>

    private CharSequence setAndGetModelAlias(QueryModel model) {
<span class="fc" id="L3630">        CharSequence name = model.getName();</span>
<span class="fc bfc" id="L3631" title="All 2 branches covered.">        if (name != null) {</span>
<span class="fc" id="L3632">            return name;</span>
        }
<span class="fc" id="L3634">        ExpressionNode alias = makeJoinAlias();</span>
<span class="fc" id="L3635">        model.setAlias(alias);</span>
<span class="fc" id="L3636">        return alias.token;</span>
    }

    private QueryModel skipNoneTypeModels(QueryModel model) {
<span class="fc bfc" id="L3640" title="All 2 branches covered.">        while (</span>
                model != null
<span class="fc bfc" id="L3642" title="All 2 branches covered.">                        &amp;&amp; model.getSelectModelType() == QueryModel.SELECT_MODEL_NONE</span>
<span class="fc bfc" id="L3643" title="All 2 branches covered.">                        &amp;&amp; model.getTableName() == null</span>
<span class="pc bpc" id="L3644" title="1 of 2 branches missed.">                        &amp;&amp; model.getTableNameFunction() == null</span>
<span class="fc bfc" id="L3645" title="All 2 branches covered.">                        &amp;&amp; model.getJoinModels().size() == 1</span>
<span class="fc bfc" id="L3646" title="All 2 branches covered.">                        &amp;&amp; model.getWhereClause() == null</span>
<span class="fc bfc" id="L3647" title="All 2 branches covered.">                        &amp;&amp; model.getLatestBy().size() == 0</span>
        ) {
<span class="fc" id="L3649">            model = model.getNestedModel();</span>
        }
<span class="fc" id="L3651">        return model;</span>
    }

    /**
     * Moves reversible join clauses, such as a.x = b.x from table &quot;from&quot; to table &quot;to&quot;.
     *
     * @param to      target table index
     * @param from    source table index
     * @param context context of target table index
     * @return false if &quot;from&quot; is outer joined table, otherwise - true
     */
    private boolean swapJoinOrder(QueryModel parent, int to, int from, final JoinContext context) {
<span class="fc" id="L3663">        ObjList&lt;QueryModel&gt; joinModels = parent.getJoinModels();</span>
<span class="fc" id="L3664">        QueryModel jm = joinModels.getQuick(from);</span>
<span class="fc bfc" id="L3665" title="All 2 branches covered.">        if (joinBarriers.contains(jm.getJoinType())) {</span>
<span class="fc" id="L3666">            return false;</span>
        }

<span class="fc" id="L3669">        final JoinContext that = jm.getContext();</span>
<span class="fc bfc" id="L3670" title="All 4 branches covered.">        if (that != null &amp;&amp; that.parents.contains(to)) {</span>
<span class="fc" id="L3671">            swapJoinOrder0(parent, jm, to, context);</span>
        }
<span class="fc" id="L3673">        return true;</span>
    }

    private void swapJoinOrder0(QueryModel parent, QueryModel jm, int to, JoinContext jc) {
<span class="fc" id="L3677">        final JoinContext that = jm.getContext();</span>
<span class="fc" id="L3678">        clausesToSteal.clear();</span>
<span class="fc" id="L3679">        int zc = that.aIndexes.size();</span>
<span class="fc bfc" id="L3680" title="All 2 branches covered.">        for (int z = 0; z &lt; zc; z++) {</span>
<span class="fc bfc" id="L3681" title="All 4 branches covered.">            if (that.aIndexes.getQuick(z) == to || that.bIndexes.getQuick(z) == to) {</span>
<span class="fc" id="L3682">                clausesToSteal.add(z);</span>
            }
        }

        // we check that parent contains &quot;to&quot;, so we must have something to do
<span class="pc bpc" id="L3687" title="1 of 2 branches missed.">        assert clausesToSteal.size() &gt; 0;</span>

<span class="fc bfc" id="L3689" title="All 2 branches covered.">        if (clausesToSteal.size() &lt; zc) {</span>
<span class="fc" id="L3690">            QueryModel target = parent.getJoinModels().getQuick(to);</span>
<span class="pc bpc" id="L3691" title="1 of 2 branches missed.">            if (jc == null) {</span>
<span class="fc" id="L3692">                target.setContext(jc = contextPool.next());</span>
            }
<span class="fc" id="L3694">            jc.slaveIndex = to;</span>
<span class="fc" id="L3695">            jm.setContext(moveClauses(parent, that, jc, clausesToSteal));</span>
<span class="pc bpc" id="L3696" title="1 of 2 branches missed.">            if (target.getJoinType() == QueryModel.JOIN_CROSS) {</span>
<span class="fc" id="L3697">                target.setJoinType(QueryModel.JOIN_INNER);</span>
            }
        }
<span class="fc" id="L3700">    }</span>

    private void traverseNamesAndIndices(QueryModel parent, ExpressionNode node) throws SqlException {
<span class="fc" id="L3703">        literalCollectorAIndexes.clear();</span>
<span class="fc" id="L3704">        literalCollectorBIndexes.clear();</span>

<span class="fc" id="L3706">        literalCollectorANames.clear();</span>
<span class="fc" id="L3707">        literalCollectorBNames.clear();</span>

<span class="fc" id="L3709">        literalCollector.withModel(parent);</span>
<span class="fc" id="L3710">        literalCollector.resetCounts();</span>
<span class="fc" id="L3711">        traversalAlgo.traverse(node.lhs, literalCollector.lhs());</span>
<span class="fc" id="L3712">        traversalAlgo.traverse(node.rhs, literalCollector.rhs());</span>
<span class="fc" id="L3713">    }</span>

    private int validateColumnAndGetModelIndex(QueryModel model, CharSequence columnName, int dot, int position) throws SqlException {
<span class="fc" id="L3716">        ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</span>
<span class="fc" id="L3717">        int index = -1;</span>
<span class="fc bfc" id="L3718" title="All 2 branches covered.">        if (dot == -1) {</span>
<span class="fc bfc" id="L3719" title="All 2 branches covered.">            for (int i = 0, n = joinModels.size(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L3720" title="All 2 branches covered.">                if (joinModels.getQuick(i).getAliasToColumnMap().excludes(columnName)) {</span>
<span class="fc" id="L3721">                    continue;</span>
                }

<span class="fc bfc" id="L3724" title="All 2 branches covered.">                if (index != -1) {</span>
<span class="fc" id="L3725">                    throw SqlException.ambiguousColumn(position, columnName);</span>
                }

<span class="fc" id="L3728">                index = i;</span>
            }

<span class="fc bfc" id="L3731" title="All 2 branches covered.">            if (index == -1) {</span>
<span class="fc" id="L3732">                throw SqlException.invalidColumn(position, columnName);</span>
            }

        } else {
<span class="fc" id="L3736">            index = model.getModelAliasIndex(columnName, 0, dot);</span>

<span class="fc bfc" id="L3738" title="All 2 branches covered.">            if (index == -1) {</span>
<span class="fc" id="L3739">                throw SqlException.$(position, &quot;Invalid table name or alias&quot;);</span>
            }

<span class="fc bfc" id="L3742" title="All 2 branches covered.">            if (joinModels.getQuick(index).getAliasToColumnMap().excludes(columnName, dot + 1, columnName.length())) {</span>
<span class="fc" id="L3743">                throw SqlException.invalidColumn(position, columnName);</span>
            }

        }
<span class="fc" id="L3747">        return index;</span>
    }

    void clear() {
<span class="fc" id="L3751">        contextPool.clear();</span>
<span class="fc" id="L3752">        intHashSetPool.clear();</span>
<span class="fc" id="L3753">        joinClausesSwap1.clear();</span>
<span class="fc" id="L3754">        joinClausesSwap2.clear();</span>
<span class="fc" id="L3755">        constNameToIndex.clear();</span>
<span class="fc" id="L3756">        constNameToNode.clear();</span>
<span class="fc" id="L3757">        constNameToToken.clear();</span>
<span class="fc" id="L3758">        literalCollectorAIndexes.clear();</span>
<span class="fc" id="L3759">        literalCollectorBIndexes.clear();</span>
<span class="fc" id="L3760">        literalCollectorANames.clear();</span>
<span class="fc" id="L3761">        literalCollectorBNames.clear();</span>
<span class="fc" id="L3762">        defaultAliasCount = 0;</span>
<span class="fc" id="L3763">        expressionNodePool.clear();</span>
<span class="fc" id="L3764">        characterStore.clear();</span>
<span class="fc" id="L3765">        tablesSoFar.clear();</span>
<span class="fc" id="L3766">        clausesToSteal.clear();</span>
<span class="fc" id="L3767">        tmpCursorAliases.clear();</span>
<span class="fc" id="L3768">        functionsInFlight.clear();</span>
<span class="fc" id="L3769">    }</span>

    QueryModel optimise(final QueryModel model, SqlExecutionContext sqlExecutionContext) throws SqlException {
<span class="fc" id="L3772">        QueryModel rewrittenModel = model;</span>
        try {
<span class="fc" id="L3774">            rewrittenModel = bubbleUpOrderByAndLimitFromUnion(rewrittenModel);</span>
            //extractCorrelatedQueriesAsJoins(rewrittenModel);
<span class="fc" id="L3776">            optimiseExpressionModels(rewrittenModel, sqlExecutionContext);</span>
<span class="fc" id="L3777">            enumerateTableColumns(rewrittenModel, sqlExecutionContext);</span>
<span class="fc" id="L3778">            rewriteTopLevelLiteralsToFunctions(rewrittenModel);</span>
<span class="fc" id="L3779">            rewrittenModel = moveOrderByFunctionsIntoOuterSelect(rewrittenModel);</span>
<span class="fc" id="L3780">            resolveJoinColumns(rewrittenModel);</span>
<span class="fc" id="L3781">            optimiseBooleanNot(rewrittenModel);</span>
<span class="fc" id="L3782">            rewrittenModel = rewriteOrderBy(</span>
<span class="fc" id="L3783">                    rewriteOrderByPositionForUnionModels(</span>
<span class="fc" id="L3784">                            rewriteOrderByPosition(</span>
<span class="fc" id="L3785">                                    rewriteSelectClause(</span>
                                            rewrittenModel,
                                            true,
                                            sqlExecutionContext
                                    )
                            )
                    )
            );
<span class="fc" id="L3793">            optimiseOrderBy(rewrittenModel, OrderByMnemonic.ORDER_BY_UNKNOWN);</span>
<span class="fc" id="L3794">            createOrderHash(rewrittenModel);</span>
<span class="fc" id="L3795">            optimiseJoins(rewrittenModel);</span>
<span class="fc" id="L3796">            moveWhereInsideSubQueries(rewrittenModel);</span>
<span class="fc" id="L3797">            eraseColumnPrefixInWhereClauses(rewrittenModel);</span>
<span class="fc" id="L3798">            moveTimestampToChooseModel(rewrittenModel);</span>
<span class="fc" id="L3799">            propagateTopDownColumns(rewrittenModel, rewrittenModel.allowsColumnsChange());</span>
<span class="fc" id="L3800">            return rewrittenModel;</span>
<span class="fc" id="L3801">        } catch (SqlException e) {</span>
            // at this point models may have functions than need to be freed
<span class="fc" id="L3803">            Misc.freeObjList(functionsInFlight);</span>
<span class="fc" id="L3804">            functionsInFlight.clear();</span>
<span class="fc" id="L3805">            throw e;</span>
        }
    }

    void optimiseUpdate(QueryModel updateQueryModel, SqlExecutionContext sqlExecutionContext, TableRecordMetadata metadata) throws SqlException {
<span class="fc" id="L3810">        final QueryModel selectQueryModel = updateQueryModel.getNestedModel();</span>
<span class="fc" id="L3811">        selectQueryModel.setIsUpdate(true);</span>
<span class="fc" id="L3812">        QueryModel optimisedNested = optimise(selectQueryModel, sqlExecutionContext);</span>
<span class="pc bpc" id="L3813" title="1 of 2 branches missed.">        assert optimisedNested.isUpdate();</span>
<span class="fc" id="L3814">        updateQueryModel.setNestedModel(optimisedNested);</span>

        // And then generate plan for UPDATE top level QueryModel
<span class="fc" id="L3817">        validateUpdateColumns(updateQueryModel, metadata, sqlExecutionContext);</span>
<span class="fc" id="L3818">    }</span>

    void validateUpdateColumns(QueryModel updateQueryModel, TableRecordMetadata metadata, SqlExecutionContext sqlExecutionContext) throws SqlException {
        try {
<span class="fc" id="L3822">            tempList.clear(metadata.getColumnCount());</span>
<span class="fc" id="L3823">            tempList.setPos(metadata.getColumnCount());</span>
<span class="fc" id="L3824">            int timestampIndex = metadata.getTimestampIndex();</span>
<span class="fc" id="L3825">            int updateSetColumnCount = updateQueryModel.getUpdateExpressions().size();</span>
<span class="fc bfc" id="L3826" title="All 2 branches covered.">            for (int i = 0; i &lt; updateSetColumnCount; i++) {</span>

                // SET left hand side expressions are stored in top level UPDATE QueryModel
<span class="fc" id="L3829">                ExpressionNode columnExpression = updateQueryModel.getUpdateExpressions().get(i);</span>
<span class="fc" id="L3830">                int position = columnExpression.position;</span>
<span class="fc" id="L3831">                int columnIndex = metadata.getColumnIndexQuiet(columnExpression.token);</span>

                // SET right hand side expressions are stored in the Nested SELECT QueryModel as columns
<span class="fc" id="L3834">                QueryColumn queryColumn = updateQueryModel.getNestedModel().getColumns().get(i);</span>
<span class="fc bfc" id="L3835" title="All 2 branches covered.">                if (columnIndex &lt; 0) {</span>
<span class="fc" id="L3836">                    throw SqlException.invalidColumn(position, queryColumn.getName());</span>
                }
<span class="fc bfc" id="L3838" title="All 2 branches covered.">                if (columnIndex == timestampIndex) {</span>
<span class="fc" id="L3839">                    throw SqlException.$(position, &quot;Designated timestamp column cannot be updated&quot;);</span>
                }
<span class="pc bpc" id="L3841" title="1 of 2 branches missed.">                if (tempList.getQuick(columnIndex) == 1) {</span>
<span class="nc" id="L3842">                    throw SqlException.$(position, &quot;Duplicate column &quot;).put(queryColumn.getName()).put(&quot; in SET clause&quot;);</span>
                }

                // When column name case does not match table column name in left side of SET
                // for example if table &quot;tbl&quot; column name is &quot;Col&quot; but update uses
                // UPDATE tbl SET coL = 1
                // we need to replace to match metadata name exactly
<span class="fc" id="L3849">                CharSequence exactColName = metadata.getColumnName(columnIndex);</span>
<span class="fc" id="L3850">                queryColumn.of(exactColName, queryColumn.getAst());</span>
<span class="fc" id="L3851">                tempList.set(columnIndex, 1);</span>

<span class="fc" id="L3853">                ExpressionNode rhs = queryColumn.getAst();</span>
<span class="fc bfc" id="L3854" title="All 2 branches covered.">                if (rhs.type == FUNCTION) {</span>
<span class="fc bfc" id="L3855" title="All 2 branches covered.">                    if (functionParser.getFunctionFactoryCache().isGroupBy(rhs.token)) {</span>
<span class="fc" id="L3856">                        throw SqlException.$(rhs.position, &quot;Unsupported function in SET clause&quot;);</span>
                    }
                }
            }

<span class="fc" id="L3861">            TableToken tableToken = metadata.getTableToken();</span>
<span class="pc bpc" id="L3862" title="1 of 4 branches missed.">            if (!sqlExecutionContext.isWalApplication() &amp;&amp; !Chars.equals(tableToken.getTableName(), updateQueryModel.getTableName())) {</span>
                // Table renamed
<span class="nc" id="L3864">                throw TableReferenceOutOfDateException.of(updateQueryModel.getTableName());</span>
            }
<span class="fc" id="L3866">            updateQueryModel.setUpdateTableToken(tableToken);</span>
<span class="nc" id="L3867">        } catch (EntryLockedException e) {</span>
<span class="nc" id="L3868">            throw SqlException.position(updateQueryModel.getModelPosition()).put(&quot;table is locked: &quot;).put(tableLookupSequence);</span>
<span class="nc" id="L3869">        } catch (CairoException e) {</span>
<span class="nc" id="L3870">            throw SqlException.position(updateQueryModel.getModelPosition()).put(e);</span>
<span class="fc" id="L3871">        }</span>
<span class="fc" id="L3872">    }</span>

<span class="fc" id="L3874">    private static class LiteralCheckingVisitor implements PostOrderTreeTraversalAlgo.Visitor {</span>
        private LowerCaseCharSequenceObjHashMap&lt;QueryColumn&gt; nameTypeMap;

        @Override
        public void visit(ExpressionNode node) {
<span class="fc bfc" id="L3879" title="All 2 branches covered.">            if (node.type == LITERAL) {</span>
<span class="fc" id="L3880">                final int len = node.token.length();</span>
<span class="fc" id="L3881">                final int dot = Chars.indexOf(node.token, 0, len, '.');</span>
<span class="fc" id="L3882">                int index = nameTypeMap.keyIndex(node.token, dot + 1, len);</span>
                // these columns are pre-validated
<span class="pc bpc" id="L3884" title="1 of 2 branches missed.">                assert index &lt; 0;</span>
<span class="fc bfc" id="L3885" title="All 2 branches covered.">                if (nameTypeMap.valueAt(index).getAst().type != LITERAL) {</span>
<span class="fc" id="L3886">                    throw NonLiteralException.INSTANCE;</span>
                }
            }
<span class="fc" id="L3889">        }</span>

        PostOrderTreeTraversalAlgo.Visitor of(LowerCaseCharSequenceObjHashMap&lt;QueryColumn&gt; nameTypeMap) {
<span class="fc" id="L3892">            this.nameTypeMap = nameTypeMap;</span>
<span class="fc" id="L3893">            return this;</span>
        }
    }

<span class="fc" id="L3897">    private static class LiteralRewritingVisitor implements PostOrderTreeTraversalAlgo.Visitor {</span>
        private LowerCaseCharSequenceObjHashMap&lt;CharSequence&gt; aliasToColumnMap;

        @Override
        public void visit(ExpressionNode node) {
<span class="fc bfc" id="L3902" title="All 2 branches covered.">            if (node.type == LITERAL) {</span>
<span class="fc" id="L3903">                int dot = Chars.indexOf(node.token, '.');</span>
<span class="fc bfc" id="L3904" title="All 2 branches covered.">                int index = dot == -1 ? aliasToColumnMap.keyIndex(node.token) : aliasToColumnMap.keyIndex(node.token, dot + 1, node.token.length());</span>
                // we have table column hit when alias is not found
                // in this case expression rewrite is unnecessary
<span class="pc bpc" id="L3907" title="1 of 2 branches missed.">                if (index &lt; 0) {</span>
<span class="fc" id="L3908">                    CharSequence column = aliasToColumnMap.valueAtQuick(index);</span>
<span class="pc bpc" id="L3909" title="1 of 2 branches missed.">                    assert column != null;</span>
                    // it is also unnecessary to rewrite literal if target value is the same
<span class="fc bfc" id="L3911" title="All 2 branches covered.">                    if (!Chars.equals(node.token, column)) {</span>
<span class="fc" id="L3912">                        node.token = column;</span>
                    }
                }
            }
<span class="fc" id="L3916">        }</span>

        PostOrderTreeTraversalAlgo.Visitor of(LowerCaseCharSequenceObjHashMap&lt;CharSequence&gt; aliasToColumnMap) {
<span class="fc" id="L3919">            this.aliasToColumnMap = aliasToColumnMap;</span>
<span class="fc" id="L3920">            return this;</span>
        }
    }

    private static class NonLiteralException extends RuntimeException {
<span class="fc" id="L3925">        private static final NonLiteralException INSTANCE = new NonLiteralException();</span>
    }

<span class="fc" id="L3928">    private class ColumnPrefixEraser implements PostOrderTreeTraversalAlgo.Visitor {</span>

        @Override
        public void visit(ExpressionNode node) {
<span class="fc bfc" id="L3932" title="All 2 branches covered.">            switch (node.type) {</span>
                case ExpressionNode.FUNCTION:
                case ExpressionNode.OPERATION:
                case ExpressionNode.SET_OPERATION:
<span class="fc bfc" id="L3936" title="All 2 branches covered.">                    if (node.paramCount &lt; 3) {</span>
<span class="fc" id="L3937">                        node.lhs = rewrite(node.lhs);</span>
<span class="fc" id="L3938">                        node.rhs = rewrite(node.rhs);</span>
                    } else {
<span class="fc bfc" id="L3940" title="All 2 branches covered.">                        for (int i = 0, n = node.paramCount; i &lt; n; i++) {</span>
<span class="fc" id="L3941">                            node.args.setQuick(i, rewrite(node.args.getQuick(i)));</span>
                        }
                    }
<span class="fc" id="L3944">                    break;</span>
                default:
                    break;
            }
<span class="fc" id="L3948">        }</span>

        private ExpressionNode rewrite(ExpressionNode node) {
<span class="fc bfc" id="L3951" title="All 4 branches covered.">            if (node != null &amp;&amp; node.type == LITERAL) {</span>
<span class="fc" id="L3952">                final int dot = Chars.indexOf(node.token, '.');</span>
<span class="fc bfc" id="L3953" title="All 2 branches covered.">                if (dot != -1) {</span>
<span class="fc" id="L3954">                    return nextLiteral(node.token.subSequence(dot + 1, node.token.length()));</span>
                }
            }
<span class="fc" id="L3957">            return node;</span>
        }
    }

<span class="fc" id="L3961">    private class LiteralCollector implements PostOrderTreeTraversalAlgo.Visitor {</span>
        private int functionCount;
        private IntHashSet indexes;
        private QueryModel model;
        private ObjList&lt;CharSequence&gt; names;
        private int nullCount;

        @Override
        public void visit(ExpressionNode node) throws SqlException {
<span class="fc bfc" id="L3970" title="All 4 branches covered.">            switch (node.type) {</span>
                case LITERAL:
<span class="fc" id="L3972">                    int dot = Chars.indexOf(node.token, '.');</span>
<span class="fc bfc" id="L3973" title="All 2 branches covered.">                    CharSequence name = dot == -1 ? node.token : node.token.subSequence(dot + 1, node.token.length());</span>
<span class="fc" id="L3974">                    indexes.add(validateColumnAndGetModelIndex(model, node.token, dot, node.position));</span>
<span class="fc bfc" id="L3975" title="All 2 branches covered.">                    if (names != null) {</span>
<span class="fc" id="L3976">                        names.add(name);</span>
                    }
                    break;
                case ExpressionNode.CONSTANT:
<span class="fc bfc" id="L3980" title="All 2 branches covered.">                    if (nullConstants.contains(node.token)) {</span>
<span class="fc" id="L3981">                        nullCount++;</span>
                    }
                    break;
                case FUNCTION:
                case OPERATION:
<span class="fc" id="L3986">                    functionCount++;</span>
<span class="fc" id="L3987">                    break;</span>
                default:
                    break;
            }
<span class="fc" id="L3991">        }</span>

        private PostOrderTreeTraversalAlgo.Visitor lhs() {
<span class="fc" id="L3994">            indexes = literalCollectorAIndexes;</span>
<span class="fc" id="L3995">            names = literalCollectorANames;</span>
<span class="fc" id="L3996">            return this;</span>
        }

        private void resetCounts() {
<span class="fc" id="L4000">            nullCount = 0;</span>
<span class="fc" id="L4001">            functionCount = 0;</span>
<span class="fc" id="L4002">        }</span>

        private PostOrderTreeTraversalAlgo.Visitor rhs() {
<span class="fc" id="L4005">            indexes = literalCollectorBIndexes;</span>
<span class="fc" id="L4006">            names = literalCollectorBNames;</span>
<span class="fc" id="L4007">            return this;</span>
        }

        private PostOrderTreeTraversalAlgo.Visitor to(IntHashSet indexes) {
<span class="fc" id="L4011">            this.indexes = indexes;</span>
<span class="fc" id="L4012">            this.names = null;</span>
<span class="fc" id="L4013">            return this;</span>
        }

        private void withModel(QueryModel model) {
<span class="fc" id="L4017">            this.model = model;</span>
<span class="fc" id="L4018">        }</span>
    }

    static {
<span class="fc" id="L4022">        notOps.put(&quot;not&quot;, NOT_OP_NOT);</span>
<span class="fc" id="L4023">        notOps.put(&quot;and&quot;, NOT_OP_AND);</span>
<span class="fc" id="L4024">        notOps.put(&quot;or&quot;, NOT_OP_OR);</span>
<span class="fc" id="L4025">        notOps.put(&quot;&gt;&quot;, NOT_OP_GREATER);</span>
<span class="fc" id="L4026">        notOps.put(&quot;&gt;=&quot;, NOT_OP_GREATER_EQ);</span>
<span class="fc" id="L4027">        notOps.put(&quot;&lt;&quot;, NOT_OP_LESS);</span>
<span class="fc" id="L4028">        notOps.put(&quot;&lt;=&quot;, NOT_OP_LESS_EQ);</span>
<span class="fc" id="L4029">        notOps.put(&quot;=&quot;, NOT_OP_EQUAL);</span>
<span class="fc" id="L4030">        notOps.put(&quot;!=&quot;, NOT_OP_NOT_EQ);</span>
<span class="fc" id="L4031">        notOps.put(&quot;&lt;&gt;&quot;, NOT_OP_NOT_EQ);</span>

<span class="fc" id="L4033">        joinBarriers = new IntHashSet();</span>
<span class="fc" id="L4034">        joinBarriers.add(QueryModel.JOIN_OUTER);</span>
<span class="fc" id="L4035">        joinBarriers.add(QueryModel.JOIN_CROSS_LEFT);</span>
<span class="fc" id="L4036">        joinBarriers.add(QueryModel.JOIN_ASOF);</span>
<span class="fc" id="L4037">        joinBarriers.add(QueryModel.JOIN_SPLICE);</span>
<span class="fc" id="L4038">        joinBarriers.add(QueryModel.JOIN_LT);</span>

<span class="fc" id="L4040">        nullConstants.add(&quot;null&quot;);</span>
<span class="fc" id="L4041">        nullConstants.add(&quot;NaN&quot;);</span>

<span class="fc" id="L4043">        joinOps.put(&quot;=&quot;, JOIN_OP_EQUAL);</span>
<span class="fc" id="L4044">        joinOps.put(&quot;and&quot;, JOIN_OP_AND);</span>
<span class="fc" id="L4045">        joinOps.put(&quot;or&quot;, JOIN_OP_OR);</span>
<span class="fc" id="L4046">        joinOps.put(&quot;~&quot;, JOIN_OP_REGEX);</span>

<span class="fc" id="L4048">        flexColumnModelTypes.add(QueryModel.SELECT_MODEL_CHOOSE);</span>
<span class="fc" id="L4049">        flexColumnModelTypes.add(QueryModel.SELECT_MODEL_NONE);</span>
<span class="fc" id="L4050">        flexColumnModelTypes.add(QueryModel.SELECT_MODEL_DISTINCT);</span>
<span class="fc" id="L4051">        flexColumnModelTypes.add(QueryModel.SELECT_MODEL_VIRTUAL);</span>
<span class="fc" id="L4052">        flexColumnModelTypes.add(QueryModel.SELECT_MODEL_ANALYTIC);</span>
<span class="fc" id="L4053">        flexColumnModelTypes.add(QueryModel.SELECT_MODEL_GROUP_BY);</span>
<span class="fc" id="L4054">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>