<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin</a> &gt; <span class="el_source">SqlParser.java</span></div><h1>SqlParser.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin;

import io.questdb.cairo.CairoConfiguration;
import io.questdb.cairo.ColumnType;
import io.questdb.cairo.PartitionBy;
import io.questdb.cairo.TableUtils;
import io.questdb.cutlass.text.Atomicity;
import io.questdb.griffin.model.*;
import io.questdb.std.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import static io.questdb.cairo.SqlWalMode.*;
import static io.questdb.griffin.SqlKeywords.*;

public final class SqlParser {
    public static final int MAX_ORDER_BY_COLUMNS = 1560;
<span class="fc" id="L42">    private static final ExpressionNode ONE = ExpressionNode.FACTORY.newInstance().of(ExpressionNode.CONSTANT, &quot;1&quot;, 0, 0);</span>
<span class="fc" id="L43">    private static final ExpressionNode ZERO_OFFSET = ExpressionNode.FACTORY.newInstance().of(ExpressionNode.CONSTANT, &quot;'00:00'&quot;, 0, 0);</span>
<span class="fc" id="L44">    private static final LowerCaseAsciiCharSequenceHashSet columnAliasStop = new LowerCaseAsciiCharSequenceHashSet();</span>
<span class="fc" id="L45">    private static final LowerCaseAsciiCharSequenceHashSet groupByStopSet = new LowerCaseAsciiCharSequenceHashSet();</span>
<span class="fc" id="L46">    private static final LowerCaseAsciiCharSequenceIntHashMap joinStartSet = new LowerCaseAsciiCharSequenceIntHashMap();</span>
<span class="fc" id="L47">    private static final LowerCaseAsciiCharSequenceHashSet setOperations = new LowerCaseAsciiCharSequenceHashSet();</span>
<span class="fc" id="L48">    private static final LowerCaseAsciiCharSequenceHashSet tableAliasStop = new LowerCaseAsciiCharSequenceHashSet();</span>
    private final ObjectPool&lt;AnalyticColumn&gt; analyticColumnPool;
    private final CharacterStore characterStore;
    private final ObjectPool&lt;ColumnCastModel&gt; columnCastModelPool;
    private final CairoConfiguration configuration;
    private final ObjectPool&lt;CopyModel&gt; copyModelPool;
    private final ObjectPool&lt;CreateTableModel&gt; createTableModelPool;
    private final ObjectPool&lt;ExplainModel&gt; explainModelPool;
    private final ObjectPool&lt;ExpressionNode&gt; expressionNodePool;
    private final ExpressionParser expressionParser;
    private final ExpressionTreeBuilder expressionTreeBuilder;
    private final ObjectPool&lt;InsertModel&gt; insertModelPool;
    private final SqlOptimiser optimiser;
    private final ObjectPool&lt;QueryColumn&gt; queryColumnPool;
    private final ObjectPool&lt;QueryModel&gt; queryModelPool;
    private final ObjectPool&lt;RenameTableModel&gt; renameTableModelPool;
<span class="fc" id="L64">    private final PostOrderTreeTraversalAlgo.Visitor rewriteConcat0Ref = this::rewriteConcat0;</span>
<span class="fc" id="L65">    private final PostOrderTreeTraversalAlgo.Visitor rewriteCount0Ref = this::rewriteCount0;</span>
<span class="fc" id="L66">    private final PostOrderTreeTraversalAlgo.Visitor rewritePgCast0Ref = this::rewritePgCast0;</span>
<span class="fc" id="L67">    private final ObjList&lt;ExpressionNode&gt; tempExprNodes = new ObjList&lt;&gt;();</span>
<span class="fc" id="L68">    private final PostOrderTreeTraversalAlgo.Visitor rewriteCase0Ref = this::rewriteCase0;</span>
<span class="fc" id="L69">    private final LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; topLevelWithModel = new LowerCaseCharSequenceObjHashMap&lt;&gt;();</span>
    private final PostOrderTreeTraversalAlgo traversalAlgo;
    private final ObjectPool&lt;WithClauseModel&gt; withClauseModelPool;
<span class="fc" id="L72">    private boolean subQueryMode = false;</span>

    SqlParser(
            CairoConfiguration configuration,
            SqlOptimiser optimiser,
            CharacterStore characterStore,
            ObjectPool&lt;ExpressionNode&gt; expressionNodePool,
            ObjectPool&lt;QueryColumn&gt; queryColumnPool,
            ObjectPool&lt;QueryModel&gt; queryModelPool,
            PostOrderTreeTraversalAlgo traversalAlgo
<span class="fc" id="L82">    ) {</span>
<span class="fc" id="L83">        this.expressionNodePool = expressionNodePool;</span>
<span class="fc" id="L84">        this.queryModelPool = queryModelPool;</span>
<span class="fc" id="L85">        this.queryColumnPool = queryColumnPool;</span>
<span class="fc" id="L86">        this.expressionTreeBuilder = new ExpressionTreeBuilder();</span>
<span class="fc" id="L87">        this.analyticColumnPool = new ObjectPool&lt;&gt;(AnalyticColumn.FACTORY, configuration.getAnalyticColumnPoolCapacity());</span>
<span class="fc" id="L88">        this.createTableModelPool = new ObjectPool&lt;&gt;(CreateTableModel.FACTORY, configuration.getCreateTableModelPoolCapacity());</span>
<span class="fc" id="L89">        this.columnCastModelPool = new ObjectPool&lt;&gt;(ColumnCastModel.FACTORY, configuration.getColumnCastModelPoolCapacity());</span>
<span class="fc" id="L90">        this.renameTableModelPool = new ObjectPool&lt;&gt;(RenameTableModel.FACTORY, configuration.getRenameTableModelPoolCapacity());</span>
<span class="fc" id="L91">        this.withClauseModelPool = new ObjectPool&lt;&gt;(WithClauseModel.FACTORY, configuration.getWithClauseModelPoolCapacity());</span>
<span class="fc" id="L92">        this.insertModelPool = new ObjectPool&lt;&gt;(InsertModel.FACTORY, configuration.getInsertPoolCapacity());</span>
<span class="fc" id="L93">        this.copyModelPool = new ObjectPool&lt;&gt;(CopyModel.FACTORY, configuration.getCopyPoolCapacity());</span>
<span class="fc" id="L94">        this.explainModelPool = new ObjectPool&lt;&gt;(ExplainModel.FACTORY, configuration.getExplainPoolCapacity());</span>
<span class="fc" id="L95">        this.configuration = configuration;</span>
<span class="fc" id="L96">        this.traversalAlgo = traversalAlgo;</span>
<span class="fc" id="L97">        this.characterStore = characterStore;</span>
<span class="fc" id="L98">        this.optimiser = optimiser;</span>
<span class="fc" id="L99">        this.expressionParser = new ExpressionParser(expressionNodePool, this, characterStore);</span>
<span class="fc" id="L100">    }</span>

    public static boolean isFullSampleByPeriod(ExpressionNode n) {
<span class="fc bfc" id="L103" title="All 8 branches covered.">        return n != null &amp;&amp; (n.type == ExpressionNode.CONSTANT || (n.type == ExpressionNode.LITERAL &amp;&amp; isValidSampleByPeriodLetter(n.token)));</span>
    }

    private static SqlException err(GenericLexer lexer, @Nullable CharSequence tok, @NotNull String msg) {
<span class="fc" id="L107">        return SqlException.parserErr(lexer.lastTokenPosition(), tok, msg);</span>
    }

    private static SqlException errUnexpected(GenericLexer lexer, CharSequence token) {
<span class="fc" id="L111">        return SqlException.unexpectedToken(lexer.lastTokenPosition(), token);</span>
    }

    private static boolean isValidSampleByPeriodLetter(CharSequence token) {
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (token.length() != 1) return false;</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        switch (token.charAt(0)) {</span>
            case 'U':
                // micros
            case 'T':
                // millis
            case 's':
                // seconds
            case 'm':
                // minutes
            case 'h':
                // hours
            case 'd':
                // days
            case 'M':
                // months
            case 'y':
<span class="fc" id="L132">                return true;</span>
            default:
<span class="fc" id="L134">                return false;</span>
        }
    }

    private void addConcatArgs(ObjList&lt;ExpressionNode&gt; args, ExpressionNode leaf) {
<span class="fc bfc" id="L139" title="All 4 branches covered.">        if (leaf.type != ExpressionNode.FUNCTION || !isConcatKeyword(leaf.token)) {</span>
<span class="fc" id="L140">            args.add(leaf);</span>
<span class="fc" id="L141">            return;</span>
        }

        // Nested CONCAT. Expand it from CONCAT(x, CONCAT(y, z)) into CONCAT(x, y, z).
<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (leaf.args.size() &gt; 0) {</span>
<span class="fc" id="L146">            args.addAll(leaf.args);</span>
        } else {
<span class="fc" id="L148">            args.add(leaf.rhs);</span>
<span class="fc" id="L149">            args.add(leaf.lhs);</span>
        }
<span class="fc" id="L151">    }</span>

    private void assertNotDot(GenericLexer lexer, CharSequence tok) throws SqlException {
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (Chars.indexOf(tok, '.') != -1) {</span>
<span class="fc" id="L155">            throw SqlException.$(lexer.lastTokenPosition(), &quot;'.' is not allowed here&quot;);</span>
        }
<span class="fc" id="L157">    }</span>

    //prevent full/right from being used as table aliases
    private void checkSupportedJoinType(GenericLexer lexer, CharSequence tok) throws SqlException {
<span class="fc bfc" id="L161" title="All 6 branches covered.">        if (tok != null &amp;&amp; (SqlKeywords.isFullKeyword(tok) || SqlKeywords.isRightKeyword(tok))) {</span>
<span class="fc" id="L162">            throw SqlException.$((lexer.lastTokenPosition()), &quot;unsupported join type&quot;);</span>
        }
<span class="fc" id="L164">    }</span>

    private CharSequence createColumnAlias(ExpressionNode node, QueryModel model) {
<span class="fc" id="L167">        return SqlUtil.createColumnAlias(</span>
                characterStore,
<span class="fc" id="L169">                GenericLexer.unquote(node.token),</span>
<span class="fc" id="L170">                Chars.indexOf(node.token, '.'),</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                model.getAliasToColumnMap(),</span>
                node.type != ExpressionNode.LITERAL
        );
    }

    private void expectBy(GenericLexer lexer) throws SqlException {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (isByKeyword(tok(lexer, &quot;'by'&quot;))) {</span>
<span class="fc" id="L178">            return;</span>
        }
<span class="fc" id="L180">        throw SqlException.$((lexer.lastTokenPosition()), &quot;'by' expected&quot;);</span>
    }

    private ExpressionNode expectExpr(GenericLexer lexer) throws SqlException {
<span class="fc" id="L184">        final ExpressionNode n = expr(lexer, (QueryModel) null);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (n != null) {</span>
<span class="fc" id="L186">            return n;</span>
        }
<span class="fc bfc" id="L188" title="All 2 branches covered.">        throw SqlException.$(lexer.hasUnparsed() ? lexer.lastTokenPosition() : lexer.getPosition(), &quot;Expression expected&quot;);</span>
    }

    private int expectInt(GenericLexer lexer) throws SqlException {
<span class="fc" id="L192">        CharSequence tok = tok(lexer, &quot;integer&quot;);</span>
        boolean negative;
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (Chars.equals(tok, '-')) {</span>
<span class="fc" id="L195">            negative = true;</span>
<span class="fc" id="L196">            tok = tok(lexer, &quot;integer&quot;);</span>
        } else {
<span class="fc" id="L198">            negative = false;</span>
        }
        try {
<span class="fc" id="L201">            int result = Numbers.parseInt(tok);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            return negative ? -result : result;</span>
<span class="fc" id="L203">        } catch (NumericException e) {</span>
<span class="fc" id="L204">            throw err(lexer, tok, &quot;bad integer&quot;);</span>
        }
    }

    private ExpressionNode expectLiteral(GenericLexer lexer) throws SqlException {
<span class="fc" id="L209">        CharSequence tok = tok(lexer, &quot;literal&quot;);</span>
<span class="fc" id="L210">        int pos = lexer.lastTokenPosition();</span>
<span class="fc" id="L211">        validateLiteral(pos, tok);</span>
<span class="fc" id="L212">        return nextLiteral(GenericLexer.immutableOf(GenericLexer.unquote(tok)), pos);</span>
    }

    private long expectLong(GenericLexer lexer) throws SqlException {
<span class="fc" id="L216">        CharSequence tok = tok(lexer, &quot;long integer&quot;);</span>
        boolean negative;
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (Chars.equals(tok, '-')) {</span>
<span class="fc" id="L219">            negative = true;</span>
<span class="fc" id="L220">            tok = tok(lexer, &quot;long integer&quot;);</span>
        } else {
<span class="fc" id="L222">            negative = false;</span>
        }
        try {
<span class="fc" id="L225">            long result = Numbers.parseLong(tok);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">            return negative ? -result : result;</span>
<span class="fc" id="L227">        } catch (NumericException e) {</span>
<span class="fc" id="L228">            throw err(lexer, tok, &quot;bad long integer&quot;);</span>
        }
    }

    private void expectObservation(GenericLexer lexer) throws SqlException {
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (isObservationKeyword(tok(lexer, &quot;'observation'&quot;))) {</span>
<span class="fc" id="L234">            return;</span>
        }
<span class="fc" id="L236">        throw SqlException.$((lexer.lastTokenPosition()), &quot;'observation' expected&quot;);</span>
    }

    private void expectOffset(GenericLexer lexer) throws SqlException {
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (isOffsetKeyword(tok(lexer, &quot;'offset'&quot;))) {</span>
<span class="fc" id="L241">            return;</span>
        }
<span class="fc" id="L243">        throw SqlException.$((lexer.lastTokenPosition()), &quot;'offset' expected&quot;);</span>
    }

    private void expectSample(GenericLexer lexer, QueryModel model) throws SqlException {
<span class="fc" id="L247">        final ExpressionNode n = expr(lexer, (QueryModel) null);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (isFullSampleByPeriod(n)) {</span>
<span class="fc" id="L249">            model.setSampleBy(n);</span>
<span class="fc" id="L250">            return;</span>
        }
        // This is complex expression of sample by period. It must follow time unit interval
<span class="fc" id="L253">        ExpressionNode periodUnit = expectLiteral(lexer);</span>
<span class="pc bpc" id="L254" title="2 of 6 branches missed.">        if (periodUnit == null || periodUnit.type != ExpressionNode.LITERAL || !isValidSampleByPeriodLetter(periodUnit.token)) {</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">            int lexerPosition = lexer.hasUnparsed() ? lexer.lastTokenPosition() : lexer.getPosition();</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">            throw SqlException.$(periodUnit != null ? periodUnit.position : lexerPosition, &quot;one letter sample by period unit expected&quot;);</span>
        }
<span class="fc" id="L258">        model.setSampleBy(n, periodUnit);</span>
<span class="fc" id="L259">    }</span>

    private CharSequence expectTableNameOrSubQuery(GenericLexer lexer) throws SqlException {
<span class="fc" id="L262">        return tok(lexer, &quot;table name or sub-query&quot;);</span>
    }

    private void expectTo(GenericLexer lexer) throws SqlException {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (isToKeyword(tok(lexer, &quot;'to'&quot;))) {</span>
<span class="fc" id="L267">            return;</span>
        }
<span class="fc" id="L269">        throw SqlException.$((lexer.lastTokenPosition()), &quot;'to' expected&quot;);</span>
    }

    private void expectTok(GenericLexer lexer, CharSequence tok, CharSequence expected) throws SqlException {
<span class="fc bfc" id="L273" title="All 4 branches covered.">        if (tok == null || !Chars.equalsLowerCaseAscii(tok, expected)) {</span>
<span class="fc" id="L274">            throw SqlException.position(lexer.lastTokenPosition()).put('\'').put(expected).put(&quot;' expected&quot;);</span>
        }
<span class="fc" id="L276">    }</span>

    private void expectTok(GenericLexer lexer, CharSequence expected) throws SqlException {
<span class="fc" id="L279">        CharSequence tok = optTok(lexer);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L281">            throw SqlException.position(lexer.getPosition()).put('\'').put(expected).put(&quot;' expected&quot;);</span>
        }
<span class="fc" id="L283">        expectTok(lexer, tok, expected);</span>
<span class="fc" id="L284">    }</span>

    private void expectTok(GenericLexer lexer, char expected) throws SqlException {
<span class="fc" id="L287">        CharSequence tok = optTok(lexer);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L289">            throw SqlException.position(lexer.getPosition()).put('\'').put(expected).put(&quot;' expected&quot;);</span>
        }
<span class="fc" id="L291">        expectTok(tok, lexer.lastTokenPosition(), expected);</span>
<span class="fc" id="L292">    }</span>

    private void expectTok(CharSequence tok, int pos, char expected) throws SqlException {
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">        if (tok == null || !Chars.equals(tok, expected)) {</span>
<span class="fc" id="L296">            throw SqlException.position(pos).put('\'').put(expected).put(&quot;' expected&quot;);</span>
        }
<span class="fc" id="L298">    }</span>

    private void expectZone(GenericLexer lexer) throws SqlException {
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (isZoneKeyword(tok(lexer, &quot;'zone'&quot;))) {</span>
<span class="fc" id="L302">            return;</span>
        }
<span class="fc" id="L304">        throw SqlException.$((lexer.lastTokenPosition()), &quot;'zone' expected&quot;);</span>
    }

    private int getCreateTableColumnIndex(CreateTableModel model, CharSequence columnName, int position) throws SqlException {
<span class="fc" id="L308">        int index = model.getColumnIndex(columnName);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (index == -1) {</span>
<span class="fc" id="L310">            throw SqlException.invalidColumn(position, columnName);</span>
        }
<span class="fc" id="L312">        return index;</span>
    }

    private boolean isFieldTerm(CharSequence tok) {
<span class="fc bfc" id="L316" title="All 4 branches covered.">        return Chars.equals(tok, ')') || Chars.equals(tok, ',');</span>
    }

    private ExpressionNode literal(GenericLexer lexer, CharSequence name) {
<span class="fc" id="L320">        return literal(name, lexer.lastTokenPosition());</span>
    }

    private ExpressionNode literal(CharSequence name, int position) {
        // this can never be null in its current contexts
        // every time this function is called is after lexer.unparse(), which ensures non-null token.
<span class="fc" id="L326">        return expressionNodePool.next().of(ExpressionNode.LITERAL, GenericLexer.unquote(name), 0, position);</span>
    }

    private ExpressionNode nextLiteral(CharSequence token, int position) {
<span class="fc" id="L330">        return SqlUtil.nextLiteral(expressionNodePool, token, position);</span>
    }

    private CharSequence notTermTok(GenericLexer lexer) throws SqlException {
<span class="fc" id="L334">        CharSequence tok = tok(lexer, &quot;')' or ','&quot;);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (isFieldTerm(tok)) {</span>
<span class="fc" id="L336">            throw err(lexer, tok, &quot;missing column definition&quot;);</span>
        }
<span class="fc" id="L338">        return tok;</span>
    }

    private CharSequence optTok(GenericLexer lexer) {
<span class="fc" id="L342">        CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L343" title="All 6 branches covered.">        if (tok == null || (subQueryMode &amp;&amp; Chars.equals(tok, ')'))) {</span>
<span class="fc" id="L344">            return null;</span>
        }
<span class="fc" id="L346">        return tok;</span>
    }

    private QueryModel parseAsSubQueryAndExpectClosingBrace(GenericLexer lexer, LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; withClauses) throws SqlException {
<span class="fc" id="L350">        final QueryModel model = parseAsSubQuery(lexer, withClauses);</span>
<span class="fc" id="L351">        expectTok(lexer, ')');</span>
<span class="fc" id="L352">        return model;</span>
    }

    private ExecutionModel parseCopy(GenericLexer lexer) throws SqlException {
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (Chars.isBlank(configuration.getSqlCopyInputRoot())) {</span>
<span class="nc" id="L357">            throw SqlException.$(lexer.lastTokenPosition(), &quot;COPY is disabled ['cairo.sql.copy.root' is not set?]&quot;);</span>
        }
<span class="fc" id="L359">        ExpressionNode target = expectExpr(lexer);</span>
<span class="fc" id="L360">        CharSequence tok = tok(lexer, &quot;'from' or 'to' or 'cancel'&quot;);</span>

<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (isCancelKeyword(tok)) {</span>
<span class="fc" id="L363">            CopyModel model = copyModelPool.next();</span>
<span class="fc" id="L364">            model.setCancel(true);</span>
<span class="fc" id="L365">            model.setTarget(target);</span>
<span class="fc" id="L366">            return model;</span>
        }

<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        if (isFromKeyword(tok)) {</span>
<span class="fc" id="L370">            final ExpressionNode fileName = expectExpr(lexer);</span>
<span class="pc bpc" id="L371" title="1 of 4 branches missed.">            if (fileName.token.length() &lt; 3 &amp;&amp; Chars.startsWith(fileName.token, '\'')) {</span>
<span class="fc" id="L372">                throw SqlException.$(fileName.position, &quot;file name expected&quot;);</span>
            }

<span class="fc" id="L375">            CopyModel model = copyModelPool.next();</span>
<span class="fc" id="L376">            model.setTarget(target);</span>
<span class="fc" id="L377">            model.setFileName(fileName);</span>

<span class="fc" id="L379">            tok = optTok(lexer);</span>
<span class="fc bfc" id="L380" title="All 4 branches covered.">            if (tok != null &amp;&amp; isWithKeyword(tok)) {</span>
<span class="fc" id="L381">                tok = tok(lexer, &quot;copy option&quot;);</span>
<span class="fc bfc" id="L382" title="All 4 branches covered.">                while (tok != null &amp;&amp; !isSemicolon(tok)) {</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                    if (isHeaderKeyword(tok)) {</span>
<span class="fc" id="L384">                        model.setHeader(isTrueKeyword(tok(lexer, &quot;'true' or 'false'&quot;)));</span>
<span class="fc" id="L385">                        tok = optTok(lexer);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">                    } else if (isPartitionKeyword(tok)) {</span>
<span class="fc" id="L387">                        expectTok(lexer, &quot;by&quot;);</span>
<span class="fc" id="L388">                        tok = tok(lexer, &quot;year month day hour&quot;);</span>
<span class="fc" id="L389">                        int partitionBy = PartitionBy.fromString(tok);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">                        if (partitionBy == -1) {</span>
<span class="fc" id="L391">                            throw SqlException.$(lexer.getPosition(), &quot;'NONE', 'HOUR', 'DAY', 'MONTH' or 'YEAR' expected&quot;);</span>
                        }
<span class="fc" id="L393">                        model.setPartitionBy(partitionBy);</span>
<span class="fc" id="L394">                        tok = optTok(lexer);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">                    } else if (isTimestampKeyword(tok)) {</span>
<span class="fc" id="L396">                        tok = tok(lexer, &quot;timestamp column name expected&quot;);</span>
<span class="fc" id="L397">                        CharSequence columnName = GenericLexer.immutableOf(GenericLexer.unquote(tok));</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">                        if (!TableUtils.isValidColumnName(columnName, configuration.getMaxFileNameLength())) {</span>
<span class="nc" id="L399">                            throw SqlException.$(lexer.getPosition(), &quot;timestamp column name contains invalid characters&quot;);</span>
                        }
<span class="fc" id="L401">                        model.setTimestampColumnName(columnName);</span>
<span class="fc" id="L402">                        tok = optTok(lexer);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">                    } else if (isFormatKeyword(tok)) {</span>
<span class="fc" id="L404">                        tok = tok(lexer, &quot;timestamp format expected&quot;);</span>
<span class="fc" id="L405">                        CharSequence format = GenericLexer.immutableOf(GenericLexer.unquote(tok));</span>
<span class="fc" id="L406">                        model.setTimestampFormat(format);</span>
<span class="fc" id="L407">                        tok = optTok(lexer);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                    } else if (isOnKeyword(tok)) {</span>
<span class="fc" id="L409">                        expectTok(lexer, &quot;error&quot;);</span>
<span class="fc" id="L410">                        tok = tok(lexer, &quot;skip_column skip_row abort&quot;);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">                        if (Chars.equalsIgnoreCase(tok, &quot;skip_column&quot;)) {</span>
<span class="fc" id="L412">                            model.setAtomicity(Atomicity.SKIP_COL);</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">                        } else if (Chars.equalsIgnoreCase(tok, &quot;skip_row&quot;)) {</span>
<span class="fc" id="L414">                            model.setAtomicity(Atomicity.SKIP_ROW);</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">                        } else if (Chars.equalsIgnoreCase(tok, &quot;abort&quot;)) {</span>
<span class="fc" id="L416">                            model.setAtomicity(Atomicity.SKIP_ALL);</span>
                        } else {
<span class="fc" id="L418">                            throw SqlException.$(lexer.getPosition(), &quot;invalid 'on error' copy option found&quot;);</span>
                        }
<span class="fc" id="L420">                        tok = optTok(lexer);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                    } else if (isDelimiterKeyword(tok)) {</span>
<span class="fc" id="L422">                        tok = tok(lexer, &quot;timestamp character expected&quot;);</span>
<span class="fc" id="L423">                        CharSequence delimiter = GenericLexer.immutableOf(GenericLexer.unquote(tok));</span>
<span class="pc bpc" id="L424" title="1 of 4 branches missed.">                        if (delimiter == null || delimiter.length() != 1) {</span>
<span class="fc" id="L425">                            throw SqlException.$(lexer.getPosition(), &quot;delimiter is empty or contains more than 1 character&quot;);</span>
                        }
<span class="fc" id="L427">                        char delimiterChar = delimiter.charAt(0);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                        if (delimiterChar &gt; 127) {</span>
<span class="fc" id="L429">                            throw SqlException.$(lexer.getPosition(), &quot;delimiter is not an ascii character&quot;);</span>
                        }
<span class="fc" id="L431">                        model.setDelimiter((byte) delimiterChar);</span>
<span class="fc" id="L432">                        tok = optTok(lexer);</span>
<span class="fc" id="L433">                    } else {</span>
<span class="fc" id="L434">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;unexpected option&quot;);</span>
                    }
                }
<span class="fc bfc" id="L437" title="All 4 branches covered.">            } else if (tok != null &amp;&amp; !SqlKeywords.isSemicolon(tok)) {</span>
<span class="fc" id="L438">                throw SqlException.$(lexer.lastTokenPosition(), &quot;'with' expected&quot;);</span>
            }
<span class="fc" id="L440">            return model;</span>
        }
<span class="nc" id="L442">        throw SqlException.$(lexer.lastTokenPosition(), &quot;'from' expected&quot;);</span>
    }

    private ExecutionModel parseCreateStatement(GenericLexer lexer, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L446">        expectTok(lexer, &quot;table&quot;);</span>
<span class="fc" id="L447">        return parseCreateTable(lexer, executionContext);</span>
    }

    private ExecutionModel parseCreateTable(GenericLexer lexer, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L451">        final CreateTableModel model = createTableModelPool.next();</span>
        final CharSequence tableName;
<span class="fc" id="L453">        CharSequence tok = tok(lexer, &quot;table name or 'if'&quot;);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (SqlKeywords.isIfKeyword(tok)) {</span>
<span class="fc bfc" id="L455" title="All 4 branches covered.">            if (SqlKeywords.isNotKeyword(tok(lexer, &quot;'not'&quot;)) &amp;&amp; SqlKeywords.isExistsKeyword(tok(lexer, &quot;'exists'&quot;))) {</span>
<span class="fc" id="L456">                model.setIgnoreIfExists(true);</span>
<span class="fc" id="L457">                tableName = tok(lexer, &quot;table name&quot;);</span>
            } else {
<span class="fc" id="L459">                throw SqlException.$(lexer.lastTokenPosition(), &quot;'if not exists' expected&quot;);</span>
            }
        } else {
<span class="fc" id="L462">            tableName = tok;</span>
        }

<span class="fc" id="L465">        model.setName(nextLiteral(GenericLexer.assertNoDotsAndSlashes(GenericLexer.unquote(tableName), lexer.lastTokenPosition()), lexer.lastTokenPosition()));</span>

<span class="fc" id="L467">        tok = tok(lexer, &quot;'(' or 'as'&quot;);</span>

<span class="fc bfc" id="L469" title="All 2 branches covered.">        if (Chars.equals(tok, '(')) {</span>
<span class="fc" id="L470">            tok = tok(lexer, &quot;like&quot;);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">            if (isLikeKeyword(tok)) {</span>
<span class="fc" id="L472">                parseLikeTableName(lexer, model);</span>
<span class="fc" id="L473">                return model;</span>
            } else {
<span class="fc" id="L475">                lexer.unparseLast();</span>
<span class="fc" id="L476">                parseCreateTableColumns(lexer, model);</span>
            }
<span class="fc bfc" id="L478" title="All 2 branches covered.">        } else if (isAsKeyword(tok)) {</span>
<span class="fc" id="L479">            parseCreateTableAsSelect(lexer, model, executionContext);</span>
        } else {
<span class="fc" id="L481">            throw errUnexpected(lexer, tok);</span>
        }

<span class="fc bfc" id="L484" title="All 4 branches covered.">        while ((tok = optTok(lexer)) != null &amp;&amp; Chars.equals(tok, ',')) {</span>
<span class="fc" id="L485">            tok = tok(lexer, &quot;'index' or 'cast'&quot;);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (isIndexKeyword(tok)) {</span>
<span class="fc" id="L487">                parseCreateTableIndexDef(lexer, model);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">            } else if (isCastKeyword(tok)) {</span>
<span class="fc" id="L489">                parseCreateTableCastDef(lexer, model);</span>
            } else {
<span class="fc" id="L491">                throw errUnexpected(lexer, tok);</span>
            }
        }

<span class="fc" id="L495">        ExpressionNode timestamp = parseTimestamp(lexer, tok);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (timestamp != null) {</span>
            // ignore index, validate column
<span class="fc" id="L498">            int timestampIdx = getCreateTableColumnIndex(model, timestamp.token, timestamp.position);</span>
<span class="fc" id="L499">            int timestampType = model.getColumnType(timestampIdx);</span>
<span class="fc bfc" id="L500" title="All 4 branches covered.">            if (timestampType != ColumnType.TIMESTAMP &amp;&amp; timestampType != -1) { //type can be -1 for create table as select because types aren't known yet</span>
<span class="fc" id="L501">                throw SqlException.position(timestamp.position).put(&quot;TIMESTAMP column expected [actual=&quot;).put(ColumnType.nameOf(timestampType)).put(']');</span>
            }
<span class="fc" id="L503">            model.setTimestamp(timestamp);</span>
<span class="fc" id="L504">            tok = optTok(lexer);</span>
        }
<span class="fc" id="L506">        int maxUncommittedRows = configuration.getMaxUncommittedRows();</span>
<span class="fc" id="L507">        long o3MaxLag = configuration.getO3MaxLag();</span>

<span class="fc" id="L509">        int walSetting = WAL_NOT_SET;</span>

<span class="fc" id="L511">        ExpressionNode partitionBy = parseCreateTablePartition(lexer, tok);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (partitionBy != null) {</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">            if (model.getTimestamp() == null) {</span>
<span class="fc" id="L514">                throw SqlException.$(partitionBy.position, &quot;partitioning is possible only on tables with designated timestamps&quot;);</span>
            }
<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (PartitionBy.fromString(partitionBy.token) == -1) {</span>
<span class="fc" id="L517">                throw SqlException.$(partitionBy.position, &quot;'NONE', 'HOUR', 'DAY', 'MONTH' or 'YEAR' expected&quot;);</span>
            }
<span class="fc" id="L519">            model.setPartitionBy(partitionBy);</span>
<span class="fc" id="L520">            tok = optTok(lexer);</span>

<span class="fc bfc" id="L522" title="All 2 branches covered.">            if (tok != null) {</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">                if (isWalKeyword(tok)) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                    if (!PartitionBy.isPartitioned(model.getPartitionBy())) {</span>
<span class="fc" id="L525">                        throw SqlException.position(lexer.lastTokenPosition()).put(&quot;WAL Write Mode can only be used on partitioned tables&quot;);</span>
                    }
<span class="fc" id="L527">                    walSetting = WAL_ENABLED;</span>
<span class="fc" id="L528">                    tok = optTok(lexer);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">                } else if (isBypassKeyword(tok)) {</span>
<span class="fc" id="L530">                    tok = optTok(lexer);</span>
<span class="fc bfc" id="L531" title="All 4 branches covered.">                    if (tok != null &amp;&amp; isWalKeyword(tok)) {</span>
<span class="fc" id="L532">                        walSetting = WAL_DISABLED;</span>
<span class="fc" id="L533">                        tok = optTok(lexer);</span>
                    } else {
<span class="fc" id="L535">                        throw SqlException.position(</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">                                        tok == null ? lexer.getPosition() : lexer.lastTokenPosition()</span>
<span class="fc" id="L537">                                ).put(&quot; invalid syntax, should be BYPASS WAL but was BYPASS &quot;)</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">                                .put(tok != null ? tok : &quot;&quot;);</span>
                    }
                }
            }

<span class="fc bfc" id="L543" title="All 4 branches covered.">            if (tok != null &amp;&amp; isWithKeyword(tok)) {</span>
                ExpressionNode expr;
<span class="fc bfc" id="L545" title="All 2 branches covered.">                while ((expr = expr(lexer, (QueryModel) null)) != null) {</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">                    if (Chars.equals(expr.token, '=')) {</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                        if (isMaxUncommittedRowsKeyword(expr.lhs.token)) {</span>
                            try {
<span class="fc" id="L549">                                maxUncommittedRows = Numbers.parseInt(expr.rhs.token);</span>
<span class="fc" id="L550">                            } catch (NumericException e) {</span>
<span class="fc" id="L551">                                throw SqlException.position(lexer.getPosition()).put(&quot; could not parse maxUncommittedRows value \&quot;&quot;).put(expr.rhs.token).put('&quot;');</span>
<span class="fc" id="L552">                            }</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                        } else if (isO3MaxLagKeyword(expr.lhs.token)) {</span>
<span class="fc" id="L554">                            o3MaxLag = SqlUtil.expectMicros(expr.rhs.token, lexer.getPosition());</span>
                        } else {
<span class="fc" id="L556">                            throw SqlException.position(lexer.getPosition()).put(&quot; unrecognized &quot;).put(expr.lhs.token).put(&quot; after WITH&quot;);</span>
                        }
<span class="fc" id="L558">                        tok = optTok(lexer);</span>
<span class="fc bfc" id="L559" title="All 4 branches covered.">                        if (null != tok &amp;&amp; Chars.equals(tok, ',')) {</span>
<span class="fc" id="L560">                            continue;</span>
                        }
                        break;
                    }
<span class="fc" id="L564">                    throw SqlException.position(lexer.getPosition()).put(&quot; expected parameter after WITH&quot;);</span>
                }
            }
        }

<span class="fc" id="L569">        model.setMaxUncommittedRows(maxUncommittedRows);</span>
<span class="fc" id="L570">        model.setO3MaxLag(o3MaxLag);</span>
<span class="fc" id="L571">        final boolean isWalEnabled =</span>
<span class="pc bpc" id="L572" title="1 of 6 branches missed.">                configuration.isWalSupported() &amp;&amp; PartitionBy.isPartitioned(model.getPartitionBy()) &amp;&amp; (</span>
<span class="fc bfc" id="L573" title="All 4 branches covered.">                        (walSetting == WAL_NOT_SET &amp;&amp; configuration.getWalEnabledDefault()) || walSetting == WAL_ENABLED</span>
                );

<span class="fc" id="L576">        model.setWalEnabled(isWalEnabled);</span>

<span class="fc bfc" id="L578" title="All 4 branches covered.">        if (tok == null || Chars.equals(tok, ';')) {</span>
<span class="fc" id="L579">            return model;</span>
        }
<span class="fc" id="L581">        throw errUnexpected(lexer, tok);</span>
    }

    private void parseCreateTableAsSelect(GenericLexer lexer, CreateTableModel model, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L585">        expectTok(lexer, '(');</span>
<span class="fc" id="L586">        QueryModel queryModel = optimiser.optimise(parseDml(lexer, null, lexer.getPosition()), executionContext);</span>
<span class="fc" id="L587">        ObjList&lt;QueryColumn&gt; columns = queryModel.getBottomUpColumns();</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        assert columns.size() &gt; 0;</span>

        // we do not know types of columns at this stage
        // compiler must put table together using query metadata.
<span class="fc bfc" id="L592" title="All 2 branches covered.">        for (int i = 0, n = columns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L593">            model.addColumn(columns.getQuick(i).getName(), -1, configuration.getDefaultSymbolCapacity());</span>
        }

<span class="fc" id="L596">        model.setQueryModel(queryModel);</span>
<span class="fc" id="L597">        expectTok(lexer, ')');</span>
<span class="fc" id="L598">    }</span>

    private void parseCreateTableCastDef(GenericLexer lexer, CreateTableModel model) throws SqlException {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (model.getQueryModel() == null) {</span>
<span class="fc" id="L602">            throw SqlException.$(lexer.lastTokenPosition(), &quot;cast is only supported in 'create table as ...' context&quot;);</span>
        }
<span class="fc" id="L604">        expectTok(lexer, '(');</span>
<span class="fc" id="L605">        ColumnCastModel columnCastModel = columnCastModelPool.next();</span>

<span class="fc" id="L607">        final ExpressionNode columnName = expectLiteral(lexer);</span>
<span class="fc" id="L608">        columnCastModel.setName(columnName);</span>
<span class="fc" id="L609">        expectTok(lexer, &quot;as&quot;);</span>

<span class="fc" id="L611">        final ExpressionNode columnType = expectLiteral(lexer);</span>
<span class="fc" id="L612">        final int type = toColumnType(lexer, columnType.token);</span>
<span class="fc" id="L613">        columnCastModel.setType(type, columnName.position, columnType.position);</span>

<span class="fc bfc" id="L615" title="All 2 branches covered.">        if (ColumnType.isSymbol(type)) {</span>
<span class="fc" id="L616">            CharSequence tok = tok(lexer, &quot;'capacity', 'nocache', 'cache' or ')'&quot;);</span>

            int symbolCapacity;
            int capacityPosition;
<span class="fc bfc" id="L620" title="All 2 branches covered.">            if (isCapacityKeyword(tok)) {</span>
<span class="fc" id="L621">                capacityPosition = lexer.getPosition();</span>
<span class="fc" id="L622">                columnCastModel.setSymbolCapacity(symbolCapacity = parseSymbolCapacity(lexer));</span>
<span class="fc" id="L623">                tok = tok(lexer, &quot;'nocache', 'cache' or ')'&quot;);</span>
            } else {
<span class="fc" id="L625">                columnCastModel.setSymbolCapacity(configuration.getDefaultSymbolCapacity());</span>
<span class="fc" id="L626">                symbolCapacity = -1;</span>
<span class="fc" id="L627">                capacityPosition = -1;</span>
            }

            final boolean cached;
<span class="fc bfc" id="L631" title="All 2 branches covered.">            if (isNoCacheKeyword(tok)) {</span>
<span class="fc" id="L632">                cached = false;</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">            } else if (isCacheKeyword(tok)) {</span>
<span class="fc" id="L634">                cached = true;</span>
            } else {
<span class="fc" id="L636">                cached = configuration.getDefaultSymbolCacheFlag();</span>
<span class="fc" id="L637">                lexer.unparseLast();</span>
            }

<span class="fc" id="L640">            columnCastModel.setSymbolCacheFlag(cached);</span>

<span class="fc bfc" id="L642" title="All 4 branches covered.">            if (cached &amp;&amp; symbolCapacity != -1) {</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">                assert capacityPosition != -1;</span>
<span class="fc" id="L644">                TableUtils.validateSymbolCapacityCached(true, symbolCapacity, capacityPosition);</span>
            }

<span class="fc" id="L647">            columnCastModel.setIndexed(false);</span>
        }

<span class="fc" id="L650">        expectTok(lexer, ')');</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">        if (!model.addColumnCastModel(columnCastModel)) {</span>
<span class="fc" id="L653">            throw SqlException.$(columnCastModel.getName().position, &quot;duplicate cast&quot;);</span>
        }
<span class="fc" id="L655">    }</span>

    private void parseCreateTableColumns(GenericLexer lexer, CreateTableModel model) throws SqlException {
        while (true) {
<span class="fc" id="L659">            final int position = lexer.lastTokenPosition();</span>
<span class="fc" id="L660">            final CharSequence name = GenericLexer.immutableOf(GenericLexer.unquote(notTermTok(lexer)));</span>
<span class="fc" id="L661">            final int type = toColumnType(lexer, notTermTok(lexer));</span>

<span class="fc bfc" id="L663" title="All 2 branches covered.">            if (!TableUtils.isValidColumnName(name, configuration.getMaxFileNameLength())) {</span>
<span class="fc" id="L664">                throw SqlException.$(position, &quot; new column name contains invalid characters&quot;);</span>
            }

<span class="fc" id="L667">            model.addColumn(position, name, type, configuration.getDefaultSymbolCapacity());</span>

            CharSequence tok;
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (ColumnType.isSymbol(type)) {</span>
<span class="fc" id="L671">                tok = tok(lexer, &quot;'capacity', 'nocache', 'cache', 'index' or ')'&quot;);</span>

                int symbolCapacity;
<span class="fc bfc" id="L674" title="All 2 branches covered.">                if (isCapacityKeyword(tok)) {</span>
                    // when capacity is not set explicitly it will default via configuration
<span class="fc" id="L676">                    model.symbolCapacity(symbolCapacity = parseSymbolCapacity(lexer));</span>
<span class="fc" id="L677">                    tok = tok(lexer, &quot;'nocache', 'cache', 'index' or ')'&quot;);</span>
                } else {
<span class="fc" id="L679">                    symbolCapacity = -1;</span>
                }

                final boolean cached;
<span class="fc bfc" id="L683" title="All 2 branches covered.">                if (isNoCacheKeyword(tok)) {</span>
<span class="fc" id="L684">                    cached = false;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">                } else if (isCacheKeyword(tok)) {</span>
<span class="fc" id="L686">                    cached = true;</span>
                } else {
<span class="fc" id="L688">                    cached = configuration.getDefaultSymbolCacheFlag();</span>
<span class="fc" id="L689">                    lexer.unparseLast();</span>
                }
<span class="fc" id="L691">                model.cached(cached);</span>
<span class="fc bfc" id="L692" title="All 4 branches covered.">                if (cached &amp;&amp; symbolCapacity != -1) {</span>
<span class="fc" id="L693">                    TableUtils.validateSymbolCapacityCached(true, symbolCapacity, lexer.lastTokenPosition());</span>
                }
<span class="fc" id="L695">                tok = parseCreateTableInlineIndexDef(lexer, model);</span>
<span class="fc" id="L696">            } else {</span>
<span class="fc" id="L697">                tok = null;</span>
            }

<span class="fc bfc" id="L700" title="All 2 branches covered.">            if (tok == null) {</span>
<span class="fc" id="L701">                tok = tok(lexer, &quot;',' or ')'&quot;);</span>
            }

            //ignoring `PRECISION`
<span class="fc bfc" id="L705" title="All 2 branches covered.">            if (SqlKeywords.isPrecisionKeyword(tok)) {</span>
<span class="fc" id="L706">                tok = tok(lexer, &quot;'NOT' or 'NULL' or ',' or ')'&quot;);</span>
            }

            //ignoring `NULL` and `NOT NULL`
<span class="fc bfc" id="L710" title="All 2 branches covered.">            if (SqlKeywords.isNotKeyword(tok)) {</span>
<span class="fc" id="L711">                tok = tok(lexer, &quot;'NULL'&quot;);</span>
            }

<span class="fc bfc" id="L714" title="All 2 branches covered.">            if (SqlKeywords.isNullKeyword(tok)) {</span>
<span class="fc" id="L715">                tok = tok(lexer, &quot;','&quot;);</span>
            }

<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (Chars.equals(tok, ')')) {</span>
<span class="fc" id="L719">                break;</span>
            }

<span class="fc bfc" id="L722" title="All 2 branches covered.">            if (!Chars.equals(tok, ',')) {</span>
<span class="fc" id="L723">                throw err(lexer, tok, &quot;',' or ')' expected&quot;);</span>
            }
<span class="fc" id="L725">        }</span>
<span class="fc" id="L726">    }</span>

    private void parseCreateTableIndexDef(GenericLexer lexer, CreateTableModel model) throws SqlException {
<span class="fc" id="L729">        expectTok(lexer, '(');</span>
<span class="fc" id="L730">        final CharSequence columnName = expectLiteral(lexer).token;</span>
<span class="fc" id="L731">        final int position = lexer.lastTokenPosition();</span>
<span class="fc" id="L732">        final int columnIndex = getCreateTableColumnIndex(model, columnName, position);</span>
<span class="fc" id="L733">        final int columnType = model.getColumnType(columnIndex);</span>
<span class="fc bfc" id="L734" title="All 4 branches covered.">        if (columnType &gt; -1 &amp;&amp; !ColumnType.isSymbol(columnType)) {</span>
<span class="fc" id="L735">            throw SqlException.$(position, &quot;indexes are supported only for SYMBOL columns: &quot;).put(columnName);</span>
        }

<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (isCapacityKeyword(tok(lexer, &quot;'capacity'&quot;))) {</span>
<span class="fc" id="L739">            int errorPosition = lexer.getPosition();</span>
<span class="fc" id="L740">            int indexValueBlockSize = expectInt(lexer);</span>
<span class="fc" id="L741">            TableUtils.validateIndexValueBlockSize(errorPosition, indexValueBlockSize);</span>
<span class="fc" id="L742">            model.setIndexFlags(columnIndex, true, Numbers.ceilPow2(indexValueBlockSize));</span>
<span class="fc" id="L743">        } else {</span>
<span class="fc" id="L744">            model.setIndexFlags(columnIndex, true, configuration.getIndexValueBlockSize());</span>
<span class="fc" id="L745">            lexer.unparseLast();</span>
        }
<span class="fc" id="L747">        expectTok(lexer, ')');</span>
<span class="fc" id="L748">    }</span>

    private CharSequence parseCreateTableInlineIndexDef(GenericLexer lexer, CreateTableModel model) throws SqlException {
<span class="fc" id="L751">        CharSequence tok = tok(lexer, &quot;')', or 'index'&quot;);</span>

<span class="fc bfc" id="L753" title="All 2 branches covered.">        if (isFieldTerm(tok)) {</span>
<span class="fc" id="L754">            model.setIndexFlags(false, configuration.getIndexValueBlockSize());</span>
<span class="fc" id="L755">            return tok;</span>
        }

<span class="fc" id="L758">        expectTok(lexer, tok, &quot;index&quot;);</span>

<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (isFieldTerm(tok = tok(lexer, &quot;) | , expected&quot;))) {</span>
<span class="fc" id="L761">            model.setIndexFlags(true, configuration.getIndexValueBlockSize());</span>
<span class="fc" id="L762">            return tok;</span>
        }

<span class="fc" id="L765">        expectTok(lexer, tok, &quot;capacity&quot;);</span>

<span class="fc" id="L767">        int errorPosition = lexer.getPosition();</span>
<span class="fc" id="L768">        int indexValueBlockSize = expectInt(lexer);</span>
<span class="fc" id="L769">        TableUtils.validateIndexValueBlockSize(errorPosition, indexValueBlockSize);</span>
<span class="fc" id="L770">        model.setIndexFlags(true, Numbers.ceilPow2(indexValueBlockSize));</span>
<span class="fc" id="L771">        return null;</span>
    }

    private ExpressionNode parseCreateTablePartition(GenericLexer lexer, CharSequence tok) throws SqlException {
<span class="fc bfc" id="L775" title="All 4 branches covered.">        if (tok != null &amp;&amp; isPartitionKeyword(tok)) {</span>
<span class="fc" id="L776">            expectTok(lexer, &quot;by&quot;);</span>
<span class="fc" id="L777">            return expectLiteral(lexer);</span>
        }
<span class="fc" id="L779">        return null;</span>
    }

    private QueryModel parseDml(
            GenericLexer lexer,
            @Nullable LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; withClauses,
            int modelPosition
    ) throws SqlException {
<span class="fc" id="L787">        QueryModel model = null;</span>
<span class="fc" id="L788">        QueryModel prevModel = null;</span>
        while (true) {

<span class="fc bfc" id="L791" title="All 2 branches covered.">            LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; parentWithClauses = prevModel != null ? prevModel.getWithClauses() : withClauses;</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">            LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; topWithClauses = model == null ? topLevelWithModel : null;</span>

<span class="fc" id="L794">            QueryModel unionModel = parseDml0(lexer, parentWithClauses, topWithClauses, modelPosition);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">            if (prevModel == null) {</span>
<span class="fc" id="L796">                model = unionModel;</span>
<span class="fc" id="L797">                prevModel = model;</span>
            } else {
<span class="fc" id="L799">                prevModel.setUnionModel(unionModel);</span>
<span class="fc" id="L800">                prevModel = unionModel;</span>
            }

<span class="fc" id="L803">            CharSequence tok = optTok(lexer);</span>
<span class="fc bfc" id="L804" title="All 6 branches covered.">            if (tok == null || Chars.equals(tok, ';') || setOperations.excludes(tok)) {</span>
<span class="fc" id="L805">                lexer.unparseLast();</span>
<span class="fc" id="L806">                return model;</span>
            }

<span class="pc bpc" id="L809" title="1 of 2 branches missed.">            if (prevModel.getNestedModel() != null) {</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">                if (prevModel.getNestedModel().getOrderByPosition() &gt; 0) {</span>
<span class="fc" id="L811">                    throw SqlException.$(prevModel.getNestedModel().getOrderByPosition(), &quot;unexpected token 'order'&quot;);</span>
                }
<span class="fc bfc" id="L813" title="All 2 branches covered.">                if (prevModel.getNestedModel().getLimitPosition() &gt; 0) {</span>
<span class="fc" id="L814">                    throw SqlException.$(prevModel.getNestedModel().getLimitPosition(), &quot;unexpected token 'limit'&quot;);</span>
                }
            }

<span class="fc bfc" id="L818" title="All 2 branches covered.">            if (isUnionKeyword(tok)) {</span>
<span class="fc" id="L819">                tok = tok(lexer, &quot;all or select&quot;);</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">                if (isAllKeyword(tok)) {</span>
<span class="fc" id="L821">                    prevModel.setSetOperationType(QueryModel.SET_OPERATION_UNION_ALL);</span>
<span class="fc" id="L822">                    modelPosition = lexer.getPosition();</span>
                } else {
<span class="fc" id="L824">                    prevModel.setSetOperationType(QueryModel.SET_OPERATION_UNION);</span>
<span class="fc" id="L825">                    lexer.unparseLast();</span>
<span class="fc" id="L826">                    modelPosition = lexer.lastTokenPosition();</span>
                }
<span class="fc" id="L828">                continue;</span>
            }

<span class="fc bfc" id="L831" title="All 2 branches covered.">            if (isExceptKeyword(tok)) {</span>
<span class="fc" id="L832">                prevModel.setSetOperationType(QueryModel.SET_OPERATION_EXCEPT);</span>
<span class="fc" id="L833">                continue;</span>
            }

<span class="pc bpc" id="L836" title="1 of 2 branches missed.">            if (isIntersectKeyword(tok)) {</span>
<span class="fc" id="L837">                prevModel.setSetOperationType(QueryModel.SET_OPERATION_INTERSECT);</span>
            }
<span class="fc" id="L839">        }</span>
    }

    @NotNull
    private QueryModel parseDml0(
            GenericLexer lexer,
            @Nullable LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; parentWithClauses,
            @Nullable LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; topWithClauses,
            int modelPosition
    ) throws SqlException {
        CharSequence tok;
<span class="fc" id="L850">        QueryModel model = queryModelPool.next();</span>
<span class="fc" id="L851">        model.setModelPosition(modelPosition);</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">        if (parentWithClauses != null) {</span>
<span class="fc" id="L853">            model.getWithClauses().putAll(parentWithClauses);</span>
        }

<span class="fc" id="L856">        tok = tok(lexer, &quot;'select', 'with' or table name expected&quot;);</span>

<span class="fc bfc" id="L858" title="All 2 branches covered.">        if (isWithKeyword(tok)) {</span>
<span class="fc" id="L859">            parseWithClauses(lexer, model.getWithClauses());</span>
<span class="fc" id="L860">            tok = tok(lexer, &quot;'select' or table name expected&quot;);</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">        } else if (topWithClauses != null) {</span>
<span class="fc" id="L862">            model.getWithClauses().putAll(topWithClauses);</span>
        }

        // [select]
<span class="fc bfc" id="L866" title="All 2 branches covered.">        if (isSelectKeyword(tok)) {</span>
<span class="fc" id="L867">            parseSelectClause(lexer, model);</span>

<span class="fc" id="L869">            tok = optTok(lexer);</span>

<span class="fc bfc" id="L871" title="All 4 branches covered.">            if (tok != null &amp;&amp; setOperations.contains(tok)) {</span>
<span class="fc" id="L872">                tok = null;</span>
            }

<span class="fc bfc" id="L875" title="All 4 branches covered.">            if (tok == null || Chars.equals(tok, ';')) { //token can also be ';' on query boundary</span>
<span class="fc" id="L876">                QueryModel nestedModel = queryModelPool.next();</span>
<span class="fc" id="L877">                nestedModel.setModelPosition(modelPosition);</span>
<span class="fc" id="L878">                ExpressionNode func = expressionNodePool.next().of(ExpressionNode.FUNCTION, &quot;long_sequence&quot;, 0, lexer.lastTokenPosition());</span>
<span class="fc" id="L879">                func.paramCount = 1;</span>
<span class="fc" id="L880">                func.rhs = ONE;</span>
<span class="fc" id="L881">                nestedModel.setTableNameExpr(func);</span>
<span class="fc" id="L882">                model.setSelectModelType(QueryModel.SELECT_MODEL_VIRTUAL);</span>
<span class="fc" id="L883">                model.setNestedModel(nestedModel);</span>
<span class="fc" id="L884">                lexer.unparseLast();</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">                return model;</span>
            }
        } else {
<span class="fc" id="L888">            lexer.unparseLast();</span>
<span class="fc" id="L889">            SqlUtil.addSelectStar(</span>
                    model,
                    queryColumnPool,
                    expressionNodePool
            );
        }

<span class="fc" id="L896">        QueryModel nestedModel = queryModelPool.next();</span>
<span class="fc" id="L897">        nestedModel.setModelPosition(modelPosition);</span>

<span class="fc" id="L899">        parseFromClause(lexer, nestedModel, model);</span>
<span class="fc bfc" id="L900" title="All 4 branches covered.">        if (nestedModel.getLimitHi() != null || nestedModel.getLimitLo() != null) {</span>
<span class="fc" id="L901">            model.setLimit(nestedModel.getLimitLo(), nestedModel.getLimitHi());</span>
<span class="fc" id="L902">            nestedModel.setLimit(null, null);</span>
        }
<span class="fc" id="L904">        model.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);</span>
<span class="fc" id="L905">        model.setNestedModel(nestedModel);</span>
<span class="fc" id="L906">        final ExpressionNode n = nestedModel.getAlias();</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">        if (n != null) {</span>
<span class="fc" id="L908">            model.setAlias(n);</span>
        }
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">        return model;</span>
    }

    private QueryModel parseDmlUpdate(GenericLexer lexer) throws SqlException {
        // Update QueryModel structure is
        // QueryModel with SET column expressions (updateQueryModel)
        // |-- nested QueryModel of select-virtual or select-choose of data selected for update (fromModel)
        //     |-- nested QueryModel with selected data (nestedModel)
        //         |-- join QueryModels to represent FROM clause
        CharSequence tok;
<span class="fc" id="L920">        final int modelPosition = lexer.getPosition();</span>

<span class="fc" id="L922">        QueryModel updateQueryModel = queryModelPool.next();</span>
<span class="fc" id="L923">        updateQueryModel.setModelType(ExecutionModel.UPDATE);</span>
<span class="fc" id="L924">        updateQueryModel.setModelPosition(modelPosition);</span>
<span class="fc" id="L925">        QueryModel fromModel = queryModelPool.next();</span>
<span class="fc" id="L926">        fromModel.setModelPosition(modelPosition);</span>
<span class="fc" id="L927">        updateQueryModel.setIsUpdate(true);</span>
<span class="fc" id="L928">        fromModel.setIsUpdate(true);</span>
<span class="fc" id="L929">        tok = tok(lexer, &quot;UPDATE, WITH or table name expected&quot;);</span>

        // [update]
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        if (isUpdateKeyword(tok)) {</span>
            // parse SET statements into updateQueryModel and rhs of SETs into fromModel to select
<span class="fc" id="L934">            parseUpdateClause(lexer, updateQueryModel, fromModel);</span>

            // create nestedModel QueryModel to source rowids for the update
<span class="fc" id="L937">            QueryModel nestedModel = queryModelPool.next();</span>
<span class="fc" id="L938">            nestedModel.setTableNameExpr(fromModel.getTableNameExpr());</span>
<span class="fc" id="L939">            nestedModel.setAlias(updateQueryModel.getAlias());</span>
<span class="fc" id="L940">            nestedModel.setIsUpdate(true);</span>

            // nest nestedModel inside fromModel
<span class="fc" id="L943">            fromModel.setTableNameExpr(null);</span>
<span class="fc" id="L944">            fromModel.setNestedModel(nestedModel);</span>

            // Add WITH clauses if they exist into fromModel
<span class="fc" id="L947">            fromModel.getWithClauses().putAll(topLevelWithModel);</span>

<span class="fc" id="L949">            tok = optTok(lexer);</span>

            // [from]
<span class="fc bfc" id="L952" title="All 4 branches covered.">            if (tok != null &amp;&amp; isFromKeyword(tok)) {</span>
<span class="fc" id="L953">                tok = &quot;,&quot;; // FROM in Postgres UPDATE statement means cross join</span>
                int joinType;
<span class="fc" id="L955">                int i = 0;</span>
<span class="fc bfc" id="L956" title="All 4 branches covered.">                while (tok != null &amp;&amp; (joinType = joinStartSet.get(tok)) != -1) {</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">                    if (i++ == 1) {</span>
<span class="fc" id="L958">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;JOIN is not supported on UPDATE statement&quot;);</span>
                    }
                    // expect multiple [[inner | outer | cross] join]
<span class="fc" id="L961">                    nestedModel.addJoinModel(parseJoin(lexer, tok, joinType, topLevelWithModel));</span>
<span class="fc" id="L962">                    tok = optTok(lexer);</span>
                }
<span class="fc bfc" id="L964" title="All 4 branches covered.">            } else if (tok != null &amp;&amp; isSemicolon(tok)) {</span>
<span class="fc" id="L965">                tok = null;</span>
<span class="fc bfc" id="L966" title="All 4 branches covered.">            } else if (tok != null &amp;&amp; !isWhereKeyword(tok)) {</span>
<span class="fc" id="L967">                throw SqlException.$(lexer.lastTokenPosition(), &quot;FROM, WHERE or EOF expected&quot;);</span>
            }

            // [where]
<span class="fc bfc" id="L971" title="All 4 branches covered.">            if (tok != null &amp;&amp; isWhereKeyword(tok)) {</span>
<span class="fc" id="L972">                ExpressionNode expr = expr(lexer, fromModel);</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">                if (expr != null) {</span>
<span class="fc" id="L974">                    nestedModel.setWhereClause(expr);</span>
                } else {
<span class="fc" id="L976">                    throw SqlException.$((lexer.lastTokenPosition()), &quot;empty where clause&quot;);</span>
                }
<span class="fc bfc" id="L978" title="All 4 branches covered.">            } else if (tok != null &amp;&amp; !isSemicolon(tok)) {</span>
<span class="fc" id="L979">                throw errUnexpected(lexer, tok);</span>
            }

<span class="fc" id="L982">            updateQueryModel.setNestedModel(fromModel);</span>
        }
<span class="fc" id="L984">        return updateQueryModel;</span>
    }

    //doesn't allow copy, rename  
    private ExecutionModel parseExplain(GenericLexer lexer, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L989">        CharSequence tok = tok(lexer, &quot;'create', 'format', 'insert', 'update', 'select' or 'with'&quot;);</span>

<span class="fc bfc" id="L991" title="All 2 branches covered.">        if (isSelectKeyword(tok)) {</span>
<span class="fc" id="L992">            return parseSelect(lexer);</span>
        }

<span class="fc bfc" id="L995" title="All 2 branches covered.">        if (isCreateKeyword(tok)) {</span>
<span class="fc" id="L996">            return parseCreateStatement(lexer, executionContext);</span>
        }

<span class="fc bfc" id="L999" title="All 2 branches covered.">        if (isUpdateKeyword(tok)) {</span>
<span class="fc" id="L1000">            return parseUpdate(lexer);</span>
        }

<span class="fc bfc" id="L1003" title="All 2 branches covered.">        if (isInsertKeyword(tok)) {</span>
<span class="fc" id="L1004">            return parseInsert(lexer);</span>
        }

<span class="fc bfc" id="L1007" title="All 2 branches covered.">        if (isWithKeyword(tok)) {</span>
<span class="fc" id="L1008">            return parseWith(lexer);</span>
        }

<span class="fc" id="L1011">        return parseSelect(lexer);</span>
    }

    private int parseExplainOptions(GenericLexer lexer, CharSequence prevTok) throws SqlException {
<span class="fc" id="L1015">        int parenthesisPos = lexer.getPosition();</span>
<span class="fc" id="L1016">        CharSequence explainTok = GenericLexer.immutableOf(prevTok);</span>
<span class="fc" id="L1017">        CharSequence tok = tok(lexer, &quot;'create', 'insert', 'update', 'select', 'with' or '('&quot;);</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        if (Chars.equals(tok, '(')) {</span>
<span class="fc" id="L1019">            tok = tok(lexer, &quot;'format'&quot;);</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">            if (isFormatKeyword(tok)) {</span>
<span class="fc" id="L1021">                tok = tok(lexer, &quot;'text' or 'json'&quot;);</span>
<span class="fc bfc" id="L1022" title="All 4 branches covered.">                if (SqlKeywords.isTextKeyword(tok) || SqlKeywords.isJsonKeyword(tok)) {</span>
<span class="fc bfc" id="L1023" title="All 2 branches covered.">                    int format = SqlKeywords.isJsonKeyword(tok) ? ExplainModel.FORMAT_JSON : ExplainModel.FORMAT_TEXT;</span>
<span class="fc" id="L1024">                    tok = tok(lexer, &quot;')'&quot;);</span>
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">                    if (!Chars.equals(tok, ')')) {</span>
<span class="nc" id="L1026">                        throw SqlException.$((lexer.lastTokenPosition()), &quot;unexpected explain option found&quot;);</span>
                    }
<span class="fc" id="L1028">                    return format;</span>
                } else {
<span class="fc" id="L1030">                    throw SqlException.$((lexer.lastTokenPosition()), &quot;unexpected explain format found&quot;);</span>
                }
            } else {
<span class="fc" id="L1033">                lexer.backTo(parenthesisPos, explainTok);</span>
<span class="fc" id="L1034">                return ExplainModel.FORMAT_TEXT;</span>
            }
        } else {
<span class="fc" id="L1037">            lexer.unparseLast();</span>
<span class="fc" id="L1038">            return ExplainModel.FORMAT_TEXT;</span>
        }
    }

    private void parseFromClause(GenericLexer lexer, QueryModel model, QueryModel masterModel) throws SqlException {
<span class="fc" id="L1043">        CharSequence tok = expectTableNameOrSubQuery(lexer);</span>
        // expect &quot;(&quot; in case of sub-query

<span class="fc bfc" id="L1046" title="All 2 branches covered.">        if (Chars.equals(tok, '(')) {</span>
<span class="fc" id="L1047">            QueryModel proposedNested = parseAsSubQueryAndExpectClosingBrace(lexer, masterModel.getWithClauses());</span>
<span class="fc" id="L1048">            tok = optTok(lexer);</span>

            // do not collapse aliased sub-queries or those that have timestamp()
            // select * from (table) x
<span class="fc bfc" id="L1052" title="All 6 branches covered.">            if (tok == null || (tableAliasStop.contains(tok) &amp;&amp; !SqlKeywords.isTimestampKeyword(tok))) {</span>
<span class="fc" id="L1053">                final QueryModel target = proposedNested.getNestedModel();</span>
                // when * is artificial, there is no union, there is no &quot;where&quot; clause inside sub-query,
                // e.g. there was no &quot;select * from&quot; we should collapse sub-query to a regular table
<span class="fc" id="L1056">                if (</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">                        proposedNested.isArtificialStar()</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">                                &amp;&amp; proposedNested.getUnionModel() == null</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">                                &amp;&amp; target.getWhereClause() == null</span>
<span class="fc bfc" id="L1060" title="All 2 branches covered.">                                &amp;&amp; target.getOrderBy().size() == 0</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                                &amp;&amp; target.getLatestBy().size() == 0</span>
<span class="fc bfc" id="L1062" title="All 2 branches covered.">                                &amp;&amp; target.getNestedModel() == null</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">                                &amp;&amp; target.getSampleBy() == null</span>
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">                                &amp;&amp; target.getGroupBy().size() == 0</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">                                &amp;&amp; proposedNested.getLimitLo() == null</span>
<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">                                &amp;&amp; proposedNested.getLimitHi() == null</span>
                ) {
<span class="fc" id="L1068">                    model.setTableNameExpr(target.getTableNameExpr());</span>
<span class="fc" id="L1069">                    model.setAlias(target.getAlias());</span>
<span class="fc" id="L1070">                    model.setTimestamp(target.getTimestamp());</span>

<span class="fc" id="L1072">                    int n = target.getJoinModels().size();</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">                    for (int i = 1; i &lt; n; i++) {</span>
<span class="fc" id="L1074">                        model.addJoinModel(target.getJoinModels().getQuick(i));</span>
                    }
<span class="fc" id="L1076">                    proposedNested = null;</span>
<span class="fc" id="L1077">                } else {</span>
<span class="fc" id="L1078">                    lexer.unparseLast();</span>
                }
<span class="fc" id="L1080">            } else {</span>
<span class="fc" id="L1081">                lexer.unparseLast();</span>
            }

<span class="fc bfc" id="L1084" title="All 2 branches covered.">            if (proposedNested != null) {</span>
<span class="fc" id="L1085">                model.setNestedModel(proposedNested);</span>
<span class="fc" id="L1086">                model.setNestedModelIsSubQuery(true);</span>
<span class="fc" id="L1087">                tok = setModelAliasAndTimestamp(lexer, model);</span>
            }
<span class="fc" id="L1089">        } else {</span>
<span class="fc" id="L1090">            lexer.unparseLast();</span>
<span class="fc" id="L1091">            parseSelectFrom(lexer, model, masterModel.getWithClauses());</span>
<span class="fc" id="L1092">            tok = setModelAliasAndTimestamp(lexer, model);</span>

            // expect [latest by] (deprecated syntax)
<span class="fc bfc" id="L1095" title="All 4 branches covered.">            if (tok != null &amp;&amp; isLatestKeyword(tok)) {</span>
<span class="fc" id="L1096">                parseLatestBy(lexer, model);</span>
<span class="fc" id="L1097">                tok = optTok(lexer);</span>
            }
        }

        // expect multiple [[inner | outer | cross] join]
        int joinType;
<span class="fc bfc" id="L1103" title="All 4 branches covered.">        while (tok != null &amp;&amp; (joinType = joinStartSet.get(tok)) != -1) {</span>
<span class="fc" id="L1104">            model.addJoinModel(parseJoin(lexer, tok, joinType, masterModel.getWithClauses()));</span>
<span class="fc" id="L1105">            tok = optTok(lexer);</span>
        }

<span class="fc" id="L1108">        checkSupportedJoinType(lexer, tok);</span>

        // expect [where]

<span class="fc bfc" id="L1112" title="All 4 branches covered.">        if (tok != null &amp;&amp; isWhereKeyword(tok)) {</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">            if (model.getLatestByType() == QueryModel.LATEST_BY_NEW) {</span>
<span class="fc" id="L1114">                throw SqlException.$((lexer.lastTokenPosition()), &quot;unexpected where clause after 'latest on'&quot;);</span>
            }
<span class="fc" id="L1116">            ExpressionNode expr = expr(lexer, model);</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">            if (expr != null) {</span>
<span class="fc" id="L1118">                model.setWhereClause(expr);</span>
<span class="fc" id="L1119">                tok = optTok(lexer);</span>
            } else {
<span class="fc" id="L1121">                throw SqlException.$((lexer.lastTokenPosition()), &quot;empty where clause&quot;);</span>
            }
        }

        // expect [latest by] (new syntax)

<span class="fc bfc" id="L1127" title="All 4 branches covered.">        if (tok != null &amp;&amp; isLatestKeyword(tok)) {</span>
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">            if (model.getLatestByType() == QueryModel.LATEST_BY_DEPRECATED) {</span>
<span class="nc" id="L1129">                throw SqlException.$((lexer.lastTokenPosition()), &quot;mix of new and deprecated 'latest by' syntax&quot;);</span>
            }
<span class="fc" id="L1131">            expectTok(lexer, &quot;on&quot;);</span>
<span class="fc" id="L1132">            parseLatestByNew(lexer, model);</span>
<span class="fc" id="L1133">            tok = optTok(lexer);</span>
        }

        // expect [sample by]

<span class="fc bfc" id="L1138" title="All 4 branches covered.">        if (tok != null &amp;&amp; isSampleKeyword(tok)) {</span>
<span class="fc" id="L1139">            expectBy(lexer);</span>
<span class="fc" id="L1140">            expectSample(lexer, model);</span>
<span class="fc" id="L1141">            tok = optTok(lexer);</span>

<span class="fc bfc" id="L1143" title="All 4 branches covered.">            if (tok != null &amp;&amp; isFillKeyword(tok)) {</span>
<span class="fc" id="L1144">                expectTok(lexer, '(');</span>
                do {
<span class="fc" id="L1146">                    final ExpressionNode fillNode = expr(lexer, model);</span>
<span class="fc bfc" id="L1147" title="All 2 branches covered.">                    if (fillNode == null) {</span>
<span class="fc" id="L1148">                        throw SqlException.$(lexer.lastTokenPosition(), &quot;'none', 'prev', 'mid', 'null' or number expected&quot;);</span>
                    }
<span class="fc" id="L1150">                    model.addSampleByFill(fillNode);</span>
<span class="fc" id="L1151">                    tok = tokIncludingLocalBrace(lexer, &quot;',' or ')'&quot;);</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">                    if (Chars.equals(tok, ')')) {</span>
<span class="fc" id="L1153">                        break;</span>
                    }
<span class="fc" id="L1155">                    expectTok(tok, lexer.lastTokenPosition(), ',');</span>
<span class="fc" id="L1156">                } while (true);</span>

<span class="fc" id="L1158">                tok = optTok(lexer);</span>
            }

<span class="fc bfc" id="L1161" title="All 4 branches covered.">            if (tok != null &amp;&amp; isAlignKeyword(tok)) {</span>
<span class="fc" id="L1162">                expectTo(lexer);</span>

<span class="fc" id="L1164">                tok = tok(lexer, &quot;'calendar' or 'first observation'&quot;);</span>

<span class="fc bfc" id="L1166" title="All 2 branches covered.">                if (isCalendarKeyword(tok)) {</span>
<span class="fc" id="L1167">                    tok = optTok(lexer);</span>
<span class="fc bfc" id="L1168" title="All 2 branches covered.">                    if (tok == null) {</span>
<span class="fc" id="L1169">                        model.setSampleByTimezoneName(null);</span>
<span class="fc" id="L1170">                        model.setSampleByOffset(ZERO_OFFSET);</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">                    } else if (isTimeKeyword(tok)) {</span>
<span class="fc" id="L1172">                        expectZone(lexer);</span>
<span class="fc" id="L1173">                        model.setSampleByTimezoneName(expectExpr(lexer));</span>
<span class="fc" id="L1174">                        tok = optTok(lexer);</span>
<span class="fc bfc" id="L1175" title="All 4 branches covered.">                        if (tok != null &amp;&amp; isWithKeyword(tok)) {</span>
<span class="fc" id="L1176">                            tok = parseWithOffset(lexer, model);</span>
                        } else {
<span class="fc" id="L1178">                            model.setSampleByOffset(ZERO_OFFSET);</span>
                        }
<span class="fc bfc" id="L1180" title="All 2 branches covered.">                    } else if (isWithKeyword(tok)) {</span>
<span class="fc" id="L1181">                        tok = parseWithOffset(lexer, model);</span>
                    } else {
<span class="fc" id="L1183">                        model.setSampleByTimezoneName(null);</span>
<span class="fc" id="L1184">                        model.setSampleByOffset(ZERO_OFFSET);</span>
                    }
<span class="fc bfc" id="L1186" title="All 2 branches covered.">                } else if (isFirstKeyword(tok)) {</span>
<span class="fc" id="L1187">                    expectObservation(lexer);</span>
<span class="fc" id="L1188">                    model.setSampleByTimezoneName(null);</span>
<span class="fc" id="L1189">                    model.setSampleByOffset(null);</span>
<span class="fc" id="L1190">                    tok = optTok(lexer);</span>
                } else {
<span class="fc" id="L1192">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;'calendar' or 'first observation' expected&quot;);</span>
                }
            }
        }

        // expect [group by]

<span class="fc bfc" id="L1199" title="All 4 branches covered.">        if (tok != null &amp;&amp; isGroupKeyword(tok)) {</span>
<span class="fc" id="L1200">            expectBy(lexer);</span>
            do {
<span class="fc" id="L1202">                tokIncludingLocalBrace(lexer, &quot;literal&quot;);</span>
<span class="fc" id="L1203">                lexer.unparseLast();</span>
<span class="fc" id="L1204">                ExpressionNode n = expr(lexer, model);</span>
<span class="pc bpc" id="L1205" title="1 of 10 branches missed.">                if (n == null || (n.type != ExpressionNode.LITERAL &amp;&amp; n.type != ExpressionNode.CONSTANT &amp;&amp; n.type != ExpressionNode.FUNCTION &amp;&amp; n.type != ExpressionNode.OPERATION)) {</span>
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">                    throw SqlException.$(n == null ? lexer.lastTokenPosition() : n.position, &quot;literal expected&quot;);</span>
                }

<span class="fc" id="L1209">                model.addGroupBy(n);</span>

<span class="fc" id="L1211">                tok = optTok(lexer);</span>
<span class="fc bfc" id="L1212" title="All 4 branches covered.">            } while (tok != null &amp;&amp; Chars.equals(tok, ','));</span>
        }

        // expect [order by]

<span class="fc bfc" id="L1217" title="All 4 branches covered.">        if (tok != null &amp;&amp; isOrderKeyword(tok)) {</span>
<span class="fc" id="L1218">            model.setOrderByPosition(lexer.lastTokenPosition());</span>
<span class="fc" id="L1219">            expectBy(lexer);</span>
            do {
<span class="fc" id="L1221">                tokIncludingLocalBrace(lexer, &quot;literal&quot;);</span>
<span class="fc" id="L1222">                lexer.unparseLast();</span>

<span class="fc" id="L1224">                ExpressionNode n = expr(lexer, model);</span>
<span class="pc bpc" id="L1225" title="2 of 6 branches missed.">                if (n == null || (n.type == ExpressionNode.QUERY || n.type == ExpressionNode.SET_OPERATION)) {</span>
<span class="fc" id="L1226">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;literal or expression expected&quot;);</span>
                }

<span class="fc" id="L1229">                tok = optTok(lexer);</span>

<span class="fc bfc" id="L1231" title="All 4 branches covered.">                if (tok != null &amp;&amp; isDescKeyword(tok)) {</span>

<span class="fc" id="L1233">                    model.addOrderBy(n, QueryModel.ORDER_DIRECTION_DESCENDING);</span>
<span class="fc" id="L1234">                    tok = optTok(lexer);</span>

                } else {

<span class="fc" id="L1238">                    model.addOrderBy(n, QueryModel.ORDER_DIRECTION_ASCENDING);</span>

<span class="fc bfc" id="L1240" title="All 4 branches covered.">                    if (tok != null &amp;&amp; isAscKeyword(tok)) {</span>
<span class="fc" id="L1241">                        tok = optTok(lexer);</span>
                    }
                }

<span class="fc bfc" id="L1245" title="All 2 branches covered.">                if (model.getOrderBy().size() &gt;= MAX_ORDER_BY_COLUMNS) {</span>
<span class="fc" id="L1246">                    throw err(lexer, tok, &quot;Too many columns&quot;);</span>
                }

<span class="fc bfc" id="L1249" title="All 4 branches covered.">            } while (tok != null &amp;&amp; Chars.equals(tok, ','));</span>
        }

        // expect [limit]
<span class="fc bfc" id="L1253" title="All 4 branches covered.">        if (tok != null &amp;&amp; isLimitKeyword(tok)) {</span>
<span class="fc" id="L1254">            model.setLimitPosition(lexer.lastTokenPosition());</span>
<span class="fc" id="L1255">            ExpressionNode lo = expr(lexer, model);</span>
<span class="fc" id="L1256">            ExpressionNode hi = null;</span>

<span class="fc" id="L1258">            tok = optTok(lexer);</span>
<span class="fc bfc" id="L1259" title="All 4 branches covered.">            if (tok != null &amp;&amp; Chars.equals(tok, ',')) {</span>
<span class="fc" id="L1260">                hi = expr(lexer, model);</span>
            } else {
<span class="fc" id="L1262">                lexer.unparseLast();</span>
            }
<span class="fc" id="L1264">            model.setLimit(lo, hi);</span>
<span class="fc" id="L1265">        } else {</span>
<span class="fc" id="L1266">            lexer.unparseLast();</span>
        }
<span class="fc" id="L1268">    }</span>

    private ExecutionModel parseInsert(GenericLexer lexer) throws SqlException {

<span class="fc" id="L1272">        final InsertModel model = insertModelPool.next();</span>
<span class="fc" id="L1273">        CharSequence tok = tok(lexer, &quot;into or batch&quot;);</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">        if (SqlKeywords.isBatchKeyword(tok)) {</span>
<span class="fc" id="L1275">            long val = expectLong(lexer);</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">            if (val &gt; 0) {</span>
<span class="fc" id="L1277">                model.setBatchSize(val);</span>
            } else {
<span class="fc" id="L1279">                throw SqlException.$(lexer.lastTokenPosition(), &quot;batch size must be positive integer&quot;);</span>
            }

<span class="fc" id="L1282">            tok = tok(lexer, &quot;into or o3MaxLag&quot;);</span>
<span class="fc bfc" id="L1283" title="All 2 branches covered.">            if (SqlKeywords.isO3MaxLagKeyword(tok)) {</span>
<span class="fc" id="L1284">                int pos = lexer.getPosition();</span>
<span class="fc" id="L1285">                model.setO3MaxLag(SqlUtil.expectMicros(tok(lexer, &quot;lag value&quot;), pos));</span>
<span class="fc" id="L1286">                expectTok(lexer, &quot;into&quot;);</span>
            }
        }

<span class="fc bfc" id="L1290" title="All 2 branches covered.">        if (!SqlKeywords.isIntoKeyword(tok)) {</span>
<span class="fc" id="L1291">            throw SqlException.$(lexer.lastTokenPosition(), &quot;'into' expected&quot;);</span>
        }

<span class="fc" id="L1294">        tok = tok(lexer, &quot;table name&quot;);</span>

<span class="fc" id="L1296">        model.setTableName(nextLiteral(GenericLexer.assertNoDotsAndSlashes(GenericLexer.unquote(tok), lexer.lastTokenPosition()), lexer.lastTokenPosition()));</span>

<span class="fc" id="L1298">        tok = tok(lexer, &quot;'(' or 'select'&quot;);</span>

<span class="fc bfc" id="L1300" title="All 2 branches covered.">        if (Chars.equals(tok, '(')) {</span>
            do {
<span class="fc" id="L1302">                tok = tok(lexer, &quot;column&quot;);</span>
<span class="fc bfc" id="L1303" title="All 2 branches covered.">                if (Chars.equals(tok, ')')) {</span>
<span class="fc" id="L1304">                    throw err(lexer, tok, &quot;missing column name&quot;);</span>
                }

<span class="fc" id="L1307">                model.addColumn(GenericLexer.unquote(tok), lexer.lastTokenPosition());</span>

<span class="fc bfc" id="L1309" title="All 2 branches covered.">            } while (Chars.equals((tok = tok(lexer, &quot;','&quot;)), ','));</span>

<span class="fc" id="L1311">            expectTok(tok, lexer.lastTokenPosition(), ')');</span>
<span class="fc" id="L1312">            tok = optTok(lexer);</span>
        }

<span class="fc bfc" id="L1315" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L1316">            throw SqlException.$(lexer.getPosition(), &quot;'select' or 'values' expected&quot;);</span>
        }

<span class="fc bfc" id="L1319" title="All 2 branches covered.">        if (isSelectKeyword(tok)) {</span>
<span class="fc" id="L1320">            model.setSelectKeywordPosition(lexer.lastTokenPosition());</span>
<span class="fc" id="L1321">            lexer.unparseLast();</span>
<span class="fc" id="L1322">            final QueryModel queryModel = parseDml(lexer, null, lexer.lastTokenPosition());</span>
<span class="fc" id="L1323">            model.setQueryModel(queryModel);</span>
<span class="fc" id="L1324">            return model;</span>
        }

<span class="fc bfc" id="L1327" title="All 2 branches covered.">        if (isValuesKeyword(tok)) {</span>
            do {
<span class="fc" id="L1329">                expectTok(lexer, '(');</span>
<span class="fc" id="L1330">                ObjList&lt;ExpressionNode&gt; rowValues = new ObjList&lt;&gt;();</span>
                do {
<span class="fc" id="L1332">                    rowValues.add(expectExpr(lexer));</span>
<span class="fc bfc" id="L1333" title="All 2 branches covered.">                } while (Chars.equals((tok = tok(lexer, &quot;','&quot;)), ','));</span>
<span class="fc" id="L1334">                expectTok(tok, lexer.lastTokenPosition(), ')');</span>
<span class="fc" id="L1335">                model.addRowTupleValues(rowValues);</span>
<span class="fc" id="L1336">                model.addEndOfRowTupleValuesPosition(lexer.lastTokenPosition());</span>
<span class="fc" id="L1337">                tok = optTok(lexer);</span>
                // no more tokens or ';' should indicate end of statement
<span class="fc bfc" id="L1339" title="All 4 branches covered.">                if (tok == null || Chars.equals(tok, ';')) {</span>
<span class="fc" id="L1340">                    return model;</span>
                }
<span class="fc" id="L1342">                expectTok(tok, lexer.lastTokenPosition(), ',');</span>
<span class="fc" id="L1343">            } while (true);</span>
        }

<span class="fc" id="L1346">        throw err(lexer, tok, &quot;'select' or 'values' expected&quot;);</span>
    }

    private QueryModel parseJoin(GenericLexer lexer, CharSequence tok, int joinType, LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; parent) throws SqlException {
<span class="fc" id="L1350">        QueryModel joinModel = queryModelPool.next();</span>

<span class="fc" id="L1352">        int errorPos = lexer.lastTokenPosition();</span>

<span class="fc bfc" id="L1354" title="All 4 branches covered.">        if (isNotJoinKeyword(tok) &amp;&amp; !Chars.equals(tok, ',')) {</span>
            // not already a join?
            // was it &quot;left&quot; ?
<span class="fc bfc" id="L1357" title="All 2 branches covered.">            if (isLeftKeyword(tok)) {</span>
<span class="fc" id="L1358">                tok = tok(lexer, &quot;join&quot;);</span>
<span class="fc" id="L1359">                joinType = QueryModel.JOIN_OUTER;</span>
<span class="fc bfc" id="L1360" title="All 2 branches covered.">                if (isOuterKeyword(tok)) {</span>
<span class="fc" id="L1361">                    tok = tok(lexer, &quot;join&quot;);</span>
                }
            } else {
<span class="fc" id="L1364">                tok = tok(lexer, &quot;join&quot;);</span>
            }
<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">            if (isNotJoinKeyword(tok)) {</span>
<span class="nc" id="L1367">                throw SqlException.position(errorPos).put(&quot;'join' expected&quot;);</span>
            }
        }

<span class="fc" id="L1371">        joinModel.setJoinType(joinType);</span>
<span class="fc" id="L1372">        joinModel.setJoinKeywordPosition(errorPos);</span>

<span class="fc" id="L1374">        tok = expectTableNameOrSubQuery(lexer);</span>

<span class="fc bfc" id="L1376" title="All 2 branches covered.">        if (Chars.equals(tok, '(')) {</span>
<span class="fc" id="L1377">            joinModel.setNestedModel(parseAsSubQueryAndExpectClosingBrace(lexer, parent));</span>
        } else {
<span class="fc" id="L1379">            lexer.unparseLast();</span>
<span class="fc" id="L1380">            parseSelectFrom(lexer, joinModel, parent);</span>
        }

<span class="fc" id="L1383">        tok = setModelAliasAndGetOptTok(lexer, joinModel);</span>

<span class="fc bfc" id="L1385" title="All 6 branches covered.">        if (joinType == QueryModel.JOIN_CROSS &amp;&amp; tok != null &amp;&amp; isOnKeyword(tok)) {</span>
<span class="fc" id="L1386">            throw SqlException.$(lexer.lastTokenPosition(), &quot;Cross joins cannot have join clauses&quot;);</span>
        }

<span class="fc bfc" id="L1389" title="All 3 branches covered.">        switch (joinType) {</span>
            case QueryModel.JOIN_ASOF:
            case QueryModel.JOIN_LT:
            case QueryModel.JOIN_SPLICE:
<span class="fc bfc" id="L1393" title="All 4 branches covered.">                if (tok == null || !isOnKeyword(tok)) {</span>
<span class="fc" id="L1394">                    lexer.unparseLast();</span>
<span class="fc" id="L1395">                    break;</span>
                }
                // intentional fall through
            case QueryModel.JOIN_INNER:
            case QueryModel.JOIN_OUTER:
<span class="fc" id="L1400">                expectTok(lexer, tok, &quot;on&quot;);</span>
                try {
<span class="fc" id="L1402">                    expressionParser.parseExpr(lexer, expressionTreeBuilder);</span>
                    ExpressionNode expr;
<span class="fc bfc" id="L1404" title="All 3 branches covered.">                    switch (expressionTreeBuilder.size()) {</span>
                        case 0:
<span class="fc" id="L1406">                            throw SqlException.$(lexer.lastTokenPosition(), &quot;Expression expected&quot;);</span>
                        case 1:
<span class="fc" id="L1408">                            expr = expressionTreeBuilder.poll();</span>
<span class="fc bfc" id="L1409" title="All 2 branches covered.">                            if (expr.type == ExpressionNode.LITERAL) {</span>
                                do {
<span class="fc" id="L1411">                                    joinModel.addJoinColumn(expr);</span>
<span class="pc bpc" id="L1412" title="1 of 2 branches missed.">                                } while ((expr = expressionTreeBuilder.poll()) != null);</span>
                            } else {
<span class="fc" id="L1414">                                joinModel.setJoinCriteria(rewriteKnownStatements(expr));</span>
                            }
<span class="fc" id="L1416">                            break;</span>
                        default:
                            // this code handles &quot;join on (a,b,c)&quot;, e.g. list of columns
<span class="fc bfc" id="L1419" title="All 2 branches covered.">                            while ((expr = expressionTreeBuilder.poll()) != null) {</span>
<span class="fc bfc" id="L1420" title="All 2 branches covered.">                                if (expr.type != ExpressionNode.LITERAL) {</span>
<span class="fc" id="L1421">                                    throw SqlException.$(lexer.lastTokenPosition(), &quot;Column name expected&quot;);</span>
                                }
<span class="fc" id="L1423">                                joinModel.addJoinColumn(expr);</span>
                            }
                            break;
                    }
<span class="fc" id="L1427">                } catch (SqlException e) {</span>
<span class="fc" id="L1428">                    expressionTreeBuilder.reset();</span>
<span class="fc" id="L1429">                    throw e;</span>
<span class="fc" id="L1430">                }</span>
                break;
            default:
<span class="fc" id="L1433">                lexer.unparseLast();</span>
                break;
        }

<span class="fc" id="L1437">        return joinModel;</span>
    }

    private void parseLatestBy(GenericLexer lexer, QueryModel model) throws SqlException {
<span class="fc" id="L1441">        CharSequence tok = optTok(lexer);</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">        if (tok != null) {</span>
<span class="fc bfc" id="L1443" title="All 2 branches covered.">            if (isByKeyword(tok)) {</span>
<span class="fc" id="L1444">                parseLatestByDeprecated(lexer, model);</span>
<span class="fc" id="L1445">                return;</span>
            }
<span class="pc bpc" id="L1447" title="1 of 2 branches missed.">            if (isOnKeyword(tok)) {</span>
<span class="fc" id="L1448">                parseLatestByNew(lexer, model);</span>
<span class="fc" id="L1449">                return;</span>
            }
        }
<span class="fc" id="L1452">        throw SqlException.$((lexer.lastTokenPosition()), &quot;'on' or 'by' expected&quot;);</span>
    }

    private void parseLatestByDeprecated(GenericLexer lexer, QueryModel model) throws SqlException {
        // 'latest by' is already parsed at this point

        CharSequence tok;
        do {
<span class="fc" id="L1460">            model.addLatestBy(expectLiteral(lexer));</span>
<span class="fc" id="L1461">            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L1462" title="All 2 branches covered.">        } while (Chars.equalsNc(tok, ','));</span>

<span class="fc" id="L1464">        model.setLatestByType(QueryModel.LATEST_BY_DEPRECATED);</span>

<span class="fc bfc" id="L1466" title="All 2 branches covered.">        if (tok != null) {</span>
<span class="fc" id="L1467">            lexer.unparseLast();</span>
        }
<span class="fc" id="L1469">    }</span>

    private void parseLatestByNew(GenericLexer lexer, QueryModel model) throws SqlException {
        // 'latest on' is already parsed at this point

        // &lt;timestamp&gt;
<span class="fc" id="L1475">        final ExpressionNode timestamp = expectLiteral(lexer);</span>
<span class="fc" id="L1476">        model.setTimestamp(timestamp);</span>
        // 'partition by'
<span class="fc" id="L1478">        expectTok(lexer, &quot;partition&quot;);</span>
<span class="fc" id="L1479">        expectTok(lexer, &quot;by&quot;);</span>
        // &lt;columns&gt;
        CharSequence tok;
        do {
<span class="fc" id="L1483">            model.addLatestBy(expectLiteral(lexer));</span>
<span class="fc" id="L1484">            tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L1485" title="All 2 branches covered.">        } while (Chars.equalsNc(tok, ','));</span>

<span class="fc" id="L1487">        model.setLatestByType(QueryModel.LATEST_BY_NEW);</span>

<span class="fc bfc" id="L1489" title="All 2 branches covered.">        if (tok != null) {</span>
<span class="fc" id="L1490">            lexer.unparseLast();</span>
        }
<span class="fc" id="L1492">    }</span>

    private void parseLikeTableName(GenericLexer lexer, CreateTableModel model) throws SqlException {
        CharSequence tok;
<span class="fc" id="L1496">        tok = tok(lexer, &quot;table name&quot;);</span>
<span class="fc" id="L1497">        model.setLikeTableName(nextLiteral(GenericLexer.assertNoDotsAndSlashes(GenericLexer.unquote(tok), lexer.lastTokenPosition()), lexer.lastTokenPosition()));</span>
<span class="fc" id="L1498">        tok = tok(lexer, &quot;)&quot;);</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">        if (!Chars.equals(tok, ')')) {</span>
<span class="fc" id="L1500">            throw errUnexpected(lexer, tok);</span>
        }
<span class="fc" id="L1502">        tok = optTok(lexer);</span>
<span class="pc bpc" id="L1503" title="1 of 4 branches missed.">        if (tok != null &amp;&amp; !Chars.equals(tok, ';')) {</span>
<span class="fc" id="L1504">            throw errUnexpected(lexer, tok);</span>
        }
<span class="fc" id="L1506">    }</span>

    private ExecutionModel parseRenameStatement(GenericLexer lexer) throws SqlException {
<span class="fc" id="L1509">        expectTok(lexer, &quot;table&quot;);</span>
<span class="fc" id="L1510">        RenameTableModel model = renameTableModelPool.next();</span>
<span class="fc" id="L1511">        ExpressionNode e = expectExpr(lexer);</span>
<span class="fc bfc" id="L1512" title="All 4 branches covered.">        if (e.type != ExpressionNode.LITERAL &amp;&amp; e.type != ExpressionNode.CONSTANT) {</span>
<span class="fc" id="L1513">            throw SqlException.$(e.position, &quot;literal or constant expected&quot;);</span>
        }
<span class="fc" id="L1515">        model.setFrom(e);</span>
<span class="fc" id="L1516">        expectTok(lexer, &quot;to&quot;);</span>

<span class="fc" id="L1518">        e = expectExpr(lexer);</span>
<span class="fc bfc" id="L1519" title="All 4 branches covered.">        if (e.type != ExpressionNode.LITERAL &amp;&amp; e.type != ExpressionNode.CONSTANT) {</span>
<span class="fc" id="L1520">            throw SqlException.$(e.position, &quot;literal or constant expected&quot;);</span>
        }
<span class="fc" id="L1522">        model.setTo(e);</span>
<span class="fc" id="L1523">        return model;</span>
    }

    private ExecutionModel parseSelect(GenericLexer lexer) throws SqlException {
<span class="fc" id="L1527">        lexer.unparseLast();</span>
<span class="fc" id="L1528">        final QueryModel model = parseDml(lexer, null, lexer.lastTokenPosition());</span>
<span class="fc" id="L1529">        final CharSequence tok = optTok(lexer);</span>
<span class="fc bfc" id="L1530" title="All 4 branches covered.">        if (tok == null || Chars.equals(tok, ';')) {</span>
<span class="fc" id="L1531">            return model;</span>
        }
<span class="fc" id="L1533">        throw errUnexpected(lexer, tok);</span>
    }

    private void parseSelectClause(GenericLexer lexer, QueryModel model) throws SqlException {
<span class="fc" id="L1537">        CharSequence tok = tok(lexer, &quot;[distinct] column&quot;);</span>

        ExpressionNode expr;
<span class="fc bfc" id="L1540" title="All 2 branches covered.">        if (isDistinctKeyword(tok)) {</span>
<span class="fc" id="L1541">            model.setDistinct(true);</span>
        } else {
<span class="fc" id="L1543">            lexer.unparseLast();</span>
        }
        while (true) {

<span class="fc" id="L1547">            tok = tok(lexer, &quot;column&quot;);</span>
<span class="fc bfc" id="L1548" title="All 2 branches covered.">            if (Chars.equals(tok, '*')) {</span>
<span class="fc" id="L1549">                expr = nextLiteral(GenericLexer.immutableOf(tok), lexer.lastTokenPosition());</span>
            } else {
                // cut off some obvious errors
<span class="fc bfc" id="L1552" title="All 2 branches covered.">                if (isFromKeyword(tok)) {</span>
<span class="fc" id="L1553">                    throw SqlException.$(lexer.getPosition(), &quot;column name expected&quot;);</span>
                }

<span class="fc bfc" id="L1556" title="All 2 branches covered.">                if (isSelectKeyword(tok)) {</span>
<span class="fc" id="L1557">                    throw SqlException.$(lexer.getPosition(), &quot;reserved name&quot;);</span>
                }

<span class="fc" id="L1560">                lexer.unparseLast();</span>
<span class="fc" id="L1561">                expr = expr(lexer, model);</span>

<span class="fc bfc" id="L1563" title="All 2 branches covered.">                if (expr == null) {</span>
<span class="fc" id="L1564">                    throw SqlException.$(lexer.lastTokenPosition(), &quot;missing expression&quot;);</span>
                }

<span class="fc bfc" id="L1567" title="All 4 branches covered.">                if (Chars.endsWith(expr.token, '.') &amp;&amp; expr.type == ExpressionNode.LITERAL) {</span>
<span class="fc" id="L1568">                    throw SqlException.$(expr.position + expr.token.length(), &quot;'*' or column name expected&quot;);</span>
                }
            }

            final CharSequence alias;

<span class="fc" id="L1574">            tok = optTok(lexer);</span>

            QueryColumn col;
<span class="fc" id="L1577">            final int colPosition = lexer.lastTokenPosition();</span>

<span class="fc bfc" id="L1579" title="All 4 branches covered.">            if (tok != null &amp;&amp; isOverKeyword(tok)) {</span>
                // analytic
<span class="fc" id="L1581">                expectTok(lexer, '(');</span>

<span class="fc" id="L1583">                col = analyticColumnPool.next().of(null, expr);</span>
<span class="fc" id="L1584">                tok = tokIncludingLocalBrace(lexer, &quot;'partition' or 'order' or ')'&quot;);</span>

<span class="fc bfc" id="L1586" title="All 2 branches covered.">                if (isPartitionKeyword(tok)) {</span>
<span class="fc" id="L1587">                    expectTok(lexer, &quot;by&quot;);</span>

<span class="fc" id="L1589">                    ObjList&lt;ExpressionNode&gt; partitionBy = ((AnalyticColumn) col).getPartitionBy();</span>

                    do {
<span class="fc" id="L1592">                        partitionBy.add(expectExpr(lexer));</span>
<span class="fc" id="L1593">                        tok = tok(lexer, &quot;'order' or ')'&quot;);</span>
<span class="fc bfc" id="L1594" title="All 2 branches covered.">                    } while (Chars.equals(tok, ','));</span>
                }
<span class="fc bfc" id="L1596" title="All 2 branches covered.">                if (isOrderKeyword(tok)) {</span>
<span class="fc" id="L1597">                    expectTok(lexer, &quot;by&quot;);</span>

                    do {
<span class="fc" id="L1600">                        final ExpressionNode orderByExpr = expectExpr(lexer);</span>

<span class="fc" id="L1602">                        tok = tokIncludingLocalBrace(lexer, &quot;'asc' or 'desc'&quot;);</span>

<span class="fc bfc" id="L1604" title="All 2 branches covered.">                        if (isDescKeyword(tok)) {</span>
<span class="fc" id="L1605">                            ((AnalyticColumn) col).addOrderBy(orderByExpr, QueryModel.ORDER_DIRECTION_DESCENDING);</span>
<span class="fc" id="L1606">                            tok = tokIncludingLocalBrace(lexer, &quot;',' or ')'&quot;);</span>
                        } else {
<span class="fc" id="L1608">                            ((AnalyticColumn) col).addOrderBy(orderByExpr, QueryModel.ORDER_DIRECTION_ASCENDING);</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">                            if (isAscKeyword(tok)) {</span>
<span class="fc" id="L1610">                                tok = tokIncludingLocalBrace(lexer, &quot;',' or ')'&quot;);</span>
                            }
                        }
<span class="fc bfc" id="L1613" title="All 2 branches covered.">                    } while (Chars.equals(tok, ','));</span>
                }
<span class="fc" id="L1615">                expectTok(tok, lexer.lastTokenPosition(), ')');</span>
<span class="fc" id="L1616">                tok = optTok(lexer);</span>

            } else {
<span class="fc bfc" id="L1619" title="All 2 branches covered.">                if (expr.type == ExpressionNode.QUERY) {</span>
<span class="fc" id="L1620">                    throw SqlException.$(expr.position, &quot;query is not expected, did you mean column?&quot;);</span>
                }
<span class="fc" id="L1622">                col = queryColumnPool.next().of(null, expr);</span>
            }

<span class="fc bfc" id="L1625" title="All 4 branches covered.">            if (tok != null &amp;&amp; Chars.equals(tok, ';')) {</span>
<span class="fc" id="L1626">                alias = createColumnAlias(expr, model);</span>
<span class="fc bfc" id="L1627" title="All 4 branches covered.">            } else if (tok != null &amp;&amp; columnAliasStop.excludes(tok)) {</span>
<span class="fc" id="L1628">                assertNotDot(lexer, tok);</span>

<span class="fc bfc" id="L1630" title="All 2 branches covered.">                if (isAsKeyword(tok)) {</span>
<span class="fc" id="L1631">                    CharSequence aliasTok = GenericLexer.immutableOf(tok(lexer, &quot;alias&quot;));</span>
<span class="fc" id="L1632">                    validateIdentifier(lexer, aliasTok);</span>
<span class="fc" id="L1633">                    alias = GenericLexer.unquote(aliasTok);</span>
<span class="fc" id="L1634">                } else {</span>
<span class="fc" id="L1635">                    validateIdentifier(lexer, tok);</span>
<span class="fc" id="L1636">                    alias = GenericLexer.immutableOf(GenericLexer.unquote(tok));</span>
                }
<span class="fc" id="L1638">                tok = optTok(lexer);</span>
            } else {
<span class="fc" id="L1640">                alias = createColumnAlias(expr, model);</span>
            }
<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">            if (alias.length() == 0) {</span>
<span class="nc" id="L1643">                throw err(lexer, null, &quot;column alias cannot be a blank string&quot;);</span>
            }
<span class="fc" id="L1645">            col.setAlias(alias);</span>

            // correlated sub-queries do not have expr.token values (they are null)
<span class="pc bpc" id="L1648" title="1 of 2 branches missed.">            if (expr.type == ExpressionNode.QUERY) {</span>
<span class="nc" id="L1649">                expr.token = alias;</span>
            }
<span class="fc" id="L1651">            model.addBottomUpColumn(colPosition, col, false);</span>

<span class="fc bfc" id="L1653" title="All 6 branches covered.">            if (model.getColumns().size() == 1 &amp;&amp; tok == null &amp;&amp; Chars.equals(expr.token, '*')) {</span>
<span class="fc" id="L1654">                throw err(lexer, null, &quot;'from' expected&quot;);</span>
            }

<span class="fc bfc" id="L1657" title="All 4 branches covered.">            if (tok == null || Chars.equals(tok, ';')) {</span>
<span class="fc" id="L1658">                lexer.unparseLast();</span>
<span class="fc" id="L1659">                break;</span>
            }

<span class="fc bfc" id="L1662" title="All 2 branches covered.">            if (isFromKeyword(tok)) {</span>
<span class="fc" id="L1663">                lexer.unparseLast();</span>
<span class="fc" id="L1664">                break;</span>
            }

<span class="fc bfc" id="L1667" title="All 2 branches covered.">            if (setOperations.contains(tok)) {</span>
<span class="fc" id="L1668">                lexer.unparseLast();</span>
<span class="fc" id="L1669">                break;</span>
            }

<span class="fc bfc" id="L1672" title="All 2 branches covered.">            if (!Chars.equals(tok, ',')) {</span>
<span class="fc" id="L1673">                throw err(lexer, tok, &quot;',', 'from' or 'over' expected&quot;);</span>
            }
<span class="fc" id="L1675">        }</span>
<span class="fc" id="L1676">    }</span>

    private void parseSelectFrom(GenericLexer lexer, QueryModel model, LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; masterModel) throws SqlException {
<span class="fc" id="L1679">        final ExpressionNode expr = expr(lexer, model);</span>
<span class="fc bfc" id="L1680" title="All 2 branches covered.">        if (expr == null) {</span>
<span class="fc" id="L1681">            throw SqlException.position(lexer.lastTokenPosition()).put(&quot;table name expected&quot;);</span>
        }
<span class="fc" id="L1683">        CharSequence name = expr.token;</span>

<span class="fc bfc" id="L1685" title="All 3 branches covered.">        switch (expr.type) {</span>
            case ExpressionNode.LITERAL:
            case ExpressionNode.CONSTANT:
<span class="fc" id="L1688">                final ExpressionNode literal = literal(name, expr.position);</span>
<span class="fc" id="L1689">                final WithClauseModel withClause = masterModel.get(name);</span>
<span class="fc bfc" id="L1690" title="All 2 branches covered.">                if (withClause != null) {</span>
<span class="fc" id="L1691">                    model.setNestedModel(parseWith(lexer, withClause, masterModel));</span>
<span class="fc" id="L1692">                    model.setAlias(literal);</span>
                } else {
<span class="fc" id="L1694">                    model.setTableNameExpr(literal);</span>
                }
<span class="fc" id="L1696">                break;</span>
            case ExpressionNode.FUNCTION:
<span class="fc" id="L1698">                model.setTableNameExpr(expr);</span>
<span class="fc" id="L1699">                break;</span>
            default:
<span class="fc" id="L1701">                throw SqlException.$(expr.position, &quot;function, literal or constant is expected&quot;);</span>
        }
<span class="fc" id="L1703">    }</span>

    private int parseSymbolCapacity(GenericLexer lexer) throws SqlException {
<span class="fc" id="L1706">        final int errorPosition = lexer.getPosition();</span>
<span class="fc" id="L1707">        final int symbolCapacity = expectInt(lexer);</span>
<span class="fc" id="L1708">        TableUtils.validateSymbolCapacity(errorPosition, symbolCapacity);</span>
<span class="fc" id="L1709">        return Numbers.ceilPow2(symbolCapacity);</span>
    }

    private ExpressionNode parseTimestamp(GenericLexer lexer, CharSequence tok) throws SqlException {
<span class="fc bfc" id="L1713" title="All 4 branches covered.">        if (tok != null &amp;&amp; isTimestampKeyword(tok)) {</span>
<span class="fc" id="L1714">            expectTok(lexer, '(');</span>
<span class="fc" id="L1715">            final ExpressionNode result = expectLiteral(lexer);</span>
<span class="fc" id="L1716">            tokIncludingLocalBrace(lexer, &quot;')'&quot;);</span>
<span class="fc" id="L1717">            return result;</span>
        }
<span class="fc" id="L1719">        return null;</span>
    }

    private ExecutionModel parseUpdate(GenericLexer lexer) throws SqlException {
<span class="fc" id="L1723">        lexer.unparseLast();</span>
<span class="fc" id="L1724">        final QueryModel model = parseDmlUpdate(lexer);</span>
<span class="fc" id="L1725">        final CharSequence tok = optTok(lexer);</span>
<span class="fc bfc" id="L1726" title="All 4 branches covered.">        if (tok == null || Chars.equals(tok, ';')) {</span>
<span class="fc" id="L1727">            return model;</span>
        }
<span class="fc" id="L1729">        throw errUnexpected(lexer, tok);</span>
    }

    private void parseUpdateClause(GenericLexer lexer, QueryModel updateQueryModel, QueryModel fromModel) throws SqlException {
<span class="fc" id="L1733">        CharSequence tok = tok(lexer, &quot;table name or alias&quot;);</span>
<span class="fc" id="L1734">        CharSequence tableName = GenericLexer.immutableOf(GenericLexer.unquote(tok));</span>
<span class="fc" id="L1735">        ExpressionNode tableNameExpr = ExpressionNode.FACTORY.newInstance().of(ExpressionNode.LITERAL, tableName, 0, 0);</span>
<span class="fc" id="L1736">        updateQueryModel.setTableNameExpr(tableNameExpr);</span>
<span class="fc" id="L1737">        fromModel.setTableNameExpr(tableNameExpr);</span>

<span class="fc" id="L1739">        tok = tok(lexer, &quot;AS, SET or table alias expected&quot;);</span>
<span class="fc bfc" id="L1740" title="All 2 branches covered.">        if (isAsKeyword(tok)) {</span>
<span class="fc" id="L1741">            tok = tok(lexer, &quot;table alias expected&quot;);</span>
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">            if (isSetKeyword(tok)) {</span>
<span class="nc" id="L1743">                throw SqlException.$(lexer.lastTokenPosition(), &quot;table alias expected&quot;);</span>
            }
        }

<span class="pc bpc" id="L1747" title="1 of 4 branches missed.">        if (!isAsKeyword(tok) &amp;&amp; !isSetKeyword(tok)) {</span>
            // This is table alias
<span class="fc" id="L1749">            CharSequence tableAlias = GenericLexer.immutableOf(tok);</span>
<span class="fc" id="L1750">            ExpressionNode tableAliasExpr = ExpressionNode.FACTORY.newInstance().of(ExpressionNode.LITERAL, tableAlias, 0, 0);</span>
<span class="fc" id="L1751">            updateQueryModel.setAlias(tableAliasExpr);</span>
<span class="fc" id="L1752">            tok = tok(lexer, &quot;SET expected&quot;);</span>
        }

<span class="fc bfc" id="L1755" title="All 2 branches covered.">        if (!isSetKeyword(tok)) {</span>
<span class="fc" id="L1756">            throw SqlException.$(lexer.lastTokenPosition(), &quot;SET expected&quot;);</span>
        }

        while (true) {
            // Column
<span class="fc" id="L1761">            tok = tok(lexer, &quot;column name&quot;);</span>
<span class="fc" id="L1762">            CharSequence col = GenericLexer.immutableOf(GenericLexer.unquote(tok));</span>
<span class="fc" id="L1763">            int colPosition = lexer.lastTokenPosition();</span>

<span class="fc" id="L1765">            expectTok(lexer, &quot;=&quot;);</span>

            // Value expression
<span class="fc" id="L1768">            ExpressionNode expr = expr(lexer, (QueryModel) null);</span>
<span class="fc" id="L1769">            ExpressionNode setColumnExpression = expressionNodePool.next().of(ExpressionNode.LITERAL, col, 0, colPosition);</span>
<span class="fc" id="L1770">            updateQueryModel.getUpdateExpressions().add(setColumnExpression);</span>

<span class="fc" id="L1772">            QueryColumn valueColumn = queryColumnPool.next().of(col, expr);</span>
<span class="fc" id="L1773">            fromModel.addBottomUpColumn(colPosition, valueColumn, false, &quot;in SET clause&quot;);</span>

<span class="fc" id="L1775">            tok = optTok(lexer);</span>
<span class="fc bfc" id="L1776" title="All 2 branches covered.">            if (tok == null) {</span>
<span class="fc" id="L1777">                break;</span>
            }

<span class="fc bfc" id="L1780" title="All 4 branches covered.">            if (tok.length() != 1 || tok.charAt(0) != ',') {</span>
<span class="fc" id="L1781">                lexer.unparseLast();</span>
<span class="fc" id="L1782">                break;</span>
            }
<span class="fc" id="L1784">        }</span>
<span class="fc" id="L1785">    }</span>

    @NotNull
    private ExecutionModel parseWith(GenericLexer lexer) throws SqlException {
<span class="fc" id="L1789">        parseWithClauses(lexer, topLevelWithModel);</span>
<span class="fc" id="L1790">        CharSequence tok = tok(lexer, &quot;'select', 'update' or name expected&quot;);</span>
<span class="fc bfc" id="L1791" title="All 2 branches covered.">        if (isSelectKeyword(tok)) {</span>
<span class="fc" id="L1792">            lexer.unparseLast();</span>
<span class="pc bpc" id="L1793" title="1 of 2 branches missed.">            return parseDml(lexer, null, lexer.lastTokenPosition());</span>
        }

<span class="fc bfc" id="L1796" title="All 2 branches covered.">        if (isUpdateKeyword(tok)) {</span>
<span class="pc bpc" id="L1797" title="1 of 2 branches missed.">            return parseUpdate(lexer);</span>
        }

<span class="fc bfc" id="L1800" title="All 2 branches covered.">        if (isInsertKeyword(tok)) {</span>
<span class="pc bpc" id="L1801" title="1 of 2 branches missed.">            return parseInsert(lexer);</span>
        }

<span class="fc" id="L1804">        throw SqlException.$(lexer.lastTokenPosition(), &quot;'select' | 'update' | 'insert' expected&quot;);</span>
    }

    private QueryModel parseWith(GenericLexer lexer, WithClauseModel wcm, LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; withClauses) throws SqlException {
<span class="fc" id="L1808">        QueryModel m = wcm.popModel();</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">        if (m != null) {</span>
<span class="fc" id="L1810">            return m;</span>
        }

<span class="fc" id="L1813">        lexer.stash();</span>
<span class="fc" id="L1814">        lexer.goToPosition(wcm.getPosition());</span>
        // this will not throw exception because this is second pass over the same sub-query
        // we wouldn't be here is syntax was wrong
<span class="fc" id="L1817">        m = parseAsSubQueryAndExpectClosingBrace(lexer, withClauses);</span>
<span class="fc" id="L1818">        lexer.unstash();</span>
<span class="fc" id="L1819">        return m;</span>
    }

    private void parseWithClauses(GenericLexer lexer, LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; model) throws SqlException {
        do {
<span class="fc" id="L1824">            ExpressionNode name = expectLiteral(lexer);</span>
<span class="fc bfc" id="L1825" title="All 2 branches covered.">            if (name.token.length() == 0) {</span>
<span class="fc" id="L1826">                throw SqlException.$(name.position, &quot;empty common table expression name&quot;);</span>
            }

<span class="fc bfc" id="L1829" title="All 2 branches covered.">            if (model.get(name.token) != null) {</span>
<span class="fc" id="L1830">                throw SqlException.$(name.position, &quot;duplicate name&quot;);</span>
            }

<span class="fc" id="L1833">            expectTok(lexer, &quot;as&quot;);</span>
<span class="fc" id="L1834">            expectTok(lexer, '(');</span>
<span class="fc" id="L1835">            int lo = lexer.lastTokenPosition();</span>
<span class="fc" id="L1836">            WithClauseModel wcm = withClauseModelPool.next();</span>
<span class="fc" id="L1837">            wcm.of(lo + 1, parseAsSubQueryAndExpectClosingBrace(lexer, model));</span>
<span class="fc" id="L1838">            model.put(name.token, wcm);</span>

<span class="fc" id="L1840">            CharSequence tok = optTok(lexer);</span>
<span class="pc bpc" id="L1841" title="1 of 4 branches missed.">            if (tok == null || !Chars.equals(tok, ',')) {</span>
<span class="fc" id="L1842">                lexer.unparseLast();</span>
<span class="fc" id="L1843">                break;</span>
            }
<span class="fc" id="L1845">        } while (true);</span>
<span class="fc" id="L1846">    }</span>

    private CharSequence parseWithOffset(GenericLexer lexer, QueryModel model) throws SqlException {
        CharSequence tok;
<span class="fc" id="L1850">        expectOffset(lexer);</span>
<span class="fc" id="L1851">        model.setSampleByOffset(expectExpr(lexer));</span>
<span class="fc" id="L1852">        tok = optTok(lexer);</span>
<span class="fc" id="L1853">        return tok;</span>
    }

    private ExpressionNode rewriteCase(ExpressionNode parent) throws SqlException {
<span class="fc" id="L1857">        traversalAlgo.traverse(parent, rewriteCase0Ref);</span>
<span class="fc" id="L1858">        return parent;</span>
    }

    private void rewriteCase0(ExpressionNode node) {
<span class="fc bfc" id="L1862" title="All 4 branches covered.">        if (node.type == ExpressionNode.FUNCTION &amp;&amp; isCaseKeyword(node.token)) {</span>
<span class="fc" id="L1863">            tempExprNodes.clear();</span>
<span class="fc" id="L1864">            ExpressionNode literal = null;</span>
            ExpressionNode elseExpr;
<span class="fc" id="L1866">            boolean convertToSwitch = true;</span>
<span class="fc" id="L1867">            final int paramCount = node.paramCount;</span>

<span class="fc bfc" id="L1869" title="All 2 branches covered.">            if (node.paramCount == 2) {</span>
                // special case, typically something like
                // case value else expression end
                // this can be simplified to &quot;expression&quot; only

<span class="fc" id="L1874">                ExpressionNode that = node.rhs;</span>
<span class="fc" id="L1875">                node.of(that.type, that.token, that.precedence, that.position);</span>
<span class="fc" id="L1876">                node.paramCount = that.paramCount;</span>
<span class="fc bfc" id="L1877" title="All 2 branches covered.">                if (that.paramCount == 2) {</span>
<span class="fc" id="L1878">                    node.lhs = that.lhs;</span>
<span class="fc" id="L1879">                    node.rhs = that.rhs;</span>
                } else {
<span class="fc" id="L1881">                    node.args.clear();</span>
<span class="fc" id="L1882">                    node.args.addAll(that.args);</span>
                }
<span class="fc" id="L1884">                return;</span>
            }
            final int lim;
<span class="fc bfc" id="L1887" title="All 2 branches covered.">            if ((paramCount &amp; 1) == 0) {</span>
<span class="fc" id="L1888">                elseExpr = node.args.getQuick(0);</span>
<span class="fc" id="L1889">                lim = 0;</span>
            } else {
<span class="fc" id="L1891">                elseExpr = null;</span>
<span class="fc" id="L1892">                lim = -1;</span>
            }

            // agrs are in inverted order, hence last list item is the first arg
<span class="fc" id="L1896">            ExpressionNode first = node.args.getQuick(paramCount - 1);</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">            if (first.token != null) {</span>
                // simple case of 'case' :) e.g.
                // case x
                //   when 1 then 'A'
                //   ...
<span class="fc" id="L1902">                node.token = &quot;switch&quot;;</span>
<span class="fc" id="L1903">                return;</span>
            }

<span class="fc bfc" id="L1906" title="All 2 branches covered.">            for (int i = paramCount - 2; i &gt; lim; i--) {</span>
<span class="fc bfc" id="L1907" title="All 2 branches covered.">                if ((i &amp; 1) == 1) {</span>
                    // this is &quot;then&quot; clause, copy it as as
<span class="fc" id="L1909">                    tempExprNodes.add(node.args.getQuick(i));</span>
<span class="fc" id="L1910">                    continue;</span>
                }
<span class="fc" id="L1912">                ExpressionNode where = node.args.getQuick(i);</span>
<span class="fc bfc" id="L1913" title="All 4 branches covered.">                if (where.type == ExpressionNode.OPERATION &amp;&amp; where.token.charAt(0) == '=') {</span>
                    ExpressionNode thisConstant;
                    ExpressionNode thisLiteral;
<span class="fc bfc" id="L1916" title="All 4 branches covered.">                    if (where.lhs.type == ExpressionNode.CONSTANT &amp;&amp; where.rhs.type == ExpressionNode.LITERAL) {</span>
<span class="fc" id="L1917">                        thisConstant = where.lhs;</span>
<span class="fc" id="L1918">                        thisLiteral = where.rhs;</span>
<span class="fc bfc" id="L1919" title="All 4 branches covered.">                    } else if (where.lhs.type == ExpressionNode.LITERAL &amp;&amp; where.rhs.type == ExpressionNode.CONSTANT) {</span>
<span class="fc" id="L1920">                        thisConstant = where.rhs;</span>
<span class="fc" id="L1921">                        thisLiteral = where.lhs;</span>
                    } else {
<span class="fc" id="L1923">                        convertToSwitch = false;</span>
                        // not supported
<span class="fc" id="L1925">                        break;</span>
                    }

<span class="fc bfc" id="L1928" title="All 2 branches covered.">                    if (literal == null) {</span>
<span class="fc" id="L1929">                        literal = thisLiteral;</span>
<span class="fc" id="L1930">                        tempExprNodes.add(thisConstant);</span>
<span class="fc bfc" id="L1931" title="All 2 branches covered.">                    } else if (Chars.equals(literal.token, thisLiteral.token)) {</span>
<span class="fc" id="L1932">                        tempExprNodes.add(thisConstant);</span>
                    } else {
<span class="fc" id="L1934">                        convertToSwitch = false;</span>
                        // not supported
<span class="fc" id="L1936">                        break;</span>
                    }
<span class="fc" id="L1938">                } else {</span>
<span class="fc" id="L1939">                    convertToSwitch = false;</span>
                    // not supported
<span class="fc" id="L1941">                    break;</span>
                }
            }

<span class="fc bfc" id="L1945" title="All 2 branches covered.">            if (convertToSwitch) {</span>
<span class="fc" id="L1946">                int n = tempExprNodes.size();</span>
<span class="fc" id="L1947">                node.token = &quot;switch&quot;;</span>
<span class="fc" id="L1948">                node.args.clear();</span>
<span class="fc" id="L1949">                node.args.add(elseExpr);</span>
<span class="fc bfc" id="L1950" title="All 2 branches covered.">                for (int i = n - 1; i &gt; -1; i--) {</span>
<span class="fc" id="L1951">                    node.args.add(tempExprNodes.getQuick(i));</span>
                }
<span class="fc" id="L1953">                node.args.add(literal);</span>
<span class="fc" id="L1954">                node.paramCount = n + 2;</span>
<span class="fc" id="L1955">            } else {</span>
<span class="fc" id="L1956">                node.args.remove(paramCount - 1);</span>
<span class="fc" id="L1957">                node.paramCount = paramCount - 1;</span>
            }
        }
<span class="fc" id="L1960">    }</span>

    private ExpressionNode rewriteConcat(ExpressionNode parent) throws SqlException {
<span class="fc" id="L1963">        traversalAlgo.traverse(parent, rewriteConcat0Ref);</span>
<span class="fc" id="L1964">        return parent;</span>
    }

    private void rewriteConcat0(ExpressionNode node) {
<span class="fc bfc" id="L1968" title="All 4 branches covered.">        if (node.type == ExpressionNode.OPERATION &amp;&amp; isConcatOperator(node.token)) {</span>
<span class="fc" id="L1969">            node.type = ExpressionNode.FUNCTION;</span>
<span class="fc" id="L1970">            node.token = CONCAT_FUNC_NAME;</span>
<span class="fc" id="L1971">            addConcatArgs(node.args, node.rhs);</span>
<span class="fc" id="L1972">            addConcatArgs(node.args, node.lhs);</span>
<span class="fc" id="L1973">            node.paramCount = node.args.size();</span>
        }
<span class="fc" id="L1975">    }</span>

    private ExpressionNode rewriteCount(ExpressionNode parent) throws SqlException {
<span class="fc" id="L1978">        traversalAlgo.traverse(parent, rewriteCount0Ref);</span>
<span class="fc" id="L1979">        return parent;</span>
    }

    /**
     * Rewrites count(*) expressions to count().
     *
     * @param node expression node, provided by tree walking algo
     */
    private void rewriteCount0(ExpressionNode node) {
<span class="fc bfc" id="L1988" title="All 4 branches covered.">        if (node.type == ExpressionNode.FUNCTION &amp;&amp; isCountKeyword(node.token)) {</span>
<span class="fc bfc" id="L1989" title="All 2 branches covered.">            if (node.paramCount == 1) {</span>
                // special case, typically something like
                // case value else expression end
                // this can be simplified to &quot;expression&quot; only

<span class="fc" id="L1994">                ExpressionNode that = node.rhs;</span>
<span class="fc bfc" id="L1995" title="All 2 branches covered.">                if (Chars.equals(that.token, '*')) {</span>
<span class="pc bpc" id="L1996" title="1 of 4 branches missed.">                    if (that.rhs == null &amp;&amp; node.lhs == null) {</span>
<span class="fc" id="L1997">                        that.paramCount = 0;</span>
<span class="fc" id="L1998">                        node.rhs = null;</span>
<span class="fc" id="L1999">                        node.paramCount = 0;</span>
                    }
                }
            }
        }
<span class="fc" id="L2004">    }</span>

    private ExpressionNode rewriteKnownStatements(ExpressionNode parent) throws SqlException {
<span class="fc" id="L2007">        return rewritePgCast(</span>
<span class="fc" id="L2008">                rewriteConcat(</span>
<span class="fc" id="L2009">                        rewriteCase(</span>
<span class="fc" id="L2010">                                rewriteCount(</span>
                                        parent
                                )
                        )
                )
        );
    }

    private ExpressionNode rewritePgCast(ExpressionNode parent) throws SqlException {
<span class="fc" id="L2019">        traversalAlgo.traverse(parent, rewritePgCast0Ref);</span>
<span class="fc" id="L2020">        return parent;</span>
    }

    private void rewritePgCast0(ExpressionNode node) {
<span class="fc bfc" id="L2024" title="All 4 branches covered.">        if (node.type == ExpressionNode.OPERATION &amp;&amp; SqlKeywords.isColonColon(node.token)) {</span>
<span class="fc" id="L2025">            node.token = &quot;cast&quot;;</span>
<span class="fc" id="L2026">            node.type = ExpressionNode.FUNCTION;</span>
<span class="fc" id="L2027">            node.rhs.type = ExpressionNode.CONSTANT;</span>
            // In PG x::float casts x to &quot;double precision&quot; type
<span class="fc bfc" id="L2029" title="All 4 branches covered.">            if (SqlKeywords.isFloatKeyword(node.rhs.token) || SqlKeywords.isFloat8Keyword(node.rhs.token)) {</span>
<span class="fc" id="L2030">                node.rhs.token = &quot;double&quot;;</span>
<span class="fc bfc" id="L2031" title="All 2 branches covered.">            } else if (SqlKeywords.isFloat4Keyword(node.rhs.token)) {</span>
<span class="fc" id="L2032">                node.rhs.token = &quot;float&quot;;</span>
<span class="fc bfc" id="L2033" title="All 2 branches covered.">            } else if (SqlKeywords.isDateKeyword(node.rhs.token)) {</span>
<span class="fc" id="L2034">                node.token = &quot;to_pg_date&quot;;</span>
<span class="fc" id="L2035">                node.rhs = node.lhs;</span>
<span class="fc" id="L2036">                node.lhs = null;</span>
<span class="fc" id="L2037">                node.paramCount = 1;</span>
            }
        }
<span class="fc" id="L2040">    }</span>

    private CharSequence setModelAliasAndGetOptTok(GenericLexer lexer, QueryModel joinModel) throws SqlException {
<span class="fc" id="L2043">        CharSequence tok = optTok(lexer);</span>
<span class="fc bfc" id="L2044" title="All 4 branches covered.">        if (tok != null &amp;&amp; tableAliasStop.excludes(tok)) {</span>
<span class="fc" id="L2045">            checkSupportedJoinType(lexer, tok);</span>
<span class="fc bfc" id="L2046" title="All 2 branches covered.">            if (SqlKeywords.isAsKeyword(tok)) {</span>
<span class="fc" id="L2047">                tok = tok(lexer, &quot;alias&quot;);</span>
            }
<span class="fc" id="L2049">            ExpressionNode alias = literal(lexer, tok);</span>
<span class="fc bfc" id="L2050" title="All 2 branches covered.">            if (alias.token.length() == 0) {</span>
<span class="fc" id="L2051">                throw SqlException.position(alias.position).put(&quot;Empty table alias&quot;);</span>
            }
<span class="fc" id="L2053">            joinModel.setAlias(alias);</span>
<span class="fc" id="L2054">            tok = optTok(lexer);</span>
        }
<span class="fc" id="L2056">        return tok;</span>
    }

    private CharSequence setModelAliasAndTimestamp(GenericLexer lexer, QueryModel model) throws SqlException {
        CharSequence tok;
<span class="fc" id="L2061">        tok = setModelAliasAndGetOptTok(lexer, model);</span>

        // expect [timestamp(column)]
<span class="fc" id="L2064">        ExpressionNode timestamp = parseTimestamp(lexer, tok);</span>
<span class="fc bfc" id="L2065" title="All 2 branches covered.">        if (timestamp != null) {</span>
<span class="fc" id="L2066">            model.setTimestamp(timestamp);</span>
<span class="fc" id="L2067">            tok = optTok(lexer);</span>
        }
<span class="fc" id="L2069">        return tok;</span>
    }

    private int toColumnType(GenericLexer lexer, CharSequence tok) throws SqlException {
<span class="fc" id="L2073">        final short type = ColumnType.tagOf(tok);</span>
<span class="fc bfc" id="L2074" title="All 2 branches covered.">        if (type == -1) {</span>
<span class="fc" id="L2075">            throw SqlException.$(lexer.lastTokenPosition(), &quot;unsupported column type: &quot;).put(tok);</span>
        }
<span class="fc bfc" id="L2077" title="All 2 branches covered.">        if (ColumnType.GEOHASH == type) {</span>
<span class="fc" id="L2078">            expectTok(lexer, '(');</span>
<span class="fc" id="L2079">            final int bits = GeoHashUtil.parseGeoHashBits(lexer.lastTokenPosition(), 0, expectLiteral(lexer).token);</span>
<span class="fc" id="L2080">            expectTok(lexer, ')');</span>
<span class="fc" id="L2081">            return ColumnType.getGeoHashTypeWithBits(bits);</span>
        }
<span class="fc" id="L2083">        return type;</span>
    }

    private @NotNull CharSequence tok(GenericLexer lexer, String expectedList) throws SqlException {
<span class="fc" id="L2087">        final int pos = lexer.getPosition();</span>
<span class="fc" id="L2088">        CharSequence tok = optTok(lexer);</span>
<span class="fc bfc" id="L2089" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L2090">            throw SqlException.position(pos).put(expectedList).put(&quot; expected&quot;);</span>
        }
<span class="pc bpc" id="L2092" title="1 of 2 branches missed.">        return tok;</span>
    }

    private @NotNull CharSequence tokIncludingLocalBrace(GenericLexer lexer, String expectedList) throws SqlException {
<span class="fc" id="L2096">        final int pos = lexer.getPosition();</span>
<span class="fc" id="L2097">        final CharSequence tok = SqlUtil.fetchNext(lexer);</span>
<span class="fc bfc" id="L2098" title="All 2 branches covered.">        if (tok == null) {</span>
<span class="fc" id="L2099">            throw SqlException.position(pos).put(expectedList).put(&quot; expected&quot;);</span>
        }
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">        return tok;</span>
    }

    private void validateIdentifier(GenericLexer lexer, CharSequence tok) throws SqlException {
<span class="pc bpc" id="L2105" title="2 of 4 branches missed.">        if (tok == null || tok.length() == 0) {</span>
<span class="nc" id="L2106">            throw SqlException.position(lexer.lastTokenPosition()).put(&quot;non-empty identifier expected&quot;);</span>
        }

<span class="fc bfc" id="L2109" title="All 2 branches covered.">        if (Chars.isQuoted(tok)) {</span>
<span class="fc bfc" id="L2110" title="All 2 branches covered.">            if (tok.length() == 2) {</span>
<span class="fc" id="L2111">                throw SqlException.position(lexer.lastTokenPosition()).put(&quot;non-empty identifier expected&quot;);</span>
            }
<span class="fc" id="L2113">            return;</span>
        }

<span class="fc" id="L2116">        char c = tok.charAt(0);</span>

<span class="fc bfc" id="L2118" title="All 4 branches covered.">        if (!(Character.isLetter(c) || c == '_')) {</span>
<span class="fc" id="L2119">            throw SqlException.position(lexer.lastTokenPosition()).put(&quot;identifier should start with a letter or '_'&quot;);</span>
        }

<span class="fc bfc" id="L2122" title="All 2 branches covered.">        for (int i = 1, n = tok.length(); i &lt; n; i++) {</span>
<span class="fc" id="L2123">            c = tok.charAt(i);</span>
<span class="fc bfc" id="L2124" title="All 2 branches covered.">            if (!(Character.isLetter(c) ||</span>
<span class="pc bpc" id="L2125" title="1 of 6 branches missed.">                    Character.isDigit(c) ||</span>
                    c == '_' ||
                    c == '$')) {
<span class="nc" id="L2128">                throw SqlException.position(lexer.lastTokenPosition()).put(&quot;identifier can contain letters, digits, '_' or '$'&quot;);</span>
            }
        }
<span class="fc" id="L2131">    }</span>

    private void validateLiteral(int pos, CharSequence tok) throws SqlException {
<span class="fc bfc" id="L2134" title="All 2 branches covered.">        switch (tok.charAt(0)) {</span>
            case '(':
            case ')':
            case ',':
            case '`':
            case '\'':
<span class="fc" id="L2140">                throw SqlException.position(pos).put(&quot;literal expected&quot;);</span>
            default:
                break;
        }
<span class="fc" id="L2144">    }</span>

    void clear() {
<span class="fc" id="L2147">        queryModelPool.clear();</span>
<span class="fc" id="L2148">        queryColumnPool.clear();</span>
<span class="fc" id="L2149">        expressionNodePool.clear();</span>
<span class="fc" id="L2150">        analyticColumnPool.clear();</span>
<span class="fc" id="L2151">        createTableModelPool.clear();</span>
<span class="fc" id="L2152">        columnCastModelPool.clear();</span>
<span class="fc" id="L2153">        renameTableModelPool.clear();</span>
<span class="fc" id="L2154">        withClauseModelPool.clear();</span>
<span class="fc" id="L2155">        subQueryMode = false;</span>
<span class="fc" id="L2156">        characterStore.clear();</span>
<span class="fc" id="L2157">        insertModelPool.clear();</span>
<span class="fc" id="L2158">        expressionTreeBuilder.reset();</span>
<span class="fc" id="L2159">        copyModelPool.clear();</span>
<span class="fc" id="L2160">        topLevelWithModel.clear();</span>
<span class="fc" id="L2161">        explainModelPool.clear();</span>
<span class="fc" id="L2162">    }</span>

    ExpressionNode expr(GenericLexer lexer, QueryModel model) throws SqlException {
        try {
<span class="fc" id="L2166">            expressionTreeBuilder.pushModel(model);</span>
<span class="fc" id="L2167">            expressionParser.parseExpr(lexer, expressionTreeBuilder);</span>
<span class="fc" id="L2168">            return rewriteKnownStatements(expressionTreeBuilder.poll());</span>
<span class="fc" id="L2169">        } catch (SqlException e) {</span>
<span class="fc" id="L2170">            expressionTreeBuilder.reset();</span>
<span class="fc" id="L2171">            throw e;</span>
        } finally {
<span class="fc" id="L2173">            expressionTreeBuilder.popModel();</span>
        }
    }

    // test only
    void expr(GenericLexer lexer, ExpressionParserListener listener) throws SqlException {
<span class="fc" id="L2179">        expressionParser.parseExpr(lexer, listener);</span>
<span class="fc" id="L2180">    }</span>

    ExecutionModel parse(GenericLexer lexer, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L2183">        CharSequence tok = tok(lexer, &quot;'create', 'rename' or 'select'&quot;);</span>

<span class="fc bfc" id="L2185" title="All 2 branches covered.">        if (isExplainKeyword(tok)) {</span>
<span class="fc" id="L2186">            int format = parseExplainOptions(lexer, tok);</span>
<span class="fc" id="L2187">            ExecutionModel model = parseExplain(lexer, executionContext);</span>
<span class="fc" id="L2188">            ExplainModel explainModel = explainModelPool.next();</span>
<span class="fc" id="L2189">            explainModel.setFormat(format);</span>
<span class="fc" id="L2190">            explainModel.setModel(model);</span>
<span class="fc" id="L2191">            return explainModel;</span>
        }

<span class="fc bfc" id="L2194" title="All 2 branches covered.">        if (isSelectKeyword(tok)) {</span>
<span class="fc" id="L2195">            return parseSelect(lexer);</span>
        }

<span class="fc bfc" id="L2198" title="All 2 branches covered.">        if (isCreateKeyword(tok)) {</span>
<span class="fc" id="L2199">            return parseCreateStatement(lexer, executionContext);</span>
        }

<span class="fc bfc" id="L2202" title="All 2 branches covered.">        if (isUpdateKeyword(tok)) {</span>
<span class="fc" id="L2203">            return parseUpdate(lexer);</span>
        }

<span class="fc bfc" id="L2206" title="All 2 branches covered.">        if (isRenameKeyword(tok)) {</span>
<span class="fc" id="L2207">            return parseRenameStatement(lexer);</span>
        }

<span class="fc bfc" id="L2210" title="All 2 branches covered.">        if (isInsertKeyword(tok)) {</span>
<span class="fc" id="L2211">            return parseInsert(lexer);</span>
        }

<span class="fc bfc" id="L2214" title="All 2 branches covered.">        if (isCopyKeyword(tok)) {</span>
<span class="fc" id="L2215">            return parseCopy(lexer);</span>
        }

<span class="fc bfc" id="L2218" title="All 2 branches covered.">        if (isWithKeyword(tok)) {</span>
<span class="fc" id="L2219">            return parseWith(lexer);</span>
        }

<span class="fc" id="L2222">        return parseSelect(lexer);</span>
    }

    QueryModel parseAsSubQuery(GenericLexer lexer, @Nullable LowerCaseCharSequenceObjHashMap&lt;WithClauseModel&gt; withClauses) throws SqlException {
        QueryModel model;
<span class="fc" id="L2227">        this.subQueryMode = true;</span>
        try {
<span class="fc" id="L2229">            model = parseDml(lexer, withClauses, lexer.getPosition());</span>
        } finally {
<span class="fc" id="L2231">            this.subQueryMode = false;</span>
        }
<span class="fc" id="L2233">        return model;</span>
    }

    static {
<span class="fc" id="L2237">        tableAliasStop.add(&quot;where&quot;);</span>
<span class="fc" id="L2238">        tableAliasStop.add(&quot;latest&quot;);</span>
<span class="fc" id="L2239">        tableAliasStop.add(&quot;join&quot;);</span>
<span class="fc" id="L2240">        tableAliasStop.add(&quot;inner&quot;);</span>
<span class="fc" id="L2241">        tableAliasStop.add(&quot;left&quot;);</span>
<span class="fc" id="L2242">        tableAliasStop.add(&quot;outer&quot;);</span>
<span class="fc" id="L2243">        tableAliasStop.add(&quot;asof&quot;);</span>
<span class="fc" id="L2244">        tableAliasStop.add(&quot;splice&quot;);</span>
<span class="fc" id="L2245">        tableAliasStop.add(&quot;lt&quot;);</span>
<span class="fc" id="L2246">        tableAliasStop.add(&quot;cross&quot;);</span>
<span class="fc" id="L2247">        tableAliasStop.add(&quot;sample&quot;);</span>
<span class="fc" id="L2248">        tableAliasStop.add(&quot;order&quot;);</span>
<span class="fc" id="L2249">        tableAliasStop.add(&quot;on&quot;);</span>
<span class="fc" id="L2250">        tableAliasStop.add(&quot;timestamp&quot;);</span>
<span class="fc" id="L2251">        tableAliasStop.add(&quot;limit&quot;);</span>
<span class="fc" id="L2252">        tableAliasStop.add(&quot;)&quot;);</span>
<span class="fc" id="L2253">        tableAliasStop.add(&quot;;&quot;);</span>
<span class="fc" id="L2254">        tableAliasStop.add(&quot;union&quot;);</span>
<span class="fc" id="L2255">        tableAliasStop.add(&quot;group&quot;);</span>
<span class="fc" id="L2256">        tableAliasStop.add(&quot;except&quot;);</span>
<span class="fc" id="L2257">        tableAliasStop.add(&quot;intersect&quot;);</span>
<span class="fc" id="L2258">        tableAliasStop.add(&quot;from&quot;);</span>
        //
<span class="fc" id="L2260">        columnAliasStop.add(&quot;from&quot;);</span>
<span class="fc" id="L2261">        columnAliasStop.add(&quot;,&quot;);</span>
<span class="fc" id="L2262">        columnAliasStop.add(&quot;over&quot;);</span>
<span class="fc" id="L2263">        columnAliasStop.add(&quot;union&quot;);</span>
<span class="fc" id="L2264">        columnAliasStop.add(&quot;except&quot;);</span>
<span class="fc" id="L2265">        columnAliasStop.add(&quot;intersect&quot;);</span>
        //
<span class="fc" id="L2267">        groupByStopSet.add(&quot;order&quot;);</span>
<span class="fc" id="L2268">        groupByStopSet.add(&quot;)&quot;);</span>
<span class="fc" id="L2269">        groupByStopSet.add(&quot;,&quot;);</span>

<span class="fc" id="L2271">        joinStartSet.put(&quot;left&quot;, QueryModel.JOIN_INNER);</span>
<span class="fc" id="L2272">        joinStartSet.put(&quot;join&quot;, QueryModel.JOIN_INNER);</span>
<span class="fc" id="L2273">        joinStartSet.put(&quot;inner&quot;, QueryModel.JOIN_INNER);</span>
<span class="fc" id="L2274">        joinStartSet.put(&quot;left&quot;, QueryModel.JOIN_OUTER);//only left join is supported currently </span>
<span class="fc" id="L2275">        joinStartSet.put(&quot;cross&quot;, QueryModel.JOIN_CROSS);</span>
<span class="fc" id="L2276">        joinStartSet.put(&quot;asof&quot;, QueryModel.JOIN_ASOF);</span>
<span class="fc" id="L2277">        joinStartSet.put(&quot;splice&quot;, QueryModel.JOIN_SPLICE);</span>
<span class="fc" id="L2278">        joinStartSet.put(&quot;lt&quot;, QueryModel.JOIN_LT);</span>
<span class="fc" id="L2279">        joinStartSet.put(&quot;,&quot;, QueryModel.JOIN_CROSS);</span>
        //
<span class="fc" id="L2281">        setOperations.add(&quot;union&quot;);</span>
<span class="fc" id="L2282">        setOperations.add(&quot;except&quot;);</span>
<span class="fc" id="L2283">        setOperations.add(&quot;intersect&quot;);</span>
<span class="fc" id="L2284">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>