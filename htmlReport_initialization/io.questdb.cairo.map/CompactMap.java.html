<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompactMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo.map</a> &gt; <span class="el_source">CompactMap.java</span></div><h1>CompactMap.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo.map;

import io.questdb.cairo.*;
import io.questdb.cairo.sql.Record;
import io.questdb.cairo.sql.RecordCursor;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.MemoryARW;
import io.questdb.cairo.vm.api.MemoryR;
import io.questdb.griffin.engine.LimitOverflowException;
import io.questdb.std.*;
import org.jetbrains.annotations.TestOnly;

/**
 * Storage structure to support queries such as &quot;select distinct ...&quot;,
 * group by queries and analytic functions. It can be thought of as a
 * hash map with composite keys and values. Composite key is allowed
 * to contain any number of fields of any type. In practice key will
 * be a record of columns, including both of variable-length (string and binary)
 * and of fixed-length types. Composite values can be any combination of
 * fixed-length types only.
 * &lt;p&gt;
 * QMap constructor requires ColumnTypes instances for both key and values
 * to determine optimal storage structure. Both keys and values are stored
 * in individually sized memory cells. Types written to these cells are not
 * yet validated. User must make sure correct types are written to correct cells.
 * Failing to do so will lead to memory corruption. But lets not dwell on that.
 * Map memory structure looks like this:
 * &lt;pre&gt;
 *     union cell {
 *         byte b;
 *         short s;
 *         int i;
 *         long l;
 *         float f;
 *         double d;
 *         BOOL bool;
 *     } cell;
 * *
 *     struct string {
 *         int size;
 *         char[] chars;
 *     } string;
 *
 *     struct bin {
 *         long size;
 *         byte[] bytes;
 *     } bin;
 *
 *     union entry_var {
 *         string s;
 *         bin b;
 *     }
 *
 *     struct entry {
 *         byte flag;
 *         long size;
 *         cell[] cells;
 *         entry_var[] var;
 *     }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * QMap uses open addressing to keep track of entry offsets. Key hash
 * code determines bucket. Entries in the same bucket are stored
 * as mono-directional linked list. In this list the reference part
 * is a one-byte distance from parent to the next list entry. The
 * value of this byte is an index in fixed jump distance table. QMap
 * also provides and maintains guarantee that each hash code root
 * entry will be stored in bucket, which can be computed directly from
 * this hash code.
 */
public class CompactMap implements Map, Reopenable {
    public static final byte BITS_DIRECT_HIT = (byte) 0b10000000;
    public static final byte BITS_DISTANCE = 0b01111111;
    public static final int jumpDistancesLen = 126;
    static final int ENTRY_HEADER_SIZE = 9;
<span class="fc" id="L100">    private static final HashFunctionFactory DEFAULT_HASH_FACTORY = CompactMap::defaultHashFunction;</span>
<span class="fc" id="L101">    private static final long[] jumpDistances =</span>
            {
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,

                    21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210, 231,
                    253, 276, 300, 325, 351, 378, 406, 435, 465, 496, 528, 561, 595, 630,
                    666, 703, 741, 780, 820, 861, 903, 946, 990, 1035, 1081, 1128, 1176,
                    1225, 1275, 1326, 1378, 1431, 1485, 1540, 1596, 1653, 1711, 1770, 1830,
                    1891, 1953, 2016, 2080, 2145, 2211, 2278, 2346, 2415, 2485, 2556,

                    3741, 8385, 18915, 42486, 95703, 215496, 485605, 1091503, 2456436,
                    5529475, 12437578, 27986421, 62972253, 141700195, 318819126, 717314626,
                    1614000520, 3631437253L, 8170829695L, 18384318876L, 41364501751L, 93070021080L, 209407709220L,
                    471167588430L, 1060127437995L, 2385287281530L, 5366895564381L, 12075513791265L, 27169907873235L,
                    61132301007778L, 137547673121001L, 309482258302503L, 696335090510256L, 1566753939653640L,
                    3525196427195653L, 7931691866727775L, 17846306747368716L, 40154190394120111L, 90346928493040500L,
                    203280588949935750L, 457381324898247375L, 1029107980662394500L, 2315492957028380766L,
                    5209859150892887590L
            };
    private final long[] columnOffsets;
    private final CompactMapCursor cursor;
    private final MemoryARW entries;
    private final long entryFixedSize;
    private final long entryKeyOffset;
    private final MemoryARW entrySlots;
    private final HashFunction hashFunction;
<span class="fc" id="L127">    private final Key key = new Key();</span>
    private final double loadFactor;
    private final int maxResizes;
    private final CompactMapRecord record;
    private final CompactMapValue value;
    private final int valueColumnCount;
    private long currentEntryOffset;
<span class="fc" id="L134">    private long currentEntrySize = 0;</span>
    private long keyCapacity;
    private long mask;
    private int nResizes;
    private long size;

    public CompactMap(int pageSize, @Transient ColumnTypes keyTypes, @Transient ColumnTypes valueTypes, long keyCapacity, double loadFactor, int maxResizes, int maxPages) {
<span class="fc" id="L141">        this(pageSize, keyTypes, valueTypes, keyCapacity, loadFactor, DEFAULT_HASH_FACTORY, maxResizes, maxPages);</span>
<span class="fc" id="L142">    }</span>

    @TestOnly
<span class="fc" id="L145">    CompactMap(int pageSize, @Transient ColumnTypes keyTypes, @Transient ColumnTypes valueTypes, long keyCapacity, double loadFactor, HashFunctionFactory hashFunctionFactory, int maxResizes, int maxPages) {</span>
<span class="fc" id="L146">        this.entries = Vm.getARWInstance(pageSize, maxPages, MemoryTag.NATIVE_COMPACT_MAP);</span>
<span class="fc" id="L147">        this.entrySlots = Vm.getARWInstance(pageSize, maxPages, MemoryTag.NATIVE_COMPACT_MAP);</span>
        try {
<span class="fc" id="L149">            this.loadFactor = loadFactor;</span>
<span class="fc" id="L150">            this.columnOffsets = new long[keyTypes.getColumnCount() + valueTypes.getColumnCount()];</span>
<span class="fc" id="L151">            this.valueColumnCount = valueTypes.getColumnCount();</span>
<span class="fc" id="L152">            this.entryFixedSize = calcColumnOffsets(keyTypes, calcColumnOffsets(valueTypes, ENTRY_HEADER_SIZE, 0), this.valueColumnCount);</span>
<span class="fc" id="L153">            this.entryKeyOffset = columnOffsets[valueColumnCount];</span>
<span class="fc" id="L154">            this.keyCapacity = Math.max(keyCapacity, 16);</span>
<span class="fc" id="L155">            this.hashFunction = hashFunctionFactory.create(entries);</span>
<span class="fc" id="L156">            configureCapacity();</span>
<span class="fc" id="L157">            this.value = new CompactMapValue(entries, columnOffsets);</span>
<span class="fc" id="L158">            this.record = new CompactMapRecord(entries, columnOffsets, value);</span>
<span class="fc" id="L159">            this.cursor = new CompactMapCursor(record);</span>
<span class="fc" id="L160">            this.nResizes = 0;</span>
<span class="fc" id="L161">            this.maxResizes = maxResizes;</span>
<span class="fc" id="L162">        } catch (Throwable e) {</span>
<span class="fc" id="L163">            Misc.free(this.entries);</span>
<span class="fc" id="L164">            Misc.free(this.entrySlots);</span>
<span class="fc" id="L165">            throw e;</span>
<span class="fc" id="L166">        }</span>
<span class="fc" id="L167">    }</span>

    @Override
    public void clear() {
<span class="fc" id="L171">        entrySlots.jumpTo((mask + 1) * 8);</span>
<span class="fc" id="L172">        entrySlots.zero();</span>
<span class="fc" id="L173">        currentEntryOffset = 0;</span>
<span class="fc" id="L174">        currentEntrySize = 0;</span>
<span class="fc" id="L175">        size = 0;</span>
<span class="fc" id="L176">        nResizes = 0;</span>
<span class="fc" id="L177">    }</span>

    @Override
    public void close() {
<span class="fc" id="L181">        entries.close();</span>
<span class="fc" id="L182">        entrySlots.close();</span>
<span class="fc" id="L183">    }</span>

    @Override
    public RecordCursor getCursor() {
<span class="fc" id="L187">        cursor.of(currentEntryOffset + currentEntrySize);</span>
<span class="fc" id="L188">        return cursor;</span>
    }

    public long getKeyCapacity() {
<span class="fc" id="L192">        return keyCapacity;</span>
    }

    @Override
    public MapRecord getRecord() {
<span class="fc" id="L197">        return record;</span>
    }

    public int getValueColumnCount() {
<span class="fc" id="L201">        return valueColumnCount;</span>
    }

    @Override
    public void reopen() {
<span class="fc" id="L206">        clear();</span>
<span class="fc" id="L207">    }</span>

    @Override
    public void restoreInitialCapacity() {
        // no op
<span class="nc" id="L212">    }</span>

    @Override
    public long size() {
<span class="fc" id="L216">        return size;</span>
    }

    @Override
    public MapValue valueAt(long address) {
<span class="nc" id="L221">        value.of(address, false);</span>
<span class="nc" id="L222">        return value;</span>
    }

    @Override
    public MapKey withKey() {
<span class="fc" id="L227">        currentEntryOffset = currentEntryOffset + currentEntrySize;</span>
<span class="fc" id="L228">        entries.jumpTo(currentEntryOffset + columnOffsets[valueColumnCount]);</span>

        // each entry cell is 8-byte value, which either holds cell value
        // or reference, relative to entry start, where value is kept in size-prefixed format
        // Variable size key cells are stored right behind entry.
        // Value (as in key-Value pair) is stored first. It is always fixed length and when
        // it is out of the way we can calculate key hash on contiguous memory.

        // entry actual size always starts with sum of fixed size columns we have
        // and may setSize when we add variable key values.
<span class="fc" id="L238">        currentEntrySize = entryFixedSize;</span>

<span class="fc" id="L240">        return key;</span>
    }

    private static HashFunction defaultHashFunction(MemoryR memory) {
<span class="fc" id="L244">        return (offset, size) -&gt; Hash.hashMem32(offset, size, memory);</span>
    }

    private long calcColumnOffsets(ColumnTypes valueTypes, long startOffset, int startPosition) {
<span class="fc" id="L248">        long o = startOffset;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        for (int i = 0, n = valueTypes.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc" id="L250">            final int columnType = valueTypes.getColumnType(i);</span>
            int sz;
<span class="pc bpc" id="L252" title="1 of 7 branches missed.">            switch (ColumnType.tagOf(columnType)) {</span>
                case ColumnType.BOOLEAN:
                case ColumnType.BYTE:
                case ColumnType.GEOBYTE:
<span class="fc" id="L256">                    sz = 1;</span>
<span class="fc" id="L257">                    break;</span>
                case ColumnType.DOUBLE:
                case ColumnType.LONG:
                case ColumnType.DATE:
                case ColumnType.TIMESTAMP:
                case ColumnType.STRING:
                case ColumnType.BINARY:
                case ColumnType.GEOLONG:
<span class="fc" id="L265">                    sz = 8;</span>
<span class="fc" id="L266">                    break;</span>
                case ColumnType.FLOAT:
                case ColumnType.INT:
                case ColumnType.GEOINT:
<span class="fc" id="L270">                    sz = 4;</span>
<span class="fc" id="L271">                    break;</span>
                case ColumnType.SHORT:
                case ColumnType.CHAR:
                case ColumnType.GEOSHORT:
<span class="fc" id="L275">                    sz = 2;</span>
<span class="fc" id="L276">                    break;</span>
                case ColumnType.LONG256:
<span class="nc" id="L278">                    sz = Long256.BYTES;</span>
<span class="nc" id="L279">                    break;</span>
                case ColumnType.LONG128:
                case ColumnType.UUID:
<span class="fc" id="L282">                    sz = Long128.BYTES;</span>
<span class="fc" id="L283">                    break;</span>
                default:
<span class="fc" id="L285">                    throw CairoException.critical(0).put(&quot;Unsupported column type: &quot;).put(ColumnType.nameOf(valueTypes.getColumnType(i)));</span>
            }
<span class="fc" id="L287">            columnOffsets[startPosition + i] = o;</span>
<span class="fc" id="L288">            o += sz;</span>
        }
<span class="fc" id="L290">        return o;</span>
    }

    private void configureCapacity() {
<span class="fc" id="L294">        this.mask = Numbers.ceilPow2((long) (keyCapacity / loadFactor)) - 1;</span>
<span class="fc" id="L295">        entrySlots.jumpTo((mask + 1) * 8);</span>
<span class="fc" id="L296">        entrySlots.zero();</span>
<span class="fc" id="L297">    }</span>

    long getActualCapacity() {
<span class="fc" id="L300">        return mask + 1;</span>
    }

    long getAppendOffset() {
<span class="fc" id="L304">        return currentEntryOffset + currentEntrySize;</span>
    }

    @FunctionalInterface
    public interface HashFunction {
        long hash(long offset, long size);
    }

    @FunctionalInterface
    public interface HashFunctionFactory {
        HashFunction create(MemoryR memory);
    }

<span class="fc" id="L317">    public class Key implements MapKey {</span>

        @Override
        public CompactMapValue createValue() {
<span class="fc" id="L321">            long slot = calculateEntrySlot(currentEntryOffset, currentEntrySize);</span>
<span class="fc" id="L322">            long offset = getOffsetAt(slot);</span>

<span class="fc bfc" id="L324" title="All 2 branches covered.">            if (offset == -1) {</span>
                // great, slot is empty, create new entry as direct hit
<span class="fc" id="L326">                return putNewEntryAt(slot, BITS_DIRECT_HIT);</span>
            }

            // check if this was a direct hit
<span class="fc" id="L330">            final byte flag = entries.getByte(offset);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if ((flag &amp; BITS_DIRECT_HIT) == 0) {</span>
                // this is not a direct hit slot, reshuffle entries to free this slot up
                // then create new entry here with direct hit flag
                // we don't have to compare keys, because this isn't our hash code

                // steps to take
                // 1. find parent of this rogue entry: compute hash code on key, find direct hit entry and
                //    descend until we find the sucker just above this one. We need this in order to change
                //    distance byte to keep structure consistent
                // 2. Find empty slot from parent
                // 3. Move current entry there
                // 4. For next entry - current will be parent
                // 5. Find empty slot from new parent
                // 6. Move entry there
                // 7. etc
                // as we shuffle these things we have to be careful not to use
                // entry we originally set out to free

<span class="fc bfc" id="L349" title="All 2 branches covered.">                if (moveForeignEntries(slot, offset)) {</span>
<span class="fc" id="L350">                    return putNewEntryAt(slot, BITS_DIRECT_HIT);</span>
                }

<span class="fc" id="L353">                grow();</span>
<span class="fc" id="L354">                return createValue();</span>
            }

            // this is direct hit, scroll down all keys with same hashcode
            // and exit this loop as soon as equality operator scores
            // in simple terms check key equality on this key
<span class="fc bfc" id="L360" title="All 2 branches covered.">            if (cmp(offset)) {</span>
<span class="fc" id="L361">                return found(offset);</span>
            }

<span class="fc" id="L364">            return appendEntry(offset, slot, flag);</span>
        }

        @Override
        public CompactMapValue findValue() {
<span class="fc" id="L369">            long slot = calculateEntrySlot(currentEntryOffset, currentEntrySize);</span>
<span class="fc" id="L370">            long offset = getOffsetAt(slot);</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">            if (offset == -1) {</span>
<span class="fc" id="L373">                return null;</span>
            } else {
                // check if this was a direct hit
<span class="fc" id="L376">                byte flag = entries.getByte(offset);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                if ((flag &amp; BITS_DIRECT_HIT) == 0) {</span>
                    // not a direct hit? not our value
<span class="fc" id="L379">                    return null;</span>
                } else {
                    // this is direct hit, scroll down all keys with same hashcode
                    // and exit this loop as soon as equality operator scores

                    // in simple terms check key equality on this key
<span class="fc bfc" id="L385" title="All 2 branches covered.">                    if (cmp(offset)) {</span>
<span class="fc" id="L386">                        return found(offset);</span>
                    } else {

                        // then go down the list until either list ends or we find value
<span class="fc" id="L390">                        int distance = flag &amp; BITS_DISTANCE;</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">                        while (distance &gt; 0) {</span>
<span class="fc" id="L392">                            slot = nextSlot(slot, distance);</span>
<span class="fc" id="L393">                            offset = getOffsetAt(slot);</span>

                            // this offset cannot be 0 when data structure is consistent
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                            assert offset != 0;</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">                            if (cmp(offset)) {</span>
<span class="fc" id="L399">                                return found(offset);</span>
                            }
<span class="fc" id="L401">                            distance = entries.getByte(offset) &amp; BITS_DISTANCE;</span>
                        }
                        // reached the end of the list, nothing found
<span class="fc" id="L404">                        return null;</span>
                    }
                }
            }
        }

        @Override
        public void put(Record record, RecordSink sink) {
<span class="fc" id="L412">            sink.copy(record, key);</span>
<span class="fc" id="L413">        }</span>

        @Override
        public void putBin(BinarySequence value) {
<span class="fc bfc" id="L417" title="All 2 branches covered.">            if (value == null) {</span>
<span class="fc" id="L418">                entries.putLong(TableUtils.NULL_LEN);</span>
            } else {
<span class="fc" id="L420">                entries.putLong(currentEntrySize);</span>
<span class="fc" id="L421">                long o = entries.getAppendOffset();</span>
<span class="fc" id="L422">                entries.jumpTo(currentEntryOffset + currentEntrySize);</span>
<span class="fc" id="L423">                entries.putBin(value);</span>
<span class="fc" id="L424">                currentEntrySize += 8 + value.length();</span>
<span class="fc" id="L425">                entries.jumpTo(o);</span>
            }
<span class="fc" id="L427">        }</span>

        @Override
        public void putBool(boolean value) {
<span class="fc" id="L431">            entries.putBool(value);</span>
<span class="fc" id="L432">        }</span>

        @Override
        public void putByte(byte value) {
<span class="fc" id="L436">            entries.putByte(value);</span>
<span class="fc" id="L437">        }</span>

        @Override
        public void putChar(char value) {
<span class="nc" id="L441">            entries.putChar(value);</span>
<span class="nc" id="L442">        }</span>

        @Override
        public void putDate(long value) {
<span class="fc" id="L446">            putLong(value);</span>
<span class="fc" id="L447">        }</span>

        @Override
        public void putDouble(double value) {
<span class="fc" id="L451">            entries.putDouble(value);</span>
<span class="fc" id="L452">        }</span>

        @Override
        public void putFloat(float value) {
<span class="fc" id="L456">            entries.putFloat(value);</span>
<span class="fc" id="L457">        }</span>

        @Override
        public void putInt(int value) {
<span class="fc" id="L461">            entries.putInt(value);</span>
<span class="fc" id="L462">        }</span>

        @Override
        public void putLong(long value) {
<span class="fc" id="L466">            entries.putLong(value);</span>
<span class="fc" id="L467">        }</span>

        @Override
        public void putLong128(long lo, long hi) {
<span class="fc" id="L471">            entries.putLong128(lo, hi);</span>
<span class="fc" id="L472">        }</span>

        @Override
        public void putLong256(Long256 value) {
<span class="nc" id="L476">            entries.putLong256(value);</span>
<span class="nc" id="L477">        }</span>

        @Override
        public void putRecord(Record value) {
            // noop
<span class="nc" id="L482">        }</span>

        @Override
        public void putShort(short value) {
<span class="fc" id="L486">            entries.putShort(value);</span>
<span class="fc" id="L487">        }</span>

        @Override
        public void putStr(CharSequence value) {
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (value == null) {</span>
<span class="fc" id="L492">                entries.putLong(TableUtils.NULL_LEN);</span>
            } else {
                // offset of string value relative to record start
<span class="fc" id="L495">                entries.putLong(currentEntrySize);</span>
<span class="fc" id="L496">                int len = value.length();</span>
<span class="fc" id="L497">                entries.putStr(currentEntryOffset + currentEntrySize, value, 0, len);</span>
<span class="fc" id="L498">                currentEntrySize += Vm.getStorageLength(len);</span>
            }
<span class="fc" id="L500">        }</span>

        @Override
        public void putStr(CharSequence value, int lo, int hi) {
            // offset of string value relative to record start
<span class="nc" id="L505">            entries.putLong(currentEntrySize);</span>
<span class="nc" id="L506">            int len = hi - lo;</span>
<span class="nc" id="L507">            entries.putStr(currentEntryOffset + currentEntrySize, value, lo, len);</span>
<span class="nc" id="L508">            currentEntrySize += Vm.getStorageLength(len);</span>
<span class="nc" id="L509">        }</span>

        @Override
        public void putTimestamp(long value) {
<span class="fc" id="L513">            putLong(value);</span>
<span class="fc" id="L514">        }</span>

        @Override
        public void skip(int bytes) {
<span class="nc" id="L518">            entries.skip(bytes);</span>
<span class="nc" id="L519">        }</span>

        private CompactMapValue appendEntry(long offset, long slot, byte flag) {
<span class="fc" id="L522">            int distance = flag &amp; BITS_DISTANCE;</span>
<span class="fc" id="L523">            long original = offset;</span>

<span class="fc bfc" id="L525" title="All 2 branches covered.">            while (distance &gt; 0) {</span>
<span class="fc" id="L526">                slot = nextSlot(slot, distance);</span>
<span class="fc" id="L527">                offset = getOffsetAt(slot);</span>

                // this offset cannot be 0 when data structure is consistent
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">                assert offset != 0;</span>

<span class="fc" id="L532">                distance = entries.getByte(offset) &amp; BITS_DISTANCE;</span>

<span class="fc bfc" id="L534" title="All 2 branches covered.">                if (cmp(offset)) {</span>
<span class="fc" id="L535">                    return found(offset);</span>
                }
            }

            // create entry at &quot;nextOffset&quot;
<span class="fc" id="L540">            distance = findFreeSlot(slot);</span>

            // we must have space here because to get to this place
            // we must have checked available capacity
            // anyway there is a test that ensures that going
            // down the chain will not hit problems.
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">            assert distance != 0;</span>

<span class="fc" id="L548">            slot = nextSlot(slot, distance);</span>

            // update distance on last entry in linked list
<span class="fc bfc" id="L551" title="All 2 branches covered.">            if (original == offset) {</span>
<span class="fc" id="L552">                distance = distance | BITS_DIRECT_HIT;</span>
            }
<span class="fc" id="L554">            entries.putByte(offset, (byte) distance);</span>

            // add new entry
<span class="fc" id="L557">            return putNewEntryAt(slot, (byte) 0);</span>
        }

        private long calculateEntrySlot(long offset, long size) {
<span class="fc" id="L561">            return hashFunction.hash(offset + entryKeyOffset, size - entryKeyOffset) &amp; mask;</span>
        }

        private boolean cmp(long offset) {
<span class="fc" id="L565">            return cmp(currentEntryOffset + entryKeyOffset, offset + entryKeyOffset, currentEntrySize - entryKeyOffset);</span>
        }

        private boolean cmp(long offset1, long offset2, long size) {
<span class="fc" id="L569">            final long lim = size - size % 8L;</span>

<span class="fc bfc" id="L571" title="All 2 branches covered.">            for (long i = 0; i &lt; lim; i += 8L) {</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                if (entries.getLong(offset1 + i) != entries.getLong(offset2 + i)) {</span>
<span class="fc" id="L573">                    return false;</span>
                }
            }

<span class="fc bfc" id="L577" title="All 2 branches covered.">            for (long i = lim; i &lt; size; i++) {</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                if (entries.getByte(offset1 + i) != entries.getByte(offset2 + i)) {</span>
<span class="fc" id="L579">                    return false;</span>
                }
            }

<span class="fc" id="L583">            return true;</span>
        }

        // technically we should always have free slots when load factory is less than 1 (which we enforce)
        // however, sometimes these free slots cannot be reached via jump table. This is purely because
        // jump table is limited. When this occurs the caller has to handle 0 distance by re-hashing
        // of all entries and retrying new entry creation.
        private int findFreeSlot(long slot) {
<span class="fc bfc" id="L591" title="All 2 branches covered.">            for (int i = 1; i &lt; jumpDistancesLen; i++) {</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">                if (entrySlots.getLong(nextSlot(slot, i) * 8) == 0) {</span>
<span class="fc" id="L593">                    return i;</span>
                }
            }
<span class="fc" id="L596">            return 0;</span>
        }

        /**
         * Finds parent of given entry. Entry in question is represented by two attributes: offset and targetSlot
         *
         * @param offset     offset of entry data
         * @param targetSlot slot of entry
         * @return parent slot - offset in entrySlots
         */
        private long findParentSlot(long offset, long targetSlot) {
<span class="fc" id="L607">            long parentSlot = calculateEntrySlot(offset, getEntrySize(offset));</span>

            do {
<span class="fc" id="L610">                final int distance = entries.getByte(getOffsetAt(parentSlot)) &amp; BITS_DISTANCE;</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                assert distance != 0;</span>
<span class="fc" id="L612">                final long nextSlot = nextSlot(parentSlot, distance);</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">                if (nextSlot == targetSlot) {</span>
<span class="fc" id="L614">                    return parentSlot;</span>
                }
<span class="fc" id="L616">                parentSlot = nextSlot;</span>
<span class="fc" id="L617">            } while (true);</span>
        }

        private CompactMapValue found(long offset) {
            // found key
            // values offset will be
<span class="fc" id="L623">            value.of(offset, false);</span>
            // undo this key append
<span class="fc" id="L625">            currentEntrySize = 0;</span>
<span class="fc" id="L626">            return value;</span>
        }

        private long getEntrySize(long offset) {
<span class="fc" id="L630">            return entries.getLong(offset + 1);</span>
        }

        private long getOffsetAt(long slot) {
<span class="fc" id="L634">            return entrySlots.getLong(slot * 8) - 1;</span>
        }

        private void grow() {
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">            if (nResizes &lt; maxResizes) {</span>
<span class="fc" id="L639">                nResizes++;</span>
                // resize offsets virtual memory
<span class="fc" id="L641">                long appendPosition = entries.getAppendOffset();</span>
                try {
<span class="fc" id="L643">                    keyCapacity = keyCapacity * 2;</span>
<span class="fc" id="L644">                    configureCapacity();</span>
<span class="fc" id="L645">                    long target = size;</span>
<span class="fc" id="L646">                    long offset = 0L;</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">                    while (target &gt; 0) {</span>
<span class="fc" id="L648">                        final long entrySize = getEntrySize(offset);</span>
<span class="fc" id="L649">                        rehashEntry(offset, entrySize);</span>
<span class="fc" id="L650">                        offset += entrySize;</span>
<span class="fc" id="L651">                        target--;</span>
<span class="fc" id="L652">                    }</span>
                } finally {
<span class="fc" id="L654">                    entries.jumpTo(appendPosition);</span>
                }
<span class="fc" id="L656">            } else {</span>
<span class="nc" id="L657">                throw LimitOverflowException.instance().put(&quot;limit of &quot;).put(maxResizes).put(&quot; resizes exceeded in CompactMap&quot;);</span>
            }
<span class="fc" id="L659">        }</span>

        private boolean moveForeignEntries(final long slot, final long offset) {
            // find parent slot for our direct hit
<span class="fc" id="L663">            long parentSlot = findParentSlot(offset, slot);</span>
            // find entry for the parent slot, we will be updating distance here
<span class="fc" id="L665">            long parentOffset = getOffsetAt(parentSlot);</span>
<span class="fc" id="L666">            long currentSlot = slot;</span>
<span class="fc" id="L667">            long currentOffset = offset;</span>

            while (true) {
                // find where &quot;current&quot; slot is going to
<span class="fc" id="L671">                int dist = findFreeSlot(parentSlot);</span>

<span class="fc bfc" id="L673" title="All 2 branches covered.">                if (dist == 0) {</span>
                    // we are out of space; let parent method know that we have to setSize slots and retry
<span class="fc" id="L675">                    return false;</span>
                }

                // update parent entry with its new location
<span class="fc bfc" id="L679" title="All 2 branches covered.">                if ((entries.getByte(parentOffset) &amp; BITS_DIRECT_HIT) == 0) {</span>
<span class="fc" id="L680">                    entries.putByte(parentOffset, (byte) dist);</span>
                } else {
<span class="fc" id="L682">                    entries.putByte(parentOffset, (byte) (dist | BITS_DIRECT_HIT));</span>
                }

                // update slot with current offset
<span class="fc" id="L686">                final long nextSlot = nextSlot(parentSlot, dist);</span>
<span class="fc" id="L687">                setOffsetAt(nextSlot, currentOffset);</span>

                // check if the current entry has child
<span class="fc" id="L690">                dist = entries.getByte(currentOffset) &amp; BITS_DISTANCE;</span>

<span class="fc bfc" id="L692" title="All 2 branches covered.">                if (currentSlot != slot) {</span>
<span class="fc" id="L693">                    setOffsetAt(currentSlot, -1);</span>
                }

<span class="fc bfc" id="L696" title="All 2 branches covered.">                if (dist == 0) {</span>
                    // done
<span class="fc" id="L698">                    break;</span>
                }

                // parent of next entry will be current entry
<span class="fc" id="L702">                parentSlot = nextSlot;</span>
<span class="fc" id="L703">                parentOffset = currentOffset;</span>
<span class="fc" id="L704">                currentSlot = nextSlot(currentSlot, dist);</span>
<span class="fc" id="L705">                currentOffset = getOffsetAt(currentSlot);</span>
<span class="fc" id="L706">            }</span>

<span class="fc" id="L708">            return true;</span>
        }

        private long nextSlot(long slot, int distance) {
<span class="fc" id="L712">            return (slot + jumpDistances[distance]) &amp; mask;</span>
        }

        private void putEntryAt(long entryOffset, long slot, byte flag) {
<span class="fc" id="L716">            setOffsetAt(slot, entryOffset);</span>
<span class="fc" id="L717">            entries.putByte(entryOffset, flag);</span>
<span class="fc" id="L718">        }</span>

        private CompactMapValue putNewEntryAt(long slot, byte flag) {
            // entry size is now known
            // values are always fixed size and already accounted for
            // so go ahead and finalize
<span class="fc" id="L724">            entries.putByte(currentEntryOffset, flag);</span>
<span class="fc" id="L725">            entries.putLong(currentEntryOffset + 1, currentEntrySize); // size</span>
<span class="fc" id="L726">            entries.jumpTo(currentEntryOffset + ENTRY_HEADER_SIZE);</span>

<span class="fc bfc" id="L728" title="All 2 branches covered.">            if (++size == keyCapacity) {</span>
                // reached capacity?
                // no need to populate slot, setSize() will do the job for us
<span class="fc" id="L731">                grow();</span>
            } else {
<span class="fc" id="L733">                setOffsetAt(slot, currentEntryOffset);</span>
            }
            // this would be offset of entry values
<span class="fc" id="L736">            value.of(currentEntryOffset, true);</span>
<span class="fc" id="L737">            return value;</span>
        }

        private void rehashEntry(long entryOffset, long currentEntrySize) {
<span class="fc" id="L741">            long slot = calculateEntrySlot(entryOffset, currentEntrySize);</span>
<span class="fc" id="L742">            long offset = getOffsetAt(slot);</span>

<span class="fc bfc" id="L744" title="All 2 branches covered.">            if (offset == -1) {</span>
                // great, slot is empty, create new entry as direct hit
<span class="fc" id="L746">                putEntryAt(entryOffset, slot, BITS_DIRECT_HIT);</span>
            } else {
                // check if this was a direct hit
<span class="fc" id="L749">                final byte flag = entries.getByte(offset);</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">                if ((flag &amp; BITS_DIRECT_HIT) == 0) {</span>
<span class="fc" id="L751">                    moveForeignEntries(slot, offset);</span>
<span class="fc" id="L752">                    putEntryAt(entryOffset, slot, BITS_DIRECT_HIT);</span>
                } else {
                    // Our entries are now guaranteed to be unique. In case of direct hit we simply append
                    // entry to end of list.
<span class="fc" id="L756">                    int distance = flag &amp; BITS_DISTANCE;</span>
<span class="fc" id="L757">                    long original = offset;</span>

<span class="fc bfc" id="L759" title="All 2 branches covered.">                    while (distance &gt; 0) {</span>
<span class="fc" id="L760">                        slot = nextSlot(slot, distance);</span>
<span class="fc" id="L761">                        distance = entries.getByte(offset = getOffsetAt(slot)) &amp; BITS_DISTANCE;</span>
                    }

                    // create entry at &quot;nextOffset&quot;
<span class="fc" id="L765">                    distance = findFreeSlot(slot);</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">                    assert distance != 0;</span>
<span class="fc" id="L767">                    slot = nextSlot(slot, distance);</span>

                    // update distance on last entry in linked list
<span class="fc bfc" id="L770" title="All 2 branches covered.">                    if (original == offset) {</span>
<span class="fc" id="L771">                        entries.putByte(offset, (byte) (distance | BITS_DIRECT_HIT));</span>
                    } else {
<span class="fc" id="L773">                        entries.putByte(offset, (byte) distance);</span>
                    }
                    // add new entry
<span class="fc" id="L776">                    putEntryAt(entryOffset, slot, (byte) 0);</span>
                }
            }
<span class="fc" id="L779">        }</span>

        private void setOffsetAt(long slot, long offset) {
<span class="fc" id="L782">            entrySlots.putLong(slot * 8, offset + 1);</span>
<span class="fc" id="L783">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>