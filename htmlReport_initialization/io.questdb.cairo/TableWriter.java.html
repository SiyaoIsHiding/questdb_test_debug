<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">TableWriter.java</span></div><h1>TableWriter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.MessageBus;
import io.questdb.MessageBusImpl;
import io.questdb.Metrics;
import io.questdb.cairo.sql.AsyncWriterCommand;
import io.questdb.cairo.sql.SymbolTable;
import io.questdb.cairo.sql.TableRecordMetadata;
import io.questdb.cairo.sql.TableReferenceOutOfDateException;
import io.questdb.cairo.vm.NullMapWriter;
import io.questdb.cairo.vm.Vm;
import io.questdb.cairo.vm.api.*;
import io.questdb.cairo.wal.*;
import io.questdb.cairo.wal.seq.TableSequencer;
import io.questdb.griffin.DropIndexOperator;
import io.questdb.griffin.SqlUtil;
import io.questdb.griffin.UpdateOperatorImpl;
import io.questdb.griffin.engine.ops.AbstractOperation;
import io.questdb.griffin.engine.ops.AlterOperation;
import io.questdb.griffin.engine.ops.UpdateOperation;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.log.LogRecord;
import io.questdb.mp.*;
import io.questdb.std.*;
import io.questdb.std.datetime.DateFormat;
import io.questdb.std.datetime.microtime.Timestamps;
import io.questdb.std.str.DirectByteCharSequence;
import io.questdb.std.str.LPSZ;
import io.questdb.std.str.Path;
import io.questdb.std.str.StringSink;
import io.questdb.tasks.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.TestOnly;

import java.io.Closeable;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.LongConsumer;

import static io.questdb.cairo.BitmapIndexUtils.keyFileName;
import static io.questdb.cairo.BitmapIndexUtils.valueFileName;
import static io.questdb.cairo.TableUtils.*;
import static io.questdb.cairo.sql.AsyncWriterCommand.Error.*;
import static io.questdb.cairo.wal.WalUtils.*;
import static io.questdb.std.Files.FILES_RENAME_OK;
import static io.questdb.tasks.TableWriterTask.*;

public class TableWriter implements TableWriterAPI, MetadataService, Closeable {
    public static final int O3_BLOCK_DATA = 2;
    public static final int O3_BLOCK_MERGE = 3;
    public static final int O3_BLOCK_NONE = -1;
    public static final int O3_BLOCK_O3 = 1;
    public static final int TIMESTAMP_MERGE_ENTRY_BYTES = Long.BYTES * 2;
<span class="fc" id="L80">    private static final ObjectFactory&lt;MemoryCMOR&gt; GET_MEMORY_CMOR = Vm::getMemoryCMOR;</span>
    private static final long IGNORE = -1L;
<span class="fc" id="L82">    private static final Log LOG = LogFactory.getLog(TableWriter.class);</span>
<span class="fc" id="L83">    private static final Runnable NOOP = () -&gt; {</span>
<span class="fc" id="L84">    };</span>
<span class="fc" id="L85">    private static final Row NOOP_ROW = new NoOpRow();</span>
    private static final int PARTITION_UPDATE_SINK_ENTRY_SIZE = 8;
    private static final int ROW_ACTION_NO_PARTITION = 1;
    private static final int ROW_ACTION_NO_TIMESTAMP = 2;
    private static final int ROW_ACTION_O3 = 3;
    private static final int ROW_ACTION_OPEN_PARTITION = 0;
    private static final int ROW_ACTION_SWITCH_PARTITION = 4;
    private static final int WINDOW_SIZE = 4;
    final ObjList&lt;MemoryMA&gt; columns;
    // Latest command sequence per command source.
    // Publisher source is identified by a long value
<span class="fc" id="L96">    private final AlterOperation alterOp = new AlterOperation();</span>
    private final LongConsumer appendTimestampSetter;
    private final LongList columnTops;
    private final ColumnVersionWriter columnVersionWriter;
    private final MPSequence commandPubSeq;
    private final RingQueue&lt;TableWriterTask&gt; commandQueue;
    private final SCSequence commandSubSeq;
    private final CairoConfiguration configuration;
    private final MemoryMAR ddlMem;
    private final int defaultCommitMode;
<span class="fc" id="L106">    private final ObjList&lt;ColumnIndexer&gt; denseIndexers = new ObjList&lt;&gt;();</span>
    private final ObjList&lt;MapWriter&gt; denseSymbolMapWriters;
    private final boolean directIOFlag;
    private final FilesFacade ff;
<span class="fc" id="L110">    private final StringSink fileNameSink = new StringSink();</span>
    private final int fileOperationRetryCount;
<span class="fc" id="L112">    private final SOCountDownLatch indexLatch = new SOCountDownLatch();</span>
<span class="fc" id="L113">    private final MemoryMR indexMem = Vm.getMRInstance();</span>
<span class="fc" id="L114">    private final LongList indexSequences = new LongList();</span>
    private final ObjList&lt;ColumnIndexer&gt; indexers;
    // This is the same message bus. When TableWriter instance created via CairoEngine, message bus is shared
    // and is owned by the engine. Since TableWriter would not have ownership of the bus it must not free it up.
    // On other hand when TableWrite is created outside CairoEngine, primarily in tests, the ownership of the
    // message bus is with the TableWriter. Therefore, message bus must be freed when writer is freed.
    // To indicate ownership, the message bus owned by the writer will be assigned to `ownMessageBus`. This reference
    // will be released by the writer
    private final MessageBus messageBus;
    private final MemoryMR metaMem;
    private final TableWriterMetadata metadata;
    private final Metrics metrics;
    private final int mkDirMode;
    private final ObjList&lt;Runnable&gt; nullSetters;
<span class="fc" id="L128">    private final ObjectPool&lt;O3Basket&gt; o3BasketPool = new ObjectPool&lt;&gt;(O3Basket::new, 64);</span>
<span class="fc" id="L129">    private final ObjectPool&lt;O3MutableAtomicInteger&gt; o3ColumnCounters = new ObjectPool&lt;&gt;(O3MutableAtomicInteger::new, 64);</span>
    private final int o3ColumnMemorySize;
    private final ObjList&lt;MemoryCR&gt; o3ColumnOverrides;
<span class="fc" id="L132">    private final SOUnboundedCountDownLatch o3DoneLatch = new SOUnboundedCountDownLatch();</span>
<span class="fc" id="L133">    private final AtomicInteger o3ErrorCount = new AtomicInteger();</span>
<span class="fc" id="L134">    private final long[] o3LastTimestampSpreads = new long[WINDOW_SIZE];</span>
<span class="fc" id="L135">    private final AtomicLong o3PartitionUpdRemaining = new AtomicLong();</span>
<span class="fc" id="L136">    private final ObjList&lt;O3CallbackTask&gt; o3PendingCallbackTasks = new ObjList&lt;&gt;();</span>
    private final boolean o3QuickSortEnabled;
    private final Path other;
    private final MessageBus ownMessageBus;
    private final boolean parallelIndexerEnabled;
    private final int partitionBy;
    private final PartitionBy.PartitionCeilMethod partitionCeilMethod;
    private final DateFormat partitionDirFmt;
    private final PartitionBy.PartitionFloorMethod partitionFloorMethod;
<span class="fc" id="L145">    private final LongList partitionRemoveCandidates = new LongList();</span>
    private final Path path;
<span class="fc" id="L147">    private final AtomicLong physicallyWrittenRowsSinceLastCommit = new AtomicLong();</span>
    private final int rootLen;
<span class="fc" id="L149">    private final FragileCode RECOVER_FROM_META_RENAME_FAILURE = this::recoverFromMetaRenameFailure;</span>
<span class="fc" id="L150">    private final FindVisitor removePartitionDirectories = this::removePartitionDirectories0;</span>
<span class="fc" id="L151">    private final Row row = new RowImpl();</span>
<span class="fc" id="L152">    private final LongList rowValueIsNotNull = new LongList();</span>
    private final TxReader slaveTxReader;
    private final ObjList&lt;MapWriter&gt; symbolMapWriters;
<span class="fc" id="L155">    private final IntList symbolRewriteMap = new IntList();</span>
<span class="fc" id="L156">    private final MemoryMARW todoMem = Vm.getMARWInstance();</span>
    private final TxWriter txWriter;
<span class="fc" id="L158">    private final FindVisitor removePartitionDirsNotAttached = this::removePartitionDirsNotAttached;</span>
    private final TxnScoreboard txnScoreboard;
<span class="fc" id="L160">    private final Uuid uuid = new Uuid();</span>
<span class="fc" id="L161">    private final LowerCaseCharSequenceIntHashMap validationMap = new LowerCaseCharSequenceIntHashMap();</span>
    private final WeakClosableObjectPool&lt;MemoryCMOR&gt; walColumnMemoryPool;
<span class="fc" id="L163">    private final ObjList&lt;MemoryCMOR&gt; walMappedColumns = new ObjList&lt;&gt;();</span>
    private ObjList&lt;? extends MemoryA&gt; activeColumns;
    private ObjList&lt;Runnable&gt; activeNullSetters;
    private ColumnVersionReader attachColumnVersionReader;
    private IndexBuilder attachIndexBuilder;
    private long attachMaxTimestamp;
    private MemoryCMR attachMetaMem;
    private TableWriterMetadata attachMetadata;
    private long attachMinTimestamp;
    private TxReader attachTxReader;
<span class="fc" id="L173">    private boolean avoidIndexOnCommit = false;</span>
    private int columnCount;
    private long commitInterval;
    private long commitIntervalDefault;
    // ILP related
    private double commitIntervalFraction;
    private long committedMasterRef;
    private String designatedTimestampColumnName;
<span class="fc" id="L181">    private boolean distressed = false;</span>
    private DropIndexOperator dropIndexOperator;
    private int indexCount;
    private boolean lastOpenPartitionIsReadOnly;
<span class="fc" id="L185">    private long lastOpenPartitionTs = -1L;</span>
    private long lastPartitionTimestamp;
    private LifecycleManager lifecycleManager;
<span class="fc" id="L188">    private int lockFd = -1;</span>
<span class="fc" id="L189">    private long masterRef = 0L;</span>
    private int metaPrevIndex;
<span class="fc" id="L191">    private final FragileCode RECOVER_FROM_TODO_WRITE_FAILURE = this::recoverFromTodoWriteFailure;</span>
    private int metaSwapIndex;
    private long noOpRowCount;
    private DirectLongList o3ColumnTopSink;
    private ReadOnlyObjList&lt;? extends MemoryCR&gt; o3Columns;
<span class="fc" id="L196">    private long o3CommitBatchTimestampMin = Long.MAX_VALUE;</span>
<span class="fc" id="L197">    private long o3EffectiveLag = 0L;</span>
<span class="fc" id="L198">    private boolean o3InError = false;</span>
<span class="fc" id="L199">    private long o3MasterRef = -1L;</span>
    private ObjList&lt;MemoryCARW&gt; o3MemColumns;
    private ObjList&lt;MemoryCARW&gt; o3MemColumns2;
<span class="fc" id="L202">    private final O3ColumnUpdateMethod oooSortVarColumnRef = this::o3SortVarColumn;</span>
<span class="fc" id="L203">    private final O3ColumnUpdateMethod oooSortFixColumnRef = this::o3SortFixColumn;</span>
<span class="fc" id="L204">    private final O3ColumnUpdateMethod o3MergeLagVarColumnRef = this::o3MergeVarColumnLag;</span>
    private ObjList&lt;Runnable&gt; o3NullSetters;
    private ObjList&lt;Runnable&gt; o3NullSetters2;
    // o3PartitionUpdateSink (offset, description):
    // 0, partitionTimestamp
    // 1, timestampMin
    // 2, timestampMax
    // 3, srcOooPartitionLo
    // 4, srcOooPartitionHi
    // 5, partitionMutates ? 1 : 0
    // 6, srcOooMax
    // 7, srcDataMax
    private DirectLongList o3PartitionUpdateSink;
    private long o3RowCount;
    private MemoryMAT o3TimestampMem;
<span class="fc" id="L219">    private final O3ColumnUpdateMethod o3MoveLagRef = this::o3MoveLag0;</span>
<span class="fc" id="L220">    private final O3ColumnUpdateMethod o3MoveUncommittedRef = this::o3MoveUncommitted0;</span>
    private MemoryARW o3TimestampMemCpy;
    private long partitionTimestampHi;
    private boolean performRecovery;
<span class="fc" id="L224">    private boolean removeDirOnCancelRow = true;</span>
<span class="fc" id="L225">    private int rowAction = ROW_ACTION_OPEN_PARTITION;</span>
    private TableToken tableToken;
<span class="fc" id="L227">    private final O3ColumnUpdateMethod o3MergeLagFixColumnRef = this::o3MergeFixColumnLag;</span>
<span class="fc" id="L228">    private long tempMem16b = Unsafe.malloc(16, MemoryTag.NATIVE_TABLE_WRITER);</span>
    private LongConsumer timestampSetter;
    private long todoTxn;
<span class="fc" id="L231">    private final FragileCode RECOVER_FROM_SYMBOL_MAP_WRITER_FAILURE = this::recoverFromSymbolMapWriterFailure;</span>
<span class="fc" id="L232">    private final FragileCode RECOVER_FROM_SWAP_RENAME_FAILURE = this::recoverFromSwapRenameFailure;</span>
<span class="fc" id="L233">    private final FragileCode RECOVER_FROM_COLUMN_OPEN_FAILURE = this::recoverOpenColumnFailure;</span>
    private UpdateOperatorImpl updateOperatorImpl;

    public TableWriter(
            CairoConfiguration configuration,
            TableToken tableToken,
            MessageBus messageBus,
            MessageBus ownMessageBus,
            boolean lock,
            LifecycleManager lifecycleManager,
            CharSequence root,
            Metrics metrics
<span class="fc" id="L245">    ) {</span>
<span class="fc" id="L246">        LOG.info().$(&quot;open '&quot;).utf8(tableToken.getTableName()).$('\'').$();</span>
<span class="fc" id="L247">        this.configuration = configuration;</span>
<span class="pc bpc" id="L248" title="3 of 4 branches missed.">        this.directIOFlag = (Os.type != Os.WINDOWS || configuration.getWriterFileOpenOpts() != CairoConfiguration.O_NONE);</span>
<span class="fc" id="L249">        this.metrics = metrics;</span>
<span class="fc" id="L250">        this.ownMessageBus = ownMessageBus;</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        this.messageBus = ownMessageBus != null ? ownMessageBus : messageBus;</span>
<span class="fc" id="L252">        this.defaultCommitMode = configuration.getCommitMode();</span>
<span class="fc" id="L253">        this.lifecycleManager = lifecycleManager;</span>
<span class="fc" id="L254">        this.parallelIndexerEnabled = configuration.isParallelIndexingEnabled();</span>
<span class="fc" id="L255">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L256">        this.mkDirMode = configuration.getMkDirMode();</span>
<span class="fc" id="L257">        this.fileOperationRetryCount = configuration.getFileOperationRetryCount();</span>
<span class="fc" id="L258">        this.tableToken = tableToken;</span>
<span class="fc" id="L259">        this.o3QuickSortEnabled = configuration.isO3QuickSortEnabled();</span>
<span class="fc" id="L260">        this.o3ColumnMemorySize = configuration.getO3ColumnMemorySize();</span>
<span class="fc" id="L261">        this.path = new Path().of(root).concat(tableToken);</span>
<span class="fc" id="L262">        this.other = new Path().of(root).concat(tableToken);</span>
<span class="fc" id="L263">        this.rootLen = path.length();</span>
        try {
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if (lock) {</span>
<span class="fc" id="L266">                lock();</span>
            } else {
<span class="fc" id="L268">                this.lockFd = -1;</span>
            }
<span class="fc" id="L270">            int todo = readTodo();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (todo == TODO_RESTORE_META) {</span>
<span class="fc" id="L272">                repairMetaRename((int) todoMem.getLong(48));</span>
            }
<span class="fc" id="L274">            this.ddlMem = Vm.getMARInstance();</span>
<span class="fc" id="L275">            this.metaMem = Vm.getMRInstance();</span>
<span class="fc" id="L276">            this.columnVersionWriter = openColumnVersionFile(ff, path, rootLen);</span>

<span class="fc" id="L278">            openMetaFile(ff, path, rootLen, metaMem);</span>
<span class="fc" id="L279">            this.metadata = new TableWriterMetadata(this.tableToken, metaMem);</span>
<span class="fc" id="L280">            this.partitionBy = metaMem.getInt(META_OFFSET_PARTITION_BY);</span>
<span class="fc" id="L281">            this.txWriter = new TxWriter(ff).ofRW(path.concat(TXN_FILE_NAME).$(), partitionBy);</span>
<span class="fc" id="L282">            this.txnScoreboard = new TxnScoreboard(ff, configuration.getTxnScoreboardEntryCount()).ofRW(path.trimTo(rootLen));</span>
<span class="fc" id="L283">            path.trimTo(rootLen);</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            this.o3ColumnOverrides = metadata.isWalEnabled() ? new ObjList&lt;&gt;() : null;</span>
            // we have to do truncate repair at this stage of constructor
            // because this operation requires metadata
<span class="pc bpc" id="L287" title="1 of 3 branches missed.">            switch (todo) {</span>
                case TODO_TRUNCATE:
<span class="nc" id="L289">                    repairTruncate();</span>
<span class="nc" id="L290">                    break;</span>
                case TODO_RESTORE_META:
                case -1:
<span class="fc" id="L293">                    break;</span>
                default:
<span class="fc" id="L295">                    LOG.error().$(&quot;ignoring unknown *todo* [code=&quot;).$(todo).I$();</span>
                    break;
            }
<span class="fc" id="L298">            this.columnCount = metadata.getColumnCount();</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (metadata.getTimestampIndex() &gt; -1) {</span>
<span class="fc" id="L300">                this.designatedTimestampColumnName = metadata.getColumnName(metadata.getTimestampIndex());</span>
            }
<span class="fc" id="L302">            this.rowValueIsNotNull.extendAndSet(columnCount, 0);</span>
<span class="fc" id="L303">            this.columns = new ObjList&lt;&gt;(columnCount * 2);</span>
<span class="fc" id="L304">            this.o3MemColumns = new ObjList&lt;&gt;(columnCount * 2);</span>
<span class="fc" id="L305">            this.o3MemColumns2 = new ObjList&lt;&gt;(columnCount * 2);</span>
<span class="fc" id="L306">            this.o3Columns = this.o3MemColumns;</span>
<span class="fc" id="L307">            this.activeColumns = columns;</span>
<span class="fc" id="L308">            this.symbolMapWriters = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L309">            this.indexers = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L310">            this.denseSymbolMapWriters = new ObjList&lt;&gt;(metadata.getSymbolMapCount());</span>
<span class="fc" id="L311">            this.nullSetters = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L312">            this.o3NullSetters = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L313">            this.o3NullSetters2 = new ObjList&lt;&gt;(columnCount);</span>
<span class="fc" id="L314">            this.activeNullSetters = nullSetters;</span>
<span class="fc" id="L315">            this.columnTops = new LongList(columnCount);</span>
<span class="fc" id="L316">            this.partitionFloorMethod = PartitionBy.getPartitionFloorMethod(partitionBy);</span>
<span class="fc" id="L317">            this.partitionCeilMethod = PartitionBy.getPartitionCeilMethod(partitionBy);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L319">                this.partitionDirFmt = PartitionBy.getPartitionDirFormatMethod(partitionBy);</span>
<span class="fc" id="L320">                this.partitionTimestampHi = txWriter.getLastPartitionTimestamp();</span>
            } else {
<span class="fc" id="L322">                this.partitionDirFmt = null;</span>
            }
<span class="fc" id="L324">            this.commitInterval = calculateCommitInterval();</span>

<span class="fc" id="L326">            configureColumnMemory();</span>
<span class="fc" id="L327">            configureTimestampSetter();</span>
<span class="fc" id="L328">            this.appendTimestampSetter = timestampSetter;</span>
<span class="fc" id="L329">            configureAppendPosition();</span>
<span class="fc" id="L330">            purgeUnusedPartitions();</span>
<span class="fc" id="L331">            clearTodoLog();</span>
<span class="fc" id="L332">            this.slaveTxReader = new TxReader(ff);</span>
<span class="fc" id="L333">            commandQueue = new RingQueue&lt;&gt;(</span>
                    TableWriterTask::new,
<span class="fc" id="L335">                    configuration.getWriterCommandQueueSlotSize(),</span>
<span class="fc" id="L336">                    configuration.getWriterCommandQueueCapacity(),</span>
                    MemoryTag.NATIVE_REPL
            );
<span class="fc" id="L339">            commandSubSeq = new SCSequence();</span>
<span class="fc" id="L340">            commandPubSeq = new MPSequence(commandQueue.getCycle());</span>
<span class="fc" id="L341">            commandPubSeq.then(commandSubSeq).then(commandPubSeq);</span>
<span class="fc" id="L342">            walColumnMemoryPool = new WeakClosableObjectPool&lt;&gt;(GET_MEMORY_CMOR, columnCount);</span>
<span class="fc" id="L343">            Arrays.fill(o3LastTimestampSpreads, 0);</span>
<span class="fc" id="L344">        } catch (Throwable e) {</span>
<span class="fc" id="L345">            doClose(false);</span>
<span class="fc" id="L346">            throw e;</span>
<span class="fc" id="L347">        }</span>
<span class="fc" id="L348">    }</span>

    @TestOnly
    public TableWriter(CairoConfiguration configuration, TableToken tableToken, Metrics metrics) {
<span class="fc" id="L352">        this(configuration, tableToken, null, new MessageBusImpl(configuration), true, DefaultLifecycleManager.INSTANCE, configuration.getRoot(), metrics);</span>
<span class="fc" id="L353">    }</span>

    @TestOnly
    public TableWriter(CairoConfiguration configuration, TableToken tableToken, MessageBus messageBus, Metrics metrics) {
<span class="fc" id="L357">        this(configuration, tableToken, null, messageBus, true, DefaultLifecycleManager.INSTANCE, configuration.getRoot(), metrics);</span>
<span class="fc" id="L358">    }</span>

    public static int getPrimaryColumnIndex(int index) {
<span class="fc" id="L361">        return index * 2;</span>
    }

    public static int getSecondaryColumnIndex(int index) {
<span class="fc" id="L365">        return getPrimaryColumnIndex(index) + 1;</span>
    }

    public static long getTimestampIndexValue(long timestampIndex, long indexRow) {
<span class="fc" id="L369">        return Unsafe.getUnsafe().getLong(timestampIndex + indexRow * 16);</span>
    }

    @Override
    public void addColumn(CharSequence columnName, int columnType) {
<span class="fc" id="L374">        addColumn(</span>
                columnName,
                columnType,
<span class="fc" id="L377">                configuration.getDefaultSymbolCapacity(),</span>
<span class="fc" id="L378">                configuration.getDefaultSymbolCacheFlag(),</span>
                false,
                0,
                false
        );
<span class="fc" id="L383">    }</span>

    @Override
    public void addColumn(
            CharSequence columnName,
            int columnType,
            int symbolCapacity,
            boolean symbolCacheFlag,
            boolean isIndexed,
            int indexValueBlockCapacity
    ) {
<span class="fc" id="L394">        addColumn(</span>
                columnName,
                columnType,
                symbolCapacity,
                symbolCacheFlag,
                isIndexed,
                indexValueBlockCapacity,
                false
        );
<span class="fc" id="L403">    }</span>

    /**
     * Adds new column to table, which can be either empty or can have data already. When existing columns
     * already have data this function will create &quot;.top&quot; file in addition to column files. &quot;.top&quot; file contains
     * size of partition at the moment of column creation. It must be used to accurately position inside new
     * column when either appending or reading.
     *
     * &lt;b&gt;Failures&lt;/b&gt;
     * Adding new column can fail in many situations. None of the failures affect integrity of data that is already in
     * the table but can leave instance of TableWriter in inconsistent state. When this happens function will throw CairoError.
     * Calling code must close TableWriter instance and open another when problems are rectified. Those problems would be
     * either with disk or memory or both.
     * &lt;p&gt;
     * Whenever function throws CairoException application code can continue using TableWriter instance and may attempt to
     * add columns again.
     *
     * &lt;b&gt;Transactions&lt;/b&gt;
     * &lt;p&gt;
     * Pending transaction will be committed before function attempts to add column. Even when function is unsuccessful it may
     * still have committed transaction.
     *
     * @param columnName              of column either ASCII or UTF8 encoded.
     * @param symbolCapacity          when column columnType is SYMBOL this parameter specifies approximate capacity for symbol map.
     *                                It should be equal to number of unique symbol values stored in the table and getting this
     *                                value badly wrong will cause performance degradation. Must be power of 2
     * @param symbolCacheFlag         when set to true, symbol values will be cached on Java heap.
     * @param columnType              {@link ColumnType}
     * @param isIndexed               configures column to be indexed or not
     * @param indexValueBlockCapacity approximation of number of rows for single index key, must be power of 2
     * @param isSequential            for columns that contain sequential values query optimiser can make assumptions on range searches (future feature)
     */
    public void addColumn(
            CharSequence columnName,
            int columnType,
            int symbolCapacity,
            boolean symbolCacheFlag,
            boolean isIndexed,
            int indexValueBlockCapacity,
            boolean isSequential
    ) {

<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        assert indexValueBlockCapacity == Numbers.ceilPow2(indexValueBlockCapacity) : &quot;power of 2 expected&quot;;</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        assert symbolCapacity == Numbers.ceilPow2(symbolCapacity) : &quot;power of 2 expected&quot;;</span>

<span class="fc" id="L448">        checkDistressed();</span>
<span class="fc" id="L449">        checkColumnName(columnName);</span>

<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (getColumnIndexQuiet(metaMem, columnName, columnCount) != -1) {</span>
<span class="fc" id="L452">            throw CairoException.duplicateColumn(columnName);</span>
        }

<span class="fc" id="L455">        commit();</span>

<span class="fc" id="L457">        long columnNameTxn = getTxn();</span>
<span class="fc" id="L458">        LOG.info().$(&quot;adding column '&quot;).utf8(columnName).$('[').$(ColumnType.nameOf(columnType)).$(&quot;], columnName txn &quot;).$(columnNameTxn).$(&quot; to &quot;).$(path).$();</span>

        // create new _meta.swp
<span class="fc" id="L461">        this.metaSwapIndex = addColumnToMeta(columnName, columnType, isIndexed, indexValueBlockCapacity, isSequential);</span>

        // close _meta so we can rename it
<span class="fc" id="L464">        metaMem.close();</span>

        // validate new meta
<span class="fc" id="L467">        validateSwapMeta(columnName);</span>

        // rename _meta to _meta.prev
<span class="fc" id="L470">        renameMetaToMetaPrev(columnName);</span>

        // after we moved _meta to _meta.prev
        // we have to have _todo to restore _meta should anything go wrong
<span class="fc" id="L474">        writeRestoreMetaTodo(columnName);</span>

        // rename _meta.swp to _meta
<span class="fc" id="L477">        renameSwapMetaToMeta(columnName);</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (ColumnType.isSymbol(columnType)) {</span>
            try {
<span class="fc" id="L481">                createSymbolMapWriter(columnName, columnNameTxn, symbolCapacity, symbolCacheFlag);</span>
<span class="fc" id="L482">            } catch (CairoException e) {</span>
<span class="nc" id="L483">                runFragile(RECOVER_FROM_SYMBOL_MAP_WRITER_FAILURE, columnName, e);</span>
<span class="pc" id="L484">            }</span>
        } else {
            // maintain sparse list of symbol writers
<span class="fc" id="L487">            symbolMapWriters.extendAndSet(columnCount, NullMapWriter.INSTANCE);</span>
        }

        // add column objects
<span class="fc" id="L491">        configureColumn(columnType, isIndexed, columnCount);</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">        if (isIndexed) {</span>
<span class="fc" id="L493">            populateDenseIndexerList();</span>
        }

        // increment column count
<span class="fc" id="L497">        columnCount++;</span>

        // extend columnTop list to make sure row cancel can work
        // need for setting correct top is hard to test without being able to read from table
<span class="fc" id="L501">        int columnIndex = columnCount - 1;</span>
<span class="fc" id="L502">        columnTops.extendAndSet(columnIndex, txWriter.getTransientRowCount());</span>

        // Set txn number in the column version file to mark the transaction where the column is added
<span class="fc" id="L505">        columnVersionWriter.upsertDefaultTxnName(columnIndex, columnNameTxn, txWriter.getLastPartitionTimestamp());</span>

        // create column files
<span class="fc bfc" id="L508" title="All 4 branches covered.">        if (txWriter.getTransientRowCount() &gt; 0 || !PartitionBy.isPartitioned(partitionBy)) {</span>
            try {
<span class="fc" id="L510">                openNewColumnFiles(columnName, isIndexed, indexValueBlockCapacity);</span>
<span class="fc" id="L511">            } catch (CairoException e) {</span>
<span class="nc" id="L512">                runFragile(RECOVER_FROM_COLUMN_OPEN_FAILURE, columnName, e);</span>
<span class="fc" id="L513">            }</span>
        }

        try {
            // open _meta file
<span class="fc" id="L518">            openMetaFile(ff, path, rootLen, metaMem);</span>

            // remove _todo
<span class="fc" id="L521">            clearTodoLog();</span>
<span class="fc" id="L522">        } catch (CairoException e) {</span>
<span class="nc" id="L523">            throwDistressException(e);</span>
<span class="fc" id="L524">        }</span>

<span class="fc" id="L526">        bumpStructureVersion();</span>

<span class="fc" id="L528">        metadata.addColumn(columnName, columnType, isIndexed, indexValueBlockCapacity, columnIndex);</span>

<span class="fc" id="L530">        LOG.info().$(&quot;ADDED column '&quot;).utf8(columnName).$('[').$(ColumnType.nameOf(columnType)).$(&quot;], columnName txn &quot;).$(columnNameTxn).$(&quot; to &quot;).$(path).$();</span>
<span class="fc" id="L531">    }</span>

    @Override
    public void addIndex(CharSequence columnName, int indexValueBlockSize) {
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        assert indexValueBlockSize == Numbers.ceilPow2(indexValueBlockSize) : &quot;power of 2 expected&quot;;</span>

<span class="fc" id="L537">        checkDistressed();</span>

<span class="fc" id="L539">        final int columnIndex = getColumnIndexQuiet(metaMem, columnName, columnCount);</span>

<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        if (columnIndex == -1) {</span>
<span class="nc" id="L542">            throw CairoException.nonCritical().put(&quot;column '&quot;).put(columnName).put(&quot;' does not exist&quot;);</span>
        }

<span class="fc" id="L545">        commit();</span>

<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (isColumnIndexed(metaMem, columnIndex)) {</span>
<span class="fc" id="L548">            throw CairoException.nonCritical().put(&quot;already indexed [column=&quot;).put(columnName).put(']');</span>
        }

<span class="fc" id="L551">        final int existingType = getColumnType(metaMem, columnIndex);</span>
<span class="fc" id="L552">        LOG.info().$(&quot;adding index to '&quot;).utf8(columnName).$('[').$(ColumnType.nameOf(existingType)).$(&quot;, path=&quot;).$(path).I$();</span>

<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        if (!ColumnType.isSymbol(existingType)) {</span>
<span class="nc" id="L555">            LOG.error().$(&quot;cannot create index for [column='&quot;).utf8(columnName).$(&quot;, type=&quot;).$(ColumnType.nameOf(existingType)).$(&quot;, path=&quot;).$(path).I$();</span>
<span class="nc" id="L556">            throw CairoException.nonCritical().put(&quot;cannot create index for [column='&quot;).put(columnName).put(&quot;, type=&quot;).put(ColumnType.nameOf(existingType)).put(&quot;, path=&quot;).put(path).put(']');</span>
        }

        // create indexer
<span class="fc" id="L560">        final SymbolColumnIndexer indexer = new SymbolColumnIndexer();</span>

<span class="fc" id="L562">        final long columnNameTxn = columnVersionWriter.getColumnNameTxn(txWriter.getLastPartitionTimestamp(), columnIndex);</span>
        try {
            try {
                // edge cases here are:
                // column spans only part of table - e.g. it was added after table was created and populated
                // column has top value, e.g. does not span entire partition
                // to this end, we have a super-edge case:

                // This piece of code is unbelievably fragile!
<span class="fc bfc" id="L571" title="All 2 branches covered.">                if (PartitionBy.isPartitioned(partitionBy)) {</span>
                    // run indexer for the whole table
<span class="fc" id="L573">                    indexHistoricPartitions(indexer, columnName, indexValueBlockSize);</span>
<span class="fc" id="L574">                    long timestamp = txWriter.getMaxTimestamp();</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                    if (timestamp != Numbers.LONG_NaN) {</span>
<span class="fc" id="L576">                        path.trimTo(rootLen);</span>
<span class="fc" id="L577">                        setStateForTimestamp(path, timestamp, false);</span>
                        // create index in last partition
<span class="fc" id="L579">                        indexLastPartition(indexer, columnName, columnNameTxn, columnIndex, indexValueBlockSize);</span>
                    }
<span class="fc" id="L581">                } else {</span>
<span class="fc" id="L582">                    setStateForTimestamp(path, 0, false);</span>
                    // create index in last partition
<span class="fc" id="L584">                    indexLastPartition(indexer, columnName, columnNameTxn, columnIndex, indexValueBlockSize);</span>
                }
            } finally {
<span class="fc" id="L587">                path.trimTo(rootLen);</span>
            }
<span class="fc" id="L589">        } catch (Throwable e) {</span>
<span class="fc" id="L590">            LOG.error().$(&quot;rolling back index created so far [path=&quot;).$(path).I$();</span>
<span class="fc" id="L591">            removeIndexFiles(columnName, columnIndex);</span>
<span class="fc" id="L592">            throw e;</span>
<span class="fc" id="L593">        }</span>

        // set index flag in metadata and  create new _meta.swp
<span class="fc" id="L596">        metaSwapIndex = copyMetadataAndSetIndexAttrs(columnIndex, META_FLAG_BIT_INDEXED, indexValueBlockSize);</span>

<span class="fc" id="L598">        swapMetaFile(columnName);</span>

<span class="fc" id="L600">        indexers.extendAndSet(columnIndex, indexer);</span>
<span class="fc" id="L601">        populateDenseIndexerList();</span>

<span class="fc" id="L603">        TableColumnMetadata columnMetadata = metadata.getColumnMetadata(columnIndex);</span>
<span class="fc" id="L604">        columnMetadata.setIndexed(true);</span>
<span class="fc" id="L605">        columnMetadata.setIndexValueBlockCapacity(indexValueBlockSize);</span>

<span class="fc" id="L607">        LOG.info().$(&quot;ADDED index to '&quot;).utf8(columnName).$('[').$(ColumnType.nameOf(existingType)).$(&quot;]' to &quot;).$(path).$();</span>
<span class="fc" id="L608">    }</span>

    public void addPhysicallyWrittenRows(long rows) {
        // maybe not thread safe but hey it's just a metric
<span class="fc" id="L612">        physicallyWrittenRowsSinceLastCommit.addAndGet(rows);</span>
<span class="fc" id="L613">        metrics.tableWriter().addPhysicallyWrittenRows(rows);</span>
<span class="fc" id="L614">    }</span>

    public void apply(AbstractOperation operation, long seqTxn) {
        try {
<span class="fc" id="L618">            setSeqTxn(seqTxn);</span>
<span class="fc" id="L619">            long txnBefore = getTxn();</span>
<span class="fc" id="L620">            operation.apply(this, true);</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (txnBefore == getTxn()) {</span>
                // Commit to update seqTxn
<span class="fc" id="L623">                txWriter.commit(defaultCommitMode, denseSymbolMapWriters);</span>
            }
<span class="fc" id="L625">        } catch (CairoException ex) {</span>
            // This is non-critical error, we can mark seqTxn as processed
<span class="fc bfc" id="L627" title="All 2 branches covered.">            if (ex.isWALTolerable()) {</span>
                try {
<span class="fc" id="L629">                    rollback(); // rollback in case on any dirty state</span>
<span class="fc" id="L630">                    commitSeqTxn(seqTxn);</span>
<span class="nc" id="L631">                } catch (Throwable th2) {</span>
<span class="nc" id="L632">                    LOG.critical().$(&quot;could not rollback, table is distressed [table=&quot;).utf8(tableToken.getTableName()).$(&quot;, error=&quot;).$(th2).I$();</span>
<span class="fc" id="L633">                }</span>
            }
<span class="fc" id="L635">            throw ex;</span>
<span class="nc" id="L636">        } catch (Throwable th) {</span>
            try {
<span class="nc" id="L638">                rollback(); // rollback seqTxn</span>
<span class="nc" id="L639">            } catch (Throwable th2) {</span>
<span class="nc" id="L640">                LOG.critical().$(&quot;could not rollback, table is distressed [table=&quot;).utf8(tableToken.getTableName()).$(&quot;, error=&quot;).$(th2).I$();</span>
<span class="nc" id="L641">            }</span>
<span class="nc" id="L642">            throw th;</span>
<span class="fc" id="L643">        }</span>
<span class="fc" id="L644">    }</span>

    @Override
    public long apply(AlterOperation alterOp, boolean contextAllowsAnyStructureChanges) throws AlterTableContextException {
<span class="fc" id="L648">        return alterOp.apply(this, contextAllowsAnyStructureChanges);</span>
    }

    @Override
    public long apply(UpdateOperation operation) {
<span class="fc" id="L653">        return operation.apply(this, true);</span>
    }

    @Override
    public AttachDetachStatus attachPartition(long timestamp) {
        // -1 means unknown size
<span class="fc" id="L659">        return attachPartition(timestamp, -1L);</span>
    }

    /**
     * Attaches a partition to the table. If size is given, partition file data is not validated.
     *
     * @param timestamp     partition timestamp
     * @param partitionSize partition size in rows. Negative means unknown size.
     * @return attached status code
     */
    public AttachDetachStatus attachPartition(long timestamp, long partitionSize) {
        // Partitioned table must have a timestamp
        // SQL compiler will check that table has it
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        assert metadata.getTimestampIndex() &gt; -1;</span>

<span class="fc bfc" id="L674" title="All 2 branches covered.">        if (txWriter.attachedPartitionsContains(timestamp)) {</span>
<span class="fc" id="L675">            LOG.info().$(&quot;partition is already attached [path=&quot;).$(path).I$();</span>
            // TODO: potentially we can merge with existing data
<span class="fc" id="L677">            return AttachDetachStatus.ATTACH_ERR_PARTITION_EXISTS;</span>
        }

<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (inTransaction()) {</span>
<span class="fc" id="L681">            LOG.info().$(&quot;committing open transaction before applying attach partition command [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L682">                    .$(&quot;, partition=&quot;).$ts(timestamp).I$();</span>
<span class="fc" id="L683">            commit();</span>

            // Check that partition we're about to attach hasn't appeared after commit
<span class="fc bfc" id="L686" title="All 2 branches covered.">            if (txWriter.attachedPartitionsContains(timestamp)) {</span>
<span class="fc" id="L687">                LOG.info().$(&quot;partition is already attached [path=&quot;).$(path).I$();</span>
<span class="fc" id="L688">                return AttachDetachStatus.ATTACH_ERR_PARTITION_EXISTS;</span>
            }
        }

        // final name of partition folder after attach
<span class="fc" id="L693">        setPathForPartition(path.trimTo(rootLen), partitionBy, timestamp, false);</span>
<span class="fc" id="L694">        TableUtils.txnPartitionConditionally(path, getTxn());</span>
<span class="fc" id="L695">        path.$();</span>

<span class="pc bpc" id="L697" title="1 of 2 branches missed.">        if (ff.exists(path)) {</span>
            // Very unlikely since txn is part of the folder name
<span class="nc" id="L699">            return AttachDetachStatus.ATTACH_ERR_DIR_EXISTS;</span>
        }

<span class="fc" id="L702">        Path detachedPath = Path.PATH.get().of(configuration.getRoot()).concat(tableToken);</span>
<span class="fc" id="L703">        setPathForPartition(detachedPath, partitionBy, timestamp, false);</span>
<span class="fc" id="L704">        detachedPath.put(configuration.getAttachPartitionSuffix()).$();</span>
<span class="fc" id="L705">        int detachedRootLen = detachedPath.length();</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        boolean forceRenamePartitionDir = partitionSize &lt; 0;</span>

<span class="fc" id="L708">        boolean checkPassed = false;</span>
        boolean isSoftLink;
        try {
<span class="fc bfc" id="L711" title="All 2 branches covered.">            if (ff.exists(detachedPath)) {</span>

<span class="fc" id="L713">                isSoftLink = ff.isSoftLink(detachedPath); // returns false regardless in Windows</span>

                // detached metadata files validation
<span class="fc" id="L716">                CharSequence timestampColName = metadata.getColumnMetadata(metadata.getTimestampIndex()).getName();</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">                if (partitionSize &gt; -1L) {</span>
                    // read detachedMinTimestamp and detachedMaxTimestamp
<span class="fc" id="L719">                    readPartitionMinMax(ff, timestamp, detachedPath.trimTo(detachedRootLen), timestampColName, partitionSize);</span>
                } else {
                    // read size, detachedMinTimestamp and detachedMaxTimestamp
<span class="fc" id="L722">                    partitionSize = readPartitionSizeMinMax(ff, timestamp, detachedPath.trimTo(detachedRootLen), timestampColName);</span>
                }

<span class="pc bpc" id="L725" title="1 of 2 branches missed.">                if (partitionSize &lt; 1) {</span>
<span class="nc" id="L726">                    return AttachDetachStatus.ATTACH_ERR_EMPTY_PARTITION;</span>
                }

<span class="fc bfc" id="L729" title="All 4 branches covered.">                if (forceRenamePartitionDir &amp;&amp; !attachPrepare(timestamp, partitionSize, detachedPath, detachedRootLen)) {</span>
<span class="fc" id="L730">                    attachValidateMetadata(partitionSize, detachedPath.trimTo(detachedRootLen), timestamp);</span>
                }

                // main columnVersionWriter is now aligned with the detached partition values read from partition _cv file
                // in case of an error it has to be clean up

<span class="pc bpc" id="L736" title="1 of 6 branches missed.">                if (forceRenamePartitionDir &amp;&amp; configuration.attachPartitionCopy() &amp;&amp; !isSoftLink) { // soft links are read-only, no copy involved</span>
                    // Copy partition if configured to do so and it's not CSV import
<span class="fc bfc" id="L738" title="All 2 branches covered.">                    if (ff.copyRecursive(detachedPath.trimTo(detachedRootLen), path, configuration.getMkDirMode()) == 0) {</span>
<span class="fc" id="L739">                        LOG.info().$(&quot;copied partition dir [from=&quot;).$(detachedPath).$(&quot;, to=&quot;).$(path).I$();</span>
                    } else {
<span class="fc" id="L741">                        LOG.error().$(&quot;could not copy [errno=&quot;).$(ff.errno()).$(&quot;, from=&quot;).$(detachedPath).$(&quot;, to=&quot;).$(path).I$();</span>
<span class="fc" id="L742">                        return AttachDetachStatus.ATTACH_ERR_COPY;</span>
                    }
                } else {
<span class="fc bfc" id="L745" title="All 2 branches covered.">                    if (ff.rename(detachedPath.trimTo(detachedRootLen).$(), path) == FILES_RENAME_OK) {</span>
<span class="fc" id="L746">                        LOG.info().$(&quot;renamed partition dir [from=&quot;).$(detachedPath).$(&quot;, to=&quot;).$(path).I$();</span>
                    } else {
<span class="fc" id="L748">                        LOG.error().$(&quot;could not rename [errno=&quot;).$(ff.errno()).$(&quot;, from=&quot;).$(detachedPath).$(&quot;, to=&quot;).$(path).I$();</span>
<span class="fc" id="L749">                        return AttachDetachStatus.ATTACH_ERR_RENAME;</span>
                    }
                }

<span class="fc" id="L753">                checkPassed = true;</span>
<span class="fc" id="L754">            } else {</span>
<span class="fc" id="L755">                LOG.info().$(&quot;attach partition command failed, partition to attach does not exist [path=&quot;).$(detachedPath).I$();</span>
<span class="fc" id="L756">                return AttachDetachStatus.ATTACH_ERR_MISSING_PARTITION;</span>
            }
        } finally {
<span class="fc" id="L759">            path.trimTo(rootLen);</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">            if (!checkPassed) {</span>
<span class="fc" id="L761">                columnVersionWriter.readUnsafe();</span>
            }
        }

        try {
            // find out lo, hi ranges of partition attached as well as size
<span class="pc bpc" id="L767" title="2 of 4 branches missed.">            assert timestamp &lt;= attachMinTimestamp &amp;&amp; attachMinTimestamp &lt;= attachMaxTimestamp;</span>
<span class="fc" id="L768">            long nextMinTimestamp = Math.min(attachMinTimestamp, txWriter.getMinTimestamp());</span>
<span class="fc" id="L769">            long nextMaxTimestamp = Math.max(attachMaxTimestamp, txWriter.getMaxTimestamp());</span>
<span class="fc bfc" id="L770" title="All 4 branches covered.">            boolean appendPartitionAttached = size() == 0 || getPartitionLo(nextMaxTimestamp) &gt; getPartitionLo(txWriter.getMaxTimestamp());</span>

<span class="fc" id="L772">            txWriter.beginPartitionSizeUpdate();</span>
<span class="fc" id="L773">            txWriter.updatePartitionSizeByTimestamp(timestamp, partitionSize, getTxn());</span>
<span class="fc" id="L774">            txWriter.finishPartitionSizeUpdate(nextMinTimestamp, nextMaxTimestamp);</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">            if (isSoftLink) {</span>
<span class="fc" id="L776">                txWriter.setPartitionReadOnlyByTimestamp(timestamp, true);</span>
            }
<span class="fc" id="L778">            txWriter.bumpTruncateVersion();</span>

<span class="fc" id="L780">            columnVersionWriter.commit();</span>
<span class="fc" id="L781">            txWriter.setColumnVersion(columnVersionWriter.getVersion());</span>
<span class="fc" id="L782">            txWriter.commit(defaultCommitMode, denseSymbolMapWriters);</span>

<span class="fc" id="L784">            LOG.info().$(&quot;partition attached [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L785">                    .$(&quot;, partition=&quot;).$ts(timestamp).I$();</span>

<span class="fc bfc" id="L787" title="All 2 branches covered.">            if (appendPartitionAttached) {</span>
<span class="fc" id="L788">                LOG.info().$(&quot;switch partition after partition attach [tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L789">                        .$(&quot;, partition=&quot;).$ts(timestamp).I$();</span>
<span class="fc" id="L790">                freeColumns(true);</span>
<span class="fc" id="L791">                configureAppendPosition();</span>
            }
<span class="fc" id="L793">            return AttachDetachStatus.OK;</span>
<span class="fc" id="L794">        } catch (Throwable e) {</span>
            // This is pretty serious, after partition copied there are no OS operations to fail
            // Do full rollback to clean up the state
<span class="fc" id="L797">            LOG.critical().$(&quot;failed on attaching partition to the table and rolling back [tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L798">                    .$(&quot;, error=&quot;).$(e).I$();</span>
<span class="nc" id="L799">            rollback();</span>
<span class="nc" id="L800">            throw e;</span>
        }
    }

    @Override
    public void changeCacheFlag(int columnIndex, boolean cache) {
<span class="fc" id="L806">        checkDistressed();</span>

<span class="fc" id="L808">        commit();</span>

<span class="fc" id="L810">        final MapWriter symbolMapWriter = symbolMapWriters.getQuick(columnIndex);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (symbolMapWriter.isCached() != cache) {</span>
<span class="fc" id="L812">            symbolMapWriter.updateCacheFlag(cache);</span>
        } else {
<span class="fc" id="L814">            return;</span>
        }
<span class="fc" id="L816">        updateMetaStructureVersion();</span>
<span class="fc" id="L817">    }</span>

    public boolean checkScoreboardHasReadersBeforeLastCommittedTxn() {
<span class="fc" id="L820">        long lastCommittedTxn = txWriter.getTxn();</span>
        try {
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">            if (txnScoreboard.acquireTxn(lastCommittedTxn)) {</span>
<span class="fc" id="L823">                txnScoreboard.releaseTxn(lastCommittedTxn);</span>
            }
<span class="nc" id="L825">        } catch (CairoException ex) {</span>
            // Scoreboard can be over allocated, don't stall writing because of that.
            // Schedule async purge and continue
<span class="nc" id="L828">            LOG.error().$(&quot;cannot lock last txn in scoreboard, partition purge will be scheduled [table=&quot;)</span>
<span class="nc" id="L829">                    .utf8(tableToken.getTableName())</span>
<span class="nc" id="L830">                    .$(&quot;, txn=&quot;).$(lastCommittedTxn)</span>
<span class="nc" id="L831">                    .$(&quot;, error=&quot;).$(ex.getFlyweightMessage())</span>
<span class="nc" id="L832">                    .$(&quot;, errno=&quot;).$(ex.getErrno()).I$();</span>
<span class="fc" id="L833">        }</span>

<span class="fc bfc" id="L835" title="All 2 branches covered.">        return txnScoreboard.getMin() != lastCommittedTxn;</span>
    }

    @Override
    public void close() {
<span class="fc bfc" id="L840" title="All 4 branches covered.">        if (lifecycleManager.close() &amp;&amp; isOpen()) {</span>
<span class="fc" id="L841">            doClose(true);</span>
        }
<span class="fc" id="L843">    }</span>

    @Override
    public long commit() {
<span class="fc" id="L847">        return commit(defaultCommitMode);</span>
    }

    public long commit(int commitMode) {
<span class="fc" id="L851">        return commit(commitMode, 0);</span>
    }

    public void commitSeqTxn(long seqTxn) {
<span class="fc" id="L855">        txWriter.setSeqTxn(seqTxn);</span>
<span class="fc" id="L856">        txWriter.commit(defaultCommitMode, denseSymbolMapWriters);</span>
<span class="fc" id="L857">    }</span>

    public void destroy() {
        // Closes all the files and makes this instance unusable e.g. it cannot return to the pool on close.
<span class="fc" id="L861">        LOG.info().$(&quot;closing table files [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L862">                .$(&quot;, dirName=&quot;).utf8(tableToken.getDirName()).I$();</span>
<span class="fc" id="L863">        distressed = true;</span>
<span class="fc" id="L864">        doClose(false);</span>
<span class="fc" id="L865">    }</span>

    public AttachDetachStatus detachPartition(long timestamp) {
        // Should be checked by SQL compiler
<span class="fc bfc" id="L869" title="All 2 branches covered.">        assert metadata.getTimestampIndex() &gt; -1;</span>
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">        assert PartitionBy.isPartitioned(partitionBy);</span>

<span class="fc bfc" id="L872" title="All 2 branches covered.">        if (inTransaction()) {</span>
<span class="fc" id="L873">            LOG.info()</span>
<span class="fc" id="L874">                    .$(&quot;committing open transaction before applying detach partition command [table=&quot;)</span>
<span class="fc" id="L875">                    .utf8(tableToken.getTableName())</span>
<span class="fc" id="L876">                    .$(&quot;, partition=&quot;).$ts(timestamp)</span>
<span class="fc" id="L877">                    .I$();</span>
<span class="fc" id="L878">            commit();</span>
        }

<span class="fc" id="L881">        int partitionIndex = txWriter.getPartitionIndex(timestamp);</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">        if (partitionIndex == -1) {</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">            assert !txWriter.attachedPartitionsContains(timestamp);</span>
<span class="fc" id="L884">            return AttachDetachStatus.DETACH_ERR_MISSING_PARTITION;</span>
        }

<span class="fc" id="L887">        long maxTimestamp = txWriter.getMaxTimestamp();</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">        if (timestamp == getPartitionLo(maxTimestamp)) {</span>
<span class="fc" id="L889">            return AttachDetachStatus.DETACH_ERR_ACTIVE;</span>
        }
<span class="fc" id="L891">        long minTimestamp = txWriter.getMinTimestamp();</span>

<span class="fc" id="L893">        long partitionNameTxn = txWriter.getPartitionNameTxn(partitionIndex);</span>
<span class="fc" id="L894">        Path detachedPath = Path.PATH.get();</span>

        try {
            // path: partition folder to be detached
<span class="fc" id="L898">            setPathForPartition(path, rootLen, partitionBy, timestamp, partitionNameTxn);</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">            if (!ff.exists(path.$())) {</span>
<span class="fc" id="L900">                LOG.error().$(&quot;partition folder does not exist [path=&quot;).$(path).I$();</span>
<span class="fc" id="L901">                return AttachDetachStatus.DETACH_ERR_MISSING_PARTITION_DIR;</span>
            }

            final int detachedPathLen;
            AttachDetachStatus attachDetachStatus;
<span class="fc bfc" id="L906" title="All 2 branches covered.">            if (ff.isSoftLink(path)) {</span>
<span class="fc" id="L907">                detachedPathLen = 0;</span>
<span class="fc" id="L908">                attachDetachStatus = AttachDetachStatus.OK;</span>
<span class="fc" id="L909">                LOG.info().$(&quot;detaching partition via unlink [path=&quot;).$(path).I$();</span>
            } else {

<span class="fc" id="L912">                detachedPath.of(configuration.getRoot()).concat(tableToken.getDirName());</span>
<span class="fc" id="L913">                int detachedRootLen = detachedPath.length();</span>
                // detachedPath: detached partition folder
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">                if (!ff.exists(detachedPath.slash$())) {</span>
                    // the detached and standard folders can have different roots
                    // (server.conf: cairo.sql.detached.root)
<span class="nc bnc" id="L918" title="All 2 branches missed.">                    if (0 != ff.mkdirs(detachedPath, mkDirMode)) {</span>
<span class="nc" id="L919">                        LOG.error().$(&quot;could no create detached partition folder [errno=&quot;).$(ff.errno())</span>
<span class="nc" id="L920">                                .$(&quot;, path=&quot;).$(detachedPath).I$();</span>
<span class="nc" id="L921">                        return AttachDetachStatus.DETACH_ERR_MKDIR;</span>
                    }
                }
<span class="fc" id="L924">                setPathForPartition(detachedPath.trimTo(detachedRootLen), partitionBy, timestamp, false);</span>
<span class="fc" id="L925">                detachedPath.put(DETACHED_DIR_MARKER).$();</span>
<span class="fc" id="L926">                detachedPathLen = detachedPath.length();</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">                if (ff.exists(detachedPath)) {</span>
<span class="fc" id="L928">                    LOG.error().$(&quot;detached partition folder already exist [path=&quot;).$(detachedPath).I$();</span>
<span class="fc" id="L929">                    return AttachDetachStatus.DETACH_ERR_ALREADY_DETACHED;</span>
                }

                // Hard link partition folder recursive to partition.detached
<span class="fc bfc" id="L933" title="All 2 branches covered.">                if (ff.hardLinkDirRecursive(path, detachedPath, mkDirMode) != 0) {</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">                    if (ff.isCrossDeviceCopyError(ff.errno())) {</span>
                        // Cross drive operation. Make full copy to another device.
<span class="fc bfc" id="L936" title="All 2 branches covered.">                        if (ff.copyRecursive(path, detachedPath, mkDirMode) != 0) {</span>
<span class="fc" id="L937">                            LOG.critical().$(&quot;could not copy detached partition [errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L938">                                    .$(&quot;, from=&quot;).$(path)</span>
<span class="fc" id="L939">                                    .$(&quot;, to=&quot;).$(detachedPath)</span>
<span class="fc" id="L940">                                    .I$();</span>
<span class="fc" id="L941">                            return AttachDetachStatus.DETACH_ERR_COPY;</span>
                        }
                    } else {
<span class="fc" id="L944">                        LOG.critical().$(&quot;could not create hard link to detached partition [errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L945">                                .$(&quot;, from=&quot;).$(path)</span>
<span class="fc" id="L946">                                .$(&quot;, to=&quot;).$(detachedPath)</span>
<span class="fc" id="L947">                                .I$();</span>
<span class="fc" id="L948">                        return AttachDetachStatus.DETACH_ERR_HARD_LINK;</span>
                    }
                }

                // copy _meta, _cv and _txn to partition.detached _meta, _cv and _txn
<span class="fc" id="L953">                other.of(path).trimTo(rootLen).concat(META_FILE_NAME).$(); // exists already checked</span>
<span class="fc" id="L954">                detachedPath.trimTo(detachedPathLen).concat(META_FILE_NAME).$();</span>

<span class="fc" id="L956">                attachDetachStatus = AttachDetachStatus.OK;</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">                if (-1 == copyOverwrite(detachedPath)) {</span>
<span class="fc" id="L958">                    attachDetachStatus = AttachDetachStatus.DETACH_ERR_COPY_META;</span>
<span class="fc" id="L959">                    LOG.critical().$(&quot;could not copy [errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L960">                            .$(&quot;, from=&quot;).$(other)</span>
<span class="fc" id="L961">                            .$(&quot;, to=&quot;).$(detachedPath)</span>
<span class="fc" id="L962">                            .I$();</span>
                } else {
<span class="fc" id="L964">                    other.parent().concat(COLUMN_VERSION_FILE_NAME).$();</span>
<span class="fc" id="L965">                    detachedPath.parent().concat(COLUMN_VERSION_FILE_NAME).$();</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">                    if (-1 == copyOverwrite(detachedPath)) {</span>
<span class="fc" id="L967">                        attachDetachStatus = AttachDetachStatus.DETACH_ERR_COPY_META;</span>
<span class="fc" id="L968">                        LOG.critical().$(&quot;could not copy [errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L969">                                .$(&quot;, from=&quot;).$(other)</span>
<span class="fc" id="L970">                                .$(&quot;, to=&quot;).$(detachedPath)</span>
<span class="fc" id="L971">                                .I$();</span>
                    } else {
<span class="fc" id="L973">                        other.parent().concat(TXN_FILE_NAME).$();</span>
<span class="fc" id="L974">                        detachedPath.parent().concat(TXN_FILE_NAME).$();</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">                        if (-1 == copyOverwrite(detachedPath)) {</span>
<span class="fc" id="L976">                            attachDetachStatus = AttachDetachStatus.DETACH_ERR_COPY_META;</span>
<span class="fc" id="L977">                            LOG.critical().$(&quot;could not copy [errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L978">                                    .$(&quot;, from=&quot;).$(other)</span>
<span class="fc" id="L979">                                    .$(&quot;, to=&quot;).$(detachedPath)</span>
<span class="fc" id="L980">                                    .I$();</span>
                        }
                    }
                }
            }

<span class="fc bfc" id="L986" title="All 2 branches covered.">            if (attachDetachStatus == AttachDetachStatus.OK) {</span>
                // find out if we are removing min partition
<span class="fc" id="L988">                long nextMinTimestamp = minTimestamp;</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">                if (timestamp == txWriter.getPartitionTimestamp(0)) {</span>
<span class="fc" id="L990">                    other.of(path).trimTo(rootLen);</span>
<span class="fc" id="L991">                    nextMinTimestamp = readMinTimestamp(txWriter.getPartitionTimestamp(1));</span>
                }

                // all good, commit
<span class="fc" id="L995">                txWriter.beginPartitionSizeUpdate();</span>
<span class="fc" id="L996">                txWriter.removeAttachedPartitions(timestamp);</span>
<span class="fc" id="L997">                txWriter.setMinTimestamp(nextMinTimestamp);</span>
<span class="fc" id="L998">                txWriter.finishPartitionSizeUpdate(nextMinTimestamp, txWriter.getMaxTimestamp());</span>
<span class="fc" id="L999">                txWriter.bumpTruncateVersion();</span>

<span class="fc" id="L1001">                columnVersionWriter.removePartition(timestamp);</span>
<span class="fc" id="L1002">                columnVersionWriter.commit();</span>

<span class="fc" id="L1004">                txWriter.setColumnVersion(columnVersionWriter.getVersion());</span>
<span class="fc" id="L1005">                txWriter.commit(defaultCommitMode, denseSymbolMapWriters);</span>
                // return at the end of the method after removing partition directory
<span class="fc" id="L1007">            } else {</span>
                // rollback detached copy
<span class="fc" id="L1009">                detachedPath.trimTo(detachedPathLen).slash().$();</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">                if (ff.rmdir(detachedPath) != 0) {</span>
<span class="fc" id="L1011">                    LOG.error()</span>
<span class="fc" id="L1012">                            .$(&quot;could not rollback detached copy (rmdir) [errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L1013">                            .$(&quot;, undo=&quot;).$(detachedPath)</span>
<span class="fc" id="L1014">                            .$(&quot;, original=&quot;).$(path)</span>
<span class="fc" id="L1015">                            .I$();</span>
                }
<span class="fc" id="L1017">                return attachDetachStatus;</span>
            }
        } finally {
<span class="fc" id="L1020">            path.trimTo(rootLen);</span>
<span class="fc" id="L1021">            other.trimTo(rootLen);</span>
        }
<span class="fc" id="L1023">        safeDeletePartitionDir(timestamp, partitionNameTxn);</span>
<span class="fc" id="L1024">        return AttachDetachStatus.OK;</span>
    }

    @Override
    public void dropIndex(CharSequence columnName) {
<span class="fc" id="L1029">        checkDistressed();</span>

<span class="fc" id="L1031">        final int columnIndex = getColumnIndexQuiet(metaMem, columnName, columnCount);</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">        if (columnIndex == -1) {</span>
<span class="nc" id="L1033">            throw CairoException.invalidMetadata(&quot;Column does not exist&quot;, columnName);</span>
        }
<span class="fc bfc" id="L1035" title="All 2 branches covered.">        if (!isColumnIndexed(metaMem, columnIndex)) {</span>
            // if a column is indexed, it is al so of type SYMBOL
<span class="fc" id="L1037">            throw CairoException.invalidMetadata(&quot;Column is not indexed&quot;, columnName);</span>
        }
<span class="fc" id="L1039">        final int defaultIndexValueBlockSize = Numbers.ceilPow2(configuration.getIndexValueBlockSize());</span>

<span class="pc bpc" id="L1041" title="1 of 2 branches missed.">        if (inTransaction()) {</span>
<span class="nc" id="L1042">            LOG.info()</span>
<span class="nc" id="L1043">                    .$(&quot;committing current transaction before DROP INDEX execution [txn=&quot;).$(txWriter.getTxn())</span>
<span class="nc" id="L1044">                    .$(&quot;, table=&quot;).utf8(tableToken.getTableName())</span>
<span class="nc" id="L1045">                    .$(&quot;, column=&quot;).utf8(columnName)</span>
<span class="nc" id="L1046">                    .I$();</span>
<span class="nc" id="L1047">            commit();</span>
        }

        try {
<span class="fc" id="L1051">            LOG.info().$(&quot;BEGIN DROP INDEX [txn=&quot;).$(txWriter.getTxn())</span>
<span class="fc" id="L1052">                    .$(&quot;, table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L1053">                    .$(&quot;, column=&quot;).utf8(columnName)</span>
<span class="fc" id="L1054">                    .I$();</span>
            // drop index
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">            if (dropIndexOperator == null) {</span>
<span class="fc" id="L1057">                dropIndexOperator = new DropIndexOperator(configuration, messageBus, this, path, other, rootLen);</span>
            }
<span class="fc" id="L1059">            dropIndexOperator.executeDropIndex(columnName, columnIndex); // upserts column version in partitions</span>
            // swap meta commit
<span class="fc" id="L1061">            metaSwapIndex = copyMetadataAndSetIndexAttrs(columnIndex, META_FLAG_BIT_NOT_INDEXED, defaultIndexValueBlockSize);</span>
<span class="fc" id="L1062">            swapMetaFile(columnName); // bumps structure version, this is in effect a commit</span>
            // refresh metadata
<span class="fc" id="L1064">            TableColumnMetadata columnMetadata = metadata.getColumnMetadata(columnIndex);</span>
<span class="fc" id="L1065">            columnMetadata.setIndexed(false);</span>
<span class="fc" id="L1066">            columnMetadata.setIndexValueBlockCapacity(defaultIndexValueBlockSize);</span>
            // remove indexer
<span class="fc" id="L1068">            ColumnIndexer columnIndexer = indexers.getQuick(columnIndex);</span>
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">            if (columnIndexer != null) {</span>
<span class="fc" id="L1070">                indexers.setQuick(columnIndex, null);</span>
<span class="fc" id="L1071">                Misc.free(columnIndexer);</span>
<span class="fc" id="L1072">                populateDenseIndexerList();</span>
            }
            // purge old column versions
<span class="fc" id="L1075">            dropIndexOperator.purgeOldColumnVersions();</span>
<span class="fc" id="L1076">            LOG.info().$(&quot;END DROP INDEX [txn=&quot;).$(txWriter.getTxn())</span>
<span class="fc" id="L1077">                    .$(&quot;, table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L1078">                    .$(&quot;, column=&quot;).utf8(columnName)</span>
<span class="fc" id="L1079">                    .I$();</span>
<span class="fc" id="L1080">        } catch (Throwable e) {</span>
<span class="fc" id="L1081">            throw CairoException.critical(0)</span>
<span class="fc" id="L1082">                    .put(&quot;Cannot DROP INDEX for [txn=&quot;).put(txWriter.getTxn())</span>
<span class="fc" id="L1083">                    .put(&quot;, table=&quot;).put(tableToken.getTableName())</span>
<span class="fc" id="L1084">                    .put(&quot;, column=&quot;).put(columnName)</span>
<span class="fc" id="L1085">                    .put(&quot;]: &quot;).put(e.getMessage());</span>
<span class="fc" id="L1086">        }</span>
<span class="fc" id="L1087">    }</span>

    public int getColumnIndex(CharSequence name) {
<span class="fc" id="L1090">        int index = metadata.getColumnIndexQuiet(name);</span>
<span class="fc bfc" id="L1091" title="All 2 branches covered.">        if (index &gt; -1) {</span>
<span class="fc" id="L1092">            return index;</span>
        }
<span class="fc" id="L1094">        throw CairoException.critical(0).put(&quot;column '&quot;).put(name).put(&quot;' does not exist&quot;);</span>
    }

    public long getColumnNameTxn(long partitionTimestamp, int columnIndex) {
<span class="fc" id="L1098">        return columnVersionWriter.getColumnNameTxn(partitionTimestamp, columnIndex);</span>
    }

    public long getColumnTop(long partitionTimestamp, int columnIndex, long defaultValue) {
<span class="fc" id="L1102">        long colTop = columnVersionWriter.getColumnTop(partitionTimestamp, columnIndex);</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">        return colTop &gt; -1L ? colTop : defaultValue;</span>
    }

    @Override
    public long getCommitInterval() {
<span class="fc" id="L1108">        return commitInterval;</span>
    }

    @TestOnly
    public ObjList&lt;MapWriter&gt; getDenseSymbolMapWriters() {
<span class="fc" id="L1113">        return denseSymbolMapWriters;</span>
    }

    public String getDesignatedTimestampColumnName() {
<span class="fc" id="L1117">        return designatedTimestampColumnName;</span>
    }

    public FilesFacade getFilesFacade() {
<span class="fc" id="L1121">        return ff;</span>
    }

    public long getMaxTimestamp() {
<span class="fc" id="L1125">        return txWriter.getMaxTimestamp();</span>
    }

    @Override
    public long getMetaMaxUncommittedRows() {
<span class="fc" id="L1130">        return metadata.getMaxUncommittedRows();</span>
    }

    @Override
    public TableRecordMetadata getMetadata() {
<span class="fc" id="L1135">        return metadata;</span>
    }

    public long getO3RowCount() {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        return hasO3() ? getO3RowCount0() : 0L;</span>
    }

    @Override
    public int getPartitionBy() {
<span class="fc" id="L1144">        return partitionBy;</span>
    }

    public int getPartitionCount() {
<span class="fc" id="L1148">        return txWriter.getPartitionCount();</span>
    }

    public long getPartitionNameTxn(int partitionIndex) {
<span class="fc" id="L1152">        return txWriter.getPartitionNameTxn(partitionIndex);</span>
    }

    public long getPartitionSize(int partitionIndex) {
<span class="pc bpc" id="L1156" title="1 of 4 branches missed.">        if (partitionIndex == txWriter.getPartitionCount() - 1 || !PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L1157">            return txWriter.getTransientRowCount();</span>
        }
<span class="fc" id="L1159">        return txWriter.getPartitionSize(partitionIndex);</span>
    }

    public long getPartitionTimestamp(int partitionIndex) {
<span class="fc" id="L1163">        return txWriter.getPartitionTimestamp(partitionIndex);</span>
    }

    public long getPhysicallyWrittenRowsSinceLastCommit() {
<span class="fc" id="L1167">        return physicallyWrittenRowsSinceLastCommit.get();</span>
    }

    public long getRowCount() {
<span class="fc" id="L1171">        return txWriter.getRowCount();</span>
    }

    public long getSeqTxn() {
<span class="fc" id="L1175">        return txWriter.getSeqTxn();</span>
    }

    @Override
    public long getStructureVersion() {
<span class="fc" id="L1180">        return txWriter.getStructureVersion();</span>
    }

    @Override
    public int getSymbolCountWatermark(int columnIndex) {
        // We don't need the watermark for non-WAL tables.
<span class="fc" id="L1186">        return -1;</span>
    }

    public int getSymbolIndexNoTransientCountUpdate(int columnIndex, CharSequence symValue) {
<span class="fc" id="L1190">        return symbolMapWriters.getQuick(columnIndex).put(symValue, SymbolValueCountCollector.NOOP);</span>
    }

    public MapWriter getSymbolMapWriter(int columnIndex) {
<span class="fc" id="L1194">        return symbolMapWriters.getQuick(columnIndex);</span>
    }

    @Override
    public TableToken getTableToken() {
<span class="fc" id="L1199">        return tableToken;</span>
    }

    public long getTransientRowCount() {
<span class="fc" id="L1203">        return txWriter.getTransientRowCount();</span>
    }

    public long getTruncateVersion() {
<span class="fc" id="L1207">        return txWriter.getTruncateVersion();</span>
    }

    @TestOnly
    public TxWriter getTxWriter() {
<span class="fc" id="L1212">        return txWriter;</span>
    }

    public long getTxn() {
<span class="fc" id="L1216">        return txWriter.getTxn();</span>
    }

    public TxnScoreboard getTxnScoreboard() {
<span class="fc" id="L1220">        return txnScoreboard;</span>
    }

    @Override
    public long getUncommittedRowCount() {
<span class="fc" id="L1225">        return (masterRef - committedMasterRef) &gt;&gt; 1;</span>
    }

    @Override
    public UpdateOperator getUpdateOperator() {
<span class="fc bfc" id="L1230" title="All 2 branches covered.">        if (updateOperatorImpl == null) {</span>
<span class="fc" id="L1231">            updateOperatorImpl = new UpdateOperatorImpl(configuration, messageBus, this, path, rootLen);</span>
        }
<span class="fc" id="L1233">        return updateOperatorImpl;</span>
    }

    public boolean hasO3() {
<span class="fc bfc" id="L1237" title="All 2 branches covered.">        return o3MasterRef &gt; -1;</span>
    }

    @Override
    public void ic(long o3MaxLag) {
<span class="fc" id="L1242">        commit(defaultCommitMode, o3MaxLag);</span>
<span class="fc" id="L1243">    }</span>

    public void ic(int commitMode) {
<span class="fc" id="L1246">        commit(commitMode, metadata.getO3MaxLag());</span>
<span class="fc" id="L1247">    }</span>

    @Override
    public void ic() {
<span class="fc" id="L1251">        commit(defaultCommitMode, metadata.getO3MaxLag());</span>
<span class="fc" id="L1252">    }</span>

    public boolean inTransaction() {
<span class="fc bfc" id="L1255" title="All 8 branches covered.">        return txWriter != null &amp;&amp; (txWriter.inTransaction() || hasO3() || columnVersionWriter.hasChanges());</span>
    }

    public boolean isOpen() {
<span class="fc bfc" id="L1259" title="All 2 branches covered.">        return tempMem16b != 0;</span>
    }

    public boolean isPartitionReadOnly(int partitionIndex) {
<span class="fc" id="L1263">        return txWriter.isPartitionReadOnly(partitionIndex);</span>
    }

    public void markSeqTxnCommitted(long seqTxn) {
<span class="fc" id="L1267">        setSeqTxn(seqTxn);</span>
<span class="fc" id="L1268">        txWriter.commit(defaultCommitMode, denseSymbolMapWriters);</span>
<span class="fc" id="L1269">    }</span>

    @Override
    public Row newRow() {
<span class="fc" id="L1273">        return newRow(0L);</span>
    }

    @Override
    public Row newRow(long timestamp) {
<span class="fc bfc" id="L1278" title="All 5 branches covered.">        switch (rowAction) {</span>
            case ROW_ACTION_OPEN_PARTITION:

<span class="fc bfc" id="L1281" title="All 2 branches covered.">                if (timestamp &lt; Timestamps.O3_MIN_TS) {</span>
<span class="fc" id="L1282">                    throw CairoException.nonCritical().put(&quot;timestamp before 1970-01-01 is not allowed&quot;);</span>
                }

<span class="fc bfc" id="L1285" title="All 2 branches covered.">                if (txWriter.getMaxTimestamp() == Long.MIN_VALUE) {</span>
<span class="fc" id="L1286">                    txWriter.setMinTimestamp(timestamp);</span>
<span class="fc" id="L1287">                    openFirstPartition(timestamp);</span>
                }
                // fall thru

<span class="fc" id="L1291">                rowAction = ROW_ACTION_SWITCH_PARTITION;</span>

            default: // switch partition
<span class="fc" id="L1294">                bumpMasterRef();</span>
<span class="fc bfc" id="L1295" title="All 4 branches covered.">                if (timestamp &gt; partitionTimestampHi || timestamp &lt; txWriter.getMaxTimestamp()) {</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">                    if (timestamp &lt; txWriter.getMaxTimestamp()) {</span>
<span class="fc" id="L1297">                        return newRowO3(timestamp);</span>
                    }

<span class="pc bpc" id="L1300" title="2 of 4 branches missed.">                    if (timestamp &gt; partitionTimestampHi &amp;&amp; PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L1301">                        switchPartition(timestamp);</span>
                    }
                }
<span class="fc bfc" id="L1304" title="All 2 branches covered.">                if (lastOpenPartitionIsReadOnly) {</span>
<span class="fc" id="L1305">                    masterRef--;</span>
<span class="fc" id="L1306">                    noOpRowCount++;</span>
<span class="fc" id="L1307">                    return NOOP_ROW;</span>
                }
<span class="fc" id="L1309">                updateMaxTimestamp(timestamp);</span>
<span class="fc" id="L1310">                break;</span>
            case ROW_ACTION_NO_PARTITION:

<span class="fc bfc" id="L1313" title="All 2 branches covered.">                if (timestamp &lt; Timestamps.O3_MIN_TS) {</span>
<span class="fc" id="L1314">                    throw CairoException.nonCritical().put(&quot;timestamp before 1970-01-01 is not allowed&quot;);</span>
                }

<span class="fc bfc" id="L1317" title="All 2 branches covered.">                if (timestamp &lt; txWriter.getMaxTimestamp()) {</span>
<span class="fc" id="L1318">                    throw CairoException.nonCritical().put(&quot;Cannot insert rows out of order to non-partitioned table. Table=&quot;).put(path);</span>
                }

<span class="fc" id="L1321">                bumpMasterRef();</span>
<span class="fc" id="L1322">                updateMaxTimestamp(timestamp);</span>
<span class="fc" id="L1323">                break;</span>
            case ROW_ACTION_NO_TIMESTAMP:
<span class="fc" id="L1325">                bumpMasterRef();</span>
<span class="fc" id="L1326">                break;</span>
            case ROW_ACTION_O3:
<span class="fc" id="L1328">                bumpMasterRef();</span>
<span class="fc" id="L1329">                o3TimestampSetter(timestamp);</span>
<span class="fc" id="L1330">                return row;</span>
        }
<span class="fc" id="L1332">        txWriter.append();</span>
<span class="fc" id="L1333">        return row;</span>
    }

    public void o3BumpErrorCount() {
<span class="fc" id="L1337">        o3ErrorCount.incrementAndGet();</span>
<span class="fc" id="L1338">    }</span>

    public void openLastPartition() {
        try {
<span class="fc" id="L1342">            openPartition(txWriter.getLastPartitionTimestamp());</span>
<span class="fc" id="L1343">            setAppendPosition(txWriter.getTransientRowCount(), false);</span>
<span class="nc" id="L1344">        } catch (Throwable e) {</span>
<span class="nc" id="L1345">            freeColumns(false);</span>
<span class="nc" id="L1346">            throw e;</span>
<span class="fc" id="L1347">        }</span>
<span class="fc" id="L1348">    }</span>

    public void processCommandQueue(TableWriterTask cmd, Sequence commandSubSeq, long cursor, boolean contextAllowsAnyStructureChanges) {
<span class="pc bpc" id="L1351" title="1 of 2 branches missed.">        if (cmd.getTableId() == getMetadata().getTableId()) {</span>
<span class="pc bpc" id="L1352" title="1 of 3 branches missed.">            switch (cmd.getType()) {</span>
                case CMD_ALTER_TABLE:
<span class="fc" id="L1354">                    processAsyncWriterCommand(alterOp, cmd, cursor, commandSubSeq, contextAllowsAnyStructureChanges);</span>
<span class="fc" id="L1355">                    break;</span>
                case CMD_UPDATE_TABLE:
<span class="fc" id="L1357">                    processAsyncWriterCommand(cmd.getAsyncWriterCommand(), cmd, cursor, commandSubSeq, false);</span>
<span class="fc" id="L1358">                    break;</span>
                default:
<span class="nc" id="L1360">                    LOG.error().$(&quot;unknown TableWriterTask type, ignored: &quot;).$(cmd.getType()).$();</span>
                    // Don't block the queue even if command is unknown
<span class="nc" id="L1362">                    commandSubSeq.done(cursor);</span>
<span class="nc" id="L1363">                    break;</span>
            }
        } else {
<span class="nc" id="L1366">            LOG.info()</span>
<span class="nc" id="L1367">                    .$(&quot;not my command [cmdTableId=&quot;).$(cmd.getTableId())</span>
<span class="nc" id="L1368">                    .$(&quot;, cmdTableName=&quot;).$(cmd.getTableToken())</span>
<span class="nc" id="L1369">                    .$(&quot;, myTableId=&quot;).$(getMetadata().getTableId())</span>
<span class="nc" id="L1370">                    .$(&quot;, myTableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="nc" id="L1371">                    .I$();</span>
<span class="nc" id="L1372">            commandSubSeq.done(cursor);</span>
        }
<span class="fc" id="L1374">    }</span>

    public boolean processWalBlock(
            @Transient Path walPath,
            int timestampIndex,
            boolean ordered,
            long rowLo,
            long rowHi,
            long o3TimestampMin,
            long o3TimestampMax,
            SymbolMapDiffCursor mapDiffCursor,
            long commitToTimestamp
    ) {
<span class="fc" id="L1387">        this.lastPartitionTimestamp = partitionFloorMethod.floor(partitionTimestampHi);</span>
<span class="fc" id="L1388">        long partitionTimestampHiLimit = partitionCeilMethod.ceil(partitionTimestampHi) - 1;</span>
<span class="fc" id="L1389">        int walRootPathLen = walPath.length();</span>

        try {
<span class="fc" id="L1392">            mmapWalColumns(walPath, timestampIndex, rowLo, rowHi);</span>
<span class="fc" id="L1393">            long o3TimestampOffset = o3TimestampMem.getAppendOffset();</span>
<span class="fc" id="L1394">            long lagRowCount = o3TimestampOffset &gt;&gt; 4;</span>
<span class="fc bfc" id="L1395" title="All 2 branches covered.">            if (lagRowCount &gt; 0) {</span>
<span class="fc" id="L1396">                o3TimestampMin = Math.min(o3TimestampMin, getTimestampIndexValue(o3TimestampMem.getAddress(), 0));</span>
            }

            try {
                long timestampAddr;
<span class="fc" id="L1401">                long o3Lo = rowLo;</span>
<span class="fc" id="L1402">                long o3Hi = rowHi;</span>
                final boolean copiedToMemory;
<span class="fc bfc" id="L1404" title="All 4 branches covered.">                final boolean needsOrdering = !ordered || lagRowCount &gt; 0;</span>
<span class="fc bfc" id="L1405" title="All 4 branches covered.">                final long symbolRowLo = needsOrdering || commitToTimestamp &lt; 0 ? lagRowCount : rowLo;</span>
<span class="fc" id="L1406">                o3Columns = remapWalSymbols(mapDiffCursor, rowLo, rowHi, walPath, symbolRowLo);</span>
<span class="fc" id="L1407">                MemoryCR walTimestampColumn = walMappedColumns.getQuick(getPrimaryColumnIndex(timestampIndex));</span>

<span class="fc bfc" id="L1409" title="All 2 branches covered.">                if (commitToTimestamp &lt; o3TimestampMin) {</span>
                    // Don't commit anything, move everything to memory instead.
                    // This usually happens when WAL transactions are very small, so it's faster
                    // to squash several of them together before writing anything to disk.
<span class="fc" id="L1413">                    LOG.debug().$(&quot;all WAL rows copied to LAG [table=&quot;).$(tableToken).I$();</span>
                    // This will copy data from mmap files to memory.
                    // Symbols are already mapped to the correct destination.
<span class="fc" id="L1416">                    o3ShiftLagRowsUp(timestampIndex, o3Hi - o3Lo, o3Lo, lagRowCount, true);</span>
<span class="fc" id="L1417">                    return false;</span>
                }

<span class="fc bfc" id="L1420" title="All 2 branches covered.">                if (needsOrdering) {</span>
<span class="fc" id="L1421">                    LOG.info().$(&quot;sorting WAL [table=&quot;).$(tableToken)</span>
<span class="fc" id="L1422">                            .$(&quot;, ordered=&quot;).$(ordered)</span>
<span class="fc" id="L1423">                            .$(&quot;, lagRowCount=&quot;).$(lagRowCount)</span>
<span class="fc" id="L1424">                            .$(&quot;, rowLo=&quot;).$(rowLo)</span>
<span class="fc" id="L1425">                            .$(&quot;, rowHi=&quot;).$(rowHi).I$();</span>

<span class="fc" id="L1427">                    final long timestampMemorySize = (rowHi - rowLo) &lt;&lt; 4;</span>
<span class="fc" id="L1428">                    o3TimestampMem.jumpTo(o3TimestampOffset + timestampMemorySize);</span>
<span class="fc" id="L1429">                    o3TimestampMemCpy.jumpTo(o3TimestampOffset + timestampMemorySize);</span>

<span class="fc" id="L1431">                    timestampAddr = o3TimestampMem.getAddress();</span>
<span class="fc" id="L1432">                    final long mappedTimestampIndexAddr = walTimestampColumn.addressOf(rowLo &lt;&lt; 4);</span>
<span class="fc" id="L1433">                    Vect.radixSortABLongIndexAscInA(</span>
                            timestampAddr,
                            lagRowCount,
                            mappedTimestampIndexAddr,
                            rowHi - rowLo,
<span class="fc" id="L1438">                            o3TimestampMemCpy.addressOf(0)</span>
                    );
<span class="fc" id="L1440">                    o3MergeIntoLag(timestampAddr, lagRowCount, rowLo, rowHi, timestampIndex);</span>

                    // Sorted data is now sorted in memory copy of the data from mmap files
                    // Row indexes start from 0, not rowLo
<span class="fc" id="L1444">                    o3Hi = rowHi - rowLo + lagRowCount;</span>
<span class="fc" id="L1445">                    o3Lo = 0L;</span>
<span class="fc" id="L1446">                    lagRowCount = 0L;</span>
<span class="fc" id="L1447">                    o3Columns = o3MemColumns;</span>
<span class="fc" id="L1448">                    copiedToMemory = true;</span>
<span class="fc" id="L1449">                    o3TimestampMin = getTimestampIndexValue(timestampAddr, o3Lo);</span>
<span class="fc" id="L1450">                    o3TimestampMax = getTimestampIndexValue(timestampAddr, o3Hi - 1);</span>
<span class="fc" id="L1451">                } else {</span>
<span class="fc" id="L1452">                    timestampAddr = walTimestampColumn.addressOf(0);</span>
<span class="fc" id="L1453">                    copiedToMemory = false;</span>
                }

<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">                if (commitToTimestamp &lt; o3TimestampMin) {</span>
                    // Don't commit anything, it is enough to move everything to memory instead.
                    // Copying is already done while sorting at the point so we can finish here.
<span class="nc" id="L1459">                    return false;</span>
                } else {
<span class="fc bfc" id="L1461" title="All 2 branches covered.">                    if (commitToTimestamp &lt; o3TimestampMax) {</span>
<span class="fc" id="L1462">                        final long lagThresholdRow = 1 +</span>
<span class="fc" id="L1463">                                Vect.boundedBinarySearchIndexT(</span>
                                        timestampAddr,
                                        commitToTimestamp,
                                        o3Lo,
                                        o3Hi - 1,
                                        BinarySearch.SCAN_DOWN
                                );
<span class="pc bpc" id="L1470" title="2 of 4 branches missed.">                        assert lagThresholdRow &gt; 0 &amp;&amp; lagThresholdRow &lt; o3Hi;</span>
<span class="fc" id="L1471">                        lagRowCount = o3Hi - o3Lo - lagThresholdRow;</span>
<span class="fc" id="L1472">                        o3Hi = lagThresholdRow;</span>
<span class="fc" id="L1473">                        o3TimestampMax = getTimestampIndexValue(timestampAddr, o3Hi - 1);</span>
<span class="pc bpc" id="L1474" title="2 of 4 branches missed.">                        assert o3TimestampMax &gt;= o3TimestampMin &amp;&amp; o3TimestampMax &lt;= commitToTimestamp;</span>

<span class="fc" id="L1476">                        LOG.debug().$(&quot;committing WAL with LAG [table=&quot;).$(tableToken)</span>
<span class="fc" id="L1477">                                .$(&quot;, lagRowCount=&quot;).$(lagRowCount)</span>
<span class="fc" id="L1478">                                .$(&quot;, rowLo=&quot;).$(o3Lo)</span>
<span class="fc" id="L1479">                                .$(&quot;, rowHi=&quot;).$(o3Hi).I$();</span>
<span class="fc" id="L1480">                    } else {</span>
<span class="fc" id="L1481">                        lagRowCount = 0;</span>
                    }

<span class="fc" id="L1484">                    o3RowCount = o3Hi - o3Lo + lagRowCount;</span>
<span class="fc" id="L1485">                    processO3Block(</span>
                            lagRowCount,
                            timestampIndex,
                            timestampAddr,
                            o3Hi,
                            o3TimestampMin,
                            o3TimestampMax,
                            copiedToMemory,
                            o3Lo
                    );
<span class="fc bfc" id="L1495" title="All 2 branches covered.">                    if (lagRowCount == 0) {</span>
<span class="fc" id="L1496">                        o3TimestampMem.jumpTo(0);</span>
                    }
                }
            } finally {
<span class="fc" id="L1500">                finishO3Append(lagRowCount);</span>
<span class="fc" id="L1501">                o3Columns = o3MemColumns;</span>
<span class="fc" id="L1502">                closeWalColumns();</span>
            }

<span class="fc" id="L1505">            finishO3Commit(partitionTimestampHiLimit);</span>
<span class="fc" id="L1506">            return true;</span>
        } finally {
<span class="fc" id="L1508">            walPath.trimTo(walRootPathLen);</span>
        }
    }

    public long processWalData(
            @Transient Path walPath,
            boolean inOrder,
            long rowLo,
            long rowHi,
            long o3TimestampMin,
            long o3TimestampMax,
            SymbolMapDiffCursor mapDiffCursor,
            long seqTxn,
            long commitToTimestamp
    ) {
<span class="pc bpc" id="L1523" title="1 of 2 branches missed.">        if (inTransaction()) {</span>
            // When writer is returned to pool, it should be rolled back. Having an open transaction is very suspicious.
            // Set the writer to distressed state and throw exception so that writer is re-created.
<span class="nc" id="L1526">            distressed = true;</span>
<span class="nc" id="L1527">            throw CairoException.critical(0).put(&quot;cannot process WAL while in transaction&quot;);</span>
        }

<span class="fc" id="L1530">        txWriter.beginPartitionSizeUpdate();</span>
<span class="fc" id="L1531">        LOG.info().$(&quot;processing WAL [path=&quot;).$(walPath).$(&quot;, roLo=&quot;).$(rowLo)</span>
<span class="fc" id="L1532">                .$(&quot;, seqTxn&quot;).$(seqTxn)</span>
<span class="fc" id="L1533">                .$(&quot;, roHi=&quot;).$(rowHi)</span>
<span class="fc" id="L1534">                .$(&quot;, tsMin=&quot;).$ts(o3TimestampMin).$(&quot;, tsMax=&quot;).$ts(o3TimestampMax)</span>
<span class="fc" id="L1535">                .$(&quot;, commitToTimestamp=&quot;).$ts(commitToTimestamp)</span>
<span class="fc" id="L1536">                .I$();</span>
<span class="fc bfc" id="L1537" title="All 4 branches covered.">        if (rowAction == ROW_ACTION_OPEN_PARTITION &amp;&amp; txWriter.getMaxTimestamp() == Long.MIN_VALUE) {</span>
            // table truncated, open partition file.
<span class="fc" id="L1539">            openFirstPartition(o3TimestampMin);</span>
        }
<span class="fc" id="L1541">        boolean dataSavedToDisk = processWalBlock(walPath, metadata.getTimestampIndex(), inOrder, rowLo, rowHi, o3TimestampMin, o3TimestampMax, mapDiffCursor, commitToTimestamp);</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">        if (dataSavedToDisk) {</span>
<span class="fc" id="L1543">            final long committedRowCount = txWriter.unsafeCommittedFixedRowCount() + txWriter.unsafeCommittedTransientRowCount();</span>
<span class="fc" id="L1544">            final long rowsAdded = txWriter.getRowCount() - committedRowCount;</span>

<span class="fc" id="L1546">            updateIndexes();</span>
<span class="fc" id="L1547">            columnVersionWriter.commit();</span>
<span class="fc" id="L1548">            txWriter.setSeqTxn(seqTxn);</span>
<span class="fc" id="L1549">            txWriter.setColumnVersion(columnVersionWriter.getVersion());</span>
<span class="fc" id="L1550">            txWriter.commit(defaultCommitMode, this.denseSymbolMapWriters);</span>

            // Bookmark masterRef to track how many rows is in uncommitted state
<span class="fc" id="L1553">            this.committedMasterRef = masterRef;</span>
<span class="fc" id="L1554">            processPartitionRemoveCandidates();</span>

<span class="fc" id="L1556">            metrics.tableWriter().incrementCommits();</span>
<span class="fc" id="L1557">            metrics.tableWriter().addCommittedRows(rowsAdded);</span>
<span class="fc" id="L1558">            return rowsAdded;</span>
        } else {
            // Keep in memory last committed seq txn, but do not write it to _txn file.
<span class="fc" id="L1561">            txWriter.setSeqTxn(seqTxn);</span>
        }
<span class="fc" id="L1563">        return 0L;</span>
    }

    public void publishAsyncWriterCommand(AsyncWriterCommand asyncWriterCommand) {
        while (true) {
<span class="fc" id="L1568">            long seq = commandPubSeq.next();</span>
<span class="fc bfc" id="L1569" title="All 2 branches covered.">            if (seq &gt; -1) {</span>
<span class="fc" id="L1570">                TableWriterTask task = commandQueue.get(seq);</span>
<span class="fc" id="L1571">                asyncWriterCommand.serialize(task);</span>
<span class="fc" id="L1572">                commandPubSeq.done(seq);</span>
<span class="fc" id="L1573">                return;</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">            } else if (seq == -1) {</span>
<span class="fc" id="L1575">                throw CairoException.nonCritical().put(&quot;could not publish, command queue is full [table=&quot;).put(tableToken.getTableName()).put(']');</span>
            }
<span class="fc" id="L1577">            Os.pause();</span>
<span class="fc" id="L1578">        }</span>
    }

    /**
     * Truncates table partitions leaving symbol files.
     * Used for truncate without holding Read lock on the table like in case of WAL tables.
     * This method leaves symbol files intact.
     */
    public final void removeAllPartitions() {
<span class="fc bfc" id="L1587" title="All 2 branches covered.">        if (size() == 0) {</span>
<span class="fc" id="L1588">            return;</span>
        }

<span class="pc bpc" id="L1591" title="1 of 2 branches missed.">        if (partitionBy == PartitionBy.NONE) {</span>
<span class="nc" id="L1592">            throw CairoException.critical(0).put(&quot;cannot remove partitions from non-partitioned table&quot;);</span>
        }

        // Remove all partition from txn file, column version file.
<span class="fc" id="L1596">        txWriter.beginPartitionSizeUpdate();</span>

<span class="fc bfc" id="L1598" title="All 2 branches covered.">        for (int i = txWriter.getPartitionCount(); i &gt; -1L; i--) {</span>
<span class="fc" id="L1599">            long timestamp = txWriter.getPartitionTimestamp(i);</span>
<span class="fc" id="L1600">            long partitionTxn = txWriter.getPartitionNameTxn(i);</span>
<span class="fc" id="L1601">            partitionRemoveCandidates.add(timestamp, partitionTxn);</span>
        }

<span class="fc" id="L1604">        columnVersionWriter.truncate(true);</span>
<span class="fc" id="L1605">        txWriter.removeAllPartitions();</span>
<span class="fc" id="L1606">        columnVersionWriter.commit();</span>
<span class="fc" id="L1607">        txWriter.setColumnVersion(columnVersionWriter.getVersion());</span>
<span class="fc" id="L1608">        txWriter.commit(defaultCommitMode, denseSymbolMapWriters);</span>
<span class="fc" id="L1609">        rowAction = ROW_ACTION_OPEN_PARTITION;</span>

<span class="fc" id="L1611">        processPartitionRemoveCandidates();</span>

<span class="fc" id="L1613">        LOG.info().$(&quot;removed all partitions (soft truncated) [name=&quot;).utf8(tableToken.getTableName()).I$();</span>
<span class="fc" id="L1614">    }</span>

    @Override
    public void removeColumn(CharSequence name) {
<span class="fc" id="L1618">        checkDistressed();</span>
<span class="fc" id="L1619">        checkColumnName(name);</span>

<span class="fc" id="L1621">        final int index = getColumnIndex(name);</span>
<span class="fc" id="L1622">        final int type = metadata.getColumnType(index);</span>

<span class="fc" id="L1624">        LOG.info().$(&quot;removing [column=&quot;).utf8(name).$(&quot;, path=&quot;).utf8(path).I$();</span>

        // check if we are moving timestamp from a partitioned table
<span class="fc" id="L1627">        final int timestampIndex = metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);</span>
<span class="fc bfc" id="L1628" title="All 2 branches covered.">        boolean timestamp = index == timestampIndex;</span>

<span class="fc bfc" id="L1630" title="All 4 branches covered.">        if (timestamp &amp;&amp; PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L1631">            throw CairoException.nonCritical().put(&quot;Cannot remove timestamp from partitioned table&quot;);</span>
        }

<span class="fc" id="L1634">        commit();</span>

<span class="fc" id="L1636">        metaSwapIndex = removeColumnFromMeta(index);</span>

        // close _meta so we can rename it
<span class="fc" id="L1639">        metaMem.close();</span>

        // rename _meta to _meta.prev
<span class="fc" id="L1642">        renameMetaToMetaPrev(name);</span>

        // after we moved _meta to _meta.prev
        // we have to have _todo to restore _meta should anything go wrong
<span class="fc" id="L1646">        writeRestoreMetaTodo(name);</span>

        // rename _meta.swp to _meta
<span class="fc" id="L1649">        renameSwapMetaToMeta(name);</span>

        // remove column objects
<span class="fc" id="L1652">        removeColumn(index);</span>

        // remove symbol map writer or entry for such
<span class="fc" id="L1655">        removeSymbolMapWriter(index);</span>

        // reset timestamp limits
<span class="fc bfc" id="L1658" title="All 2 branches covered.">        if (timestamp) {</span>
<span class="fc" id="L1659">            txWriter.resetTimestamp();</span>
<span class="fc" id="L1660">            timestampSetter = value -&gt; {</span>
<span class="fc" id="L1661">            };</span>
        }

        try {
            // open _meta file
<span class="fc" id="L1666">            openMetaFile(ff, path, rootLen, metaMem);</span>

            // remove _todo
<span class="fc" id="L1669">            clearTodoLog();</span>

            // remove column files has to be done after _todo is removed
<span class="fc" id="L1672">            removeColumnFiles(name, index, type);</span>
<span class="nc" id="L1673">        } catch (CairoException e) {</span>
<span class="nc" id="L1674">            throwDistressException(e);</span>
<span class="fc" id="L1675">        }</span>

<span class="fc" id="L1677">        bumpStructureVersion();</span>

<span class="fc" id="L1679">        metadata.removeColumn(index);</span>
<span class="fc bfc" id="L1680" title="All 2 branches covered.">        if (timestamp) {</span>
<span class="fc" id="L1681">            metadata.clearTimestampIndex();</span>
        }

<span class="fc" id="L1684">        LOG.info().$(&quot;REMOVED column '&quot;).utf8(name).$('[').$(ColumnType.nameOf(type)).$(&quot;]' from &quot;).$(path).$();</span>
<span class="fc" id="L1685">    }</span>

    @Override
    public boolean removePartition(long timestamp) {
<span class="fc bfc" id="L1689" title="All 2 branches covered.">        if (!PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L1690">            return false;</span>
        }

        // commit changes, there may be uncommitted rows of any partition
<span class="fc" id="L1694">        commit();</span>

<span class="fc" id="L1696">        final long minTimestamp = txWriter.getMinTimestamp(); // partition min timestamp</span>
<span class="fc" id="L1697">        final long maxTimestamp = txWriter.getMaxTimestamp(); // partition max timestamp</span>

<span class="fc" id="L1699">        timestamp = getPartitionLo(timestamp);</span>
<span class="fc" id="L1700">        final int index = txWriter.getPartitionIndex(timestamp);</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L1702">            LOG.error().$(&quot;partition is already removed [path=&quot;).utf8(path).$(&quot;, partitionTimestamp=&quot;).$ts(timestamp).I$();</span>
<span class="fc" id="L1703">            return false;</span>
        }

<span class="fc" id="L1706">        final long partitionNameTxn = txWriter.getPartitionNameTxnByPartitionTimestamp(timestamp);</span>

<span class="fc bfc" id="L1708" title="All 2 branches covered.">        if (timestamp == getPartitionLo(maxTimestamp)) {</span>

            // removing active partition

            // calculate new transient row count, min/max timestamps and find the partition to open next
            final long nextMaxTimestamp;
            final long newTransientRowCount;
            final long prevTimestamp;
<span class="fc bfc" id="L1716" title="All 2 branches covered.">            if (index == 0) {</span>
<span class="fc" id="L1717">                nextMaxTimestamp = Long.MIN_VALUE;</span>
<span class="fc" id="L1718">                newTransientRowCount = 0L;</span>
<span class="fc" id="L1719">                prevTimestamp = 0L; // meaningless</span>
            } else {
<span class="fc" id="L1721">                final int prevIndex = index - 1;</span>
<span class="fc" id="L1722">                prevTimestamp = txWriter.getPartitionTimestamp(prevIndex);</span>
<span class="fc" id="L1723">                newTransientRowCount = txWriter.getPartitionSize(prevIndex);</span>
                try {
<span class="fc" id="L1725">                    setPathForPartition(path.trimTo(rootLen), partitionBy, prevTimestamp, false);</span>
<span class="fc" id="L1726">                    TableUtils.txnPartitionConditionally(path, txWriter.getPartitionNameTxn(prevIndex));</span>
<span class="fc" id="L1727">                    readPartitionMinMax(ff, prevTimestamp, path, metadata.getColumnName(metadata.getTimestampIndex()), newTransientRowCount);</span>
<span class="fc" id="L1728">                    nextMaxTimestamp = attachMaxTimestamp;</span>
                } finally {
<span class="fc" id="L1730">                    path.trimTo(rootLen);</span>
                }
            }

<span class="fc" id="L1734">            columnVersionWriter.removePartition(timestamp);</span>
<span class="fc" id="L1735">            txWriter.beginPartitionSizeUpdate();</span>
<span class="fc" id="L1736">            txWriter.removeAttachedPartitions(timestamp);</span>
<span class="fc bfc" id="L1737" title="All 2 branches covered.">            txWriter.finishPartitionSizeUpdate(index == 0 ? Long.MAX_VALUE : txWriter.getMinTimestamp(), nextMaxTimestamp);</span>
<span class="fc" id="L1738">            txWriter.bumpTruncateVersion();</span>

<span class="fc" id="L1740">            columnVersionWriter.commit();</span>
<span class="fc" id="L1741">            txWriter.setColumnVersion(columnVersionWriter.getVersion());</span>
<span class="fc" id="L1742">            txWriter.commit(defaultCommitMode, denseSymbolMapWriters);</span>

<span class="fc" id="L1744">            closeActivePartition(true);</span>

<span class="fc bfc" id="L1746" title="All 2 branches covered.">            if (index != 0) {</span>
<span class="fc" id="L1747">                openPartition(prevTimestamp);</span>
<span class="fc" id="L1748">                setAppendPosition(newTransientRowCount, false);</span>
            } else {
<span class="fc" id="L1750">                rowAction = ROW_ACTION_OPEN_PARTITION;</span>
            }
<span class="fc" id="L1752">        } else {</span>

            // when we want to delete first partition we must find out minTimestamp from
            // next partition if it exists, or next partition, and so on
            //
            // when somebody removed data directories manually and then attempts to tidy
            // up metadata with logical partition delete we have to uphold the effort and
            // re-compute table size and its minTimestamp from what remains on disk

            // find out if we are removing min partition
<span class="fc" id="L1762">            long nextMinTimestamp = minTimestamp;</span>
<span class="fc bfc" id="L1763" title="All 2 branches covered.">            if (timestamp == txWriter.getPartitionTimestamp(0)) {</span>
<span class="fc" id="L1764">                nextMinTimestamp = readMinTimestamp(txWriter.getPartitionTimestamp(1));</span>
            }

<span class="fc" id="L1767">            columnVersionWriter.removePartition(timestamp);</span>

<span class="fc" id="L1769">            txWriter.beginPartitionSizeUpdate();</span>
<span class="fc" id="L1770">            txWriter.removeAttachedPartitions(timestamp);</span>
<span class="fc" id="L1771">            txWriter.setMinTimestamp(nextMinTimestamp);</span>
<span class="fc" id="L1772">            txWriter.finishPartitionSizeUpdate(nextMinTimestamp, txWriter.getMaxTimestamp());</span>
<span class="fc" id="L1773">            txWriter.bumpTruncateVersion();</span>

<span class="fc" id="L1775">            columnVersionWriter.commit();</span>
<span class="fc" id="L1776">            txWriter.setColumnVersion(columnVersionWriter.getVersion());</span>
<span class="fc" id="L1777">            txWriter.commit(defaultCommitMode, denseSymbolMapWriters);</span>
        }

        // Call O3 methods to remove check TxnScoreboard and remove partition directly
<span class="fc" id="L1781">        safeDeletePartitionDir(timestamp, partitionNameTxn);</span>
<span class="fc" id="L1782">        return true;</span>
    }

    @Override
    public void renameColumn(CharSequence currentName, CharSequence newName) {
<span class="fc" id="L1787">        checkDistressed();</span>
<span class="fc" id="L1788">        checkColumnName(newName);</span>

<span class="fc" id="L1790">        final int index = getColumnIndex(currentName);</span>
<span class="fc" id="L1791">        final int type = metadata.getColumnType(index);</span>

<span class="fc" id="L1793">        LOG.info().$(&quot;renaming column '&quot;).utf8(currentName).$('[').$(ColumnType.nameOf(type)).$(&quot;]' to '&quot;).utf8(newName).$(&quot;' in &quot;).$(path).$();</span>

<span class="fc" id="L1795">        commit();</span>

<span class="fc" id="L1797">        this.metaSwapIndex = renameColumnFromMeta(index, newName);</span>

        // close _meta so we can rename it
<span class="fc" id="L1800">        metaMem.close();</span>

        // rename _meta to _meta.prev
<span class="fc" id="L1803">        renameMetaToMetaPrev(currentName);</span>

        // after we moved _meta to _meta.prev
        // we have to have _todo to restore _meta should anything go wrong
<span class="fc" id="L1807">        writeRestoreMetaTodo(currentName);</span>

        // rename _meta.swp to _meta
<span class="fc" id="L1810">        renameSwapMetaToMeta(currentName);</span>

        try {
            // open _meta file
<span class="fc" id="L1814">            openMetaFile(ff, path, rootLen, metaMem);</span>

            // remove _todo
<span class="fc" id="L1817">            clearTodoLog();</span>

            // rename column files has to be done after _todo is removed
<span class="fc" id="L1820">            renameColumnFiles(currentName, index, newName, type);</span>
<span class="nc" id="L1821">        } catch (CairoException e) {</span>
<span class="nc" id="L1822">            throwDistressException(e);</span>
<span class="fc" id="L1823">        }</span>

<span class="fc" id="L1825">        bumpStructureVersion();</span>

<span class="fc" id="L1827">        metadata.renameColumn(currentName, newName);</span>

<span class="fc bfc" id="L1829" title="All 2 branches covered.">        if (index == metadata.getTimestampIndex()) {</span>
<span class="fc" id="L1830">            designatedTimestampColumnName = Chars.toString(newName);</span>
        }

<span class="fc" id="L1833">        LOG.info().$(&quot;RENAMED column '&quot;).utf8(currentName).$(&quot;' to '&quot;).utf8(newName).$(&quot;' from &quot;).$(path).$();</span>
<span class="fc" id="L1834">    }</span>

    @Override
    public void rollback() {
<span class="fc" id="L1838">        checkDistressed();</span>
<span class="fc bfc" id="L1839" title="All 4 branches covered.">        if (o3InError || inTransaction()) {</span>
            try {
<span class="fc" id="L1841">                LOG.info().$(&quot;tx rollback [name=&quot;).utf8(tableToken.getTableName()).I$();</span>
<span class="fc" id="L1842">                partitionRemoveCandidates.clear();</span>
<span class="fc" id="L1843">                o3CommitBatchTimestampMin = Long.MAX_VALUE;</span>
<span class="fc bfc" id="L1844" title="All 2 branches covered.">                if ((masterRef &amp; 1) != 0) {</span>
<span class="fc" id="L1845">                    masterRef++;</span>
                }
<span class="fc" id="L1847">                freeColumns(false);</span>
<span class="fc" id="L1848">                txWriter.unsafeLoadAll();</span>
<span class="fc" id="L1849">                rollbackIndexes();</span>
<span class="fc" id="L1850">                rollbackSymbolTables();</span>
<span class="fc" id="L1851">                columnVersionWriter.readUnsafe();</span>
<span class="fc" id="L1852">                purgeUnusedPartitions();</span>
<span class="fc" id="L1853">                configureAppendPosition();</span>
<span class="fc" id="L1854">                o3InError = false;</span>
                // when we rolled transaction back, hasO3() has to be false
<span class="fc" id="L1856">                o3MasterRef = -1;</span>
<span class="fc" id="L1857">                LOG.info().$(&quot;tx rollback complete [name=&quot;).utf8(tableToken.getTableName()).I$();</span>
<span class="fc" id="L1858">                processCommandQueue(false);</span>
<span class="fc" id="L1859">                metrics.tableWriter().incrementRollbacks();</span>
<span class="fc" id="L1860">            } catch (Throwable e) {</span>
<span class="fc" id="L1861">                LOG.critical().$(&quot;could not perform rollback [name=&quot;).utf8(tableToken.getTableName()).$(&quot;, msg=&quot;).$(e.getMessage()).I$();</span>
<span class="fc" id="L1862">                distressed = true;</span>
<span class="fc" id="L1863">            }</span>
        }
<span class="fc" id="L1865">    }</span>

    public void setExtensionListener(ExtensionListener listener) {
<span class="fc" id="L1868">        txWriter.setExtensionListener(listener);</span>
<span class="fc" id="L1869">    }</span>

    public void setLifecycleManager(LifecycleManager lifecycleManager) {
<span class="fc" id="L1872">        this.lifecycleManager = lifecycleManager;</span>
<span class="fc" id="L1873">    }</span>

    @Override
    public void setMetaMaxUncommittedRows(int maxUncommittedRows) {
        try {
<span class="fc" id="L1878">            commit();</span>
<span class="fc" id="L1879">            long metaSize = copyMetadataAndUpdateVersion();</span>
<span class="fc" id="L1880">            openMetaSwapFileByIndex(ff, ddlMem, path, rootLen, this.metaSwapIndex);</span>
            try {
<span class="fc" id="L1882">                ddlMem.jumpTo(META_OFFSET_MAX_UNCOMMITTED_ROWS);</span>
<span class="fc" id="L1883">                ddlMem.putInt(maxUncommittedRows);</span>
<span class="fc" id="L1884">                ddlMem.jumpTo(metaSize);</span>
            } finally {
<span class="fc" id="L1886">                ddlMem.close();</span>
            }

<span class="fc" id="L1889">            finishMetaSwapUpdate();</span>
<span class="fc" id="L1890">            metadata.setMaxUncommittedRows(maxUncommittedRows);</span>
<span class="fc" id="L1891">            clearTodoLog();</span>
        } finally {
<span class="fc" id="L1893">            ddlMem.close();</span>
        }
<span class="fc" id="L1895">    }</span>

    @Override
    public void setMetaO3MaxLag(long o3MaxLagUs) {
        try {
<span class="fc" id="L1900">            commit();</span>
<span class="fc" id="L1901">            long metaSize = copyMetadataAndUpdateVersion();</span>
<span class="fc" id="L1902">            openMetaSwapFileByIndex(ff, ddlMem, path, rootLen, this.metaSwapIndex);</span>
            try {
<span class="fc" id="L1904">                ddlMem.jumpTo(META_OFFSET_O3_MAX_LAG);</span>
<span class="fc" id="L1905">                ddlMem.putLong(o3MaxLagUs);</span>
<span class="fc" id="L1906">                ddlMem.jumpTo(metaSize);</span>
            } finally {
<span class="fc" id="L1908">                ddlMem.close();</span>
            }

<span class="fc" id="L1911">            finishMetaSwapUpdate();</span>
<span class="fc" id="L1912">            metadata.setO3MaxLag(o3MaxLagUs);</span>
<span class="fc" id="L1913">            clearTodoLog();</span>
        } finally {
<span class="fc" id="L1915">            ddlMem.close();</span>
        }
<span class="fc" id="L1917">    }</span>

    public void setSeqTxn(long seqTxn) {
<span class="fc" id="L1920">        txWriter.setSeqTxn(seqTxn);</span>
<span class="fc" id="L1921">    }</span>

    public long size() {
        // This is uncommitted row count
<span class="fc" id="L1925">        return txWriter.getRowCount() + getO3RowCount();</span>
    }

    @Override
    public boolean supportsMultipleWriters() {
<span class="fc" id="L1930">        return false;</span>
    }

    /**
     * Processes writer command queue to execute writer async commands such as replication and table alters.
     * Does not accept structure changes, e.g. equivalent to tick(false)
     * Some tick calls can result into transaction commit.
     */
    @Override
    public void tick() {
<span class="fc" id="L1940">        tick(false);</span>
<span class="fc" id="L1941">    }</span>

    /**
     * Processes writer command queue to execute writer async commands such as replication and table alters.
     * Some tick calls can result into transaction commit.
     *
     * @param contextAllowsAnyStructureChanges If true accepts any Alter table command, if false does not accept significant table
     *                                         structure changes like column drop, rename
     */
    public void tick(boolean contextAllowsAnyStructureChanges) {
        // Some alter table trigger commit() which trigger tick()
        // If already inside the tick(), do not re-enter it.
<span class="fc" id="L1953">        processCommandQueue(contextAllowsAnyStructureChanges);</span>
<span class="fc" id="L1954">    }</span>

    @Override
    public String toString() {
<span class="fc" id="L1958">        return &quot;TableWriter{name=&quot; + tableToken.getTableName() + '}';</span>
    }

    public void transferLock(int lockFd) {
<span class="pc bpc" id="L1962" title="1 of 2 branches missed.">        assert lockFd != -1;</span>
<span class="fc" id="L1963">        this.lockFd = lockFd;</span>
<span class="fc" id="L1964">    }</span>

    /**
     * Truncates table. When operation is unsuccessful it throws CairoException. With that truncate can be
     * retried or alternatively table can be closed. Outcome of any other operation with the table is undefined
     * and likely to cause segmentation fault. When table re-opens any partial truncate will be retried.
     */
    @Override
    public final void truncate() {
<span class="fc" id="L1973">        rollback();</span>

        // we do this before size check so that &quot;old&quot; corrupt symbol tables are brought back in line
<span class="fc bfc" id="L1976" title="All 2 branches covered.">        for (int i = 0, n = denseSymbolMapWriters.size(); i &lt; n; i++) {</span>
<span class="fc" id="L1977">            denseSymbolMapWriters.getQuick(i).truncate();</span>
        }

<span class="fc bfc" id="L1980" title="All 2 branches covered.">        if (size() == 0) {</span>
<span class="fc" id="L1981">            return;</span>
        }

        // this is a crude block to test things for now
<span class="fc" id="L1985">        todoMem.putLong(0, ++todoTxn); // write txn, reader will first read txn at offset 24 and then at offset 0</span>
<span class="fc" id="L1986">        Unsafe.getUnsafe().storeFence(); // make sure we do not write hash before writing txn (view from another thread)</span>
<span class="fc" id="L1987">        todoMem.putLong(8, configuration.getDatabaseIdLo()); // write out our instance hashes</span>
<span class="fc" id="L1988">        todoMem.putLong(16, configuration.getDatabaseIdHi());</span>
<span class="fc" id="L1989">        Unsafe.getUnsafe().storeFence();</span>
<span class="fc" id="L1990">        todoMem.putLong(24, todoTxn);</span>
<span class="fc" id="L1991">        todoMem.putLong(32, 1);</span>
<span class="fc" id="L1992">        todoMem.putLong(40, TODO_TRUNCATE);</span>
        // ensure file is closed with correct length
<span class="fc" id="L1994">        todoMem.jumpTo(48);</span>

<span class="fc bfc" id="L1996" title="All 2 branches covered.">        if (partitionBy != PartitionBy.NONE) {</span>
<span class="fc" id="L1997">            freeColumns(false);</span>
<span class="pc bpc" id="L1998" title="1 of 2 branches missed.">            if (indexers != null) {</span>
<span class="fc bfc" id="L1999" title="All 2 branches covered.">                for (int i = 0, n = indexers.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2000">                    Misc.free(indexers.getQuick(i));</span>
                }
            }
<span class="fc" id="L2003">            removePartitionDirectories();</span>
<span class="fc" id="L2004">            rowAction = ROW_ACTION_OPEN_PARTITION;</span>
        } else {
            // truncate columns, we cannot remove them
<span class="fc bfc" id="L2007" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2008">                getPrimaryColumn(i).truncate();</span>
<span class="fc" id="L2009">                MemoryMA mem = getSecondaryColumn(i);</span>
<span class="pc bpc" id="L2010" title="1 of 4 branches missed.">                if (mem != null &amp;&amp; mem.isOpen()) {</span>
<span class="fc" id="L2011">                    mem.truncate();</span>
<span class="fc" id="L2012">                    mem.putLong(0);</span>
                }
            }
        }

<span class="fc" id="L2017">        txWriter.resetTimestamp();</span>
<span class="fc" id="L2018">        columnVersionWriter.truncate(PartitionBy.isPartitioned(partitionBy));</span>
<span class="fc" id="L2019">        txWriter.truncate(columnVersionWriter.getVersion());</span>
        try {
<span class="fc" id="L2021">            clearTodoLog();</span>
<span class="nc" id="L2022">        } catch (CairoException e) {</span>
<span class="nc" id="L2023">            throwDistressException(e);</span>
<span class="fc" id="L2024">        }</span>

<span class="fc" id="L2026">        LOG.info().$(&quot;truncated [name=&quot;).utf8(tableToken.getTableName()).I$();</span>
<span class="fc" id="L2027">    }</span>

    @Override
    public void updateCommitInterval(double commitIntervalFraction, long commitIntervalDefault) {
<span class="fc" id="L2031">        this.commitIntervalFraction = commitIntervalFraction;</span>
<span class="fc" id="L2032">        this.commitIntervalDefault = commitIntervalDefault;</span>
<span class="fc" id="L2033">        this.commitInterval = calculateCommitInterval();</span>
<span class="fc" id="L2034">    }</span>

    public void updateTableToken(TableToken tableToken) {
<span class="fc" id="L2037">        this.tableToken = tableToken;</span>
<span class="fc" id="L2038">        this.metadata.updateTableToken(tableToken);</span>
<span class="fc" id="L2039">    }</span>

    public void upsertColumnVersion(long partitionTimestamp, int columnIndex, long columnTop) {
<span class="fc" id="L2042">        columnVersionWriter.upsert(partitionTimestamp, columnIndex, txWriter.txn, columnTop);</span>
<span class="fc" id="L2043">        txWriter.updatePartitionColumnVersion(partitionTimestamp);</span>
<span class="fc" id="L2044">    }</span>

    /**
     * Eagerly sets up writer instance. Otherwise, writer will initialize lazily. Invoking this method could improve
     * performance of some applications. UDP receivers use this in order to avoid initial receive buffer contention.
     */
    public void warmUp() {
<span class="fc" id="L2051">        Row r = newRow(Math.max(Timestamps.O3_MIN_TS, txWriter.getMaxTimestamp()));</span>
        try {
<span class="fc bfc" id="L2053" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2054">                r.putByte(i, (byte) 0);</span>
            }
        } finally {
<span class="fc" id="L2057">            r.cancel();</span>
        }
<span class="fc" id="L2059">    }</span>

    private static void configureNullSetters(ObjList&lt;Runnable&gt; nullers, int type, MemoryA mem1, MemoryA mem2) {
<span class="fc bfc" id="L2062" title="All 17 branches covered.">        switch (ColumnType.tagOf(type)) {</span>
            case ColumnType.BOOLEAN:
            case ColumnType.BYTE:
<span class="fc" id="L2065">                nullers.add(() -&gt; mem1.putByte((byte) 0));</span>
<span class="fc" id="L2066">                break;</span>
            case ColumnType.DOUBLE:
<span class="fc" id="L2068">                nullers.add(() -&gt; mem1.putDouble(Double.NaN));</span>
<span class="fc" id="L2069">                break;</span>
            case ColumnType.FLOAT:
<span class="fc" id="L2071">                nullers.add(() -&gt; mem1.putFloat(Float.NaN));</span>
<span class="fc" id="L2072">                break;</span>
            case ColumnType.INT:
<span class="fc" id="L2074">                nullers.add(() -&gt; mem1.putInt(Numbers.INT_NaN));</span>
<span class="fc" id="L2075">                break;</span>
            case ColumnType.LONG:
            case ColumnType.DATE:
            case ColumnType.TIMESTAMP:
<span class="fc" id="L2079">                nullers.add(() -&gt; mem1.putLong(Numbers.LONG_NaN));</span>
<span class="fc" id="L2080">                break;</span>
            case ColumnType.LONG128:
                // fall through
            case ColumnType.UUID:
<span class="fc" id="L2084">                nullers.add(() -&gt; mem1.putLong128(Numbers.LONG_NaN, Numbers.LONG_NaN));</span>
<span class="fc" id="L2085">                break;</span>
            case ColumnType.LONG256:
<span class="fc" id="L2087">                nullers.add(() -&gt; mem1.putLong256(Numbers.LONG_NaN, Numbers.LONG_NaN, Numbers.LONG_NaN, Numbers.LONG_NaN));</span>
<span class="fc" id="L2088">                break;</span>
            case ColumnType.SHORT:
<span class="fc" id="L2090">                nullers.add(() -&gt; mem1.putShort((short) 0));</span>
<span class="fc" id="L2091">                break;</span>
            case ColumnType.CHAR:
<span class="fc" id="L2093">                nullers.add(() -&gt; mem1.putChar((char) 0));</span>
<span class="fc" id="L2094">                break;</span>
            case ColumnType.STRING:
<span class="fc" id="L2096">                nullers.add(() -&gt; mem2.putLong(mem1.putNullStr()));</span>
<span class="fc" id="L2097">                break;</span>
            case ColumnType.SYMBOL:
<span class="fc" id="L2099">                nullers.add(() -&gt; mem1.putInt(SymbolTable.VALUE_IS_NULL));</span>
<span class="fc" id="L2100">                break;</span>
            case ColumnType.BINARY:
<span class="fc" id="L2102">                nullers.add(() -&gt; mem2.putLong(mem1.putNullBin()));</span>
<span class="fc" id="L2103">                break;</span>
            case ColumnType.GEOBYTE:
<span class="fc" id="L2105">                nullers.add(() -&gt; mem1.putByte(GeoHashes.BYTE_NULL));</span>
<span class="fc" id="L2106">                break;</span>
            case ColumnType.GEOSHORT:
<span class="fc" id="L2108">                nullers.add(() -&gt; mem1.putShort(GeoHashes.SHORT_NULL));</span>
<span class="fc" id="L2109">                break;</span>
            case ColumnType.GEOINT:
<span class="fc" id="L2111">                nullers.add(() -&gt; mem1.putInt(GeoHashes.INT_NULL));</span>
<span class="fc" id="L2112">                break;</span>
            case ColumnType.GEOLONG:
<span class="fc" id="L2114">                nullers.add(() -&gt; mem1.putLong(GeoHashes.NULL));</span>
<span class="fc" id="L2115">                break;</span>
            default:
<span class="fc" id="L2117">                nullers.add(NOOP);</span>
        }
<span class="fc" id="L2119">    }</span>

    /**
     * This an O(n) method to find if column by the same name already exists. The benefit of poor performance
     * is that we don't keep column name strings on heap. We only use this method when adding new column, where
     * high performance of name check does not matter much.
     *
     * @param name to check
     * @return 0 based column index.
     */
    private static int getColumnIndexQuiet(MemoryMR metaMem, CharSequence name, int columnCount) {
<span class="fc" id="L2130">        long nameOffset = getColumnNameOffset(columnCount);</span>
<span class="fc bfc" id="L2131" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2132">            CharSequence col = metaMem.getStr(nameOffset);</span>
<span class="fc" id="L2133">            int columnType = getColumnType(metaMem, i); // Negative means deleted column</span>
<span class="fc bfc" id="L2134" title="All 4 branches covered.">            if (columnType &gt; 0 &amp;&amp; Chars.equalsIgnoreCase(col, name)) {</span>
<span class="fc" id="L2135">                return i;</span>
            }
<span class="fc" id="L2137">            nameOffset += Vm.getStorageLength(col);</span>
        }
<span class="fc" id="L2139">        return -1;</span>
    }

    private static ColumnVersionWriter openColumnVersionFile(FilesFacade ff, Path path, int rootLen) {
<span class="fc" id="L2143">        path.concat(COLUMN_VERSION_FILE_NAME).$();</span>
        try {
<span class="fc" id="L2145">            return new ColumnVersionWriter(ff, path, 0);</span>
        } finally {
<span class="fc" id="L2147">            path.trimTo(rootLen);</span>
        }
    }

    private static void openMetaFile(FilesFacade ff, Path path, int rootLen, MemoryMR metaMem) {
<span class="fc" id="L2152">        path.concat(META_FILE_NAME).$();</span>
        try {
<span class="fc" id="L2154">            metaMem.smallFile(ff, path, MemoryTag.MMAP_TABLE_WRITER);</span>
        } finally {
<span class="fc" id="L2156">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L2158">    }</span>

    private static void removeFileAndOrLog(FilesFacade ff, LPSZ name) {
<span class="fc bfc" id="L2161" title="All 2 branches covered.">        if (ff.exists(name)) {</span>
<span class="fc bfc" id="L2162" title="All 2 branches covered.">            if (ff.remove(name)) {</span>
<span class="fc" id="L2163">                LOG.debug().$(&quot;removed [file=&quot;).utf8(name).I$();</span>
            } else {
<span class="fc" id="L2165">                LOG.error()</span>
<span class="fc" id="L2166">                        .$(&quot;could not remove [errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L2167">                        .$(&quot;, file=&quot;).utf8(name)</span>
<span class="fc" id="L2168">                        .I$();</span>
            }
        }
<span class="fc" id="L2171">    }</span>

    private static void renameFileOrLog(FilesFacade ff, LPSZ from, LPSZ to) {
<span class="fc bfc" id="L2174" title="All 2 branches covered.">        if (ff.exists(from)) {</span>
<span class="fc bfc" id="L2175" title="All 2 branches covered.">            if (ff.rename(from, to) == FILES_RENAME_OK) {</span>
<span class="fc" id="L2176">                LOG.debug().$(&quot;renamed [from=&quot;).utf8(from).$(&quot;, to=&quot;).utf8(to).I$();</span>
            } else {
<span class="fc" id="L2178">                LOG.critical()</span>
<span class="fc" id="L2179">                        .$(&quot;could not rename [errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L2180">                        .$(&quot;, from=&quot;).utf8(from)</span>
<span class="fc" id="L2181">                        .$(&quot;, to=&quot;).utf8(to)</span>
<span class="fc" id="L2182">                        .I$();</span>
            }
        }
<span class="fc" id="L2185">    }</span>

    private int addColumnToMeta(
            CharSequence name,
            int type,
            boolean indexFlag,
            int indexValueBlockCapacity,
            boolean sequentialFlag
    ) {
        int index;
        try {
<span class="fc" id="L2196">            index = openMetaSwapFile(ff, ddlMem, path, rootLen, configuration.getMaxSwapFileCount());</span>
<span class="fc" id="L2197">            int columnCount = metaMem.getInt(META_OFFSET_COUNT);</span>

<span class="fc" id="L2199">            ddlMem.putInt(columnCount + 1);</span>
<span class="fc" id="L2200">            ddlMem.putInt(metaMem.getInt(META_OFFSET_PARTITION_BY));</span>
<span class="fc" id="L2201">            ddlMem.putInt(metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX));</span>
<span class="fc" id="L2202">            copyVersionAndLagValues();</span>
<span class="fc" id="L2203">            ddlMem.jumpTo(META_OFFSET_COLUMN_TYPES);</span>
<span class="fc bfc" id="L2204" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2205">                writeColumnEntry(i, false);</span>
            }

            // add new column metadata to bottom of list
<span class="fc" id="L2209">            ddlMem.putInt(type);</span>
<span class="fc" id="L2210">            long flags = 0;</span>
<span class="fc bfc" id="L2211" title="All 2 branches covered.">            if (indexFlag) {</span>
<span class="fc" id="L2212">                flags |= META_FLAG_BIT_INDEXED;</span>
            }

<span class="pc bpc" id="L2215" title="1 of 2 branches missed.">            if (sequentialFlag) {</span>
<span class="nc" id="L2216">                flags |= META_FLAG_BIT_SEQUENTIAL;</span>
            }

<span class="fc" id="L2219">            ddlMem.putLong(flags);</span>
<span class="fc" id="L2220">            ddlMem.putInt(indexValueBlockCapacity);</span>
<span class="fc" id="L2221">            ddlMem.putLong(configuration.getRandom().nextLong());</span>
<span class="fc" id="L2222">            ddlMem.skip(8);</span>

<span class="fc" id="L2224">            long nameOffset = getColumnNameOffset(columnCount);</span>
<span class="fc bfc" id="L2225" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2226">                CharSequence columnName = metaMem.getStr(nameOffset);</span>
<span class="fc" id="L2227">                ddlMem.putStr(columnName);</span>
<span class="fc" id="L2228">                nameOffset += Vm.getStorageLength(columnName);</span>
            }
<span class="fc" id="L2230">            ddlMem.putStr(name);</span>
        } finally {
<span class="fc" id="L2232">            ddlMem.close();</span>
        }
<span class="fc" id="L2234">        return index;</span>
    }

    private void attachPartitionCheckFilesMatchFixedColumn(
            int columnType,
            long partitionSize,
            long columnTop,
            String columnName,
            long columnNameTxn,
            Path partitionPath,
            long partitionTimestamp,
            int columnIndex
    ) {
<span class="fc" id="L2247">        long columnSize = partitionSize - columnTop;</span>
<span class="pc bpc" id="L2248" title="1 of 2 branches missed.">        if (columnSize == 0) {</span>
<span class="nc" id="L2249">            return;</span>
        }

<span class="fc" id="L2252">        TableUtils.dFile(partitionPath, columnName, columnNameTxn);</span>
<span class="fc bfc" id="L2253" title="All 2 branches covered.">        if (!ff.exists(partitionPath.$())) {</span>
<span class="fc" id="L2254">            LOG.info().$(&quot;attaching partition with missing column [path=&quot;).$(partitionPath).I$();</span>
<span class="fc" id="L2255">            columnVersionWriter.upsertColumnTop(partitionTimestamp, columnIndex, partitionSize);</span>
        } else {
<span class="fc" id="L2257">            long fileSize = ff.length(partitionPath);</span>
<span class="fc bfc" id="L2258" title="All 2 branches covered.">            if (fileSize &lt; (columnSize &lt;&lt; ColumnType.pow2SizeOf(columnType))) {</span>
<span class="fc" id="L2259">                throw CairoException.critical(0)</span>
<span class="fc" id="L2260">                        .put(&quot;Column file is too small. &quot;)</span>
<span class="fc" id="L2261">                        .put(&quot;Partition files inconsistent [file=&quot;)</span>
<span class="fc" id="L2262">                        .put(partitionPath)</span>
<span class="fc" id="L2263">                        .put(&quot;, expectedSize=&quot;)</span>
<span class="fc" id="L2264">                        .put(columnSize &lt;&lt; ColumnType.pow2SizeOf(columnType))</span>
<span class="fc" id="L2265">                        .put(&quot;, actual=&quot;)</span>
<span class="fc" id="L2266">                        .put(fileSize)</span>
<span class="fc" id="L2267">                        .put(']');</span>
            }
        }
<span class="fc" id="L2270">    }</span>

    private void attachPartitionCheckFilesMatchVarLenColumn(
            long partitionSize,
            long columnTop,
            String columnName,
            long columnNameTxn,
            Path partitionPath,
            long partitionTimestamp,
            int columnIndex
    ) throws CairoException {
<span class="fc" id="L2281">        long columnSize = partitionSize - columnTop;</span>
<span class="pc bpc" id="L2282" title="1 of 2 branches missed.">        if (columnSize == 0) {</span>
<span class="nc" id="L2283">            return;</span>
        }

<span class="fc" id="L2286">        int pathLen = partitionPath.length();</span>
<span class="fc" id="L2287">        TableUtils.dFile(partitionPath, columnName, columnNameTxn);</span>
<span class="fc" id="L2288">        long dataLength = ff.length(partitionPath.$());</span>

<span class="fc bfc" id="L2290" title="All 2 branches covered.">        if (dataLength &gt; 0) {</span>
<span class="fc" id="L2291">            partitionPath.trimTo(pathLen);</span>
<span class="fc" id="L2292">            TableUtils.iFile(partitionPath, columnName, columnNameTxn);</span>

<span class="fc" id="L2294">            int typeSize = Long.BYTES;</span>
<span class="fc" id="L2295">            int indexFd = openRO(ff, partitionPath, LOG);</span>
            try {
<span class="fc" id="L2297">                long fileSize = ff.length(indexFd);</span>
<span class="fc" id="L2298">                long expectedFileSize = (columnSize + 1) * typeSize;</span>
<span class="fc bfc" id="L2299" title="All 2 branches covered.">                if (fileSize &lt; expectedFileSize) {</span>
<span class="fc" id="L2300">                    throw CairoException.critical(0)</span>
<span class="fc" id="L2301">                            .put(&quot;Column file is too small. &quot;)</span>
<span class="fc" id="L2302">                            .put(&quot;Partition files inconsistent [file=&quot;)</span>
<span class="fc" id="L2303">                            .put(partitionPath)</span>
<span class="fc" id="L2304">                            .put(&quot;,expectedSize=&quot;)</span>
<span class="fc" id="L2305">                            .put(expectedFileSize)</span>
<span class="fc" id="L2306">                            .put(&quot;,actual=&quot;)</span>
<span class="fc" id="L2307">                            .put(fileSize)</span>
<span class="fc" id="L2308">                            .put(']');</span>
                }

<span class="fc" id="L2311">                long mappedAddr = mapRO(ff, indexFd, expectedFileSize, MemoryTag.MMAP_DEFAULT);</span>
                try {
<span class="fc" id="L2313">                    long prevDataAddress = dataLength;</span>
<span class="fc bfc" id="L2314" title="All 2 branches covered.">                    for (long offset = columnSize * typeSize; offset &gt;= 0; offset -= typeSize) {</span>
<span class="fc" id="L2315">                        long dataAddress = Unsafe.getUnsafe().getLong(mappedAddr + offset);</span>
<span class="fc bfc" id="L2316" title="All 4 branches covered.">                        if (dataAddress &lt; 0 || dataAddress &gt; dataLength) {</span>
<span class="fc" id="L2317">                            throw CairoException.critical(0).put(&quot;Variable size column has invalid data address value [path=&quot;).put(path)</span>
<span class="fc" id="L2318">                                    .put(&quot;, indexOffset=&quot;).put(offset)</span>
<span class="fc" id="L2319">                                    .put(&quot;, dataAddress=&quot;).put(dataAddress)</span>
<span class="fc" id="L2320">                                    .put(&quot;, dataFileSize=&quot;).put(dataLength)</span>
<span class="fc" id="L2321">                                    .put(']');</span>
                        }

                        // Check that addresses are monotonic
<span class="fc bfc" id="L2325" title="All 2 branches covered.">                        if (dataAddress &gt; prevDataAddress) {</span>
<span class="fc" id="L2326">                            throw CairoException.critical(0).put(&quot;Variable size column has invalid data address value [path=&quot;).put(partitionPath)</span>
<span class="fc" id="L2327">                                    .put(&quot;, indexOffset=&quot;).put(offset)</span>
<span class="fc" id="L2328">                                    .put(&quot;, dataAddress=&quot;).put(dataAddress)</span>
<span class="fc" id="L2329">                                    .put(&quot;, prevDataAddress=&quot;).put(prevDataAddress)</span>
<span class="fc" id="L2330">                                    .put(&quot;, dataFileSize=&quot;).put(dataLength)</span>
<span class="fc" id="L2331">                                    .put(']');</span>
                        }
<span class="fc" id="L2333">                        prevDataAddress = dataAddress;</span>
                    }
                } finally {
<span class="fc" id="L2336">                    ff.munmap(mappedAddr, expectedFileSize, MemoryTag.MMAP_DEFAULT);</span>
                }
            } finally {
<span class="fc" id="L2339">                ff.close(indexFd);</span>
            }
<span class="fc" id="L2341">        } else {</span>
<span class="fc" id="L2342">            LOG.info().$(&quot;attaching partition with missing column [path=&quot;).$(partitionPath).I$();</span>
<span class="fc" id="L2343">            columnVersionWriter.upsertColumnTop(partitionTimestamp, columnIndex, partitionSize);</span>
        }
<span class="fc" id="L2345">    }</span>

    private void attachPartitionCheckSymbolColumn(long partitionSize, long columnTop, String columnName, long columnNameTxn, Path partitionPath, long partitionTimestamp, int columnIndex) {
<span class="fc" id="L2348">        long columnSize = partitionSize - columnTop;</span>
<span class="pc bpc" id="L2349" title="1 of 2 branches missed.">        if (columnSize == 0) {</span>
<span class="nc" id="L2350">            return;</span>
        }

<span class="fc" id="L2353">        int pathLen = partitionPath.length();</span>
<span class="fc" id="L2354">        TableUtils.dFile(partitionPath, columnName, columnNameTxn);</span>
<span class="fc bfc" id="L2355" title="All 2 branches covered.">        if (!ff.exists(partitionPath.$())) {</span>
<span class="fc" id="L2356">            columnVersionWriter.upsertColumnTop(partitionTimestamp, columnIndex, partitionSize);</span>
<span class="fc" id="L2357">            return;</span>
        }

<span class="fc" id="L2360">        int fd = openRO(ff, partitionPath.$(), LOG);</span>
        try {
<span class="fc" id="L2362">            long fileSize = ff.length(fd);</span>
<span class="fc" id="L2363">            int typeSize = Integer.BYTES;</span>
<span class="fc" id="L2364">            long expectedSize = columnSize * typeSize;</span>
<span class="pc bpc" id="L2365" title="1 of 2 branches missed.">            if (fileSize &lt; expectedSize) {</span>
<span class="nc" id="L2366">                throw CairoException.critical(0)</span>
<span class="nc" id="L2367">                        .put(&quot;Column file is too small. &quot;)</span>
<span class="nc" id="L2368">                        .put(&quot;Partition files inconsistent [file=&quot;)</span>
<span class="nc" id="L2369">                        .put(partitionPath)</span>
<span class="nc" id="L2370">                        .put(&quot;, expectedSize=&quot;)</span>
<span class="nc" id="L2371">                        .put(expectedSize)</span>
<span class="nc" id="L2372">                        .put(&quot;, actual=&quot;)</span>
<span class="nc" id="L2373">                        .put(fileSize)</span>
<span class="nc" id="L2374">                        .put(']');</span>
            }

<span class="fc" id="L2377">            long address = mapRO(ff, fd, fileSize, MemoryTag.MMAP_DEFAULT);</span>
            try {
<span class="fc" id="L2379">                int maxKey = Vect.maxInt(address, columnSize);</span>
<span class="fc" id="L2380">                int symbolValues = symbolMapWriters.getQuick(columnIndex).getSymbolCount();</span>
<span class="fc bfc" id="L2381" title="All 2 branches covered.">                if (maxKey &gt;= symbolValues) {</span>
<span class="fc" id="L2382">                    throw CairoException.critical(0)</span>
<span class="fc" id="L2383">                            .put(&quot;Symbol file does not match symbol column [file=&quot;)</span>
<span class="fc" id="L2384">                            .put(path)</span>
<span class="fc" id="L2385">                            .put(&quot;, key=&quot;)</span>
<span class="fc" id="L2386">                            .put(maxKey)</span>
<span class="fc" id="L2387">                            .put(&quot;, columnKeys=&quot;)</span>
<span class="fc" id="L2388">                            .put(symbolValues)</span>
<span class="fc" id="L2389">                            .put(']');</span>
                }
<span class="fc" id="L2391">                int minKey = Vect.minInt(address, columnSize);</span>
<span class="pc bpc" id="L2392" title="1 of 4 branches missed.">                if (minKey != SymbolTable.VALUE_IS_NULL &amp;&amp; minKey &lt; 0) {</span>
<span class="fc" id="L2393">                    throw CairoException.critical(0)</span>
<span class="fc" id="L2394">                            .put(&quot;Symbol file does not match symbol column, invalid key [file=&quot;)</span>
<span class="fc" id="L2395">                            .put(path)</span>
<span class="fc" id="L2396">                            .put(&quot;, key=&quot;)</span>
<span class="fc" id="L2397">                            .put(minKey)</span>
<span class="fc" id="L2398">                            .put(']');</span>
                }
            } finally {
<span class="fc" id="L2401">                ff.munmap(address, fileSize, MemoryTag.MMAP_DEFAULT);</span>
            }

<span class="fc bfc" id="L2404" title="All 2 branches covered.">            if (metadata.isColumnIndexed(columnIndex)) {</span>
<span class="fc" id="L2405">                valueFileName(partitionPath.trimTo(pathLen), columnName, columnNameTxn);</span>
<span class="fc bfc" id="L2406" title="All 2 branches covered.">                if (!ff.exists(partitionPath.$())) {</span>
<span class="fc" id="L2407">                    throw CairoException.critical(0)</span>
<span class="fc" id="L2408">                            .put(&quot;Symbol index value file does not exist [file=&quot;)</span>
<span class="fc" id="L2409">                            .put(partitionPath)</span>
<span class="fc" id="L2410">                            .put(']');</span>
                }
<span class="fc" id="L2412">                keyFileName(partitionPath.trimTo(pathLen), columnName, columnNameTxn);</span>
<span class="fc bfc" id="L2413" title="All 2 branches covered.">                if (!ff.exists(partitionPath.$())) {</span>
<span class="fc" id="L2414">                    throw CairoException.critical(0)</span>
<span class="fc" id="L2415">                            .put(&quot;Symbol index key file does not exist [file=&quot;)</span>
<span class="fc" id="L2416">                            .put(partitionPath)</span>
<span class="fc" id="L2417">                            .put(']');</span>
                }
            }
        } finally {
<span class="fc" id="L2421">            ff.close(fd);</span>
        }
<span class="fc" id="L2423">    }</span>

    private boolean attachPrepare(long partitionTimestamp, long partitionSize, Path detachedPath, int detachedPartitionRoot) {
        try {
            // load/check _meta
<span class="fc" id="L2428">            detachedPath.trimTo(detachedPartitionRoot).concat(META_FILE_NAME);</span>
<span class="fc bfc" id="L2429" title="All 2 branches covered.">            if (!ff.exists(detachedPath.$())) {</span>
                // Backups and older versions of detached partitions will not have _dmeta
<span class="fc" id="L2431">                LOG.info().$(&quot;detached &quot;).$(META_FILE_NAME).$(&quot; file not found, skipping check [path=&quot;).$(detachedPath).I$();</span>
<span class="fc" id="L2432">                return false;</span>
            }

<span class="fc bfc" id="L2435" title="All 2 branches covered.">            if (attachMetadata == null) {</span>
<span class="fc" id="L2436">                attachMetaMem = Vm.getCMRInstance();</span>
<span class="fc" id="L2437">                attachMetaMem.smallFile(ff, detachedPath, MemoryTag.MMAP_TABLE_WRITER);</span>
<span class="fc" id="L2438">                attachMetadata = new TableWriterMetadata(tableToken, attachMetaMem);</span>
            } else {
<span class="fc" id="L2440">                attachMetaMem.smallFile(ff, detachedPath, MemoryTag.MMAP_TABLE_WRITER);</span>
<span class="fc" id="L2441">                attachMetadata.reload(attachMetaMem);</span>
            }

<span class="fc bfc" id="L2444" title="All 2 branches covered.">            if (metadata.getTableId() != attachMetadata.getTableId()) {</span>
                // very same table, attaching foreign partitions is not allowed
<span class="fc" id="L2446">                throw CairoException.detachedMetadataMismatch(&quot;table_id&quot;);</span>
            }
<span class="fc bfc" id="L2448" title="All 2 branches covered.">            if (metadata.getTimestampIndex() != attachMetadata.getTimestampIndex()) {</span>
                // designated timestamps in both tables, same index
<span class="fc" id="L2450">                throw CairoException.detachedMetadataMismatch(&quot;timestamp_index&quot;);</span>
            }

            // load/check _dcv, updating local column tops
            // set current _dcv to where the partition was
<span class="fc" id="L2455">            detachedPath.trimTo(detachedPartitionRoot).concat(COLUMN_VERSION_FILE_NAME).$();</span>
<span class="pc bpc" id="L2456" title="1 of 2 branches missed.">            if (!ff.exists(detachedPath)) {</span>
                // Backups and older versions of detached partitions will not have _cv
<span class="nc" id="L2458">                LOG.error().$(&quot;detached _dcv file not found, skipping check [path=&quot;).$(detachedPath).I$();</span>
<span class="nc" id="L2459">                return false;</span>
            } else {
<span class="fc bfc" id="L2461" title="All 2 branches covered.">                if (attachColumnVersionReader == null) {</span>
<span class="fc" id="L2462">                    attachColumnVersionReader = new ColumnVersionReader();</span>
                }
<span class="fc" id="L2464">                attachColumnVersionReader.ofRO(ff, detachedPath);</span>
<span class="fc" id="L2465">                attachColumnVersionReader.readUnsafe();</span>
            }

            // override column tops for the partition we are attaching
<span class="fc" id="L2469">            columnVersionWriter.copyPartition(partitionTimestamp, attachColumnVersionReader);</span>

<span class="fc bfc" id="L2471" title="All 2 branches covered.">            for (int colIdx = 0; colIdx &lt; columnCount; colIdx++) {</span>
<span class="fc" id="L2472">                String columnName = metadata.getColumnName(colIdx);</span>

                // check name
<span class="fc" id="L2475">                int detColIdx = attachMetadata.getColumnIndexQuiet(columnName);</span>
<span class="fc bfc" id="L2476" title="All 2 branches covered.">                if (detColIdx == -1) {</span>
<span class="fc" id="L2477">                    columnVersionWriter.upsertColumnTop(partitionTimestamp, colIdx, partitionSize);</span>
<span class="fc" id="L2478">                    continue;</span>
                }

<span class="pc bpc" id="L2481" title="1 of 2 branches missed.">                if (detColIdx != colIdx) {</span>
<span class="nc" id="L2482">                    throw CairoException.detachedColumnMetadataMismatch(colIdx, columnName, &quot;name&quot;);</span>
                }

                // check type
<span class="fc" id="L2486">                int tableColType = metadata.getColumnType(colIdx);</span>
<span class="fc" id="L2487">                int attachColType = attachMetadata.getColumnType(detColIdx);</span>
<span class="pc bpc" id="L2488" title="1 of 4 branches missed.">                if (tableColType != attachColType &amp;&amp; tableColType != -attachColType) {</span>
<span class="fc" id="L2489">                    throw CairoException.detachedColumnMetadataMismatch(colIdx, columnName, &quot;type&quot;);</span>
                }

<span class="pc bpc" id="L2492" title="1 of 2 branches missed.">                if (tableColType != attachColType) {</span>
                    // This is very suspicious. The column was deleted in the detached partition,
                    // but it exists in the target table.
<span class="nc" id="L2495">                    LOG.info().$(&quot;detached partition has column deleted while the table has the same column alive [tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="nc" id="L2496">                            .$(&quot;, columnName=&quot;).utf8(columnName)</span>
<span class="nc" id="L2497">                            .$(&quot;, columnType=&quot;).$(ColumnType.nameOf(tableColType))</span>
<span class="nc" id="L2498">                            .I$();</span>
<span class="nc" id="L2499">                    columnVersionWriter.upsertColumnTop(partitionTimestamp, colIdx, partitionSize);</span>
                }

                // check column is / was indexed
<span class="fc bfc" id="L2503" title="All 2 branches covered.">                if (ColumnType.isSymbol(tableColType)) {</span>
<span class="fc" id="L2504">                    boolean isIndexedNow = metadata.isColumnIndexed(colIdx);</span>
<span class="fc" id="L2505">                    boolean wasIndexedAtDetached = attachMetadata.isColumnIndexed(detColIdx);</span>
<span class="fc" id="L2506">                    int indexValueBlockCapacityNow = metadata.getIndexValueBlockCapacity(colIdx);</span>
<span class="fc" id="L2507">                    int indexValueBlockCapacityDetached = attachMetadata.getIndexValueBlockCapacity(detColIdx);</span>

<span class="fc bfc" id="L2509" title="All 4 branches covered.">                    if (!isIndexedNow &amp;&amp; wasIndexedAtDetached) {</span>
<span class="fc" id="L2510">                        long columnNameTxn = attachColumnVersionReader.getColumnNameTxn(partitionTimestamp, colIdx);</span>
<span class="fc" id="L2511">                        keyFileName(detachedPath.trimTo(detachedPartitionRoot), columnName, columnNameTxn);</span>
<span class="fc" id="L2512">                        removeFileAndOrLog(ff, detachedPath);</span>
<span class="fc" id="L2513">                        valueFileName(detachedPath.trimTo(detachedPartitionRoot), columnName, columnNameTxn);</span>
<span class="fc" id="L2514">                        removeFileAndOrLog(ff, detachedPath);</span>
<span class="fc bfc" id="L2515" title="All 6 branches covered.">                    } else if (isIndexedNow</span>
                            &amp;&amp; (!wasIndexedAtDetached || indexValueBlockCapacityNow != indexValueBlockCapacityDetached)) {
                        // Was not indexed before or value block capacity has changed
<span class="fc" id="L2518">                        detachedPath.trimTo(detachedPartitionRoot);</span>
<span class="fc" id="L2519">                        rebuildAttachedPartitionColumnIndex(partitionTimestamp, partitionSize, detachedPath, columnName);</span>
                    }
                }
            }
<span class="fc" id="L2523">            return true;</span>
            // Do not remove _dmeta and _dcv to keep partition attachable in case of fs copy / rename failure
        } finally {
<span class="fc" id="L2526">            Misc.free(attachColumnVersionReader);</span>
<span class="fc" id="L2527">            Misc.free(attachMetaMem);</span>
<span class="fc" id="L2528">            Misc.free(attachIndexBuilder);</span>
        }
    }

    private void attachValidateMetadata(long partitionSize, Path partitionPath, long partitionTimestamp) throws CairoException {
        // for each column, check that file exists in the partition folder
<span class="fc" id="L2534">        int rootLen = partitionPath.length();</span>
<span class="fc bfc" id="L2535" title="All 2 branches covered.">        for (int columnIndex = 0, size = metadata.getColumnCount(); columnIndex &lt; size; columnIndex++) {</span>
            try {
<span class="fc" id="L2537">                final String columnName = metadata.getColumnName(columnIndex);</span>
<span class="fc" id="L2538">                int columnType = metadata.getColumnType(columnIndex);</span>

<span class="pc bpc" id="L2540" title="1 of 2 branches missed.">                if (columnType &gt; -1L) {</span>
<span class="fc" id="L2541">                    long columnTop = columnVersionWriter.getColumnTop(partitionTimestamp, columnIndex);</span>
<span class="pc bpc" id="L2542" title="2 of 4 branches missed.">                    if (columnTop &lt; 0 || columnTop == partitionSize) {</span>
                        // Column does not exist in the partition
                        continue;
                    }
<span class="fc" id="L2546">                    long columnNameTxn = columnVersionWriter.getDefaultColumnNameTxn(columnIndex);</span>
<span class="pc bpc" id="L2547" title="1 of 4 branches missed.">                    switch (ColumnType.tagOf(columnType)) {</span>
                        case ColumnType.INT:
                        case ColumnType.LONG:
                        case ColumnType.BOOLEAN:
                        case ColumnType.BYTE:
                        case ColumnType.TIMESTAMP:
                        case ColumnType.DATE:
                        case ColumnType.DOUBLE:
                        case ColumnType.CHAR:
                        case ColumnType.SHORT:
                        case ColumnType.FLOAT:
                        case ColumnType.LONG128:
                        case ColumnType.LONG256:
                        case ColumnType.GEOBYTE:
                        case ColumnType.GEOSHORT:
                        case ColumnType.GEOINT:
                        case ColumnType.GEOLONG:
                        case ColumnType.UUID:
<span class="fc" id="L2565">                            attachPartitionCheckFilesMatchFixedColumn(columnType, partitionSize, columnTop, columnName, columnNameTxn, partitionPath, partitionTimestamp, columnIndex);</span>
<span class="fc" id="L2566">                            break;</span>
                        case ColumnType.STRING:
                        case ColumnType.BINARY:
<span class="fc" id="L2569">                            attachPartitionCheckFilesMatchVarLenColumn(partitionSize, columnTop, columnName, columnNameTxn, partitionPath, partitionTimestamp, columnIndex);</span>
<span class="fc" id="L2570">                            break;</span>
                        case ColumnType.SYMBOL:
<span class="fc" id="L2572">                            attachPartitionCheckSymbolColumn(partitionSize, columnTop, columnName, columnNameTxn, partitionPath, partitionTimestamp, columnIndex);</span>
                            break;
                    }
                }
            } finally {
<span class="fc" id="L2577">                partitionPath.trimTo(rootLen);</span>
            }
        }
<span class="fc" id="L2580">    }</span>

    private void bumpMasterRef() {
<span class="fc bfc" id="L2583" title="All 2 branches covered.">        if ((masterRef &amp; 1) == 0) {</span>
<span class="fc" id="L2584">            masterRef++;</span>
        } else {
<span class="fc" id="L2586">            cancelRowAndBump();</span>
        }
<span class="fc" id="L2588">    }</span>

    private void bumpStructureVersion() {
<span class="fc" id="L2591">        columnVersionWriter.commit();</span>
<span class="fc" id="L2592">        txWriter.setColumnVersion(columnVersionWriter.getVersion());</span>
<span class="fc" id="L2593">        txWriter.bumpStructureVersion(this.denseSymbolMapWriters);</span>
<span class="pc bpc" id="L2594" title="1 of 2 branches missed.">        assert txWriter.getStructureVersion() == metadata.getStructureVersion();</span>
<span class="fc" id="L2595">    }</span>

    private long calculateCommitInterval() {
<span class="fc" id="L2598">        long commitIntervalMicros = (long) (configuration.getO3MinLag() * commitIntervalFraction);</span>
<span class="fc bfc" id="L2599" title="All 2 branches covered.">        return commitIntervalMicros &gt; 0 ? commitIntervalMicros / 1000 : commitIntervalDefault;</span>
    }

    private void cancelRowAndBump() {
<span class="fc" id="L2603">        rowCancel();</span>
<span class="fc" id="L2604">        masterRef++;</span>
<span class="fc" id="L2605">    }</span>

    private void checkColumnName(CharSequence name) {
<span class="pc bpc" id="L2608" title="1 of 2 branches missed.">        if (!TableUtils.isValidColumnName(name, configuration.getMaxFileNameLength())) {</span>
<span class="nc" id="L2609">            throw CairoException.nonCritical().put(&quot;invalid column name [table=&quot;).put(tableToken.getTableName()).put(&quot;, column=&quot;).putAsPrintable(name).put(']');</span>
        }
<span class="fc" id="L2611">    }</span>

    private void checkDistressed() {
<span class="fc bfc" id="L2614" title="All 2 branches covered.">        if (!distressed) {</span>
<span class="fc" id="L2615">            return;</span>
        }
<span class="fc" id="L2617">        throw new CairoError(&quot;Table '&quot; + tableToken.getTableName() + &quot;' is distressed&quot;);</span>
    }

    private void clearO3() {
<span class="fc" id="L2621">        this.o3MasterRef = -1; // clears o3 flag, hasO3() will be returning false</span>
<span class="fc" id="L2622">        rowAction = ROW_ACTION_SWITCH_PARTITION;</span>
        // transaction log is either not required or pending
<span class="fc" id="L2624">        activeColumns = columns;</span>
<span class="fc" id="L2625">        activeNullSetters = nullSetters;</span>
<span class="fc" id="L2626">    }</span>

    private void clearTodoLog() {
        try {
<span class="fc" id="L2630">            todoMem.putLong(0, ++todoTxn); // write txn, reader will first read txn at offset 24 and then at offset 0</span>
<span class="fc" id="L2631">            Unsafe.getUnsafe().storeFence(); // make sure we do not write hash before writing txn (view from another thread)</span>
<span class="fc" id="L2632">            todoMem.putLong(8, 0); // write out our instance hashes</span>
<span class="fc" id="L2633">            todoMem.putLong(16, 0);</span>
<span class="fc" id="L2634">            Unsafe.getUnsafe().storeFence();</span>
<span class="fc" id="L2635">            todoMem.putLong(32, 0);</span>
<span class="fc" id="L2636">            Unsafe.getUnsafe().storeFence();</span>
<span class="fc" id="L2637">            todoMem.putLong(24, todoTxn);</span>
            // ensure file is closed with correct length
<span class="fc" id="L2639">            todoMem.jumpTo(40);</span>
        } finally {
<span class="fc" id="L2641">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L2643">    }</span>

    private void closeAppendMemoryTruncate(boolean truncate) {
<span class="fc bfc" id="L2646" title="All 2 branches covered.">        for (int i = 0, n = columns.size(); i &lt; n; i++) {</span>
<span class="fc" id="L2647">            MemoryMA m = columns.getQuick(i);</span>
<span class="fc bfc" id="L2648" title="All 2 branches covered.">            if (m != null) {</span>
<span class="fc" id="L2649">                m.close(truncate);</span>
            }
        }
<span class="fc" id="L2652">    }</span>

    private void closeWalColumns() {
<span class="fc bfc" id="L2655" title="All 2 branches covered.">        for (int col = 0, n = walMappedColumns.size(); col &lt; n; col++) {</span>
<span class="fc" id="L2656">            MemoryCMOR mappedColumnMem = walMappedColumns.getQuick(col);</span>
<span class="fc bfc" id="L2657" title="All 2 branches covered.">            if (mappedColumnMem != null) {</span>
<span class="fc" id="L2658">                Misc.free(mappedColumnMem);</span>
<span class="fc" id="L2659">                walColumnMemoryPool.push(mappedColumnMem);</span>
            }
        }
<span class="fc" id="L2662">    }</span>

    /**
     * Commits newly added rows of data. This method updates transaction file with pointers to end of appended data.
     * &lt;p&gt;
     * &lt;b&gt;Pending rows&lt;/b&gt;
     * &lt;p&gt;This method will cancel pending rows by calling {@link #rowCancel()}. Data in partially appended row will be lost.&lt;/p&gt;
     *
     * @param commitMode commit durability mode.
     * @param o3MaxLag   if &gt; 0 then do a partial commit, leaving the rows within the lag in a new uncommitted transaction
     * @return commit transaction number or -1 if there was nothing to commit
     */
    private long commit(int commitMode, long o3MaxLag) {
<span class="fc" id="L2675">        checkDistressed();</span>
<span class="fc" id="L2676">        physicallyWrittenRowsSinceLastCommit.set(0);</span>

<span class="pc bpc" id="L2678" title="1 of 2 branches missed.">        if (o3InError) {</span>
<span class="nc" id="L2679">            rollback();</span>
<span class="nc" id="L2680">            return TableSequencer.NO_TXN;</span>
        }

<span class="fc bfc" id="L2683" title="All 2 branches covered.">        if ((masterRef &amp; 1) != 0) {</span>
<span class="fc" id="L2684">            rowCancel();</span>
        }

<span class="fc bfc" id="L2687" title="All 2 branches covered.">        if (inTransaction()) {</span>
<span class="fc" id="L2688">            final boolean o3 = hasO3();</span>
<span class="fc bfc" id="L2689" title="All 2 branches covered.">            if (o3) {</span>
<span class="fc" id="L2690">                final boolean noop = o3Commit(o3MaxLag);</span>
<span class="fc bfc" id="L2691" title="All 2 branches covered.">                if (noop) {</span>
                    // Bookmark masterRef to track how many rows is in uncommitted state
<span class="fc" id="L2693">                    this.committedMasterRef = masterRef;</span>
<span class="fc" id="L2694">                    return getTxn();</span>
<span class="fc bfc" id="L2695" title="All 2 branches covered.">                } else if (o3MaxLag &gt; 0) {</span>
                    // It is possible that O3 commit will create partition just before
                    // the last one, leaving last partition row count 0 when doing ic().
                    // That's when the data from the last partition is moved to in-memory lag.
                    // One way to detect this is to check if index of the &quot;last&quot; partition is not
                    // last partition in the attached partition list.
<span class="fc bfc" id="L2701" title="All 2 branches covered.">                    if (txWriter.reconcileOptimisticPartitions()) {</span>
<span class="fc" id="L2702">                        this.lastPartitionTimestamp = txWriter.getLastPartitionTimestamp();</span>
<span class="fc" id="L2703">                        this.partitionTimestampHi = partitionCeilMethod.ceil(txWriter.getMaxTimestamp()) - 1;</span>
<span class="fc" id="L2704">                        openLastPartition();</span>
                    }
                }
<span class="fc bfc" id="L2707" title="All 2 branches covered.">            } else if (noOpRowCount &gt; 0) {</span>
<span class="fc" id="L2708">                LOG.critical()</span>
<span class="fc" id="L2709">                        .$(&quot;o3 ignoring write on read-only partition [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L2710">                        .$(&quot;, timestamp=&quot;).$ts(lastOpenPartitionTs)</span>
<span class="fc" id="L2711">                        .$(&quot;, numRows=&quot;).$(noOpRowCount)</span>
<span class="fc" id="L2712">                        .$();</span>
            }

<span class="fc bfc" id="L2715" title="All 2 branches covered.">            if (commitMode != CommitMode.NOSYNC) {</span>
<span class="fc" id="L2716">                syncColumns(commitMode);</span>
            }

<span class="fc" id="L2719">            final long committedRowCount = txWriter.unsafeCommittedFixedRowCount() + txWriter.unsafeCommittedTransientRowCount();</span>
<span class="fc" id="L2720">            final long rowsAdded = txWriter.getRowCount() - committedRowCount;</span>

<span class="fc" id="L2722">            updateIndexes();</span>
<span class="fc" id="L2723">            columnVersionWriter.commit();</span>
<span class="fc" id="L2724">            txWriter.setColumnVersion(columnVersionWriter.getVersion());</span>
<span class="fc" id="L2725">            txWriter.commit(commitMode, denseSymbolMapWriters);</span>

            // Bookmark masterRef to track how many rows is in uncommitted state
<span class="fc" id="L2728">            this.committedMasterRef = masterRef;</span>
<span class="fc" id="L2729">            processPartitionRemoveCandidates();</span>

<span class="fc" id="L2731">            metrics.tableWriter().incrementCommits();</span>
<span class="fc" id="L2732">            metrics.tableWriter().addCommittedRows(rowsAdded);</span>
<span class="fc bfc" id="L2733" title="All 2 branches covered.">            if (!o3) {</span>
                // If `o3`, the metric is tracked inside `o3Commit`, possibly async.
<span class="fc" id="L2735">                addPhysicallyWrittenRows(rowsAdded);</span>
            }

<span class="fc" id="L2738">            noOpRowCount = 0L;</span>
<span class="fc" id="L2739">            return getTxn();</span>
        }
<span class="fc" id="L2741">        return TableSequencer.NO_TXN;</span>
    }

    private void configureAppendPosition() {
<span class="fc" id="L2745">        final boolean partitioned = PartitionBy.isPartitioned(partitionBy);</span>
<span class="fc bfc" id="L2746" title="All 4 branches covered.">        if (this.txWriter.getMaxTimestamp() &gt; Long.MIN_VALUE || !partitioned) {</span>
<span class="fc" id="L2747">            openFirstPartition(this.txWriter.getMaxTimestamp());</span>
<span class="fc bfc" id="L2748" title="All 2 branches covered.">            if (partitioned) {</span>
<span class="fc" id="L2749">                partitionTimestampHi = partitionCeilMethod.ceil(txWriter.getMaxTimestamp()) - 1;</span>
<span class="fc" id="L2750">                rowAction = ROW_ACTION_OPEN_PARTITION;</span>
<span class="fc" id="L2751">                timestampSetter = appendTimestampSetter;</span>
            } else {
<span class="fc bfc" id="L2753" title="All 2 branches covered.">                if (metadata.getTimestampIndex() &lt; 0) {</span>
<span class="fc" id="L2754">                    rowAction = ROW_ACTION_NO_TIMESTAMP;</span>
                } else {
<span class="fc" id="L2756">                    rowAction = ROW_ACTION_NO_PARTITION;</span>
<span class="fc" id="L2757">                    timestampSetter = appendTimestampSetter;</span>
                }
            }
        } else {
<span class="fc" id="L2761">            rowAction = ROW_ACTION_OPEN_PARTITION;</span>
<span class="fc" id="L2762">            timestampSetter = appendTimestampSetter;</span>
        }
<span class="fc" id="L2764">        activeColumns = columns;</span>
<span class="fc" id="L2765">        activeNullSetters = nullSetters;</span>
<span class="fc" id="L2766">    }</span>

    private void configureColumn(int type, boolean indexFlag, int index) {
        final MemoryMA primary;
        final MemoryMA secondary;
        final MemoryCARW oooPrimary;
        final MemoryCARW oooSecondary;
        final MemoryCARW oooPrimary2;
        final MemoryCARW oooSecondary2;

<span class="fc bfc" id="L2776" title="All 2 branches covered.">        if (type &gt; 0) {</span>
<span class="fc" id="L2777">            primary = Vm.getMAInstance();</span>
<span class="fc" id="L2778">            oooPrimary = Vm.getCARWInstance(o3ColumnMemorySize, Integer.MAX_VALUE, MemoryTag.NATIVE_O3);</span>
<span class="fc" id="L2779">            oooPrimary2 = Vm.getCARWInstance(o3ColumnMemorySize, Integer.MAX_VALUE, MemoryTag.NATIVE_O3);</span>

<span class="fc bfc" id="L2781" title="All 2 branches covered.">            switch (ColumnType.tagOf(type)) {</span>
                case ColumnType.BINARY:
                case ColumnType.STRING:
<span class="fc" id="L2784">                    secondary = Vm.getMAInstance();</span>
<span class="fc" id="L2785">                    oooSecondary = Vm.getCARWInstance(o3ColumnMemorySize, Integer.MAX_VALUE, MemoryTag.NATIVE_O3);</span>
<span class="fc" id="L2786">                    oooSecondary2 = Vm.getCARWInstance(o3ColumnMemorySize, Integer.MAX_VALUE, MemoryTag.NATIVE_O3);</span>
<span class="fc" id="L2787">                    break;</span>
                default:
<span class="fc" id="L2789">                    secondary = null;</span>
<span class="fc" id="L2790">                    oooSecondary = null;</span>
<span class="fc" id="L2791">                    oooSecondary2 = null;</span>
<span class="fc" id="L2792">                    break;</span>
            }
        } else {
<span class="fc" id="L2795">            primary = secondary = NullMemory.INSTANCE;</span>
<span class="fc" id="L2796">            oooPrimary = oooSecondary = oooPrimary2 = oooSecondary2 = NullMemory.INSTANCE;</span>
        }

<span class="fc" id="L2799">        int baseIndex = getPrimaryColumnIndex(index);</span>
<span class="fc" id="L2800">        columns.extendAndSet(baseIndex, primary);</span>
<span class="fc" id="L2801">        columns.extendAndSet(baseIndex + 1, secondary);</span>
<span class="fc" id="L2802">        o3MemColumns.extendAndSet(baseIndex, oooPrimary);</span>
<span class="fc" id="L2803">        o3MemColumns.extendAndSet(baseIndex + 1, oooSecondary);</span>
<span class="fc" id="L2804">        o3MemColumns2.extendAndSet(baseIndex, oooPrimary2);</span>
<span class="fc" id="L2805">        o3MemColumns2.extendAndSet(baseIndex + 1, oooSecondary2);</span>
<span class="fc" id="L2806">        configureNullSetters(nullSetters, type, primary, secondary);</span>
<span class="fc" id="L2807">        configureNullSetters(o3NullSetters, type, oooPrimary, oooSecondary);</span>
<span class="fc" id="L2808">        configureNullSetters(o3NullSetters2, type, oooPrimary2, oooSecondary2);</span>

<span class="fc bfc" id="L2810" title="All 2 branches covered.">        if (indexFlag) {</span>
<span class="fc" id="L2811">            indexers.extendAndSet(index, new SymbolColumnIndexer());</span>
        }
<span class="fc" id="L2813">        rowValueIsNotNull.add(0);</span>
<span class="fc" id="L2814">    }</span>

    private void configureColumnMemory() {
<span class="fc" id="L2817">        this.symbolMapWriters.setPos(columnCount);</span>
<span class="fc bfc" id="L2818" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2819">            int type = metadata.getColumnType(i);</span>
<span class="fc" id="L2820">            configureColumn(type, metadata.isColumnIndexed(i), i);</span>

<span class="fc bfc" id="L2822" title="All 2 branches covered.">            if (ColumnType.isSymbol(type)) {</span>
<span class="fc" id="L2823">                final int symbolIndex = denseSymbolMapWriters.size();</span>
<span class="fc" id="L2824">                long columnNameTxn = columnVersionWriter.getDefaultColumnNameTxn(i);</span>
<span class="fc" id="L2825">                SymbolMapWriter symbolMapWriter = new SymbolMapWriter(</span>
                        configuration,
<span class="fc" id="L2827">                        path.trimTo(rootLen),</span>
<span class="fc" id="L2828">                        metadata.getColumnName(i),</span>
                        columnNameTxn,
<span class="fc" id="L2830">                        txWriter.unsafeReadSymbolTransientCount(symbolIndex),</span>
                        symbolIndex,
                        txWriter
                );

<span class="fc" id="L2835">                symbolMapWriters.extendAndSet(i, symbolMapWriter);</span>
<span class="fc" id="L2836">                denseSymbolMapWriters.add(symbolMapWriter);</span>
            }
        }
<span class="fc" id="L2839">        final int timestampIndex = metadata.getTimestampIndex();</span>
<span class="fc bfc" id="L2840" title="All 2 branches covered.">        if (timestampIndex != -1) {</span>
<span class="fc" id="L2841">            o3TimestampMem = o3MemColumns.getQuick(getPrimaryColumnIndex(timestampIndex));</span>
<span class="fc" id="L2842">            o3TimestampMemCpy = o3MemColumns2.getQuick(getPrimaryColumnIndex(timestampIndex));</span>
        }
<span class="fc" id="L2844">    }</span>

    private void configureTimestampSetter() {
<span class="fc" id="L2847">        int index = metadata.getTimestampIndex();</span>
<span class="fc bfc" id="L2848" title="All 2 branches covered.">        if (index == -1) {</span>
<span class="fc" id="L2849">            timestampSetter = value -&gt; {</span>
<span class="fc" id="L2850">            };</span>
        } else {
<span class="fc" id="L2852">            nullSetters.setQuick(index, NOOP);</span>
<span class="fc" id="L2853">            o3NullSetters.setQuick(index, NOOP);</span>
<span class="fc" id="L2854">            o3NullSetters2.setQuick(index, NOOP);</span>
<span class="fc" id="L2855">            timestampSetter = getPrimaryColumn(index)::putLong;</span>
        }
<span class="fc" id="L2857">    }</span>

    private int copyMetadataAndSetIndexAttrs(int columnIndex, int indexedFlag, int indexValueBlockSize) {
        try {
<span class="fc" id="L2861">            int index = openMetaSwapFile(ff, ddlMem, path, rootLen, configuration.getMaxSwapFileCount());</span>
<span class="fc" id="L2862">            int columnCount = metaMem.getInt(META_OFFSET_COUNT);</span>
<span class="fc" id="L2863">            ddlMem.putInt(columnCount);</span>
<span class="fc" id="L2864">            ddlMem.putInt(metaMem.getInt(META_OFFSET_PARTITION_BY));</span>
<span class="fc" id="L2865">            ddlMem.putInt(metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX));</span>
<span class="fc" id="L2866">            copyVersionAndLagValues();</span>
<span class="fc" id="L2867">            ddlMem.jumpTo(META_OFFSET_COLUMN_TYPES);</span>
<span class="fc bfc" id="L2868" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L2869" title="All 2 branches covered.">                if (i != columnIndex) {</span>
<span class="fc" id="L2870">                    writeColumnEntry(i, false);</span>
                } else {
<span class="fc" id="L2872">                    ddlMem.putInt(getColumnType(metaMem, i));</span>
<span class="fc" id="L2873">                    long flags = indexedFlag;</span>
<span class="pc bpc" id="L2874" title="1 of 2 branches missed.">                    if (isSequential(metaMem, i)) {</span>
<span class="nc" id="L2875">                        flags |= META_FLAG_BIT_SEQUENTIAL;</span>
                    }
<span class="fc" id="L2877">                    ddlMem.putLong(flags);</span>
<span class="fc" id="L2878">                    ddlMem.putInt(indexValueBlockSize);</span>
<span class="fc" id="L2879">                    ddlMem.skip(16);</span>
                }
            }

<span class="fc" id="L2883">            long nameOffset = getColumnNameOffset(columnCount);</span>
<span class="fc bfc" id="L2884" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2885">                CharSequence columnName = metaMem.getStr(nameOffset);</span>
<span class="fc" id="L2886">                ddlMem.putStr(columnName);</span>
<span class="fc" id="L2887">                nameOffset += Vm.getStorageLength(columnName);</span>
            }
<span class="fc" id="L2889">            return index;</span>
        } finally {
<span class="fc" id="L2891">            ddlMem.close();</span>
        }
    }

    private long copyMetadataAndUpdateVersion() {
        try {
<span class="fc" id="L2897">            int index = openMetaSwapFile(ff, ddlMem, path, rootLen, configuration.getMaxSwapFileCount());</span>
<span class="fc" id="L2898">            int columnCount = metaMem.getInt(META_OFFSET_COUNT);</span>

<span class="fc" id="L2900">            ddlMem.putInt(columnCount);</span>
<span class="fc" id="L2901">            ddlMem.putInt(metaMem.getInt(META_OFFSET_PARTITION_BY));</span>
<span class="fc" id="L2902">            ddlMem.putInt(metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX));</span>
<span class="fc" id="L2903">            copyVersionAndLagValues();</span>
<span class="fc" id="L2904">            ddlMem.jumpTo(META_OFFSET_COLUMN_TYPES);</span>
<span class="fc bfc" id="L2905" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2906">                writeColumnEntry(i, false);</span>
            }

<span class="fc" id="L2909">            long nameOffset = getColumnNameOffset(columnCount);</span>
<span class="fc bfc" id="L2910" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L2911">                CharSequence columnName = metaMem.getStr(nameOffset);</span>
<span class="fc" id="L2912">                ddlMem.putStr(columnName);</span>
<span class="fc" id="L2913">                nameOffset += Vm.getStorageLength(columnName);</span>
            }
<span class="fc" id="L2915">            this.metaSwapIndex = index;</span>
<span class="fc" id="L2916">            return nameOffset;</span>
        } finally {
<span class="fc" id="L2918">            ddlMem.close();</span>
        }
    }

    private int copyOverwrite(Path to) {
<span class="fc" id="L2923">        int res = ff.copy(other, to);</span>
<span class="pc bpc" id="L2924" title="5 of 6 branches missed.">        if (Os.isWindows() &amp;&amp; res == -1 &amp;&amp; ff.errno() == Files.WINDOWS_ERROR_FILE_EXISTS) {</span>
            // Windows throws an error the destination file already exists, other platforms do not
<span class="nc bnc" id="L2926" title="All 2 branches missed.">            if (!ff.remove(to)) {</span>
                // If file is open, return here so that errno is 5 in the error message
<span class="nc" id="L2928">                return -1;</span>
            }
<span class="nc" id="L2930">            return ff.copy(other, to);</span>
        }
<span class="fc" id="L2932">        return res;</span>
    }

    private void copyVersionAndLagValues() {
<span class="fc" id="L2936">        ddlMem.putInt(ColumnType.VERSION);</span>
<span class="fc" id="L2937">        ddlMem.putInt(metaMem.getInt(META_OFFSET_TABLE_ID));</span>
<span class="fc" id="L2938">        ddlMem.putInt(metaMem.getInt(META_OFFSET_MAX_UNCOMMITTED_ROWS));</span>
<span class="fc" id="L2939">        ddlMem.putLong(metaMem.getLong(META_OFFSET_O3_MAX_LAG));</span>
<span class="fc" id="L2940">        ddlMem.putLong(txWriter.getStructureVersion() + 1);</span>
<span class="fc" id="L2941">        ddlMem.putBool(metaMem.getBool(META_OFFSET_WAL_ENABLED));</span>
<span class="fc" id="L2942">        metadata.setStructureVersion(txWriter.getStructureVersion() + 1);</span>
<span class="fc" id="L2943">    }</span>

    /**
     * Creates bitmap index files for a column. This method uses primary column instance as temporary tool to
     * append index data. Therefore, it must be called before primary column is initialized.
     *
     * @param columnName              column name
     * @param indexValueBlockCapacity approximate number of values per index key
     * @param plen                    path length. This is used to trim shared path object to.
     */
    private void createIndexFiles(CharSequence columnName, long columnNameTxn, int indexValueBlockCapacity, int plen, boolean force) {
        try {
<span class="fc" id="L2955">            keyFileName(path.trimTo(plen), columnName, columnNameTxn);</span>

<span class="fc bfc" id="L2957" title="All 4 branches covered.">            if (!force &amp;&amp; ff.exists(path)) {</span>
<span class="fc" id="L2958">                return;</span>
            }

            // reuse memory column object to create index and close it at the end
            try {
<span class="fc" id="L2963">                ddlMem.smallFile(ff, path, MemoryTag.MMAP_TABLE_WRITER);</span>
<span class="fc" id="L2964">                BitmapIndexWriter.initKeyMemory(ddlMem, indexValueBlockCapacity);</span>
<span class="fc" id="L2965">            } catch (CairoException e) {</span>
                // looks like we could not create key file properly
                // lets not leave half-baked file sitting around
<span class="fc" id="L2968">                LOG.error()</span>
<span class="fc" id="L2969">                        .$(&quot;could not create index [name=&quot;).utf8(path)</span>
<span class="fc" id="L2970">                        .$(&quot;, errno=&quot;).$(e.getErrno())</span>
<span class="fc" id="L2971">                        .I$();</span>
<span class="pc bpc" id="L2972" title="1 of 2 branches missed.">                if (!ff.remove(path)) {</span>
<span class="fc" id="L2973">                    LOG.critical()</span>
<span class="fc" id="L2974">                            .$(&quot;could not remove '&quot;).utf8(path).$(&quot;'. Please remove MANUALLY.&quot;)</span>
<span class="fc" id="L2975">                            .$(&quot;[errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L2976">                            .I$();</span>
                }
<span class="fc" id="L2978">                throw e;</span>
            } finally {
<span class="fc" id="L2980">                ddlMem.close();</span>
            }
<span class="fc bfc" id="L2982" title="All 2 branches covered.">            if (!ff.touch(valueFileName(path.trimTo(plen), columnName, columnNameTxn))) {</span>
<span class="fc" id="L2983">                LOG.error().$(&quot;could not create index [name=&quot;).$(path)</span>
<span class="fc" id="L2984">                        .$(&quot;, errno=&quot;).$(ff.errno())</span>
<span class="fc" id="L2985">                        .I$();</span>
<span class="fc" id="L2986">                throw CairoException.critical(ff.errno()).put(&quot;could not create index [name=&quot;).put(path).put(']');</span>
            }
        } finally {
<span class="fc" id="L2989">            path.trimTo(plen);</span>
        }
<span class="fc" id="L2991">    }</span>

    private void createSymbolMapWriter(CharSequence name, long columnNameTxn, int symbolCapacity, boolean symbolCacheFlag) {
<span class="fc" id="L2994">        MapWriter.createSymbolMapFiles(ff, ddlMem, path, name, columnNameTxn, symbolCapacity, symbolCacheFlag);</span>
<span class="fc" id="L2995">        SymbolMapWriter w = new SymbolMapWriter(</span>
                configuration,
                path,
                name,
                columnNameTxn,
                0,
<span class="fc" id="L3001">                denseSymbolMapWriters.size(),</span>
                txWriter
        );
<span class="fc" id="L3004">        denseSymbolMapWriters.add(w);</span>
<span class="fc" id="L3005">        symbolMapWriters.extendAndSet(columnCount, w);</span>
<span class="fc" id="L3006">    }</span>

    private boolean createWalSymbolMapping(SymbolMapDiff symbolMapDiff, int columnIndex, IntList symbolMap) {
<span class="fc" id="L3009">        final int cleanSymbolCount = symbolMapDiff.getCleanSymbolCount();</span>
<span class="fc" id="L3010">        symbolMap.setPos(symbolMapDiff.getSize());</span>

        // This is defensive. It validates that all the symbols used in WAL are set in SymbolMapDiff
<span class="fc" id="L3013">        symbolMap.setAll(symbolMapDiff.getSize(), -1);</span>
<span class="fc" id="L3014">        final MapWriter mapWriter = symbolMapWriters.get(columnIndex);</span>
<span class="fc" id="L3015">        boolean identical = true;</span>

<span class="fc bfc" id="L3017" title="All 2 branches covered.">        if (symbolMapDiff.hasNullValue()) {</span>
<span class="fc" id="L3018">            mapWriter.updateNullFlag(true);</span>
        }

        SymbolMapDiffEntry entry;
<span class="fc bfc" id="L3022" title="All 2 branches covered.">        while ((entry = symbolMapDiff.nextEntry()) != null) {</span>
<span class="fc" id="L3023">            final CharSequence symbolValue = entry.getSymbol();</span>
<span class="fc" id="L3024">            final int newKey = mapWriter.put(symbolValue);</span>
<span class="fc bfc" id="L3025" title="All 2 branches covered.">            identical &amp;= newKey == entry.getKey();</span>
<span class="fc" id="L3026">            symbolMap.setQuick(entry.getKey() - cleanSymbolCount, newKey);</span>
<span class="fc" id="L3027">        }</span>
<span class="fc" id="L3028">        return identical;</span>
    }

    private void doClose(boolean truncate) {
        // destroy() may already closed everything
<span class="fc" id="L3033">        boolean tx = inTransaction();</span>
<span class="fc" id="L3034">        freeSymbolMapWriters();</span>
<span class="fc" id="L3035">        freeIndexers();</span>
<span class="fc" id="L3036">        Misc.free(txWriter);</span>
<span class="fc" id="L3037">        Misc.free(metaMem);</span>
<span class="fc" id="L3038">        Misc.free(ddlMem);</span>
<span class="fc" id="L3039">        Misc.free(indexMem);</span>
<span class="fc" id="L3040">        Misc.free(other);</span>
<span class="fc" id="L3041">        Misc.free(todoMem);</span>
<span class="fc" id="L3042">        Misc.free(attachMetaMem);</span>
<span class="fc" id="L3043">        Misc.free(attachColumnVersionReader);</span>
<span class="fc" id="L3044">        Misc.free(attachIndexBuilder);</span>
<span class="fc" id="L3045">        Misc.free(columnVersionWriter);</span>
<span class="fc" id="L3046">        Misc.free(o3ColumnTopSink);</span>
<span class="fc" id="L3047">        Misc.free(o3PartitionUpdateSink);</span>
<span class="fc" id="L3048">        Misc.free(slaveTxReader);</span>
<span class="fc" id="L3049">        Misc.free(commandQueue);</span>
<span class="fc" id="L3050">        updateOperatorImpl = Misc.free(updateOperatorImpl);</span>
<span class="fc" id="L3051">        dropIndexOperator = null;</span>
<span class="fc" id="L3052">        noOpRowCount = 0L;</span>
<span class="fc" id="L3053">        lastOpenPartitionTs = -1L;</span>
<span class="fc" id="L3054">        lastOpenPartitionIsReadOnly = false;</span>
<span class="fc bfc" id="L3055" title="All 2 branches covered.">        freeColumns(truncate &amp; !distressed);</span>
        try {
<span class="fc bfc" id="L3057" title="All 2 branches covered.">            releaseLock(!truncate | tx | performRecovery | distressed);</span>
        } finally {
<span class="fc" id="L3059">            Misc.free(txnScoreboard);</span>
<span class="fc" id="L3060">            Misc.free(path);</span>
<span class="fc" id="L3061">            Misc.free(o3TimestampMem);</span>
<span class="fc" id="L3062">            Misc.free(o3TimestampMemCpy);</span>
<span class="fc" id="L3063">            Misc.free(ownMessageBus);</span>
<span class="pc bpc" id="L3064" title="1 of 2 branches missed.">            if (tempMem16b != 0) {</span>
<span class="fc" id="L3065">                Unsafe.free(tempMem16b, 16, MemoryTag.NATIVE_TABLE_WRITER);</span>
<span class="fc" id="L3066">                tempMem16b = 0;</span>
            }
<span class="fc" id="L3068">            LOG.info().$(&quot;closed '&quot;).utf8(tableToken.getTableName()).$('\'').$();</span>
        }
<span class="fc" id="L3070">    }</span>

    private void finishMetaSwapUpdate() {

        // rename _meta to _meta.prev
<span class="fc" id="L3075">        this.metaPrevIndex = rename(fileOperationRetryCount);</span>
<span class="fc" id="L3076">        writeRestoreMetaTodo();</span>

        try {
            // rename _meta.swp to -_meta
<span class="fc" id="L3080">            restoreMetaFrom(META_SWAP_FILE_NAME, metaSwapIndex);</span>
<span class="fc" id="L3081">        } catch (CairoException e) {</span>
            try {
<span class="fc" id="L3083">                recoverFromTodoWriteFailure(null);</span>
<span class="fc" id="L3084">            } catch (CairoException e2) {</span>
<span class="nc" id="L3085">                throwDistressException(e2);</span>
<span class="fc" id="L3086">            }</span>
<span class="fc" id="L3087">            throw e;</span>
<span class="fc" id="L3088">        }</span>

        try {
            // open _meta file
<span class="fc" id="L3092">            openMetaFile(ff, path, rootLen, metaMem);</span>
<span class="fc" id="L3093">        } catch (CairoException e) {</span>
<span class="nc" id="L3094">            throwDistressException(e);</span>
<span class="fc" id="L3095">        }</span>

<span class="fc" id="L3097">        bumpStructureVersion();</span>
<span class="fc" id="L3098">        metadata.setTableVersion();</span>
<span class="fc" id="L3099">    }</span>

    private void finishO3Append(long o3LagRowCount) {
<span class="fc bfc" id="L3102" title="All 2 branches covered.">        if (denseIndexers.size() == 0) {</span>
<span class="fc" id="L3103">            populateDenseIndexerList();</span>
        }
<span class="fc" id="L3105">        path.trimTo(rootLen);</span>
        // Alright, we finished updating partitions. Now we need to get this writer instance into
        // a consistent state.
        //
        // We start with ensuring append memory is in ready-to-use state. When max timestamp changes we need to
        // move append memory to new set of files. Otherwise, we stay on the same set but advance to append position.
<span class="fc bfc" id="L3111" title="All 2 branches covered.">        avoidIndexOnCommit = o3ErrorCount.get() == 0;</span>
<span class="fc bfc" id="L3112" title="All 2 branches covered.">        if (o3LagRowCount == 0) {</span>
<span class="fc" id="L3113">            clearO3();</span>
<span class="fc" id="L3114">            LOG.debug().$(&quot;lag segment is empty&quot;).$();</span>
        } else {
            // adjust O3 master ref so that virtual row count becomes equal to value of &quot;o3LagRowCount&quot;
<span class="fc" id="L3117">            this.o3MasterRef = this.masterRef - o3LagRowCount * 2 + 1;</span>
<span class="fc" id="L3118">            LOG.debug().$(&quot;adjusted [o3RowCount=&quot;).$(getO3RowCount0()).I$();</span>
        }
<span class="fc" id="L3120">    }</span>

    private void finishO3Commit(long partitionTimestampHiLimit) {
<span class="pc bpc" id="L3123" title="1 of 2 branches missed.">        if (!o3InError) {</span>
<span class="fc" id="L3124">            updateO3ColumnTops();</span>
        }
<span class="fc bfc" id="L3126" title="All 4 branches covered.">        if (!isLastPartitionColumnsOpen() || partitionTimestampHi &gt; partitionTimestampHiLimit) {</span>
<span class="fc" id="L3127">            openPartition(txWriter.getMaxTimestamp());</span>
        }

        // Data is written out successfully, however, we can still fail to set append position, for
        // example when we ran out of address space and new page cannot be mapped. The &quot;allocate&quot; calls here
        // ensure we can trigger this situation in tests. We should perhaps align our data such that setAppendPosition()
        // will attempt to mmap new page and fail... Then we can remove the 'true' parameter
        try {
<span class="fc" id="L3135">            setAppendPosition(txWriter.getTransientRowCount(), true);</span>
<span class="fc" id="L3136">        } catch (Throwable e) {</span>
<span class="fc" id="L3137">            LOG.critical().$(&quot;data is committed but writer failed to update its state `&quot;).$(e).$('`').$();</span>
<span class="fc" id="L3138">            distressed = true;</span>
<span class="fc" id="L3139">            throw e;</span>
<span class="fc" id="L3140">        }</span>

<span class="fc" id="L3142">        metrics.tableWriter().incrementO3Commits();</span>
<span class="fc" id="L3143">    }</span>

    private void freeAndRemoveColumnPair(ObjList&lt;MemoryMA&gt; columns, int pi, int si) {
<span class="fc" id="L3146">        Misc.free(columns.getAndSetQuick(pi, NullMemory.INSTANCE));</span>
<span class="fc" id="L3147">        Misc.free(columns.getAndSetQuick(si, NullMemory.INSTANCE));</span>
<span class="fc" id="L3148">    }</span>

    private void freeAndRemoveO3ColumnPair(ObjList&lt;MemoryCARW&gt; columns, int pi, int si) {
<span class="fc" id="L3151">        Misc.free(columns.getAndSetQuick(pi, NullMemory.INSTANCE));</span>
<span class="fc" id="L3152">        Misc.free(columns.getAndSetQuick(si, NullMemory.INSTANCE));</span>
<span class="fc" id="L3153">    }</span>

    private void freeColumns(boolean truncate) {
        // null check is because this method could be called from the constructor
<span class="fc bfc" id="L3157" title="All 2 branches covered.">        if (columns != null) {</span>
<span class="fc" id="L3158">            closeAppendMemoryTruncate(truncate);</span>
        }
<span class="fc" id="L3160">        Misc.freeObjListAndKeepObjects(o3MemColumns);</span>
<span class="fc" id="L3161">        Misc.freeObjListAndKeepObjects(o3MemColumns2);</span>
<span class="fc" id="L3162">    }</span>

    private void freeIndexers() {
<span class="fc bfc" id="L3165" title="All 2 branches covered.">        if (indexers != null) {</span>
            // Don't change items of indexers, they are re-used
<span class="fc bfc" id="L3167" title="All 2 branches covered.">            for (int i = 0, n = indexers.size(); i &lt; n; i++) {</span>
<span class="fc" id="L3168">                Misc.free(indexers.getQuick(i));</span>
            }
<span class="fc" id="L3170">            denseIndexers.clear();</span>
        }
<span class="fc" id="L3172">    }</span>

    private void freeNullSetter(ObjList&lt;Runnable&gt; nullSetters, int columnIndex) {
<span class="fc" id="L3175">        nullSetters.setQuick(columnIndex, NOOP);</span>
<span class="fc" id="L3176">    }</span>

    private void freeSymbolMapWriters() {
<span class="fc bfc" id="L3179" title="All 2 branches covered.">        if (denseSymbolMapWriters != null) {</span>
<span class="fc bfc" id="L3180" title="All 2 branches covered.">            for (int i = 0, n = denseSymbolMapWriters.size(); i &lt; n; i++) {</span>
<span class="fc" id="L3181">                Misc.freeIfCloseable(denseSymbolMapWriters.getQuick(i));</span>
            }
<span class="fc" id="L3183">            denseSymbolMapWriters.clear();</span>
        }

<span class="fc bfc" id="L3186" title="All 2 branches covered.">        if (symbolMapWriters != null) {</span>
<span class="fc" id="L3187">            symbolMapWriters.clear();</span>
        }
<span class="fc" id="L3189">    }</span>

    private long getO3RowCount0() {
<span class="fc" id="L3192">        return (masterRef - o3MasterRef + 1) / 2;</span>
    }

    private long getPartitionLo(long timestamp) {
<span class="fc" id="L3196">        return partitionFloorMethod.floor(timestamp);</span>
    }

    private MemoryMA getPrimaryColumn(int column) {
<span class="pc bpc" id="L3200" title="1 of 2 branches missed.">        assert column &lt; columnCount : &quot;Column index is out of bounds: &quot; + column + &quot; &gt;= &quot; + columnCount;</span>
<span class="fc" id="L3201">        return columns.getQuick(getPrimaryColumnIndex(column));</span>
    }

    private MemoryMA getSecondaryColumn(int column) {
<span class="pc bpc" id="L3205" title="1 of 2 branches missed.">        assert column &lt; columnCount : &quot;Column index is out of bounds: &quot; + column + &quot; &gt;= &quot; + columnCount;</span>
<span class="fc" id="L3206">        return columns.getQuick(getSecondaryColumnIndex(column));</span>
    }

    private void indexHistoricPartitions(SymbolColumnIndexer indexer, CharSequence columnName, int indexValueBlockSize) {
<span class="fc" id="L3210">        long ts = this.txWriter.getMaxTimestamp();</span>
<span class="fc bfc" id="L3211" title="All 2 branches covered.">        if (ts &gt; Numbers.LONG_NaN) {</span>
<span class="fc" id="L3212">            final int columnIndex = metadata.getColumnIndex(columnName);</span>
<span class="fc" id="L3213">            try (final MemoryMR roMem = indexMem) {</span>
                // Index last partition separately
<span class="fc bfc" id="L3215" title="All 2 branches covered.">                for (int i = 0, n = txWriter.getPartitionCount() - 1; i &lt; n; i++) {</span>

<span class="fc" id="L3217">                    long timestamp = txWriter.getPartitionTimestamp(i);</span>
<span class="fc" id="L3218">                    path.trimTo(rootLen);</span>
<span class="fc" id="L3219">                    setStateForTimestamp(path, timestamp, false);</span>

<span class="pc bpc" id="L3221" title="1 of 2 branches missed.">                    if (ff.exists(path.$())) {</span>
<span class="fc" id="L3222">                        final int plen = path.length();</span>

<span class="fc" id="L3224">                        long columnNameTxn = columnVersionWriter.getColumnNameTxn(timestamp, columnIndex);</span>
<span class="fc" id="L3225">                        TableUtils.dFile(path.trimTo(plen), columnName, columnNameTxn);</span>

<span class="fc bfc" id="L3227" title="All 2 branches covered.">                        if (ff.exists(path)) {</span>

<span class="fc" id="L3229">                            path.trimTo(plen);</span>
<span class="fc" id="L3230">                            LOG.info().$(&quot;indexing [path=&quot;).$(path).I$();</span>

<span class="fc" id="L3232">                            createIndexFiles(columnName, columnNameTxn, indexValueBlockSize, plen, true);</span>
<span class="fc" id="L3233">                            final long partitionSize = txWriter.getPartitionSizeByPartitionTimestamp(timestamp);</span>
<span class="fc" id="L3234">                            final long columnTop = columnVersionWriter.getColumnTop(timestamp, columnIndex);</span>

<span class="pc bpc" id="L3236" title="1 of 4 branches missed.">                            if (columnTop &gt; -1L &amp;&amp; partitionSize &gt; columnTop) {</span>
<span class="fc" id="L3237">                                TableUtils.dFile(path.trimTo(plen), columnName, columnNameTxn);</span>
<span class="fc" id="L3238">                                final long columnSize = (partitionSize - columnTop) &lt;&lt; ColumnType.pow2SizeOf(ColumnType.INT);</span>
<span class="fc" id="L3239">                                roMem.of(ff, path, columnSize, columnSize, MemoryTag.MMAP_TABLE_WRITER);</span>
<span class="fc" id="L3240">                                indexer.configureWriter(configuration, path.trimTo(plen), columnName, columnNameTxn, columnTop);</span>
<span class="fc" id="L3241">                                indexer.index(roMem, columnTop, partitionSize);</span>
                            }
                        }
                    }
                }
            } finally {
<span class="fc" id="L3247">                Misc.free(indexer);</span>
            }
        }
<span class="fc" id="L3250">    }</span>

    private void indexLastPartition(SymbolColumnIndexer indexer, CharSequence columnName, long columnNameTxn, int columnIndex, int indexValueBlockSize) {
<span class="fc" id="L3253">        final int plen = path.length();</span>

<span class="fc" id="L3255">        createIndexFiles(columnName, columnNameTxn, indexValueBlockSize, plen, true);</span>

<span class="fc" id="L3257">        final long lastPartitionTs = txWriter.getLastPartitionTimestamp();</span>
<span class="fc" id="L3258">        final long columnTop = columnVersionWriter.getColumnTopQuick(lastPartitionTs, columnIndex);</span>

        // set indexer up to continue functioning as normal
<span class="fc" id="L3261">        indexer.configureFollowerAndWriter(configuration, path.trimTo(plen), columnName, columnNameTxn, getPrimaryColumn(columnIndex), columnTop);</span>
<span class="fc" id="L3262">        indexer.refreshSourceAndIndex(0, txWriter.getTransientRowCount());</span>
<span class="fc" id="L3263">    }</span>

    private boolean isLastPartitionColumnsOpen() {
<span class="pc bpc" id="L3266" title="1 of 2 branches missed.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L3267" title="All 2 branches covered.">            if (metadata.getColumnType(i) &gt; 0) {</span>
<span class="fc" id="L3268">                return columns.getQuick(getPrimaryColumnIndex(i)).isOpen();</span>
            }
        }
        // No columns, doesn't matter
<span class="nc" id="L3272">        return true;</span>
    }

    private void lock() {
        try {
<span class="fc" id="L3277">            path.trimTo(rootLen);</span>
<span class="fc" id="L3278">            lockName(path);</span>
<span class="fc" id="L3279">            performRecovery = ff.exists(path);</span>
<span class="fc" id="L3280">            this.lockFd = TableUtils.lock(ff, path);</span>
        } finally {
<span class="fc" id="L3282">            path.trimTo(rootLen);</span>
        }

<span class="fc bfc" id="L3285" title="All 2 branches covered.">        if (this.lockFd == -1) {</span>
<span class="fc" id="L3286">            throw CairoException.critical(ff.errno()).put(&quot;Cannot lock table: &quot;).put(path.$());</span>
        }
<span class="fc" id="L3288">    }</span>

    private void mmapWalColumns(@Transient Path walPath, int timestampIndex, long rowLo, long rowHi) {
<span class="fc" id="L3291">        walMappedColumns.clear();</span>
<span class="fc" id="L3292">        int walPathLen = walPath.length();</span>
<span class="fc" id="L3293">        final int columnCount = metadata.getColumnCount();</span>

        try {
<span class="fc bfc" id="L3296" title="All 2 branches covered.">            for (int columnIndex = 0; columnIndex &lt; columnCount; columnIndex++) {</span>
<span class="fc" id="L3297">                int type = metadata.getColumnType(columnIndex);</span>
<span class="fc" id="L3298">                o3RowCount = rowHi - rowLo;</span>
<span class="fc bfc" id="L3299" title="All 2 branches covered.">                if (type &gt; 0) {</span>
<span class="fc" id="L3300">                    int sizeBitsPow2 = ColumnType.pow2SizeOf(type);</span>
<span class="fc bfc" id="L3301" title="All 2 branches covered.">                    if (columnIndex == timestampIndex) {</span>
<span class="fc" id="L3302">                        sizeBitsPow2 += 1;</span>
                    }

<span class="fc bfc" id="L3305" title="All 2 branches covered.">                    if (!ColumnType.isVariableLength(type)) {</span>
<span class="fc" id="L3306">                        MemoryCMOR primary = walColumnMemoryPool.pop();</span>

<span class="fc" id="L3308">                        dFile(walPath, metadata.getColumnName(columnIndex), -1L);</span>
<span class="fc" id="L3309">                        primary.ofOffset(</span>
<span class="fc" id="L3310">                                configuration.getFilesFacade(),</span>
                                walPath,
                                rowLo &lt;&lt; sizeBitsPow2,
                                rowHi &lt;&lt; sizeBitsPow2,
                                MemoryTag.MMAP_TABLE_WRITER,
                                CairoConfiguration.O_NONE
                        );
<span class="fc" id="L3317">                        walPath.trimTo(walPathLen);</span>

<span class="fc" id="L3319">                        walMappedColumns.add(primary);</span>
<span class="fc" id="L3320">                        walMappedColumns.add(null);</span>
<span class="fc" id="L3321">                    } else {</span>
<span class="fc" id="L3322">                        sizeBitsPow2 = 3;</span>
<span class="fc" id="L3323">                        MemoryCMOR fixed = walColumnMemoryPool.pop();</span>
<span class="fc" id="L3324">                        MemoryCMOR var = walColumnMemoryPool.pop();</span>

<span class="fc" id="L3326">                        iFile(walPath, metadata.getColumnName(columnIndex), -1L);</span>
<span class="fc" id="L3327">                        fixed.ofOffset(</span>
<span class="fc" id="L3328">                                configuration.getFilesFacade(),</span>
                                walPath,
                                rowLo &lt;&lt; sizeBitsPow2,
                                (rowHi + 1) &lt;&lt; sizeBitsPow2,
                                MemoryTag.MMAP_TABLE_WRITER,
                                CairoConfiguration.O_NONE
                        );
<span class="fc" id="L3335">                        walPath.trimTo(walPathLen);</span>

<span class="fc" id="L3337">                        long varOffset = fixed.getLong(rowLo &lt;&lt; sizeBitsPow2);</span>
<span class="fc" id="L3338">                        long varLen = fixed.getLong(rowHi &lt;&lt; sizeBitsPow2) - varOffset;</span>
<span class="fc" id="L3339">                        dFile(walPath, metadata.getColumnName(columnIndex), -1L);</span>
<span class="fc" id="L3340">                        var.ofOffset(</span>
<span class="fc" id="L3341">                                configuration.getFilesFacade(),</span>
                                walPath,
                                varOffset,
                                varOffset + varLen,
                                MemoryTag.MMAP_TABLE_WRITER,
                                CairoConfiguration.O_NONE
                        );
<span class="fc" id="L3348">                        walPath.trimTo(walPathLen);</span>

<span class="fc" id="L3350">                        walMappedColumns.add(var);</span>
<span class="fc" id="L3351">                        walMappedColumns.add(fixed);</span>
                    }
<span class="fc" id="L3353">                } else {</span>
<span class="fc" id="L3354">                    walMappedColumns.add(null);</span>
<span class="fc" id="L3355">                    walMappedColumns.add(null);</span>
                }
            }
<span class="fc" id="L3358">            o3Columns = walMappedColumns;</span>
<span class="nc" id="L3359">        } catch (Throwable th) {</span>
<span class="nc" id="L3360">            closeWalColumns();</span>
<span class="nc" id="L3361">            throw th;</span>
<span class="fc" id="L3362">        }</span>
<span class="fc" id="L3363">    }</span>

    private Row newRowO3(long timestamp) {
<span class="fc" id="L3366">        LOG.info().$(&quot;switched to o3 [table=&quot;).utf8(tableToken.getTableName()).I$();</span>
<span class="fc" id="L3367">        txWriter.beginPartitionSizeUpdate();</span>
<span class="fc" id="L3368">        o3OpenColumns();</span>
<span class="fc" id="L3369">        o3InError = false;</span>
<span class="fc" id="L3370">        o3MasterRef = masterRef;</span>
<span class="fc" id="L3371">        rowAction = ROW_ACTION_O3;</span>
<span class="fc" id="L3372">        o3TimestampSetter(timestamp);</span>
<span class="fc" id="L3373">        return row;</span>
    }

    /**
     * Commits O3 data. Lag is optional. When 0 is specified the entire O3 segment is committed.
     *
     * @param o3MaxLag interval in microseconds that determines the length of O3 segment that is not going to be
     *                 committed to disk. The interval starts at max timestamp of O3 segment and ends &lt;i&gt;o3MaxLag&lt;/i&gt;
     *                 microseconds before this timestamp.
     * @return &lt;i&gt;true&lt;/i&gt; when commit has is a NOOP, e.g. no data has been committed to disk. &lt;i&gt;false&lt;/i&gt; otherwise.
     */
    private boolean o3Commit(long o3MaxLag) {
<span class="fc" id="L3385">        o3RowCount = getO3RowCount0();</span>

<span class="fc" id="L3387">        long o3LagRowCount = 0;</span>
<span class="fc" id="L3388">        long maxUncommittedRows = metadata.getMaxUncommittedRows();</span>
<span class="fc" id="L3389">        final int timestampIndex = metadata.getTimestampIndex();</span>
<span class="fc" id="L3390">        lastPartitionTimestamp = partitionFloorMethod.floor(partitionTimestampHi);</span>
        // we will check new partitionTimestampHi value against the limit to see if the writer
        // will have to switch partition internally
<span class="fc" id="L3393">        long partitionTimestampHiLimit = partitionCeilMethod.ceil(partitionTimestampHi) - 1;</span>
        try {
<span class="fc" id="L3395">            o3RowCount += o3MoveUncommitted(timestampIndex);</span>

            // we may need to re-use file descriptors when this partition is the &quot;current&quot; one
            // we cannot open file again due to sharing violation
            //
            // to determine that 'ooTimestampLo' goes into current partition
            // we need to compare 'partitionTimestampHi', which is appropriately truncated to DAY/MONTH/YEAR
            // to this.maxTimestamp, which isn't truncated yet. So we need to truncate it first
<span class="fc" id="L3403">            LOG.debug().$(&quot;sorting o3 [table=&quot;).utf8(tableToken.getTableName()).I$();</span>
<span class="fc" id="L3404">            final long sortedTimestampsAddr = o3TimestampMem.getAddress();</span>

            // ensure there is enough size
<span class="pc bpc" id="L3407" title="1 of 2 branches missed.">            assert o3TimestampMem.getAppendOffset() == o3RowCount * TIMESTAMP_MERGE_ENTRY_BYTES;</span>
<span class="pc bpc" id="L3408" title="1 of 4 branches missed.">            if (o3RowCount &gt; 600 || !o3QuickSortEnabled) {</span>
<span class="fc" id="L3409">                o3TimestampMemCpy.jumpTo(o3TimestampMem.getAppendOffset());</span>
<span class="fc" id="L3410">                Vect.radixSortLongIndexAscInPlace(sortedTimestampsAddr, o3RowCount, o3TimestampMemCpy.addressOf(0));</span>
            } else {
<span class="nc" id="L3412">                Vect.quickSortLongIndexAscInPlace(sortedTimestampsAddr, o3RowCount);</span>
            }

            // we have three frames:
            // partition logical &quot;lo&quot; and &quot;hi&quot; - absolute bounds (partitionLo, partitionHi)
            // partition actual data &quot;lo&quot; and &quot;hi&quot; (dataLo, dataHi)
            // out of order &quot;lo&quot; and &quot;hi&quot; (indexLo, indexHi)

            long srcOooMax;
<span class="fc" id="L3421">            final long o3TimestampMin = getTimestampIndexValue(sortedTimestampsAddr, 0);</span>
<span class="fc bfc" id="L3422" title="All 2 branches covered.">            if (o3TimestampMin &lt; Timestamps.O3_MIN_TS) {</span>
<span class="fc" id="L3423">                o3InError = true;</span>
<span class="fc" id="L3424">                throw CairoException.nonCritical().put(&quot;timestamps before 1970-01-01 are not allowed for O3&quot;);</span>
            }

<span class="fc" id="L3427">            long o3TimestampMax = getTimestampIndexValue(sortedTimestampsAddr, o3RowCount - 1);</span>
<span class="fc bfc" id="L3428" title="All 2 branches covered.">            if (o3TimestampMax &lt; Timestamps.O3_MIN_TS) {</span>
<span class="fc" id="L3429">                o3InError = true;</span>
<span class="fc" id="L3430">                throw CairoException.nonCritical().put(&quot;timestamps before 1970-01-01 are not allowed for O3&quot;);</span>
            }

            // Safe check of the sort. No known way to reproduce
<span class="pc bpc" id="L3434" title="1 of 2 branches missed.">            assert o3TimestampMin &lt;= o3TimestampMax;</span>

<span class="fc bfc" id="L3436" title="All 2 branches covered.">            if (o3MaxLag &gt; 0) {</span>
<span class="fc" id="L3437">                long lagError = 0;</span>
<span class="fc bfc" id="L3438" title="All 2 branches covered.">                if (getMaxTimestamp() != Long.MIN_VALUE) {</span>

                    // When table already has data we can calculate the overlap of the newly added
                    // batch of records with existing data in the table. Positive value of the overlap
                    // means that our o3EffectiveLag was undersized.

<span class="fc" id="L3444">                    lagError = getMaxTimestamp() - o3CommitBatchTimestampMin;</span>

<span class="fc" id="L3446">                    int n = WINDOW_SIZE - 1;</span>

<span class="fc bfc" id="L3448" title="All 2 branches covered.">                    if (lagError &gt; 0) {</span>
<span class="fc" id="L3449">                        o3EffectiveLag += lagError * configuration.getO3LagIncreaseFactor();</span>
<span class="fc" id="L3450">                        o3EffectiveLag = Math.min(o3EffectiveLag, o3MaxLag);</span>
                    } else {
                        // avoid using negative o3EffectiveLag
<span class="fc" id="L3453">                        o3EffectiveLag += lagError * configuration.getO3LagDecreaseFactor();</span>
<span class="fc" id="L3454">                        o3EffectiveLag = Math.max(0, o3EffectiveLag);</span>
                    }

<span class="fc" id="L3457">                    long max = Long.MIN_VALUE;</span>
<span class="fc bfc" id="L3458" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
                        // shift array left and find out max at the same time
<span class="fc" id="L3460">                        final long e = o3LastTimestampSpreads[i + 1];</span>
<span class="fc" id="L3461">                        o3LastTimestampSpreads[i] = e;</span>
<span class="fc" id="L3462">                        max = Math.max(e, max);</span>
                    }

<span class="fc" id="L3465">                    o3LastTimestampSpreads[n] = o3EffectiveLag;</span>
<span class="fc" id="L3466">                    o3EffectiveLag = Math.max(o3EffectiveLag, max);</span>
<span class="fc" id="L3467">                } else {</span>
<span class="fc" id="L3468">                    o3EffectiveLag = o3MaxLag;</span>
                }

<span class="fc" id="L3471">                long lagThresholdTimestamp = o3TimestampMax - o3EffectiveLag;</span>
<span class="fc bfc" id="L3472" title="All 2 branches covered.">                if (lagThresholdTimestamp &gt;= o3TimestampMin) {</span>
<span class="fc" id="L3473">                    final long lagThresholdRow = Vect.boundedBinarySearchIndexT(</span>
                            sortedTimestampsAddr,
                            lagThresholdTimestamp,
                            0,
                            o3RowCount - 1,
                            BinarySearch.SCAN_DOWN
                    );
<span class="fc" id="L3480">                    o3LagRowCount = o3RowCount - lagThresholdRow - 1;</span>
<span class="fc bfc" id="L3481" title="All 2 branches covered.">                    if (o3LagRowCount &gt; maxUncommittedRows) {</span>
<span class="fc" id="L3482">                        o3LagRowCount = maxUncommittedRows;</span>
<span class="fc" id="L3483">                        srcOooMax = o3RowCount - maxUncommittedRows;</span>
                    } else {
<span class="fc" id="L3485">                        srcOooMax = lagThresholdRow + 1;</span>
                    }
<span class="fc" id="L3487">                } else {</span>
<span class="fc" id="L3488">                    o3LagRowCount = o3RowCount;</span>
                    // This is a scenario where &quot;o3MaxLag&quot; and &quot;maxUncommitted&quot; values do not work with the data
                    // in that the &quot;o3EffectiveLag&quot; is larger than dictated &quot;maxUncommitted&quot;. A simple plan here is to
                    // commit half of the o3MaxLag.
<span class="fc bfc" id="L3492" title="All 2 branches covered.">                    if (o3LagRowCount &gt; maxUncommittedRows) {</span>
<span class="fc" id="L3493">                        o3LagRowCount = maxUncommittedRows / 2;</span>
<span class="fc" id="L3494">                        srcOooMax = o3RowCount - o3LagRowCount;</span>
                    } else {
<span class="fc" id="L3496">                        srcOooMax = 0;</span>
                    }
                }

<span class="fc" id="L3500">                LOG.info().$(&quot;o3 commit [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L3501">                        .$(&quot;, maxUncommittedRows=&quot;).$(maxUncommittedRows)</span>
<span class="fc" id="L3502">                        .$(&quot;, o3TimestampMin=&quot;).$ts(o3TimestampMin)</span>
<span class="fc" id="L3503">                        .$(&quot;, o3TimestampMax=&quot;).$ts(o3TimestampMax)</span>
<span class="fc" id="L3504">                        .$(&quot;, o3MaxLagUs=&quot;).$(o3MaxLag)</span>
<span class="fc" id="L3505">                        .$(&quot;, o3EffectiveLagUs=&quot;).$(o3EffectiveLag)</span>
<span class="fc" id="L3506">                        .$(&quot;, lagError=&quot;).$(lagError)</span>
<span class="fc" id="L3507">                        .$(&quot;, o3SpreadUs=&quot;).$(o3TimestampMax - o3TimestampMin)</span>
<span class="fc" id="L3508">                        .$(&quot;, lagThresholdTimestamp=&quot;).$ts(lagThresholdTimestamp)</span>
<span class="fc" id="L3509">                        .$(&quot;, o3LagRowCount=&quot;).$(o3LagRowCount)</span>
<span class="fc" id="L3510">                        .$(&quot;, srcOooMax=&quot;).$(srcOooMax)</span>
<span class="fc" id="L3511">                        .$(&quot;, o3RowCount=&quot;).$(o3RowCount)</span>
<span class="fc" id="L3512">                        .I$();</span>

<span class="fc" id="L3514">            } else {</span>
<span class="fc" id="L3515">                LOG.info()</span>
<span class="fc" id="L3516">                        .$(&quot;o3 commit [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L3517">                        .$(&quot;, o3RowCount=&quot;).$(o3RowCount)</span>
<span class="fc" id="L3518">                        .I$();</span>
<span class="fc" id="L3519">                srcOooMax = o3RowCount;</span>
            }

<span class="fc" id="L3522">            o3CommitBatchTimestampMin = Long.MAX_VALUE;</span>

<span class="fc bfc" id="L3524" title="All 2 branches covered.">            if (srcOooMax == 0) {</span>
<span class="fc" id="L3525">                return true;</span>
            }

            // we could have moved the &quot;srcOooMax&quot; and hence we re-read the max timestamp
<span class="fc" id="L3529">            o3TimestampMax = getTimestampIndexValue(sortedTimestampsAddr, srcOooMax - 1);</span>


            // we are going to use this soon to avoid double-copying lag data
            // final boolean yep = isAppendLastPartitionOnly(sortedTimestampsAddr, o3TimestampMax);

            // reshuffle all columns according to timestamp index
<span class="fc" id="L3536">            o3Sort(sortedTimestampsAddr, timestampIndex, o3RowCount);</span>
<span class="fc" id="L3537">            LOG.info()</span>
<span class="fc" id="L3538">                    .$(&quot;sorted [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L3539">                    .$(&quot;, o3RowCount=&quot;).$(o3RowCount)</span>
<span class="fc" id="L3540">                    .I$();</span>

<span class="fc" id="L3542">            processO3Block(</span>
                    o3LagRowCount,
                    timestampIndex,
                    sortedTimestampsAddr,
                    srcOooMax,
                    o3TimestampMin,
                    o3TimestampMax,
                    true,
                    0L
            );
        } finally {
<span class="fc" id="L3553">            finishO3Append(o3LagRowCount);</span>
        }

<span class="fc" id="L3556">        finishO3Commit(partitionTimestampHiLimit);</span>
<span class="fc" id="L3557">        return false;</span>
    }

    private void o3CommitPartitionAsync(
            AtomicInteger columnCounter,
            long maxTimestamp,
            long sortedTimestampsAddr,
            long srcOooMax,
            long oooTimestampMin,
            long oooTimestampMax,
            long srcOooLo,
            long srcOooHi,
            long partitionTimestamp,
            boolean last,
            long srcDataMax,
            long srcNameTxn,
            O3Basket o3Basket,
            long colTopSinkAddr
    ) {
<span class="fc" id="L3576">        long cursor = messageBus.getO3PartitionPubSeq().next();</span>
<span class="fc bfc" id="L3577" title="All 2 branches covered.">        if (cursor &gt; -1) {</span>
<span class="fc" id="L3578">            O3PartitionTask task = messageBus.getO3PartitionQueue().get(cursor);</span>
<span class="fc" id="L3579">            task.of(</span>
                    path,
                    partitionBy,
                    columns,
                    o3Columns,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    oooTimestampMin,
                    oooTimestampMax,
                    partitionTimestamp,
                    maxTimestamp,
                    srcDataMax,
                    srcNameTxn,
                    last,
<span class="fc" id="L3594">                    getTxn(),</span>
                    sortedTimestampsAddr,
                    this,
                    columnCounter,
                    o3Basket,
                    colTopSinkAddr
            );
<span class="fc" id="L3601">            messageBus.getO3PartitionPubSeq().done(cursor);</span>
<span class="fc" id="L3602">        } else {</span>
<span class="fc" id="L3603">            O3PartitionJob.processPartition(</span>
                    path,
                    partitionBy,
                    columns,
                    o3Columns,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    oooTimestampMin,
                    oooTimestampMax,
                    partitionTimestamp,
                    maxTimestamp,
                    srcDataMax,
                    srcNameTxn,
                    last,
<span class="fc" id="L3618">                    getTxn(),</span>
                    sortedTimestampsAddr,
                    this,
                    columnCounter,
                    o3Basket,
                    colTopSinkAddr
            );
        }
<span class="fc" id="L3626">    }</span>

    private void o3ConsumePartitionUpdateSink() {
<span class="fc" id="L3629">        long size = o3PartitionUpdateSink.size();</span>

<span class="fc bfc" id="L3631" title="All 2 branches covered.">        for (long offset = 0; offset &lt; size; offset += PARTITION_UPDATE_SINK_ENTRY_SIZE) {</span>
<span class="fc" id="L3632">            long partitionTimestamp = o3PartitionUpdateSink.get(offset);</span>
<span class="fc" id="L3633">            long timestampMin = o3PartitionUpdateSink.get(offset + 1);</span>

<span class="fc bfc" id="L3635" title="All 4 branches covered.">            if (partitionTimestamp != -1L &amp;&amp; timestampMin != -1L) {</span>
<span class="fc" id="L3636">                long timestampMax = o3PartitionUpdateSink.get(offset + 2);</span>
<span class="fc" id="L3637">                long srcOooPartitionLo = o3PartitionUpdateSink.get(offset + 3);</span>
<span class="fc" id="L3638">                long srcOooPartitionHi = o3PartitionUpdateSink.get(offset + 4);</span>
<span class="fc bfc" id="L3639" title="All 2 branches covered.">                boolean partitionMutates = o3PartitionUpdateSink.get(offset + 5) != 0;</span>
<span class="fc" id="L3640">                long srcOooMax = o3PartitionUpdateSink.get(offset + 6);</span>
<span class="fc" id="L3641">                long srcDataMax = o3PartitionUpdateSink.get(offset + 7);</span>

<span class="fc" id="L3643">                o3PartitionUpdate(</span>
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcOooPartitionLo,
                        srcOooPartitionHi,
                        srcOooMax,
                        srcDataMax,
                        partitionMutates
                );

            }
        }
<span class="fc" id="L3656">    }</span>

    private void o3ConsumePartitionUpdates() {
<span class="fc" id="L3659">        final Sequence partitionSubSeq = messageBus.getO3PartitionSubSeq();</span>
<span class="fc" id="L3660">        final RingQueue&lt;O3PartitionTask&gt; partitionQueue = messageBus.getO3PartitionQueue();</span>
<span class="fc" id="L3661">        final Sequence openColumnSubSeq = messageBus.getO3OpenColumnSubSeq();</span>
<span class="fc" id="L3662">        final RingQueue&lt;O3OpenColumnTask&gt; openColumnQueue = messageBus.getO3OpenColumnQueue();</span>
<span class="fc" id="L3663">        final Sequence copySubSeq = messageBus.getO3CopySubSeq();</span>
<span class="fc" id="L3664">        final RingQueue&lt;O3CopyTask&gt; copyQueue = messageBus.getO3CopyQueue();</span>

        do {
<span class="fc" id="L3667">            long cursor = partitionSubSeq.next();</span>
<span class="fc bfc" id="L3668" title="All 2 branches covered.">            if (cursor &gt; -1) {</span>
<span class="fc" id="L3669">                final O3PartitionTask partitionTask = partitionQueue.get(cursor);</span>
<span class="fc bfc" id="L3670" title="All 4 branches covered.">                if (partitionTask.getTableWriter() == this &amp;&amp; o3ErrorCount.get() &gt; 0) {</span>
                    // do we need to free anything on the task?
<span class="fc" id="L3672">                    partitionSubSeq.done(cursor);</span>
<span class="fc" id="L3673">                    o3ClockDownPartitionUpdateCount();</span>
<span class="fc" id="L3674">                    o3CountDownDoneLatch();</span>
                } else {
<span class="fc" id="L3676">                    o3ProcessPartitionSafe(partitionSubSeq, cursor, partitionTask);</span>
                }
<span class="fc" id="L3678">                continue;</span>
            }

<span class="fc" id="L3681">            cursor = openColumnSubSeq.next();</span>
<span class="fc bfc" id="L3682" title="All 2 branches covered.">            if (cursor &gt; -1) {</span>
<span class="fc" id="L3683">                O3OpenColumnTask openColumnTask = openColumnQueue.get(cursor);</span>
<span class="fc bfc" id="L3684" title="All 4 branches covered.">                if (openColumnTask.getTableWriter() == this &amp;&amp; o3ErrorCount.get() &gt; 0) {</span>
<span class="fc" id="L3685">                    O3CopyJob.closeColumnIdle(</span>
<span class="fc" id="L3686">                            openColumnTask.getColumnCounter(),</span>
<span class="fc" id="L3687">                            openColumnTask.getTimestampMergeIndexAddr(),</span>
<span class="fc" id="L3688">                            openColumnTask.getTimestampMergeIndexSize(),</span>
<span class="fc" id="L3689">                            openColumnTask.getSrcTimestampFd(),</span>
<span class="fc" id="L3690">                            openColumnTask.getSrcTimestampAddr(),</span>
<span class="fc" id="L3691">                            openColumnTask.getSrcTimestampSize(),</span>
                            this
                    );
<span class="fc" id="L3694">                    openColumnSubSeq.done(cursor);</span>
                } else {
<span class="fc" id="L3696">                    o3OpenColumnSafe(openColumnSubSeq, cursor, openColumnTask);</span>
                }
<span class="fc" id="L3698">                continue;</span>
            }

<span class="fc" id="L3701">            cursor = copySubSeq.next();</span>
<span class="fc bfc" id="L3702" title="All 2 branches covered.">            if (cursor &gt; -1) {</span>
<span class="fc" id="L3703">                O3CopyTask copyTask = copyQueue.get(cursor);</span>
<span class="fc bfc" id="L3704" title="All 4 branches covered.">                if (copyTask.getTableWriter() == this &amp;&amp; o3ErrorCount.get() &gt; 0) {</span>
<span class="fc" id="L3705">                    O3CopyJob.copyIdle(</span>
<span class="fc" id="L3706">                            copyTask.getColumnCounter(),</span>
<span class="fc" id="L3707">                            copyTask.getPartCounter(),</span>
<span class="fc" id="L3708">                            copyTask.getTimestampMergeIndexAddr(),</span>
<span class="fc" id="L3709">                            copyTask.getTimestampMergeIndexSize(),</span>
<span class="fc" id="L3710">                            copyTask.getSrcDataFixFd(),</span>
<span class="fc" id="L3711">                            copyTask.getSrcDataFixAddr(),</span>
<span class="fc" id="L3712">                            copyTask.getSrcDataFixSize(),</span>
<span class="fc" id="L3713">                            copyTask.getSrcDataVarFd(),</span>
<span class="fc" id="L3714">                            copyTask.getSrcDataVarAddr(),</span>
<span class="fc" id="L3715">                            copyTask.getSrcDataVarSize(),</span>
<span class="fc" id="L3716">                            copyTask.getDstFixFd(),</span>
<span class="fc" id="L3717">                            copyTask.getDstFixAddr(),</span>
<span class="fc" id="L3718">                            copyTask.getDstFixSize(),</span>
<span class="fc" id="L3719">                            copyTask.getDstVarFd(),</span>
<span class="fc" id="L3720">                            copyTask.getDstVarAddr(),</span>
<span class="fc" id="L3721">                            copyTask.getDstVarSize(),</span>
<span class="fc" id="L3722">                            copyTask.getSrcTimestampFd(),</span>
<span class="fc" id="L3723">                            copyTask.getSrcTimestampAddr(),</span>
<span class="fc" id="L3724">                            copyTask.getSrcTimestampSize(),</span>
<span class="fc" id="L3725">                            copyTask.getDstKFd(),</span>
<span class="fc" id="L3726">                            copyTask.getDstVFd(),</span>
                            this
                    );
<span class="fc" id="L3729">                    copySubSeq.done(cursor);</span>
                } else {
<span class="fc" id="L3731">                    o3CopySafe(cursor);</span>
                }
            }
<span class="fc bfc" id="L3734" title="All 2 branches covered.">        } while (this.o3PartitionUpdRemaining.get() &gt; 0);</span>

<span class="fc bfc" id="L3736" title="All 2 branches covered.">        if (o3ErrorCount.get() == 0) {</span>
<span class="fc" id="L3737">            o3ConsumePartitionUpdateSink();</span>
        }
<span class="fc" id="L3739">    }</span>

    private void o3CopySafe(
            long cursor
    ) {
<span class="fc" id="L3744">        final O3CopyTask task = messageBus.getO3CopyQueue().get(cursor);</span>
        try {
<span class="fc" id="L3746">            O3CopyJob.copy(</span>
                    task,
                    cursor,
<span class="fc" id="L3749">                    messageBus.getO3CopySubSeq()</span>
            );
<span class="fc" id="L3751">        } catch (CairoException | CairoError e) {</span>
<span class="fc" id="L3752">            LOG.error().$((Sinkable) e).$();</span>
<span class="nc" id="L3753">        } catch (Throwable e) {</span>
<span class="nc" id="L3754">            LOG.error().$(e).$();</span>
<span class="fc" id="L3755">        }</span>
<span class="fc" id="L3756">    }</span>

    private void o3MergeFixColumnLag(int columnIndex, int columnType, long mergeIndex, long lagRows, long mappedRowLo, long mappedRowHi) {
<span class="fc" id="L3759">        final long rowCount = lagRows + mappedRowHi - mappedRowLo;</span>
<span class="fc" id="L3760">        final int primaryColumnIndex = getPrimaryColumnIndex(columnIndex);</span>
<span class="fc" id="L3761">        final MemoryCARW lagMem = o3MemColumns.getQuick(primaryColumnIndex);</span>
<span class="fc" id="L3762">        final MemoryCR mappedMem = o3Columns.getQuick(primaryColumnIndex);</span>
<span class="fc bfc" id="L3763" title="All 2 branches covered.">        if (mappedMem == lagMem) {</span>
<span class="pc bpc" id="L3764" title="1 of 2 branches missed.">            if (ColumnType.isSymbol(columnType)) {</span>
<span class="fc" id="L3765">                mappedRowLo = lagRows;</span>
            } else {
<span class="nc" id="L3767">                throw CairoException.critical(0)</span>
<span class="nc" id="L3768">                        .put(&quot;same source and destination to copy data from for non-symbol column [&quot;)</span>
<span class="nc" id="L3769">                        .put(ColumnType.nameOf(columnType)).put(&quot;] in o3MergeFixColumnLag routine is not supported &quot;);</span>
            }
        }
<span class="fc" id="L3772">        final MemoryCARW destMem = o3MemColumns2.getQuick(primaryColumnIndex);</span>

<span class="fc" id="L3774">        final int shl = ColumnType.pow2SizeOf(columnType);</span>
<span class="fc" id="L3775">        destMem.jumpTo(rowCount &lt;&lt; shl);</span>
<span class="fc" id="L3776">        long src1 = mappedMem.addressOf(mappedRowLo &lt;&lt; shl);</span>
<span class="fc" id="L3777">        long src2 = lagMem.addressOf(0);</span>
<span class="fc" id="L3778">        final long dest = destMem.addressOf(0);</span>
<span class="pc bpc" id="L3779" title="1 of 4 branches missed.">        if (src2 == 0 &amp;&amp; lagRows != 0) {</span>
<span class="nc" id="L3780">            throw CairoException.critical(0)</span>
<span class="nc" id="L3781">                    .put(&quot;cannot sort WAL data, lag rows are missing [table&quot;).put(tableToken.getTableName())</span>
<span class="nc" id="L3782">                    .put(&quot;, columnName=&quot;).put(metadata.getColumnName(columnIndex))</span>
<span class="nc" id="L3783">                    .put(&quot;, type=&quot;).put(ColumnType.nameOf(columnType))</span>
<span class="nc" id="L3784">                    .put(&quot;, lagRows=&quot;).put(lagRows)</span>
<span class="nc" id="L3785">                    .put(']');</span>
        }
<span class="pc bpc" id="L3787" title="1 of 2 branches missed.">        if (src1 == 0) {</span>
<span class="nc" id="L3788">            throw CairoException.critical(0)</span>
<span class="nc" id="L3789">                    .put(&quot;cannot sort WAL data, rows are missing [table&quot;).put(tableToken.getTableName())</span>
<span class="nc" id="L3790">                    .put(&quot;, columnName=&quot;).put(metadata.getColumnName(columnIndex))</span>
<span class="nc" id="L3791">                    .put(&quot;, type=&quot;).put(ColumnType.nameOf(columnType))</span>
<span class="nc" id="L3792">                    .put(']');</span>
        }
<span class="pc bpc" id="L3794" title="1 of 2 branches missed.">        if (dest == 0) {</span>
<span class="nc" id="L3795">            throw CairoException.critical(0)</span>
<span class="nc" id="L3796">                    .put(&quot;cannot sort WAL data, destination buffer is empty [table&quot;).put(tableToken.getTableName())</span>
<span class="nc" id="L3797">                    .put(&quot;, columnName=&quot;).put(metadata.getColumnName(columnIndex))</span>
<span class="nc" id="L3798">                    .put(&quot;, type=&quot;).put(ColumnType.nameOf(columnType))</span>
<span class="nc" id="L3799">                    .put(']');</span>
        }

<span class="pc bpc" id="L3802" title="1 of 7 branches missed.">        switch (shl) {</span>
            case 0:
<span class="fc" id="L3804">                Vect.mergeShuffle8Bit(src1, src2, dest, mergeIndex, rowCount);</span>
<span class="fc" id="L3805">                break;</span>
            case 1:
<span class="fc" id="L3807">                Vect.mergeShuffle16Bit(src1, src2, dest, mergeIndex, rowCount);</span>
<span class="fc" id="L3808">                break;</span>
            case 2:
<span class="fc" id="L3810">                Vect.mergeShuffle32Bit(src1, src2, dest, mergeIndex, rowCount);</span>
<span class="fc" id="L3811">                break;</span>
            case 3:
<span class="fc" id="L3813">                Vect.mergeShuffle64Bit(src1, src2, dest, mergeIndex, rowCount);</span>
<span class="fc" id="L3814">                break;</span>
            case 4:
<span class="fc" id="L3816">                Vect.mergeShuffle128Bit(src1, src2, dest, mergeIndex, rowCount);</span>
<span class="fc" id="L3817">                break;</span>
            case 5:
<span class="fc" id="L3819">                Vect.mergeShuffle256Bit(src1, src2, dest, mergeIndex, rowCount);</span>
<span class="fc" id="L3820">                break;</span>
            default:
<span class="nc" id="L3822">                assert false : &quot;col type is unsupported&quot;;</span>
                break;
        }
<span class="fc" id="L3825">    }</span>

    private void o3MergeIntoLag(long mergedTimestamps, long countInLag, long mappedRowLo, long mappedRoHi, int timestampIndex) {
<span class="fc" id="L3828">        o3PendingCallbackTasks.clear();</span>

<span class="fc" id="L3830">        final Sequence pubSeq = this.messageBus.getO3CallbackPubSeq();</span>
<span class="fc" id="L3831">        final RingQueue&lt;O3CallbackTask&gt; queue = this.messageBus.getO3CallbackQueue();</span>

<span class="fc" id="L3833">        o3DoneLatch.reset();</span>
<span class="fc" id="L3834">        int queuedCount = 0;</span>
<span class="fc bfc" id="L3835" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L3836">            final int type = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L3837" title="All 4 branches covered.">            if (timestampIndex != i &amp;&amp; type &gt; 0) {</span>
<span class="fc" id="L3838">                long cursor = pubSeq.next();</span>
<span class="fc bfc" id="L3839" title="All 2 branches covered.">                if (cursor &gt; -1) {</span>
                    try {
<span class="fc" id="L3841">                        final O3CallbackTask task = queue.get(cursor);</span>
<span class="fc" id="L3842">                        task.of(</span>
                                o3DoneLatch,
                                i,
                                type,
                                mergedTimestamps,
                                countInLag,
                                mappedRowLo,
                                mappedRoHi,
<span class="fc bfc" id="L3850" title="All 2 branches covered.">                                ColumnType.isVariableLength(type) ? o3MergeLagVarColumnRef : o3MergeLagFixColumnRef</span>
                        );
<span class="fc" id="L3852">                        o3PendingCallbackTasks.add(task);</span>
                    } finally {
<span class="fc" id="L3854">                        queuedCount++;</span>
<span class="fc" id="L3855">                        pubSeq.done(cursor);</span>
<span class="fc" id="L3856">                    }</span>
                } else {
<span class="fc" id="L3858">                    o3MergeIntoLagColumn(mergedTimestamps, i, type, countInLag, mappedRowLo, mappedRoHi);</span>
                }
            }
        }

<span class="fc bfc" id="L3863" title="All 2 branches covered.">        for (int n = o3PendingCallbackTasks.size() - 1; n &gt; -1; n--) {</span>
<span class="fc" id="L3864">            final O3CallbackTask task = o3PendingCallbackTasks.getQuick(n);</span>
<span class="fc bfc" id="L3865" title="All 2 branches covered.">            if (task.tryLock()) {</span>
<span class="fc" id="L3866">                O3CallbackJob.runCallbackWithCol(</span>
                        task,
                        -1,
                        null
                );
            }
        }

<span class="fc" id="L3874">        o3DoneLatch.await(queuedCount);</span>
<span class="fc" id="L3875">        swapO3ColumnsExcept(timestampIndex);</span>
<span class="fc" id="L3876">    }</span>

    private void o3MergeIntoLagColumn(long mergedTimestampAddress, int columnIndex, int type, long lagRows, long mappedRowLo, long mappedRowHi) {
<span class="fc bfc" id="L3879" title="All 2 branches covered.">        if (ColumnType.isVariableLength(type)) {</span>
<span class="fc" id="L3880">            o3MergeVarColumnLag(columnIndex, type, mergedTimestampAddress, lagRows, mappedRowLo, mappedRowHi);</span>
        } else {
<span class="fc" id="L3882">            o3MergeFixColumnLag(columnIndex, type, mergedTimestampAddress, lagRows, mappedRowLo, mappedRowHi);</span>
        }
<span class="fc" id="L3884">    }</span>

    private void o3MergeVarColumnLag(int columnIndex, int type, long mergedTimestampAddress, long lagRows, long mappedRowLo, long mappedRowHi) {
<span class="fc" id="L3887">        final long rowCount = lagRows + mappedRowHi - mappedRowLo;</span>
<span class="fc" id="L3888">        final int primaryIndex = getPrimaryColumnIndex(columnIndex);</span>
<span class="fc" id="L3889">        final int secondaryIndex = primaryIndex + 1;</span>

<span class="fc" id="L3891">        final MemoryCR src1Data = o3Columns.getQuick(primaryIndex);</span>
<span class="fc" id="L3892">        final MemoryCR src1Index = o3Columns.getQuick(secondaryIndex);</span>
<span class="fc" id="L3893">        final MemoryCR src2Data = o3MemColumns.getQuick(primaryIndex);</span>
<span class="fc" id="L3894">        final MemoryCR src2Index = o3MemColumns.getQuick(secondaryIndex);</span>

<span class="fc" id="L3896">        final MemoryCARW destData = o3MemColumns2.getQuick(primaryIndex);</span>
<span class="fc" id="L3897">        final MemoryCARW destIndex = o3MemColumns2.getQuick(secondaryIndex);</span>

        // ensure we have enough memory allocated
<span class="fc" id="L3900">        final long src1DataHi = src1Index.getLong(mappedRowHi &lt;&lt; 3);</span>
<span class="fc" id="L3901">        final long src1DataLo = src1Index.getLong(mappedRowLo &lt;&lt; 3);</span>
<span class="fc" id="L3902">        final long src1DataSize = src1DataHi - src1DataLo;</span>
<span class="pc bpc" id="L3903" title="1 of 2 branches missed.">        assert src1Data.size() &gt;= src1DataSize;</span>
<span class="fc bfc" id="L3904" title="All 2 branches covered.">        final long src2DataSize = lagRows &gt; 0 ? src2Index.getLong(lagRows &lt;&lt; 3) : 0;</span>
<span class="pc bpc" id="L3905" title="1 of 2 branches missed.">        assert src2Data.size() &gt;= src2DataSize;</span>

<span class="fc" id="L3907">        destData.jumpTo(src1DataSize + src2DataSize);</span>
<span class="fc" id="L3908">        destIndex.jumpTo((rowCount + 1) &gt;&gt; 3);</span>
<span class="fc" id="L3909">        destIndex.putLong(rowCount &lt;&lt; 3, src1DataSize + src2DataSize);</span>

        // exclude the trailing offset from shuffling
<span class="fc" id="L3912">        final long destDataAddr = destData.addressOf(0);</span>
<span class="fc" id="L3913">        final long destIndxAddr = destIndex.addressOf(0);</span>

<span class="fc" id="L3915">        final long src1DataAddr = src1Data.addressOf(src1DataLo) - src1DataLo;</span>
<span class="fc" id="L3916">        final long src1IndxAddr = src1Index.addressOf(mappedRowLo &lt;&lt; 3);</span>
<span class="fc" id="L3917">        final long src2DataAddr = src2Data.addressOf(0);</span>
<span class="fc" id="L3918">        final long src2IndxAddr = src2Index.addressOf(0);</span>

<span class="fc bfc" id="L3920" title="All 2 branches covered.">        if (type == ColumnType.STRING) {</span>
            // add max offset so that we do not have conditionals inside loop
<span class="fc" id="L3922">            Vect.oooMergeCopyStrColumn(</span>
                    mergedTimestampAddress,
                    rowCount,
                    src1IndxAddr,
                    src1DataAddr,
                    src2IndxAddr,
                    src2DataAddr,
                    destIndxAddr,
                    destDataAddr,
                    0L
            );
<span class="pc bpc" id="L3933" title="1 of 2 branches missed.">        } else if (type == ColumnType.BINARY) {</span>
<span class="fc" id="L3934">            Vect.oooMergeCopyBinColumn(</span>
                    mergedTimestampAddress,
                    rowCount,
                    src1IndxAddr,
                    src1DataAddr,
                    src2IndxAddr,
                    src2DataAddr,
                    destIndxAddr,
                    destDataAddr,
                    0L
            );
        } else {
<span class="nc" id="L3946">            throw new UnsupportedOperationException(&quot;unsupported column type:&quot; + ColumnType.nameOf(type));</span>
        }
<span class="fc" id="L3948">    }</span>

    private void o3MoveLag0(
            int columnIndex,
            final int columnType,
            long copyToLagRowCount,
            long columnDataRowOffset,
            long existingLagRows,
            long excludeSymbols
    ) {
<span class="fc bfc" id="L3958" title="All 2 branches covered.">        if (columnIndex &gt; -1) {</span>
<span class="fc" id="L3959">            MemoryCR o3SrcDataMem = o3Columns.get(getPrimaryColumnIndex(columnIndex));</span>
<span class="fc" id="L3960">            MemoryCR o3SrcIndexMem = o3Columns.get(getSecondaryColumnIndex(columnIndex));</span>
<span class="fc" id="L3961">            MemoryARW o3DstDataMem = o3MemColumns.get(getPrimaryColumnIndex(columnIndex));</span>
<span class="fc" id="L3962">            MemoryARW o3DstIndexMem = o3MemColumns.get(getSecondaryColumnIndex(columnIndex));</span>

<span class="pc bpc" id="L3964" title="1 of 6 branches missed.">            if (o3SrcDataMem == o3DstDataMem &amp;&amp; excludeSymbols &gt; 0 &amp;&amp; columnType == ColumnType.SYMBOL) {</span>
                // nothing to do. This is the case when WAL symbols are remapped to the correct place in LAG buffers.
<span class="fc" id="L3966">                return;</span>
            }

            long size;
            long sourceOffset;
            long destOffset;
<span class="fc" id="L3972">            final int shl = ColumnType.pow2SizeOf(columnType);</span>
<span class="fc bfc" id="L3973" title="All 2 branches covered.">            if (null == o3SrcIndexMem) {</span>
                // Fixed size column
<span class="fc" id="L3975">                sourceOffset = columnDataRowOffset &lt;&lt; shl;</span>
<span class="fc" id="L3976">                size = copyToLagRowCount &lt;&lt; shl;</span>
<span class="fc" id="L3977">                destOffset = existingLagRows &lt;&lt; shl;</span>
            } else {
                // Var size column
<span class="fc" id="L3980">                long committedIndexOffset = columnDataRowOffset &lt;&lt; 3;</span>
<span class="fc" id="L3981">                sourceOffset = o3SrcIndexMem.getLong(committedIndexOffset);</span>
<span class="fc" id="L3982">                size = o3SrcIndexMem.getLong((columnDataRowOffset + copyToLagRowCount) &lt;&lt; 3) - sourceOffset;</span>
<span class="fc bfc" id="L3983" title="All 2 branches covered.">                destOffset = existingLagRows == 0 ? 0L : o3DstIndexMem.getLong(existingLagRows &lt;&lt; 3);</span>

                // adjust append position of the index column to
                // maintain n+1 number of entries
<span class="fc" id="L3987">                o3DstIndexMem.jumpTo((existingLagRows + copyToLagRowCount + 1) &lt;&lt; 3);</span>

                // move count + 1 rows, to make sure index column remains n+1
                // the data is copied back to start of the buffer, no need to set size first
<span class="fc" id="L3991">                O3Utils.shiftCopyFixedSizeColumnData(</span>
                        sourceOffset - destOffset,
<span class="fc" id="L3993">                        o3SrcIndexMem.addressOf(committedIndexOffset),</span>
                        0,
                        copyToLagRowCount, // No need to do +1 here, hi is inclusive
<span class="fc" id="L3996">                        o3DstIndexMem.addressOf(existingLagRows &lt;&lt; 3)</span>
                );
            }


<span class="fc" id="L4001">            o3DstDataMem.jumpTo(destOffset + size);</span>
<span class="pc bpc" id="L4002" title="1 of 2 branches missed.">            assert o3SrcDataMem.size() &gt;= size;</span>
<span class="fc" id="L4003">            Vect.memmove(o3DstDataMem.addressOf(destOffset), o3SrcDataMem.addressOf(sourceOffset), size);</span>
            // the data is copied back to start of the buffer, no need to set size first
<span class="fc" id="L4005">        } else {</span>
<span class="fc" id="L4006">            MemoryCR o3SrcDataMem = o3Columns.get(getPrimaryColumnIndex(-columnIndex - 1));</span>

            // Special case, designated timestamp column
            // Move values and set index to  0..copyToLagRowCount
<span class="fc" id="L4010">            final long sourceOffset = columnDataRowOffset &lt;&lt; 4;</span>
<span class="fc" id="L4011">            o3TimestampMem.jumpTo((copyToLagRowCount + existingLagRows) &lt;&lt; 4);</span>
<span class="fc" id="L4012">            final long dstTimestampAddr = o3TimestampMem.getAddress() + (existingLagRows &lt;&lt; 4);</span>
<span class="fc" id="L4013">            Vect.shiftTimestampIndex(o3SrcDataMem.addressOf(sourceOffset), copyToLagRowCount, dstTimestampAddr);</span>
        }
<span class="fc" id="L4015">    }</span>

    private long o3MoveUncommitted(final int timestampIndex) {
<span class="fc" id="L4018">        final long committedRowCount = txWriter.unsafeCommittedFixedRowCount() + txWriter.unsafeCommittedTransientRowCount();</span>
<span class="fc" id="L4019">        final long rowsAdded = txWriter.getRowCount() - committedRowCount;</span>
<span class="fc" id="L4020">        final long transientRowCount = txWriter.getTransientRowCount();</span>
<span class="fc" id="L4021">        final long transientRowsAdded = Math.min(transientRowCount, rowsAdded);</span>
<span class="fc bfc" id="L4022" title="All 2 branches covered.">        if (transientRowsAdded &gt; 0) {</span>
<span class="fc" id="L4023">            LOG.debug()</span>
<span class="fc" id="L4024">                    .$(&quot;o3 move uncommitted [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L4025">                    .$(&quot;, transientRowsAdded=&quot;).$(transientRowsAdded)</span>
<span class="fc" id="L4026">                    .I$();</span>
<span class="fc" id="L4027">            final long committedTransientRowCount = transientRowCount - transientRowsAdded;</span>
<span class="fc" id="L4028">            return o3ScheduleMoveUncommitted0(</span>
                    timestampIndex,
                    transientRowsAdded,
                    committedTransientRowCount
            );
        }
<span class="fc" id="L4034">        return 0;</span>
    }

    private void o3MoveUncommitted0(
            int colIndex,
            int columnType,
            long committedTransientRowCount,
            long transientRowsAdded,
            long ignore1,
            long ignore2
    ) {
<span class="fc bfc" id="L4045" title="All 2 branches covered.">        if (colIndex &gt; -1) {</span>
<span class="fc" id="L4046">            MemoryMA srcDataMem = getPrimaryColumn(colIndex);</span>
<span class="fc" id="L4047">            int shl = ColumnType.pow2SizeOf(columnType);</span>
            long srcFixOffset;
<span class="fc" id="L4049">            final MemoryARW o3DataMem = o3MemColumns.get(getPrimaryColumnIndex(colIndex));</span>
<span class="fc" id="L4050">            final MemoryARW o3IndexMem = o3MemColumns.get(getSecondaryColumnIndex(colIndex));</span>

            long extendedSize;
<span class="fc" id="L4053">            long dstVarOffset = o3DataMem.getAppendOffset();</span>

<span class="fc" id="L4055">            final long columnTop = columnTops.getQuick(colIndex);</span>

<span class="fc bfc" id="L4057" title="All 2 branches covered.">            if (columnTop &gt; 0) {</span>
<span class="fc" id="L4058">                LOG.debug()</span>
<span class="fc" id="L4059">                        .$(&quot;move uncommitted [columnTop=&quot;).$(columnTop)</span>
<span class="fc" id="L4060">                        .$(&quot;, columnIndex=&quot;).$(colIndex)</span>
<span class="fc" id="L4061">                        .$(&quot;, committedTransientRowCount=&quot;).$(committedTransientRowCount)</span>
<span class="fc" id="L4062">                        .$(&quot;, transientRowsAdded=&quot;).$(transientRowsAdded)</span>
<span class="fc" id="L4063">                        .I$();</span>
            }

<span class="fc bfc" id="L4066" title="All 2 branches covered.">            if (null == o3IndexMem) {</span>
                // Fixed size
<span class="fc" id="L4068">                extendedSize = transientRowsAdded &lt;&lt; shl;</span>
<span class="fc" id="L4069">                srcFixOffset = (committedTransientRowCount - columnTop) &lt;&lt; shl;</span>
            } else {
                // Var size
<span class="fc" id="L4072">                final int indexShl = 3; // ColumnType.pow2SizeOf(ColumnType.LONG);</span>
<span class="fc" id="L4073">                final MemoryMA srcFixMem = getSecondaryColumn(colIndex);</span>
<span class="fc" id="L4074">                long sourceOffset = (committedTransientRowCount - columnTop) &lt;&lt; indexShl;</span>

                // the size includes trailing LONG
<span class="fc" id="L4077">                long sourceLen = (transientRowsAdded + 1) &lt;&lt; indexShl;</span>
<span class="fc" id="L4078">                long dstAppendOffset = o3IndexMem.getAppendOffset();</span>

                // ensure memory is available
<span class="fc" id="L4081">                o3IndexMem.jumpTo(dstAppendOffset + (transientRowsAdded &lt;&lt; indexShl));</span>
                long alignedExtraLen;
<span class="fc" id="L4083">                long srcAddress = srcFixMem.map(sourceOffset, sourceLen);</span>
<span class="fc bfc" id="L4084" title="All 2 branches covered.">                boolean locallyMapped = srcAddress == 0;</span>

<span class="fc bfc" id="L4086" title="All 2 branches covered.">                if (!locallyMapped) {</span>
<span class="fc" id="L4087">                    alignedExtraLen = 0;</span>
                } else {
                    // Linux requires the mmap offset to be page aligned
<span class="fc" id="L4090">                    final long alignedOffset = Files.floorPageSize(sourceOffset);</span>
<span class="fc" id="L4091">                    alignedExtraLen = sourceOffset - alignedOffset;</span>
<span class="fc" id="L4092">                    srcAddress = mapRO(ff, srcFixMem.getFd(), sourceLen + alignedExtraLen, alignedOffset, MemoryTag.MMAP_TABLE_WRITER);</span>
                }

<span class="fc" id="L4095">                final long srcVarOffset = Unsafe.getUnsafe().getLong(srcAddress + alignedExtraLen);</span>
<span class="fc" id="L4096">                O3Utils.shiftCopyFixedSizeColumnData(</span>
                        srcVarOffset - dstVarOffset,
                        srcAddress + alignedExtraLen + Long.BYTES,
                        0,
                        transientRowsAdded - 1,
                        // copy uncommitted index over the trailing LONG
<span class="fc" id="L4102">                        o3IndexMem.addressOf(dstAppendOffset)</span>
                );

<span class="fc bfc" id="L4105" title="All 2 branches covered.">                if (locallyMapped) {</span>
                    // If memory mapping was mapped specially for this move, close it
<span class="fc" id="L4107">                    ff.munmap(srcAddress, sourceLen + alignedExtraLen, MemoryTag.MMAP_TABLE_WRITER);</span>
                }

<span class="fc" id="L4110">                extendedSize = srcDataMem.getAppendOffset() - srcVarOffset;</span>
<span class="fc" id="L4111">                srcFixOffset = srcVarOffset;</span>
<span class="fc" id="L4112">                srcFixMem.jumpTo(sourceOffset + Long.BYTES);</span>
            }

<span class="fc" id="L4115">            o3DataMem.jumpTo(dstVarOffset + extendedSize);</span>
<span class="fc" id="L4116">            long appendAddress = o3DataMem.addressOf(dstVarOffset);</span>
<span class="fc" id="L4117">            long sourceAddress = srcDataMem.map(srcFixOffset, extendedSize);</span>
<span class="fc bfc" id="L4118" title="All 2 branches covered.">            if (sourceAddress != 0) {</span>
<span class="fc" id="L4119">                Vect.memcpy(appendAddress, sourceAddress, extendedSize);</span>
            } else {
                // Linux requires the mmap offset to be page aligned
<span class="fc" id="L4122">                long alignedOffset = Files.floorPageSize(srcFixOffset);</span>
<span class="fc" id="L4123">                long alignedExtraLen = srcFixOffset - alignedOffset;</span>
<span class="fc" id="L4124">                sourceAddress = mapRO(ff, srcDataMem.getFd(), extendedSize + alignedExtraLen, alignedOffset, MemoryTag.MMAP_TABLE_WRITER);</span>
<span class="fc" id="L4125">                Vect.memcpy(appendAddress, sourceAddress + alignedExtraLen, extendedSize);</span>
<span class="fc" id="L4126">                ff.munmap(sourceAddress, extendedSize + alignedExtraLen, MemoryTag.MMAP_TABLE_WRITER);</span>
            }
<span class="fc" id="L4128">            srcDataMem.jumpTo(srcFixOffset);</span>
<span class="fc" id="L4129">        } else {</span>
            // Timestamp column
<span class="fc" id="L4131">            colIndex = -colIndex - 1;</span>
<span class="fc" id="L4132">            int shl = ColumnType.pow2SizeOf(ColumnType.TIMESTAMP);</span>
<span class="fc" id="L4133">            MemoryMA srcDataMem = getPrimaryColumn(colIndex);</span>
            // this cannot have &quot;top&quot;
<span class="fc" id="L4135">            long srcFixOffset = committedTransientRowCount &lt;&lt; shl;</span>
<span class="fc" id="L4136">            long srcFixLen = transientRowsAdded &lt;&lt; shl;</span>
            long alignedExtraLen;
<span class="fc" id="L4138">            long address = srcDataMem.map(srcFixOffset, srcFixLen);</span>
<span class="fc bfc" id="L4139" title="All 2 branches covered.">            boolean locallyMapped = address == 0;</span>

            // column could not provide necessary length of buffer
            // because perhaps its internal buffer is not big enough
<span class="fc bfc" id="L4143" title="All 2 branches covered.">            if (!locallyMapped) {</span>
<span class="fc" id="L4144">                alignedExtraLen = 0;</span>
            } else {
                // Linux requires the mmap offset to be page aligned
<span class="fc" id="L4147">                long alignedOffset = Files.floorPageSize(srcFixOffset);</span>
<span class="fc" id="L4148">                alignedExtraLen = srcFixOffset - alignedOffset;</span>
<span class="fc" id="L4149">                address = mapRO(ff, srcDataMem.getFd(), srcFixLen + alignedExtraLen, alignedOffset, MemoryTag.MMAP_TABLE_WRITER);</span>
            }

<span class="fc bfc" id="L4152" title="All 2 branches covered.">            for (long n = 0; n &lt; transientRowsAdded; n++) {</span>
<span class="fc" id="L4153">                long ts = Unsafe.getUnsafe().getLong(address + alignedExtraLen + (n &lt;&lt; shl));</span>
<span class="fc" id="L4154">                o3TimestampMem.putLong128(ts, o3RowCount + n);</span>
            }

<span class="fc bfc" id="L4157" title="All 2 branches covered.">            if (locallyMapped) {</span>
<span class="fc" id="L4158">                ff.munmap(address, srcFixLen + alignedExtraLen, MemoryTag.MMAP_TABLE_WRITER);</span>
            }

<span class="fc" id="L4161">            srcDataMem.jumpTo(srcFixOffset);</span>
        }
<span class="fc" id="L4163">    }</span>

    private void o3OpenColumnSafe(Sequence openColumnSubSeq, long cursor, O3OpenColumnTask openColumnTask) {
        try {
<span class="fc" id="L4167">            O3OpenColumnJob.openColumn(openColumnTask, cursor, openColumnSubSeq);</span>
<span class="fc" id="L4168">        } catch (CairoException | CairoError e) {</span>
<span class="fc" id="L4169">            LOG.error().$((Sinkable) e).$();</span>
<span class="nc" id="L4170">        } catch (Throwable e) {</span>
<span class="nc" id="L4171">            LOG.error().$(e).$();</span>
<span class="fc" id="L4172">        }</span>
<span class="fc" id="L4173">    }</span>

    private void o3OpenColumns() {
<span class="fc bfc" id="L4176" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L4177" title="All 2 branches covered.">            if (metadata.getColumnType(i) &gt; 0) {</span>
<span class="fc" id="L4178">                MemoryARW mem1 = o3MemColumns.getQuick(getPrimaryColumnIndex(i));</span>
<span class="fc" id="L4179">                mem1.jumpTo(0);</span>
<span class="fc" id="L4180">                MemoryARW mem2 = o3MemColumns.getQuick(getSecondaryColumnIndex(i));</span>
<span class="fc bfc" id="L4181" title="All 2 branches covered.">                if (mem2 != null) {</span>
<span class="fc" id="L4182">                    mem2.jumpTo(0);</span>
<span class="fc" id="L4183">                    mem2.putLong(0);</span>
                }
            }
        }
<span class="fc" id="L4187">        activeColumns = o3MemColumns;</span>
<span class="fc" id="L4188">        activeNullSetters = o3NullSetters;</span>
<span class="fc" id="L4189">        LOG.debug().$(&quot;switched partition to memory&quot;).$();</span>
<span class="fc" id="L4190">    }</span>

    private void o3PartitionUpdate(
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            long srcOooPartitionLo,
            long srcOooPartitionHi,
            long srcOooMax,
            long srcDataMax,
            boolean partitionMutates
    ) {
<span class="fc" id="L4202">        txWriter.minTimestamp = Math.min(timestampMin, txWriter.minTimestamp);</span>
<span class="fc" id="L4203">        final long partitionSize = srcDataMax + srcOooPartitionHi - srcOooPartitionLo + 1;</span>
<span class="fc" id="L4204">        final long rowDelta = srcOooPartitionHi - srcOooMax;</span>
<span class="fc" id="L4205">        final int partitionIndex = txWriter.findAttachedPartitionIndexByLoTimestamp(partitionTimestamp);</span>
<span class="fc bfc" id="L4206" title="All 2 branches covered.">        if (partitionTimestamp == lastPartitionTimestamp) {</span>
<span class="fc bfc" id="L4207" title="All 2 branches covered.">            if (partitionMutates) {</span>
<span class="fc" id="L4208">                closeActivePartition(true);</span>
<span class="fc bfc" id="L4209" title="All 2 branches covered.">            } else if (rowDelta &lt; -1) {</span>
<span class="fc" id="L4210">                closeActivePartition(partitionSize);</span>
            } else {
<span class="fc" id="L4212">                setAppendPosition(partitionSize, false);</span>
            }
        }

<span class="fc" id="L4216">        LOG.debug().$(&quot;o3 partition update [timestampMin=&quot;).$ts(timestampMin)</span>
<span class="fc" id="L4217">                .$(&quot;, timestampMax=&quot;).$ts(timestampMax)</span>
<span class="fc bfc" id="L4218" title="All 2 branches covered.">                .$(&quot;, last=&quot;).$(partitionTimestamp == lastPartitionTimestamp)</span>
<span class="fc" id="L4219">                .$(&quot;, partitionTimestamp=&quot;).$ts(partitionTimestamp)</span>
<span class="fc" id="L4220">                .$(&quot;, srcOooPartitionLo=&quot;).$(srcOooPartitionLo)</span>
<span class="fc" id="L4221">                .$(&quot;, srcOooPartitionHi=&quot;).$(srcOooPartitionHi)</span>
<span class="fc" id="L4222">                .$(&quot;, srcOooMax=&quot;).$(srcOooMax)</span>
<span class="fc" id="L4223">                .$(&quot;, srcDataMax=&quot;).$(srcDataMax)</span>
<span class="fc" id="L4224">                .$(&quot;, partitionMutates=&quot;).$(partitionMutates)</span>
<span class="fc" id="L4225">                .$(&quot;, lastPartitionTimestamp=&quot;).$(lastPartitionTimestamp)</span>
<span class="fc" id="L4226">                .$(&quot;, partitionSize=&quot;).$(partitionSize)</span>
<span class="fc" id="L4227">                .I$();</span>

<span class="fc bfc" id="L4229" title="All 2 branches covered.">        if (partitionMutates) {</span>
<span class="fc" id="L4230">            final long srcDataTxn = txWriter.getPartitionNameTxnByIndex(partitionIndex);</span>
<span class="fc" id="L4231">            LOG.info()</span>
<span class="fc" id="L4232">                    .$(&quot;merged partition [table=`&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L4233">                    .$(&quot;`, ts=&quot;).$ts(partitionTimestamp)</span>
<span class="fc" id="L4234">                    .$(&quot;, txn=&quot;).$(txWriter.txn).I$();</span>
<span class="fc" id="L4235">            txWriter.updatePartitionSizeAndTxnByIndex(partitionIndex, partitionSize);</span>
<span class="fc" id="L4236">            partitionRemoveCandidates.add(partitionTimestamp, srcDataTxn);</span>
<span class="fc" id="L4237">            txWriter.bumpPartitionTableVersion();</span>
<span class="fc" id="L4238">        } else {</span>
<span class="fc bfc" id="L4239" title="All 2 branches covered.">            if (partitionTimestamp != lastPartitionTimestamp) {</span>
<span class="fc" id="L4240">                txWriter.bumpPartitionTableVersion();</span>
            }
<span class="fc" id="L4242">            txWriter.updatePartitionSizeByIndex(partitionIndex, partitionTimestamp, partitionSize);</span>
        }
<span class="fc" id="L4244">    }</span>

    private void o3ProcessPartitionSafe(Sequence partitionSubSeq, long cursor, O3PartitionTask partitionTask) {
        try {
<span class="fc" id="L4248">            O3PartitionJob.processPartition(partitionTask, cursor, partitionSubSeq);</span>
<span class="fc" id="L4249">        } catch (CairoException | CairoError e) {</span>
<span class="fc" id="L4250">            LOG.error().$((Sinkable) e).$();</span>
<span class="nc" id="L4251">        } catch (Throwable e) {</span>
<span class="nc" id="L4252">            LOG.error().$(e).$();</span>
<span class="fc" id="L4253">        }</span>
<span class="fc" id="L4254">    }</span>

    private long o3ScheduleMoveUncommitted0(int timestampIndex, long transientRowsAdded, long committedTransientRowCount) {
<span class="pc bpc" id="L4257" title="1 of 2 branches missed.">        if (transientRowsAdded &gt; 0) {</span>
<span class="fc" id="L4258">            final Sequence pubSeq = this.messageBus.getO3CallbackPubSeq();</span>
<span class="fc" id="L4259">            final RingQueue&lt;O3CallbackTask&gt; queue = this.messageBus.getO3CallbackQueue();</span>
<span class="fc" id="L4260">            o3PendingCallbackTasks.clear();</span>
<span class="fc" id="L4261">            o3DoneLatch.reset();</span>
<span class="fc" id="L4262">            int queuedCount = 0;</span>

<span class="fc bfc" id="L4264" title="All 2 branches covered.">            for (int colIndex = 0; colIndex &lt; columnCount; colIndex++) {</span>
<span class="fc" id="L4265">                int columnType = metadata.getColumnType(colIndex);</span>
<span class="fc bfc" id="L4266" title="All 2 branches covered.">                if (columnType &gt; 0) {</span>
<span class="fc bfc" id="L4267" title="All 2 branches covered.">                    int columnIndex = colIndex != timestampIndex ? colIndex : -colIndex - 1;</span>

<span class="fc" id="L4269">                    long cursor = pubSeq.next();</span>

                    // Pass column index as -1 when it's designated timestamp column to o3 move method
<span class="fc bfc" id="L4272" title="All 2 branches covered.">                    if (cursor &gt; -1) {</span>
                        try {
<span class="fc" id="L4274">                            final O3CallbackTask task = queue.get(cursor);</span>
<span class="fc" id="L4275">                            task.of(</span>
                                    o3DoneLatch,
                                    columnIndex,
                                    columnType,
                                    committedTransientRowCount,
                                    transientRowsAdded,
                                    IGNORE,
                                    IGNORE,
                                    this.o3MoveUncommittedRef
                            );

<span class="fc" id="L4286">                            o3PendingCallbackTasks.add(task);</span>
                        } finally {
<span class="fc" id="L4288">                            queuedCount++;</span>
<span class="fc" id="L4289">                            pubSeq.done(cursor);</span>
<span class="fc" id="L4290">                        }</span>
                    } else {
<span class="fc" id="L4292">                        o3MoveUncommitted0(columnIndex, columnType, committedTransientRowCount, transientRowsAdded, IGNORE, IGNORE);</span>
                    }
                }
            }

<span class="fc bfc" id="L4297" title="All 2 branches covered.">            for (int n = o3PendingCallbackTasks.size() - 1; n &gt; -1; n--) {</span>
<span class="fc" id="L4298">                final O3CallbackTask task = o3PendingCallbackTasks.getQuick(n);</span>
<span class="fc bfc" id="L4299" title="All 2 branches covered.">                if (task.tryLock()) {</span>
<span class="fc" id="L4300">                    O3CallbackJob.runCallbackWithCol(</span>
                            task,
                            -1,
                            null
                    );
                }
            }

<span class="fc" id="L4308">            o3DoneLatch.await(queuedCount);</span>
        }
<span class="fc" id="L4310">        txWriter.resetToLastPartition(committedTransientRowCount);</span>
<span class="fc" id="L4311">        return transientRowsAdded;</span>
    }

    private void o3SetAppendOffset(
            int columnIndex,
            final int columnType,
            long o3RowCount
    ) {
<span class="fc bfc" id="L4319" title="All 2 branches covered.">        if (columnIndex != metadata.getTimestampIndex()) {</span>
<span class="fc" id="L4320">            MemoryARW o3DataMem = o3MemColumns.get(getPrimaryColumnIndex(columnIndex));</span>
<span class="fc" id="L4321">            MemoryARW o3IndexMem = o3MemColumns.get(getSecondaryColumnIndex(columnIndex));</span>

            long size;
<span class="fc bfc" id="L4324" title="All 2 branches covered.">            if (null == o3IndexMem) {</span>
                // Fixed size column
<span class="fc" id="L4326">                size = o3RowCount &lt;&lt; ColumnType.pow2SizeOf(columnType);</span>
            } else {
                // Var size column
<span class="fc bfc" id="L4329" title="All 2 branches covered.">                if (o3RowCount &gt; 0) {</span>
<span class="fc" id="L4330">                    size = o3IndexMem.getLong(o3RowCount * 8);</span>
                } else {
<span class="fc" id="L4332">                    size = 0;</span>
                }
<span class="fc" id="L4334">                o3IndexMem.jumpTo((o3RowCount + 1) * 8);</span>
            }

<span class="fc" id="L4337">            o3DataMem.jumpTo(size);</span>
<span class="fc" id="L4338">        } else {</span>
            // Special case, designated timestamp column
<span class="fc" id="L4340">            o3TimestampMem.jumpTo(o3RowCount * 16);</span>
        }
<span class="fc" id="L4342">    }</span>

    private void o3ShiftLagRowsUp(int timestampIndex, long o3LagRowCount, long o3RowCount, long existingLagRowCount, boolean excludeSymbols) {
<span class="fc" id="L4345">        o3PendingCallbackTasks.clear();</span>

<span class="fc" id="L4347">        final Sequence pubSeq = this.messageBus.getO3CallbackPubSeq();</span>
<span class="fc" id="L4348">        final RingQueue&lt;O3CallbackTask&gt; queue = this.messageBus.getO3CallbackQueue();</span>

<span class="fc" id="L4350">        o3DoneLatch.reset();</span>
<span class="fc" id="L4351">        int queuedCount = 0;</span>
<span class="fc bfc" id="L4352" title="All 2 branches covered.">        long excludeSymbolsL = excludeSymbols ? 1 : 0;</span>
<span class="fc bfc" id="L4353" title="All 2 branches covered.">        for (int colIndex = 0; colIndex &lt; columnCount; colIndex++) {</span>
<span class="fc" id="L4354">            int columnType = metadata.getColumnType(colIndex);</span>
<span class="fc bfc" id="L4355" title="All 2 branches covered.">            int columnIndex = colIndex != timestampIndex ? colIndex : -colIndex - 1;</span>
<span class="fc" id="L4356">            long cursor = pubSeq.next();</span>

            // Pass column index as -1 when it's designated timestamp column to o3 move method
<span class="fc bfc" id="L4359" title="All 4 branches covered.">            if (cursor &gt; -1 &amp;&amp; columnType &gt; 0) {</span>
                try {
<span class="fc" id="L4361">                    final O3CallbackTask task = queue.get(cursor);</span>
<span class="fc" id="L4362">                    task.of(</span>
                            o3DoneLatch,
                            columnIndex,
                            columnType,
                            o3LagRowCount,
                            o3RowCount,
                            existingLagRowCount,
                            excludeSymbolsL,
                            this.o3MoveLagRef
                    );

<span class="fc" id="L4373">                    o3PendingCallbackTasks.add(task);</span>
                } finally {
<span class="fc" id="L4375">                    queuedCount++;</span>
<span class="fc" id="L4376">                    pubSeq.done(cursor);</span>
<span class="fc" id="L4377">                }</span>
<span class="fc bfc" id="L4378" title="All 2 branches covered.">            } else if (columnType &gt; 0) {</span>
<span class="fc" id="L4379">                o3MoveLag0(columnIndex, columnType, o3LagRowCount, o3RowCount, existingLagRowCount, excludeSymbolsL);</span>
            }
        }

<span class="fc bfc" id="L4383" title="All 2 branches covered.">        for (int n = o3PendingCallbackTasks.size() - 1; n &gt; -1; n--) {</span>
<span class="fc" id="L4384">            final O3CallbackTask task = o3PendingCallbackTasks.getQuick(n);</span>
<span class="fc bfc" id="L4385" title="All 2 branches covered.">            if (task.tryLock()) {</span>
<span class="fc" id="L4386">                O3CallbackJob.runCallbackWithCol(</span>
                        task,
                        -1,
                        null
                );
            }
        }

<span class="fc" id="L4394">        o3DoneLatch.await(queuedCount);</span>
<span class="fc" id="L4395">    }</span>

    private void o3Sort(long mergedTimestamps, int timestampIndex, long rowCount) {
<span class="fc" id="L4398">        o3PendingCallbackTasks.clear();</span>

<span class="fc" id="L4400">        final Sequence pubSeq = this.messageBus.getO3CallbackPubSeq();</span>
<span class="fc" id="L4401">        final RingQueue&lt;O3CallbackTask&gt; queue = this.messageBus.getO3CallbackQueue();</span>

<span class="fc" id="L4403">        o3DoneLatch.reset();</span>
<span class="fc" id="L4404">        int queuedCount = 0;</span>
<span class="fc bfc" id="L4405" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L4406">            final int type = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L4407" title="All 4 branches covered.">            if (timestampIndex != i &amp;&amp; type &gt; 0) {</span>
<span class="fc" id="L4408">                long cursor = pubSeq.next();</span>
<span class="fc bfc" id="L4409" title="All 2 branches covered.">                if (cursor &gt; -1) {</span>
                    try {
<span class="fc" id="L4411">                        final O3CallbackTask task = queue.get(cursor);</span>
<span class="fc" id="L4412">                        task.of(</span>
                                o3DoneLatch,
                                i,
                                type,
                                mergedTimestamps,
                                rowCount,
                                IGNORE,
                                IGNORE,
<span class="fc bfc" id="L4420" title="All 2 branches covered.">                                ColumnType.isVariableLength(type) ? oooSortVarColumnRef : oooSortFixColumnRef</span>
                        );
<span class="fc" id="L4422">                        o3PendingCallbackTasks.add(task);</span>
                    } finally {
<span class="fc" id="L4424">                        queuedCount++;</span>
<span class="fc" id="L4425">                        pubSeq.done(cursor);</span>
<span class="fc" id="L4426">                    }</span>
                } else {
<span class="fc" id="L4428">                    o3SortColumn(mergedTimestamps, i, type, rowCount);</span>
                }
            }
        }

<span class="fc bfc" id="L4433" title="All 2 branches covered.">        for (int n = o3PendingCallbackTasks.size() - 1; n &gt; -1; n--) {</span>
<span class="fc" id="L4434">            final O3CallbackTask task = o3PendingCallbackTasks.getQuick(n);</span>
<span class="fc bfc" id="L4435" title="All 2 branches covered.">            if (task.tryLock()) {</span>
<span class="fc" id="L4436">                O3CallbackJob.runCallbackWithCol(</span>
                        task,
                        -1,
                        null
                );
            }
        }

<span class="fc" id="L4444">        o3DoneLatch.await(queuedCount);</span>
<span class="fc" id="L4445">        swapO3ColumnsExcept(timestampIndex);</span>
<span class="fc" id="L4446">    }</span>

    private void o3SortColumn(long mergedTimestamps, int i, int type, long rowCount) {
<span class="fc bfc" id="L4449" title="All 2 branches covered.">        if (ColumnType.isVariableLength(type)) {</span>
<span class="fc" id="L4450">            o3SortVarColumn(i, type, mergedTimestamps, rowCount, IGNORE, IGNORE);</span>
        } else {
<span class="fc" id="L4452">            o3SortFixColumn(i, type, mergedTimestamps, rowCount, IGNORE, IGNORE);</span>
        }
<span class="fc" id="L4454">    }</span>

    private void o3SortFixColumn(
            int columnIndex,
            final int columnType,
            long mergedTimestampsAddr,
            long valueCount,
            long ignore1,
            long ignore2
    ) {
<span class="fc" id="L4464">        final int columnOffset = getPrimaryColumnIndex(columnIndex);</span>
<span class="fc" id="L4465">        final MemoryCR mem = o3Columns.getQuick(columnOffset);</span>
<span class="fc" id="L4466">        final MemoryCARW mem2 = o3MemColumns2.getQuick(columnOffset);</span>
<span class="fc" id="L4467">        final int shl = ColumnType.pow2SizeOf(columnType);</span>
<span class="fc" id="L4468">        final long src = mem.addressOf(0);</span>
<span class="fc" id="L4469">        mem2.jumpTo(valueCount &lt;&lt; shl);</span>
<span class="fc" id="L4470">        final long tgtDataAddr = mem2.addressOf(0);</span>
<span class="pc bpc" id="L4471" title="1 of 7 branches missed.">        switch (shl) {</span>
            case 0:
<span class="fc" id="L4473">                Vect.indexReshuffle8Bit(src, tgtDataAddr, mergedTimestampsAddr, valueCount);</span>
<span class="fc" id="L4474">                break;</span>
            case 1:
<span class="fc" id="L4476">                Vect.indexReshuffle16Bit(src, tgtDataAddr, mergedTimestampsAddr, valueCount);</span>
<span class="fc" id="L4477">                break;</span>
            case 2:
<span class="fc" id="L4479">                Vect.indexReshuffle32Bit(src, tgtDataAddr, mergedTimestampsAddr, valueCount);</span>
<span class="fc" id="L4480">                break;</span>
            case 3:
<span class="fc" id="L4482">                Vect.indexReshuffle64Bit(src, tgtDataAddr, mergedTimestampsAddr, valueCount);</span>
<span class="fc" id="L4483">                break;</span>
            case 4:
<span class="fc" id="L4485">                Vect.indexReshuffle128Bit(src, tgtDataAddr, mergedTimestampsAddr, valueCount);</span>
<span class="fc" id="L4486">                break;</span>
            case 5:
<span class="fc" id="L4488">                Vect.indexReshuffle256Bit(src, tgtDataAddr, mergedTimestampsAddr, valueCount);</span>
<span class="fc" id="L4489">                break;</span>
            default:
<span class="nc" id="L4491">                assert false : &quot;col type is unsupported&quot;;</span>
                break;
        }
<span class="fc" id="L4494">    }</span>

    private void o3SortVarColumn(
            int columnIndex,
            int columnType,
            long mergedTimestampsAddr,
            long valueCount,
            long ignore1,
            long ignore2
    ) {
<span class="fc" id="L4504">        final int primaryIndex = getPrimaryColumnIndex(columnIndex);</span>
<span class="fc" id="L4505">        final int secondaryIndex = primaryIndex + 1;</span>
<span class="fc" id="L4506">        final MemoryCR dataMem = o3Columns.getQuick(primaryIndex);</span>
<span class="fc" id="L4507">        final MemoryCR indexMem = o3Columns.getQuick(secondaryIndex);</span>
<span class="fc" id="L4508">        final MemoryCARW dataMem2 = o3MemColumns2.getQuick(primaryIndex);</span>
<span class="fc" id="L4509">        final MemoryCARW indexMem2 = o3MemColumns2.getQuick(secondaryIndex);</span>
        // ensure we have enough memory allocated
<span class="fc" id="L4511">        final long srcDataAddr = dataMem.addressOf(0);</span>
<span class="fc" id="L4512">        final long srcIndxAddr = indexMem.addressOf(0);</span>
        // exclude the trailing offset from shuffling
<span class="fc" id="L4514">        final long tgtDataAddr = dataMem2.resize(dataMem.size());</span>
<span class="fc" id="L4515">        final long tgtIndxAddr = indexMem2.resize(valueCount * Long.BYTES);</span>

<span class="pc bpc" id="L4517" title="1 of 2 branches missed.">        assert srcDataAddr != 0;</span>
<span class="pc bpc" id="L4518" title="1 of 2 branches missed.">        assert srcIndxAddr != 0;</span>
<span class="pc bpc" id="L4519" title="1 of 2 branches missed.">        assert tgtDataAddr != 0;</span>
<span class="pc bpc" id="L4520" title="1 of 2 branches missed.">        assert tgtIndxAddr != 0;</span>

        // add max offset so that we do not have conditionals inside loop
<span class="fc" id="L4523">        final long offset = Vect.sortVarColumn(</span>
                mergedTimestampsAddr,
                valueCount,
                srcDataAddr,
                srcIndxAddr,
                tgtDataAddr,
                tgtIndxAddr
        );
<span class="fc" id="L4531">        dataMem2.jumpTo(offset);</span>
<span class="fc" id="L4532">        indexMem2.jumpTo(valueCount * Long.BYTES);</span>
<span class="fc" id="L4533">        indexMem2.putLong(offset);</span>
<span class="fc" id="L4534">    }</span>

    private void o3TimestampSetter(long timestamp) {
<span class="fc" id="L4537">        o3TimestampMem.putLong128(timestamp, getO3RowCount0());</span>
<span class="fc" id="L4538">        o3CommitBatchTimestampMin = Math.min(o3CommitBatchTimestampMin, timestamp);</span>
<span class="fc" id="L4539">    }</span>

    private void openColumnFiles(CharSequence name, long columnNameTxn, int columnIndex, int pathTrimToLen) {
<span class="fc" id="L4542">        MemoryMA mem1 = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L4543">        MemoryMA mem2 = getSecondaryColumn(columnIndex);</span>

        try {
<span class="fc" id="L4546">            mem1.of(ff,</span>
<span class="fc" id="L4547">                    dFile(path.trimTo(pathTrimToLen), name, columnNameTxn),</span>
<span class="fc" id="L4548">                    configuration.getDataAppendPageSize(),</span>
                    -1,
                    MemoryTag.MMAP_TABLE_WRITER,
<span class="fc" id="L4551">                    configuration.getWriterFileOpenOpts(),</span>
                    Files.POSIX_MADV_RANDOM
            );
<span class="fc bfc" id="L4554" title="All 2 branches covered.">            if (mem2 != null) {</span>
<span class="fc" id="L4555">                mem2.of(</span>
                        ff,
<span class="fc" id="L4557">                        iFile(path.trimTo(pathTrimToLen), name, columnNameTxn),</span>
<span class="fc" id="L4558">                        configuration.getDataAppendPageSize(),</span>
                        -1,
                        MemoryTag.MMAP_TABLE_WRITER,
<span class="fc" id="L4561">                        configuration.getWriterFileOpenOpts(),</span>
                        Files.POSIX_MADV_RANDOM
                );
            }
        } finally {
<span class="fc" id="L4566">            path.trimTo(pathTrimToLen);</span>
        }
<span class="fc" id="L4568">    }</span>

    private void openFirstPartition(long timestamp) {
<span class="fc" id="L4571">        final long ts = repairDataGaps(timestamp);</span>
<span class="fc" id="L4572">        openPartition(ts);</span>
<span class="fc" id="L4573">        populateDenseIndexerList();</span>
<span class="fc" id="L4574">        setAppendPosition(txWriter.getTransientRowCount(), false);</span>
<span class="fc bfc" id="L4575" title="All 2 branches covered.">        if (performRecovery) {</span>
<span class="fc" id="L4576">            performRecovery();</span>
        }
<span class="fc" id="L4578">        txWriter.openFirstPartition(ts);</span>
<span class="fc" id="L4579">    }</span>

    private void openNewColumnFiles(CharSequence name, boolean indexFlag, int indexValueBlockCapacity) {
        try {
            // open column files
<span class="fc" id="L4584">            long partitionTimestamp = txWriter.getLastPartitionTimestamp();</span>
<span class="fc" id="L4585">            setStateForTimestamp(path, partitionTimestamp, false);</span>
<span class="fc" id="L4586">            final int plen = path.length();</span>
<span class="fc" id="L4587">            final int columnIndex = columnCount - 1;</span>

            // Adding column in the current transaction.
<span class="fc" id="L4590">            long columnNameTxn = getTxn();</span>

            // index must be created before column is initialised because
            // it uses primary column object as temporary tool
<span class="fc bfc" id="L4594" title="All 2 branches covered.">            if (indexFlag) {</span>
<span class="fc" id="L4595">                createIndexFiles(name, columnNameTxn, indexValueBlockCapacity, plen, true);</span>
            }

<span class="fc" id="L4598">            openColumnFiles(name, columnNameTxn, columnIndex, plen);</span>
<span class="fc bfc" id="L4599" title="All 2 branches covered.">            if (txWriter.getTransientRowCount() &gt; 0) {</span>
                // write top offset to column version file
<span class="fc" id="L4601">                columnVersionWriter.upsert(txWriter.getLastPartitionTimestamp(), columnIndex, columnNameTxn, txWriter.getTransientRowCount());</span>
            }

<span class="fc bfc" id="L4604" title="All 2 branches covered.">            if (indexFlag) {</span>
<span class="fc" id="L4605">                ColumnIndexer indexer = indexers.getQuick(columnIndex);</span>
<span class="pc bpc" id="L4606" title="1 of 2 branches missed.">                assert indexer != null;</span>
<span class="fc" id="L4607">                indexers.getQuick(columnIndex).configureFollowerAndWriter(configuration, path.trimTo(plen), name, columnNameTxn, getPrimaryColumn(columnIndex), txWriter.getTransientRowCount());</span>
            }

            // configure append position for variable length columns
<span class="fc" id="L4611">            MemoryMA mem2 = getSecondaryColumn(columnCount - 1);</span>
<span class="fc bfc" id="L4612" title="All 2 branches covered.">            if (mem2 != null) {</span>
<span class="fc" id="L4613">                mem2.putLong(0);</span>
            }
        } finally {
<span class="fc" id="L4616">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L4618">    }</span>

    private void openPartition(long timestamp) {
        try {
<span class="fc" id="L4622">            setStateForTimestamp(path, timestamp, true);</span>
<span class="fc" id="L4623">            int plen = path.length();</span>
<span class="fc bfc" id="L4624" title="All 2 branches covered.">            if (ff.mkdirs(path.slash$(), mkDirMode) != 0) {</span>
<span class="fc" id="L4625">                throw CairoException.critical(ff.errno()).put(&quot;Cannot create directory: &quot;).put(path);</span>
            }

<span class="pc bpc" id="L4628" title="1 of 2 branches missed.">            assert columnCount &gt; 0;</span>

<span class="fc" id="L4630">            lastOpenPartitionTs = txWriter.getPartitionTimestampLo(timestamp);</span>
<span class="fc bfc" id="L4631" title="All 4 branches covered.">            lastOpenPartitionIsReadOnly = partitionBy != PartitionBy.NONE &amp;&amp; txWriter.isPartitionReadOnlyByPartitionTimestamp(lastOpenPartitionTs);</span>

<span class="fc bfc" id="L4633" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L4634" title="All 2 branches covered.">                if (metadata.getColumnType(i) &gt; 0) {</span>
<span class="fc" id="L4635">                    final CharSequence name = metadata.getColumnName(i);</span>
<span class="fc" id="L4636">                    long columnNameTxn = columnVersionWriter.getColumnNameTxn(lastOpenPartitionTs, i);</span>
<span class="fc bfc" id="L4637" title="All 2 branches covered.">                    final ColumnIndexer indexer = metadata.isColumnIndexed(i) ? indexers.getQuick(i) : null;</span>
                    final long columnTop;

                    // prepare index writer if column requires indexing
<span class="fc bfc" id="L4641" title="All 2 branches covered.">                    if (indexer != null) {</span>
                        // we have to create files before columns are open
                        // because we are reusing MAMemoryImpl object from columns list
<span class="fc bfc" id="L4644" title="All 2 branches covered.">                        createIndexFiles(name, columnNameTxn, metadata.getIndexValueBlockCapacity(i), plen, txWriter.getTransientRowCount() &lt; 1);</span>
<span class="fc" id="L4645">                        indexer.closeSlider();</span>
                    }

<span class="fc" id="L4648">                    openColumnFiles(name, columnNameTxn, i, plen);</span>
<span class="fc" id="L4649">                    columnTop = columnVersionWriter.getColumnTopQuick(lastOpenPartitionTs, i);</span>
<span class="fc" id="L4650">                    columnTops.extendAndSet(i, columnTop);</span>

<span class="fc bfc" id="L4652" title="All 2 branches covered.">                    if (indexer != null) {</span>
<span class="fc" id="L4653">                        indexer.configureFollowerAndWriter(configuration, path, name, columnNameTxn, getPrimaryColumn(i), columnTop);</span>
                    }
                }
            }
<span class="fc" id="L4657">            populateDenseIndexerList();</span>
<span class="fc" id="L4658">            LOG.info().$(&quot;switched partition [path='&quot;).utf8(path).$('\'').I$();</span>
<span class="fc" id="L4659">        } catch (Throwable e) {</span>
<span class="fc" id="L4660">            distressed = true;</span>
<span class="fc" id="L4661">            throw e;</span>
        } finally {
<span class="fc" id="L4663">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L4665">    }</span>

    private long openTodoMem() {
<span class="fc" id="L4668">        path.concat(TODO_FILE_NAME).$();</span>
        try {
<span class="fc bfc" id="L4670" title="All 2 branches covered.">            if (ff.exists(path)) {</span>
<span class="fc" id="L4671">                long fileLen = ff.length(path);</span>
<span class="fc bfc" id="L4672" title="All 2 branches covered.">                if (fileLen &lt; 32) {</span>
<span class="fc" id="L4673">                    throw CairoException.critical(0).put(&quot;corrupt &quot;).put(path);</span>
                }

<span class="fc" id="L4676">                todoMem.smallFile(ff, path, MemoryTag.MMAP_TABLE_WRITER);</span>
<span class="fc" id="L4677">                this.todoTxn = todoMem.getLong(0);</span>
                // check if _todo_ file is consistent, if not, we just ignore its contents and reset hash
<span class="pc bpc" id="L4679" title="1 of 2 branches missed.">                if (todoMem.getLong(24) != todoTxn) {</span>
<span class="nc" id="L4680">                    todoMem.putLong(8, configuration.getDatabaseIdLo());</span>
<span class="nc" id="L4681">                    todoMem.putLong(16, configuration.getDatabaseIdHi());</span>
<span class="nc" id="L4682">                    Unsafe.getUnsafe().storeFence();</span>
<span class="nc" id="L4683">                    todoMem.putLong(24, todoTxn);</span>
<span class="nc" id="L4684">                    return 0;</span>
                }

<span class="fc" id="L4687">                return todoMem.getLong(32);</span>
            } else {
<span class="fc" id="L4689">                TableUtils.resetTodoLog(ff, path, rootLen, todoMem);</span>
<span class="fc" id="L4690">                todoTxn = 0;</span>
<span class="fc" id="L4691">                return 0;</span>
            }
        } finally {
<span class="fc" id="L4694">            path.trimTo(rootLen);</span>
        }
    }

    private void performRecovery() {
<span class="fc" id="L4699">        rollbackIndexes();</span>
<span class="fc" id="L4700">        rollbackSymbolTables();</span>
<span class="fc" id="L4701">        performRecovery = false;</span>
<span class="fc" id="L4702">    }</span>

    private void populateDenseIndexerList() {
<span class="fc" id="L4705">        denseIndexers.clear();</span>
<span class="fc bfc" id="L4706" title="All 2 branches covered.">        for (int i = 0, n = indexers.size(); i &lt; n; i++) {</span>
<span class="fc" id="L4707">            ColumnIndexer indexer = indexers.getQuick(i);</span>
<span class="fc bfc" id="L4708" title="All 2 branches covered.">            if (indexer != null) {</span>
<span class="fc" id="L4709">                denseIndexers.add(indexer);</span>
            }
        }
<span class="fc" id="L4712">        indexCount = denseIndexers.size();</span>
<span class="fc" id="L4713">    }</span>

    private void processAsyncWriterCommand(
            AsyncWriterCommand asyncWriterCommand,
            TableWriterTask cmd,
            long cursor,
            Sequence sequence,
            boolean contextAllowsAnyStructureChanges
    ) {
<span class="fc" id="L4722">        final int cmdType = cmd.getType();</span>
<span class="fc" id="L4723">        final long correlationId = cmd.getInstance();</span>
<span class="fc" id="L4724">        final long tableId = cmd.getTableId();</span>

<span class="fc" id="L4726">        int errorCode = 0;</span>
<span class="fc" id="L4727">        CharSequence errorMsg = null;</span>
<span class="fc" id="L4728">        long affectedRowsCount = 0;</span>
        try {
<span class="fc" id="L4730">            publishTableWriterEvent(cmdType, tableId, correlationId, AsyncWriterCommand.Error.OK, null, 0L, TSK_BEGIN);</span>
<span class="fc" id="L4731">            LOG.info()</span>
<span class="fc" id="L4732">                    .$(&quot;received async cmd [type=&quot;).$(cmdType)</span>
<span class="fc" id="L4733">                    .$(&quot;, tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L4734">                    .$(&quot;, tableId=&quot;).$(tableId)</span>
<span class="fc" id="L4735">                    .$(&quot;, correlationId=&quot;).$(correlationId)</span>
<span class="fc" id="L4736">                    .$(&quot;, cursor=&quot;).$(cursor)</span>
<span class="fc" id="L4737">                    .I$();</span>
<span class="fc" id="L4738">            asyncWriterCommand = asyncWriterCommand.deserialize(cmd);</span>
<span class="fc" id="L4739">            affectedRowsCount = asyncWriterCommand.apply(this, contextAllowsAnyStructureChanges);</span>
<span class="fc" id="L4740">        } catch (TableReferenceOutOfDateException ex) {</span>
<span class="fc" id="L4741">            LOG.info()</span>
<span class="fc" id="L4742">                    .$(&quot;cannot complete async cmd, reader is out of date [type=&quot;).$(cmdType)</span>
<span class="fc" id="L4743">                    .$(&quot;, tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L4744">                    .$(&quot;, tableId=&quot;).$(tableId)</span>
<span class="fc" id="L4745">                    .$(&quot;, correlationId=&quot;).$(correlationId)</span>
<span class="fc" id="L4746">                    .I$();</span>
<span class="fc" id="L4747">            errorCode = READER_OUT_OF_DATE;</span>
<span class="fc" id="L4748">            errorMsg = ex.getMessage();</span>
<span class="fc" id="L4749">        } catch (AlterTableContextException ex) {</span>
<span class="fc" id="L4750">            LOG.info()</span>
<span class="fc" id="L4751">                    .$(&quot;cannot complete async cmd, table structure change is not allowed [type=&quot;).$(cmdType)</span>
<span class="fc" id="L4752">                    .$(&quot;, tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L4753">                    .$(&quot;, tableId=&quot;).$(tableId)</span>
<span class="fc" id="L4754">                    .$(&quot;, correlationId=&quot;).$(correlationId)</span>
<span class="fc" id="L4755">                    .I$();</span>
<span class="fc" id="L4756">            errorCode = STRUCTURE_CHANGE_NOT_ALLOWED;</span>
<span class="fc" id="L4757">            errorMsg = &quot;async cmd cannot change table structure while writer is busy&quot;;</span>
<span class="fc" id="L4758">        } catch (CairoException ex) {</span>
<span class="fc" id="L4759">            errorCode = CAIRO_ERROR;</span>
<span class="fc" id="L4760">            errorMsg = ex.getFlyweightMessage();</span>
<span class="fc" id="L4761">        } catch (Throwable ex) {</span>
<span class="fc" id="L4762">            LOG.error().$(&quot;error on processing async cmd [type=&quot;).$(cmdType)</span>
<span class="fc" id="L4763">                    .$(&quot;, tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L4764">                    .$(&quot;, ex=&quot;).$(ex)</span>
<span class="fc" id="L4765">                    .I$();</span>
<span class="fc" id="L4766">            errorCode = UNEXPECTED_ERROR;</span>
<span class="fc" id="L4767">            errorMsg = ex.getMessage();</span>
        } finally {
<span class="fc" id="L4769">            sequence.done(cursor);</span>
        }
<span class="fc" id="L4771">        publishTableWriterEvent(cmdType, tableId, correlationId, errorCode, errorMsg, affectedRowsCount, TSK_COMPLETE);</span>
<span class="fc" id="L4772">    }</span>

    private void processCommandQueue(boolean contextAllowsAnyStructureChanges) {
        long cursor;
<span class="fc bfc" id="L4776" title="All 2 branches covered.">        while ((cursor = commandSubSeq.next()) &gt; -1) {</span>
<span class="fc" id="L4777">            TableWriterTask cmd = commandQueue.get(cursor);</span>
<span class="fc" id="L4778">            processCommandQueue(cmd, commandSubSeq, cursor, contextAllowsAnyStructureChanges);</span>
<span class="fc" id="L4779">        }</span>
<span class="fc" id="L4780">    }</span>

    private void processO3Block(
            final long o3LagRowCount,
            int timestampIndex,
            long sortedTimestampsAddr,
            final long srcOooMax,
            long o3TimestampMin,
            long o3TimestampMax,
            boolean flattenTimestamp,
            long rowLo
    ) {
<span class="fc" id="L4792">        o3ErrorCount.set(0);</span>
<span class="fc" id="L4793">        partitionRemoveCandidates.clear();</span>
<span class="fc" id="L4794">        o3ColumnCounters.clear();</span>
<span class="fc" id="L4795">        o3BasketPool.clear();</span>

        // move uncommitted is liable to change max timestamp
        // however we need to identify last partition before max timestamp skips to NULL for example
<span class="fc" id="L4799">        final long maxTimestamp = txWriter.getMaxTimestamp();</span>
<span class="fc" id="L4800">        final long transientRowCount = txWriter.transientRowCount;</span>

<span class="fc" id="L4802">        o3DoneLatch.reset();</span>
<span class="fc" id="L4803">        o3PartitionUpdRemaining.set(0L);</span>
<span class="fc" id="L4804">        boolean success = true;</span>
<span class="fc" id="L4805">        int latchCount = 0;</span>
<span class="fc" id="L4806">        long srcOoo = rowLo;</span>
<span class="fc" id="L4807">        int pCount = 0;</span>
        try {
            // We do not know upfront which partition is going to be last because this is
            // a single pass over the data. Instead, we will update transient row count in a rolling
            // manner, assuming the partition marked &quot;last&quot; is the last and then for a new partition
            // we move prevTransientRowCount into the &quot;fixedRowCount&quot; sum and set new value on the
            // transientRowCount
<span class="fc" id="L4814">            long commitTransientRowCount = transientRowCount;</span>

<span class="fc" id="L4816">            resizeColumnTopSink(o3TimestampMin, o3TimestampMax);</span>
<span class="fc" id="L4817">            resizePartitionUpdateSink(o3TimestampMin, o3TimestampMax);</span>

            // One loop iteration per partition.
<span class="fc bfc" id="L4820" title="All 2 branches covered.">            while (srcOoo &lt; srcOooMax) {</span>
                try {
<span class="fc" id="L4822">                    final long srcOooLo = srcOoo;</span>
<span class="fc" id="L4823">                    final long o3Timestamp = getTimestampIndexValue(sortedTimestampsAddr, srcOoo);</span>
                    final long srcOooHi;
                    // keep ceil inclusive in the interval
<span class="fc" id="L4826">                    final long srcOooTimestampCeil = partitionCeilMethod.ceil(o3Timestamp) - 1;</span>
<span class="fc bfc" id="L4827" title="All 2 branches covered.">                    if (srcOooTimestampCeil &lt; o3TimestampMax) {</span>
<span class="fc" id="L4828">                        srcOooHi = Vect.boundedBinarySearchIndexT(</span>
                                sortedTimestampsAddr,
                                srcOooTimestampCeil,
                                srcOooLo,
                                srcOooMax - 1,
                                BinarySearch.SCAN_DOWN
                        );
                    } else {
<span class="fc" id="L4836">                        srcOooHi = srcOooMax - 1;</span>
                    }

<span class="fc" id="L4839">                    final long partitionTimestamp = partitionFloorMethod.floor(o3Timestamp);</span>

                    // This partition is the last partition.
<span class="fc bfc" id="L4842" title="All 2 branches covered.">                    final boolean last = partitionTimestamp == lastPartitionTimestamp;</span>

<span class="fc" id="L4844">                    srcOoo = srcOooHi + 1;</span>

                    final long srcDataMax;
                    final long srcNameTxn;
<span class="fc" id="L4848">                    final int partitionIndex = txWriter.findAttachedPartitionIndexByLoTimestamp(partitionTimestamp);</span>
<span class="fc bfc" id="L4849" title="All 2 branches covered.">                    if (partitionIndex &gt; -1) {</span>
<span class="fc bfc" id="L4850" title="All 2 branches covered.">                        if (last) {</span>
<span class="fc" id="L4851">                            srcDataMax = transientRowCount;</span>
                        } else {
<span class="fc" id="L4853">                            srcDataMax = getPartitionSizeByIndex(partitionIndex);</span>
                        }
<span class="fc" id="L4855">                        srcNameTxn = getPartitionNameTxnByIndex(partitionIndex);</span>
                    } else {
<span class="fc" id="L4857">                        srcDataMax = 0;</span>
                        // A version needed to housekeep dropped partitions
                        // When partition created without O3 merge, use `txn-1` as partition version.
                        // `txn` version is used when partition is merged. Both `txn-1` and `txn` can
                        // be written within the same commit when new partition initially written in order
                        // and then O3 triggers a merge of the partition.
<span class="fc" id="L4863">                        srcNameTxn = txWriter.getTxn() - 1;</span>
                    }

                    // We're appending onto the last (active) partition.
<span class="fc bfc" id="L4867" title="All 6 branches covered.">                    final boolean append = last &amp;&amp; (srcDataMax == 0 || o3Timestamp &gt;= maxTimestamp);</span>

                    // Number of rows to insert from the O3 segment into this partition.
<span class="fc" id="L4870">                    final long srcOooBatchRowSize = srcOooHi - srcOooLo + 1;</span>

                    // Final partition size after current insertions.
<span class="fc" id="L4873">                    final long partitionSize = srcDataMax + srcOooBatchRowSize;</span>

                    // check partition read-only state
<span class="fc" id="L4876">                    final boolean partitionIsReadOnly = txWriter.isPartitionReadOnlyByPartitionTimestamp(partitionTimestamp);</span>

<span class="fc" id="L4878">                    pCount++;</span>

<span class="fc" id="L4880">                    LOG.info().</span>
<span class="fc" id="L4881">                            $(&quot;o3 partition task [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L4882">                            .$(&quot;, partitionIsReadOnly=&quot;).$(partitionIsReadOnly)</span>
<span class="fc" id="L4883">                            .$(&quot;, srcOooBatchRowSize=&quot;).$(srcOooBatchRowSize)</span>
<span class="fc" id="L4884">                            .$(&quot;, srcOooLo=&quot;).$(srcOooLo)</span>
<span class="fc" id="L4885">                            .$(&quot;, srcOooHi=&quot;).$(srcOooHi)</span>
<span class="fc" id="L4886">                            .$(&quot;, srcOooMax=&quot;).$(srcOooMax)</span>
<span class="fc" id="L4887">                            .$(&quot;, o3RowCount=&quot;).$(o3RowCount)</span>
<span class="fc" id="L4888">                            .$(&quot;, o3LagRowCount=&quot;).$(o3LagRowCount)</span>
<span class="fc" id="L4889">                            .$(&quot;, srcDataMax=&quot;).$(srcDataMax)</span>
<span class="fc" id="L4890">                            .$(&quot;, o3TimestampMin=&quot;).$ts(o3TimestampMin)</span>
<span class="fc" id="L4891">                            .$(&quot;, o3Timestamp=&quot;).$ts(o3Timestamp)</span>
<span class="fc" id="L4892">                            .$(&quot;, o3TimestampMax=&quot;).$ts(o3TimestampMax)</span>
<span class="fc" id="L4893">                            .$(&quot;, partitionTimestamp=&quot;).$ts(partitionTimestamp)</span>
<span class="fc" id="L4894">                            .$(&quot;, partitionIndex=&quot;).$(partitionIndex)</span>
<span class="fc" id="L4895">                            .$(&quot;, partitionSize=&quot;).$(partitionSize)</span>
<span class="fc" id="L4896">                            .$(&quot;, maxTimestamp=&quot;).$ts(maxTimestamp)</span>
<span class="fc" id="L4897">                            .$(&quot;, last=&quot;).$(last)</span>
<span class="fc" id="L4898">                            .$(&quot;, append=&quot;).$(append)</span>
<span class="fc" id="L4899">                            .$(&quot;, pCount=&quot;).$(pCount)</span>
<span class="fc" id="L4900">                            .$(&quot;, flattenTimestamp=&quot;).$(flattenTimestamp)</span>
<span class="fc" id="L4901">                            .$(&quot;, memUsed=&quot;).$(Unsafe.getMemUsed())</span>
<span class="fc" id="L4902">                            .I$();</span>

<span class="fc bfc" id="L4904" title="All 2 branches covered.">                    if (partitionIsReadOnly) {</span>
                        // move over read-only partitions
<span class="fc" id="L4906">                        LOG.critical()</span>
<span class="fc" id="L4907">                                .$(&quot;o3 ignoring write on read-only partition [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L4908">                                .$(&quot;, timestamp=&quot;).$ts(partitionTimestamp)</span>
<span class="fc" id="L4909">                                .$(&quot;, numRows=&quot;).$(srcOooBatchRowSize)</span>
<span class="fc" id="L4910">                                .$();</span>
<span class="fc" id="L4911">                        continue;</span>
                    }

<span class="fc bfc" id="L4914" title="All 2 branches covered.">                    if (partitionTimestamp &lt; lastPartitionTimestamp) {</span>
                        // increment fixedRowCount by number of rows old partition incremented
<span class="fc" id="L4916">                        this.txWriter.fixedRowCount += srcOooBatchRowSize;</span>
<span class="fc bfc" id="L4917" title="All 2 branches covered.">                    } else if (partitionTimestamp == lastPartitionTimestamp) {</span>
                        // this is existing &quot;last&quot; partition, we can set the size directly
<span class="fc" id="L4919">                        commitTransientRowCount = partitionSize;</span>
                    } else {
                        // this is potentially a new last partition
<span class="fc" id="L4922">                        this.txWriter.fixedRowCount += commitTransientRowCount;</span>
<span class="fc" id="L4923">                        commitTransientRowCount = partitionSize;</span>
                    }

<span class="fc" id="L4926">                    o3PartitionUpdRemaining.incrementAndGet();</span>
<span class="fc" id="L4927">                    final O3Basket o3Basket = o3BasketPool.next();</span>
<span class="fc" id="L4928">                    o3Basket.ensureCapacity(columnCount, indexCount);</span>

<span class="fc" id="L4930">                    AtomicInteger columnCounter = o3ColumnCounters.next();</span>

                    // async partition processing set this counter to the column count
                    // and then manages issues if publishing of column tasks fails
                    // mid-column-count.
<span class="fc" id="L4935">                    latchCount++;</span>

<span class="fc bfc" id="L4937" title="All 2 branches covered.">                    if (append) {</span>
                        // we are appending last partition, make sure it has been mapped!
                        // this also might fail, make sure exception is trapped and partitions are
                        // counted down correctly
                        try {
<span class="fc" id="L4942">                            setAppendPosition(srcDataMax, false);</span>
<span class="nc" id="L4943">                        } catch (Throwable e) {</span>
<span class="nc" id="L4944">                            o3BumpErrorCount();</span>
<span class="nc" id="L4945">                            o3ClockDownPartitionUpdateCount();</span>
<span class="nc" id="L4946">                            o3CountDownDoneLatch();</span>
<span class="nc" id="L4947">                            throw e;</span>
<span class="fc" id="L4948">                        }</span>

<span class="fc" id="L4950">                        columnCounter.set(TableUtils.compressColumnCount(metadata));</span>
<span class="fc" id="L4951">                        Path pathToPartition = Path.getThreadLocal(path);</span>
<span class="fc" id="L4952">                        TableUtils.setPathForPartition(pathToPartition, partitionBy, o3TimestampMin, false);</span>
<span class="fc" id="L4953">                        TableUtils.txnPartitionConditionally(pathToPartition, srcNameTxn);</span>
<span class="fc" id="L4954">                        final int plen = pathToPartition.length();</span>
<span class="fc" id="L4955">                        int columnsPublished = 0;</span>
<span class="fc bfc" id="L4956" title="All 2 branches covered.">                        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L4957">                            final int columnType = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L4958" title="All 2 branches covered.">                            if (columnType &lt; 0) {</span>
<span class="fc" id="L4959">                                continue;</span>
                            }
<span class="fc" id="L4961">                            final int colOffset = TableWriter.getPrimaryColumnIndex(i);</span>
<span class="fc bfc" id="L4962" title="All 2 branches covered.">                            final boolean notTheTimestamp = i != timestampIndex;</span>
<span class="fc" id="L4963">                            final CharSequence columnName = metadata.getColumnName(i);</span>
<span class="fc bfc" id="L4964" title="All 2 branches covered.">                            final int indexBlockCapacity = metadata.isColumnIndexed(i) ? metadata.getIndexValueBlockCapacity(i) : -1;</span>
<span class="fc bfc" id="L4965" title="All 2 branches covered.">                            final BitmapIndexWriter indexWriter = indexBlockCapacity &gt; -1 ? getBitmapIndexWriter(i) : null;</span>
<span class="fc" id="L4966">                            final MemoryR oooMem1 = o3Columns.getQuick(colOffset);</span>
<span class="fc" id="L4967">                            final MemoryR oooMem2 = o3Columns.getQuick(colOffset + 1);</span>
<span class="fc" id="L4968">                            final MemoryMA mem1 = columns.getQuick(colOffset);</span>
<span class="fc" id="L4969">                            final MemoryMA mem2 = columns.getQuick(colOffset + 1);</span>
<span class="fc" id="L4970">                            final long srcDataTop = getColumnTop(i);</span>
                            final long srcOooFixAddr;
                            final long srcOooVarAddr;
                            final MemoryMA dstFixMem;
                            final MemoryMA dstVarMem;
<span class="fc bfc" id="L4975" title="All 2 branches covered.">                            if (!ColumnType.isVariableLength(columnType)) {</span>
<span class="fc" id="L4976">                                srcOooFixAddr = oooMem1.addressOf(0);</span>
<span class="fc" id="L4977">                                srcOooVarAddr = 0;</span>
<span class="fc" id="L4978">                                dstFixMem = mem1;</span>
<span class="fc" id="L4979">                                dstVarMem = null;</span>
                            } else {
<span class="fc" id="L4981">                                srcOooFixAddr = oooMem2.addressOf(0);</span>
<span class="fc" id="L4982">                                srcOooVarAddr = oooMem1.addressOf(0);</span>
<span class="fc" id="L4983">                                dstFixMem = mem2;</span>
<span class="fc" id="L4984">                                dstVarMem = mem1;</span>
                            }

<span class="fc" id="L4987">                            columnsPublished++;</span>
                            try {
<span class="fc" id="L4989">                                O3OpenColumnJob.appendLastPartition(</span>
                                        pathToPartition,
                                        plen,
                                        columnName,
                                        columnCounter,
<span class="fc bfc" id="L4994" title="All 2 branches covered.">                                        notTheTimestamp ? columnType : ColumnType.setDesignatedTimestampBit(columnType, true),</span>
                                        srcOooFixAddr,
                                        srcOooVarAddr,
                                        srcOooLo,
                                        srcOooHi,
                                        srcOooMax,
                                        o3TimestampMin,
                                        o3TimestampMax,
                                        partitionTimestamp,
                                        srcDataTop,
                                        srcDataMax,
                                        indexBlockCapacity,
                                        dstFixMem,
                                        dstVarMem,
                                        this,
                                        indexWriter,
<span class="fc" id="L5010">                                        getColumnNameTxn(partitionTimestamp, i)</span>
                                );
<span class="nc" id="L5012">                            } catch (Throwable e) {</span>
<span class="nc bnc" id="L5013" title="All 2 branches missed.">                                if (columnCounter.addAndGet(columnsPublished - columnCount) == 0) {</span>
<span class="nc" id="L5014">                                    o3ClockDownPartitionUpdateCount();</span>
<span class="nc" id="L5015">                                    o3CountDownDoneLatch();</span>
                                }
<span class="nc" id="L5017">                                throw e;</span>
<span class="fc" id="L5018">                            }</span>
                        }

<span class="fc" id="L5021">                        addPhysicallyWrittenRows(srcOooBatchRowSize);</span>
<span class="fc" id="L5022">                    } else {</span>
<span class="pc bpc" id="L5023" title="1 of 4 branches missed.">                        if (flattenTimestamp &amp;&amp; o3RowCount &gt; 0) {</span>
<span class="fc" id="L5024">                            Vect.flattenIndex(sortedTimestampsAddr, o3RowCount);</span>
<span class="fc" id="L5025">                            flattenTimestamp = false;</span>
                        }

                        // To collect column top values from o3 partition tasks add them to pre-allocated array of longs
                        // use o3ColumnTopSink LongList and allocate columns + 1 longs per partition
                        // then set first value to partition timestamp
<span class="fc" id="L5031">                        long colTopSinkIndex = (long) (pCount - 1) * (metadata.getColumnCount() + 1);</span>
<span class="fc" id="L5032">                        long columnTopSinkAddress = colTopSinkIndex * Long.BYTES;</span>
<span class="fc" id="L5033">                        long columnTopPartitionSinkAddr = o3ColumnTopSink.getAddress() + columnTopSinkAddress;</span>
<span class="pc bpc" id="L5034" title="1 of 2 branches missed.">                        assert columnTopPartitionSinkAddr + (columnCount + 1L) * Long.BYTES &lt;= o3ColumnTopSink.getAddress() + o3ColumnTopSink.size() * Long.BYTES;</span>

<span class="fc" id="L5036">                        o3ColumnTopSink.set(colTopSinkIndex, partitionTimestamp);</span>
<span class="fc" id="L5037">                        o3CommitPartitionAsync(</span>
                                columnCounter,
                                maxTimestamp,
                                sortedTimestampsAddr,
                                srcOooMax,
                                o3TimestampMin,
                                o3TimestampMax,
                                srcOooLo,
                                srcOooHi,
                                partitionTimestamp,
                                last,
                                srcDataMax,
                                srcNameTxn,
                                o3Basket,
                                columnTopPartitionSinkAddr + Long.BYTES
                        );
                    }
<span class="fc" id="L5054">                } catch (CairoException | CairoError e) {</span>
<span class="fc" id="L5055">                    LOG.error().$((Sinkable) e).$();</span>
<span class="fc" id="L5056">                    success = false;</span>
<span class="fc" id="L5057">                    throw e;</span>
<span class="fc" id="L5058">                }</span>
            } // end while(srcOoo &lt; srcOooMax)

            // at this point we should know the last partition row count
<span class="fc" id="L5062">            this.txWriter.transientRowCount = commitTransientRowCount;</span>
<span class="fc" id="L5063">            this.partitionTimestampHi = Math.max(this.partitionTimestampHi, o3TimestampMax);</span>
<span class="fc" id="L5064">            this.txWriter.updateMaxTimestamp(Math.max(txWriter.getMaxTimestamp(), o3TimestampMax));</span>
<span class="fc" id="L5065">        } catch (Throwable th) {</span>
<span class="fc" id="L5066">            LOG.error().$(th).$();</span>
<span class="fc" id="L5067">            throw th;</span>
        } finally {
            // we are stealing work here it is possible we get exception from this method
<span class="fc" id="L5070">            LOG.debug()</span>
<span class="fc" id="L5071">                    .$(&quot;o3 expecting updates [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L5072">                    .$(&quot;, partitionsPublished=&quot;).$(pCount)</span>
<span class="fc" id="L5073">                    .I$();</span>

<span class="fc" id="L5075">            o3ConsumePartitionUpdates();</span>
<span class="fc" id="L5076">            o3DoneLatch.await(latchCount);</span>

<span class="fc bfc" id="L5078" title="All 4 branches covered.">            o3InError = !success || o3ErrorCount.get() &gt; 0;</span>
<span class="fc bfc" id="L5079" title="All 4 branches covered.">            if (success &amp;&amp; o3ErrorCount.get() &gt; 0) {</span>
                //noinspection ThrowFromFinallyBlock
<span class="fc" id="L5081">                throw CairoException.critical(0).put(&quot;bulk update failed and will be rolled back&quot;);</span>
            }
        }

<span class="fc bfc" id="L5085" title="All 2 branches covered.">        if (o3LagRowCount &gt; 0) {</span>
<span class="fc" id="L5086">            o3ShiftLagRowsUp(timestampIndex, o3LagRowCount, srcOooMax, 0L, false);</span>
        }
<span class="fc" id="L5088">    }</span>

    private void processPartitionRemoveCandidates() {
        try {
<span class="fc" id="L5092">            final int n = partitionRemoveCandidates.size();</span>
<span class="fc bfc" id="L5093" title="All 2 branches covered.">            if (n &gt; 0) {</span>
<span class="fc" id="L5094">                processPartitionRemoveCandidates0(n);</span>
            }
        } finally {
<span class="fc" id="L5097">            partitionRemoveCandidates.clear();</span>
        }
<span class="fc" id="L5099">    }</span>

    private void processPartitionRemoveCandidates0(int n) {
<span class="fc" id="L5102">        boolean anyReadersBeforeCommittedTxn = checkScoreboardHasReadersBeforeLastCommittedTxn();</span>
        // This flag will determine to schedule O3PartitionPurgeJob at the end or all done already.
<span class="fc" id="L5104">        boolean scheduleAsyncPurge = anyReadersBeforeCommittedTxn;</span>

<span class="fc bfc" id="L5106" title="All 2 branches covered.">        if (!anyReadersBeforeCommittedTxn) {</span>
<span class="fc bfc" id="L5107" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i += 2) {</span>
                try {
<span class="fc" id="L5109">                    final long timestamp = partitionRemoveCandidates.getQuick(i);</span>
<span class="fc" id="L5110">                    final long txn = partitionRemoveCandidates.getQuick(i + 1);</span>
<span class="fc" id="L5111">                    setPathForPartition(</span>
                            other,
                            partitionBy,
                            timestamp,
                            false
                    );
<span class="fc" id="L5117">                    TableUtils.txnPartitionConditionally(other, txn);</span>
<span class="fc" id="L5118">                    other.$();</span>
<span class="fc" id="L5119">                    int errno = ff.unlinkOrRemove(other, LOG);</span>
<span class="fc bfc" id="L5120" title="All 4 branches covered.">                    if (!(errno == 0 || errno == -1)) {</span>
<span class="fc" id="L5121">                        LOG.info()</span>
<span class="fc" id="L5122">                                .$(&quot;could not purge partition version, async purge will be scheduled [path=&quot;)</span>
<span class="fc" id="L5123">                                .utf8(other)</span>
<span class="fc" id="L5124">                                .$(&quot;, errno=&quot;).$(errno).I$();</span>
<span class="fc" id="L5125">                        scheduleAsyncPurge = true;</span>
                    }
                } finally {
<span class="fc" id="L5128">                    other.trimTo(rootLen);</span>
                }
            }
        }

<span class="fc bfc" id="L5133" title="All 2 branches covered.">        if (scheduleAsyncPurge) {</span>
            // Any more complicated case involve looking at what folders are present on disk before removing
            // do it async in O3PartitionPurgeJob
<span class="fc bfc" id="L5136" title="All 2 branches covered.">            if (schedulePurgeO3Partitions(messageBus, tableToken, partitionBy)) {</span>
<span class="fc" id="L5137">                LOG.info().$(&quot;scheduled to purge partitions [table=&quot;).utf8(tableToken.getTableName()).I$();</span>
            } else {
<span class="fc" id="L5139">                LOG.error().$(&quot;could not queue for purge, queue is full [table=&quot;).utf8(tableToken.getTableName()).I$();</span>
            }
        }
<span class="fc" id="L5142">    }</span>

    private void publishTableWriterEvent(int cmdType, long tableId, long correlationId, int errorCode, CharSequence errorMsg, long affectedRowsCount, int eventType) {
        long pubCursor;
        do {
<span class="fc" id="L5147">            pubCursor = messageBus.getTableWriterEventPubSeq().next();</span>
<span class="pc bpc" id="L5148" title="1 of 2 branches missed.">            if (pubCursor == -2) {</span>
<span class="nc" id="L5149">                Os.pause();</span>
            }
<span class="pc bpc" id="L5151" title="1 of 2 branches missed.">        } while (pubCursor &lt; -1);</span>

<span class="fc bfc" id="L5153" title="All 2 branches covered.">        if (pubCursor &gt; -1) {</span>
            try {
<span class="fc" id="L5155">                final TableWriterTask event = messageBus.getTableWriterEventQueue().get(pubCursor);</span>
<span class="fc" id="L5156">                event.of(eventType, tableId, tableToken);</span>
<span class="fc" id="L5157">                event.putInt(errorCode);</span>
<span class="fc bfc" id="L5158" title="All 2 branches covered.">                if (errorCode != AsyncWriterCommand.Error.OK) {</span>
<span class="fc" id="L5159">                    event.putStr(errorMsg);</span>
                } else {
<span class="fc" id="L5161">                    event.putLong(affectedRowsCount);</span>
                }
<span class="fc" id="L5163">                event.setInstance(correlationId);</span>
            } finally {
<span class="fc" id="L5165">                messageBus.getTableWriterEventPubSeq().done(pubCursor);</span>
            }

            // Log result
<span class="fc bfc" id="L5169" title="All 2 branches covered.">            if (eventType == TSK_COMPLETE) {</span>
<span class="fc" id="L5170">                LogRecord lg = LOG.info()</span>
<span class="fc" id="L5171">                        .$(&quot;published async command complete event [type=&quot;).$(cmdType)</span>
<span class="fc" id="L5172">                        .$(&quot;,tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L5173">                        .$(&quot;,tableId=&quot;).$(tableId)</span>
<span class="fc" id="L5174">                        .$(&quot;,correlationId=&quot;).$(correlationId);</span>
<span class="fc bfc" id="L5175" title="All 2 branches covered.">                if (errorCode != AsyncWriterCommand.Error.OK) {</span>
<span class="fc" id="L5176">                    lg.$(&quot;,errorCode=&quot;).$(errorCode).$(&quot;,errorMsg=&quot;).$(errorMsg);</span>
                }
<span class="fc" id="L5178">                lg.I$();</span>
<span class="fc" id="L5179">            }</span>
        } else {
            // Queue is full
<span class="fc" id="L5182">            LOG.error()</span>
<span class="fc" id="L5183">                    .$(&quot;could not publish sync command complete event [type=&quot;).$(cmdType)</span>
<span class="fc" id="L5184">                    .$(&quot;,tableName=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L5185">                    .$(&quot;,tableId=&quot;).$(tableId)</span>
<span class="fc" id="L5186">                    .$(&quot;,correlationId=&quot;).$(correlationId)</span>
<span class="fc" id="L5187">                    .I$();</span>
        }
<span class="fc" id="L5189">    }</span>

    private long readMinTimestamp(long partitionTimestamp) {
<span class="fc" id="L5192">        setStateForTimestamp(other, partitionTimestamp, false);</span>
        try {
<span class="fc" id="L5194">            dFile(other, metadata.getColumnName(metadata.getTimestampIndex()), COLUMN_NAME_TXN_NONE);</span>
<span class="pc bpc" id="L5195" title="1 of 2 branches missed.">            if (ff.exists(other)) {</span>
                // read min timestamp value
<span class="fc" id="L5197">                final int fd = TableUtils.openRO(ff, other, LOG);</span>
                try {
<span class="fc" id="L5199">                    return TableUtils.readLongOrFail(ff, fd, 0, tempMem16b, other);</span>
                } finally {
<span class="fc" id="L5201">                    ff.close(fd);</span>
                }
            } else {
<span class="nc" id="L5204">                throw CairoException.critical(0).put(&quot;Partition does not exist [path=&quot;).put(other).put(']');</span>
            }
        } finally {
<span class="fc" id="L5207">            other.trimTo(rootLen);</span>
        }
    }

    private void readPartitionMinMax(FilesFacade ff, long partitionTimestamp, Path path, CharSequence columnName, long partitionSize) {
<span class="fc" id="L5212">        dFile(path, columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc" id="L5213">        final int fd = TableUtils.openRO(ff, path, LOG);</span>
        try {
<span class="fc" id="L5215">            attachMinTimestamp = ff.readNonNegativeLong(fd, 0);</span>
<span class="fc" id="L5216">            attachMaxTimestamp = ff.readNonNegativeLong(fd, (partitionSize - 1) * ColumnType.sizeOf(ColumnType.TIMESTAMP));</span>
<span class="fc bfc" id="L5217" title="All 4 branches covered.">            if (attachMinTimestamp &lt; 0 || attachMaxTimestamp &lt; 0) {</span>
<span class="fc" id="L5218">                throw CairoException.critical(ff.errno())</span>
<span class="fc" id="L5219">                        .put(&quot;cannot read min, max timestamp from the column [path=&quot;).put(path)</span>
<span class="fc" id="L5220">                        .put(&quot;, partitionSizeRows=&quot;).put(partitionSize)</span>
<span class="fc" id="L5221">                        .put(&quot;, errno=&quot;).put(ff.errno()).put(']');</span>
            }
<span class="fc bfc" id="L5223" title="All 2 branches covered.">            if (partitionFloorMethod.floor(attachMinTimestamp) != partitionTimestamp</span>
<span class="pc bpc" id="L5224" title="1 of 2 branches missed.">                    || partitionFloorMethod.floor(attachMaxTimestamp) != partitionTimestamp) {</span>
<span class="fc" id="L5225">                throw CairoException.critical(0)</span>
<span class="fc" id="L5226">                        .put(&quot;invalid timestamp column data in detached partition, data does not match partition directory name [path=&quot;).put(path)</span>
<span class="fc" id="L5227">                        .put(&quot;, minTimestamp=&quot;).ts(attachMinTimestamp)</span>
<span class="fc" id="L5228">                        .put(&quot;, maxTimestamp=&quot;).ts(attachMaxTimestamp).put(']');</span>
            }
        } finally {
<span class="fc" id="L5231">            ff.close(fd);</span>
        }
<span class="fc" id="L5233">    }</span>

    // Scans timestamp file
    // returns size of partition detected, e.g. size of monotonic increase
    // of timestamp longs read from 0 offset to the end of the file
    // It also writes min and max values found in detachedMinTimestamp and detachedMaxTimestamp
    private long readPartitionSizeMinMax(FilesFacade ff, long partitionTimestamp, Path path, CharSequence columnName) {
<span class="fc" id="L5240">        int pathLen = path.length();</span>
        try {
<span class="fc" id="L5242">            path.concat(TXN_FILE_NAME).$();</span>
<span class="fc bfc" id="L5243" title="All 2 branches covered.">            if (ff.exists(path)) {</span>
<span class="fc bfc" id="L5244" title="All 2 branches covered.">                if (attachTxReader == null) {</span>
<span class="fc" id="L5245">                    attachTxReader = new TxReader(ff);</span>
                }
<span class="fc" id="L5247">                attachTxReader.ofRO(path, partitionBy);</span>
<span class="fc" id="L5248">                attachTxReader.unsafeLoadAll();</span>

                try {
<span class="fc" id="L5251">                    path.trimTo(pathLen);</span>
<span class="fc" id="L5252">                    long partitionSize = attachTxReader.getPartitionSizeByPartitionTimestamp(partitionTimestamp);</span>
<span class="fc bfc" id="L5253" title="All 2 branches covered.">                    if (partitionSize &lt;= 0) {</span>
<span class="fc" id="L5254">                        throw CairoException.nonCritical()</span>
<span class="fc" id="L5255">                                .put(&quot;partition is not preset in detached txn file [path=&quot;)</span>
<span class="fc" id="L5256">                                .put(path).put(&quot;, partitionSize=&quot;).put(partitionSize).put(']');</span>
                    }

                    // Read min and max timestamp values from the file
<span class="fc" id="L5260">                    readPartitionMinMax(ff, partitionTimestamp, path.trimTo(pathLen), columnName, partitionSize);</span>
<span class="fc" id="L5261">                    return partitionSize;</span>
                } finally {
<span class="fc" id="L5263">                    Misc.free(attachTxReader);</span>
                }
            }

            // No txn file found, scan the file to get min, max timestamp
            // Scan forward while value increases

<span class="fc" id="L5270">            dFile(path.trimTo(pathLen), columnName, COLUMN_NAME_TXN_NONE);</span>
<span class="fc" id="L5271">            final int fd = TableUtils.openRO(ff, path, LOG);</span>
            try {
<span class="fc" id="L5273">                long fileSize = ff.length(fd);</span>
<span class="pc bpc" id="L5274" title="1 of 2 branches missed.">                if (fileSize &lt;= 0) {</span>
<span class="nc" id="L5275">                    throw CairoException.critical(ff.errno())</span>
<span class="nc" id="L5276">                            .put(&quot;timestamp column is too small to attach the partition [path=&quot;)</span>
<span class="nc" id="L5277">                            .put(path).put(&quot;, fileSize=&quot;).put(fileSize).put(']');</span>
                }
<span class="fc" id="L5279">                long mappedMem = mapRO(ff, fd, fileSize, MemoryTag.MMAP_DEFAULT);</span>
                try {
<span class="fc" id="L5281">                    long maxTimestamp = partitionTimestamp;</span>
<span class="fc" id="L5282">                    long size = 0L;</span>

<span class="pc bpc" id="L5284" title="1 of 2 branches missed.">                    for (long ptr = mappedMem, hi = mappedMem + fileSize; ptr &lt; hi; ptr += Long.BYTES) {</span>
<span class="fc" id="L5285">                        long ts = Unsafe.getUnsafe().getLong(ptr);</span>
<span class="fc bfc" id="L5286" title="All 2 branches covered.">                        if (ts &gt;= maxTimestamp) {</span>
<span class="fc" id="L5287">                            maxTimestamp = ts;</span>
<span class="fc" id="L5288">                            size++;</span>
                        } else {
                            break;
                        }
                    }
<span class="pc bpc" id="L5293" title="1 of 2 branches missed.">                    if (size &gt; 0) {</span>
<span class="fc" id="L5294">                        attachMinTimestamp = Unsafe.getUnsafe().getLong(mappedMem);</span>
<span class="fc" id="L5295">                        attachMaxTimestamp = maxTimestamp;</span>
                    }
<span class="fc" id="L5297">                    return size;</span>
                } finally {
<span class="fc" id="L5299">                    ff.munmap(mappedMem, fileSize, MemoryTag.MMAP_DEFAULT);</span>
                }
            } finally {
<span class="fc" id="L5302">                ff.close(fd);</span>
            }
        } finally {
<span class="fc" id="L5305">            path.trimTo(pathLen);</span>
        }
    }

    private int readTodo() {
        long todoCount;
        try {
            // This is first FS call to the table directory.
            // If table is removed / renamed this should fail with table does not exist.
<span class="fc" id="L5314">            todoCount = openTodoMem();</span>
<span class="fc" id="L5315">        } catch (CairoException ex) {</span>
<span class="fc bfc" id="L5316" title="All 2 branches covered.">            if (ex.errnoReadPathDoesNotExist()) {</span>
<span class="fc" id="L5317">                throw CairoException.tableDoesNotExist(tableToken.getTableName());</span>
            }
<span class="fc" id="L5319">            throw ex;</span>
<span class="fc" id="L5320">        }</span>
        int todo;
<span class="fc bfc" id="L5322" title="All 2 branches covered.">        if (todoCount &gt; 0) {</span>
<span class="fc" id="L5323">            todo = (int) todoMem.getLong(40);</span>
        } else {
<span class="fc" id="L5325">            todo = -1;</span>
        }
<span class="fc" id="L5327">        return todo;</span>
    }

    private void rebuildAttachedPartitionColumnIndex(long partitionTimestamp, long partitionSize, Path path, CharSequence columnName) {
<span class="pc bpc" id="L5331" title="1 of 2 branches missed.">        if (attachIndexBuilder == null) {</span>
<span class="fc" id="L5332">            attachIndexBuilder = new IndexBuilder();</span>

            // no need to pass table name, full partition name will be specified
<span class="fc" id="L5335">            attachIndexBuilder.of(&quot;&quot;, configuration);</span>
        }

<span class="fc" id="L5338">        attachIndexBuilder.reindexColumn(</span>
                attachColumnVersionReader,
                // use metadata instead of detachedMetadata to get correct value block capacity
                // detachedMetadata does not have the column
                metadata,
<span class="fc" id="L5343">                metadata.getColumnIndex(columnName),</span>
                path,
                -1L,
                partitionTimestamp,
                partitionSize
        );
<span class="fc" id="L5349">    }</span>

    private void recoverFromMetaRenameFailure(CharSequence columnName) {
<span class="fc" id="L5352">        openMetaFile(ff, path, rootLen, metaMem);</span>
<span class="fc" id="L5353">    }</span>

    private void recoverFromSwapRenameFailure(CharSequence columnName) {
<span class="fc" id="L5356">        recoverFromTodoWriteFailure(columnName);</span>
<span class="fc" id="L5357">        clearTodoLog();</span>
<span class="fc" id="L5358">    }</span>

    private void recoverFromSymbolMapWriterFailure(CharSequence columnName) {
<span class="fc" id="L5361">        removeSymbolMapFilesQuiet(columnName, getTxn());</span>
<span class="fc" id="L5362">        removeMetaFile();</span>
<span class="fc" id="L5363">        recoverFromSwapRenameFailure(columnName);</span>
<span class="fc" id="L5364">    }</span>

    private void recoverFromTodoWriteFailure(CharSequence columnName) {
<span class="fc" id="L5367">        restoreMetaFrom(META_PREV_FILE_NAME, metaPrevIndex);</span>
<span class="fc" id="L5368">        openMetaFile(ff, path, rootLen, metaMem);</span>
<span class="fc" id="L5369">    }</span>

    private void recoverOpenColumnFailure(CharSequence columnName) {
<span class="fc" id="L5372">        final int index = columnCount - 1;</span>
<span class="fc" id="L5373">        removeMetaFile();</span>
<span class="fc" id="L5374">        removeLastColumn();</span>
<span class="fc" id="L5375">        columnCount--;</span>
<span class="fc" id="L5376">        recoverFromSwapRenameFailure(columnName);</span>
<span class="fc" id="L5377">        removeSymbolMapWriter(index);</span>
<span class="fc" id="L5378">    }</span>

    private void releaseLock(boolean distressed) {
<span class="fc bfc" id="L5381" title="All 2 branches covered.">        if (lockFd != -1L) {</span>
<span class="fc bfc" id="L5382" title="All 2 branches covered.">            if (distressed) {</span>
<span class="fc" id="L5383">                ff.close(lockFd);</span>
<span class="fc" id="L5384">                return;</span>
            }

            try {
<span class="fc" id="L5388">                lockName(path);</span>
<span class="fc" id="L5389">                removeOrException(ff, lockFd, path);</span>
            } finally {
<span class="fc" id="L5391">                path.trimTo(rootLen);</span>
            }
        }
<span class="fc" id="L5394">    }</span>

    private ReadOnlyObjList&lt;? extends MemoryCR&gt; remapWalSymbols(
            SymbolMapDiffCursor symbolMapDiffCursor,
            long rowLo,
            long rowHi,
            Path walPath,
            long destRowLo
    ) {
<span class="fc" id="L5403">        o3ColumnOverrides.clear();</span>
<span class="fc bfc" id="L5404" title="All 2 branches covered.">        if (symbolMapDiffCursor != null) {</span>
            SymbolMapDiff symbolMapDiff;
<span class="fc bfc" id="L5406" title="All 2 branches covered.">            while ((symbolMapDiff = symbolMapDiffCursor.nextSymbolMapDiff()) != null) {</span>
<span class="fc" id="L5407">                int columnIndex = symbolMapDiff.getColumnIndex();</span>
<span class="fc" id="L5408">                int columnType = metadata.getColumnType(columnIndex);</span>
<span class="fc bfc" id="L5409" title="All 2 branches covered.">                if (columnType == -ColumnType.SYMBOL) {</span>
                    // Scroll the cursor, don't apply, symbol is deleted
<span class="fc" id="L5411">                    symbolMapDiff.drain();</span>
<span class="fc" id="L5412">                    continue;</span>
                }

<span class="pc bpc" id="L5415" title="1 of 2 branches missed.">                if (!ColumnType.isSymbol(columnType)) {</span>
<span class="nc" id="L5416">                    throw CairoException.critical(0).put(&quot;WAL column and table writer column types don't match [columnIndex=&quot;).put(columnIndex)</span>
<span class="nc" id="L5417">                            .put(&quot;, walPath=&quot;).put(walPath)</span>
<span class="nc" id="L5418">                            .put(']');</span>
                }
<span class="fc" id="L5420">                boolean identical = createWalSymbolMapping(symbolMapDiff, columnIndex, symbolRewriteMap);</span>

<span class="fc bfc" id="L5422" title="All 2 branches covered.">                if (!identical) {</span>
<span class="fc" id="L5423">                    int primaryColumnIndex = getPrimaryColumnIndex(columnIndex);</span>
<span class="fc" id="L5424">                    MemoryCR o3SymbolColumn = o3Columns.getQuick(primaryColumnIndex);</span>
                    final MemoryCARW symbolColumnDest;

                    // Column is read-only mapped memory, so we need to take in RAM column and remap values into it
<span class="fc bfc" id="L5428" title="All 2 branches covered.">                    if (o3ColumnOverrides.size() == 0) {</span>
<span class="fc" id="L5429">                        o3ColumnOverrides.addAll(o3Columns);</span>
                    }

<span class="fc" id="L5432">                    symbolColumnDest = o3MemColumns.get(primaryColumnIndex);</span>
<span class="fc" id="L5433">                    long destOffset = (destRowLo - rowLo) &lt;&lt; 2;</span>
<span class="fc" id="L5434">                    symbolColumnDest.jumpTo(destOffset + (rowHi &lt;&lt; 2));</span>
<span class="fc" id="L5435">                    o3ColumnOverrides.setQuick(primaryColumnIndex, symbolColumnDest);</span>
<span class="fc" id="L5436">                    final int cleanSymbolCount = symbolMapDiff.getCleanSymbolCount();</span>
<span class="fc bfc" id="L5437" title="All 2 branches covered.">                    for (long rowId = rowLo; rowId &lt; rowHi; rowId++) {</span>

<span class="fc" id="L5439">                        final long valueOffset = rowId &lt;&lt; 2;</span>
<span class="fc" id="L5440">                        int symKey = o3SymbolColumn.getInt(valueOffset);</span>
<span class="pc bpc" id="L5441" title="1 of 4 branches missed.">                        assert (symKey &gt;= 0 || symKey == SymbolTable.VALUE_IS_NULL);</span>
<span class="fc bfc" id="L5442" title="All 2 branches covered.">                        if (symKey &gt;= cleanSymbolCount) {</span>
<span class="fc" id="L5443">                            int newKey = symbolRewriteMap.getQuick(symKey - cleanSymbolCount);</span>
<span class="pc bpc" id="L5444" title="1 of 2 branches missed.">                            if (newKey &lt; 0) {</span>
                                // This symbol was not mapped in WAL
                                // WAL is invalid
<span class="nc" id="L5447">                                throw CairoException.critical(0).put(&quot;WAL symbol key not mapped [columnIndex=&quot;).put(columnIndex)</span>
<span class="nc" id="L5448">                                        .put(&quot;, columnKey=&quot;).put(symKey)</span>
<span class="nc" id="L5449">                                        .put(&quot;, walPath=&quot;).put(walPath)</span>
<span class="nc" id="L5450">                                        .put(&quot;, walRowId=&quot;).put(rowId)</span>
<span class="nc" id="L5451">                                        .put(']');</span>
                            }
<span class="fc" id="L5453">                            symKey = newKey;</span>
                        }
<span class="fc" id="L5455">                        symbolColumnDest.putInt(destOffset + valueOffset, symKey);</span>
                    }
                }
<span class="fc" id="L5458">            }</span>
        }

<span class="fc bfc" id="L5461" title="All 2 branches covered.">        if (o3ColumnOverrides.size() == 0) {</span>
            // No mappins were made.
<span class="fc" id="L5463">            return o3Columns;</span>
        }
<span class="fc" id="L5465">        return o3ColumnOverrides;</span>
    }

    private void removeColumn(int columnIndex) {
<span class="fc" id="L5469">        final int pi = getPrimaryColumnIndex(columnIndex);</span>
<span class="fc" id="L5470">        final int si = getSecondaryColumnIndex(columnIndex);</span>
<span class="fc" id="L5471">        freeNullSetter(nullSetters, columnIndex);</span>
<span class="fc" id="L5472">        freeNullSetter(o3NullSetters, columnIndex);</span>
<span class="fc" id="L5473">        freeNullSetter(o3NullSetters2, columnIndex);</span>
<span class="fc" id="L5474">        freeAndRemoveColumnPair(columns, pi, si);</span>
<span class="fc" id="L5475">        freeAndRemoveO3ColumnPair(o3MemColumns, pi, si);</span>
<span class="fc" id="L5476">        freeAndRemoveO3ColumnPair(o3MemColumns2, pi, si);</span>
<span class="fc bfc" id="L5477" title="All 2 branches covered.">        if (columnIndex &lt; indexers.size()) {</span>
<span class="fc" id="L5478">            Misc.free(indexers.getAndSetQuick(columnIndex, null));</span>
<span class="fc" id="L5479">            populateDenseIndexerList();</span>
        }
<span class="fc" id="L5481">    }</span>

    private void removeColumnFiles(CharSequence columnName, int columnIndex, int columnType) {
        try {
<span class="fc bfc" id="L5485" title="All 2 branches covered.">            for (int i = txWriter.getPartitionCount() - 1; i &gt; -1L; i--) {</span>
<span class="fc" id="L5486">                long partitionTimestamp = txWriter.getPartitionTimestamp(i);</span>
<span class="fc" id="L5487">                long partitionNameTxn = txWriter.getPartitionNameTxn(i);</span>
<span class="fc" id="L5488">                removeColumnFilesInPartition(columnName, columnIndex, partitionTimestamp, partitionNameTxn);</span>
            }
<span class="fc bfc" id="L5490" title="All 2 branches covered.">            if (!PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L5491">                removeColumnFilesInPartition(columnName, columnIndex, txWriter.getLastPartitionTimestamp(), -1L);</span>
            }

<span class="fc" id="L5494">            long columnNameTxn = columnVersionWriter.getDefaultColumnNameTxn(columnIndex);</span>
<span class="fc bfc" id="L5495" title="All 2 branches covered.">            if (ColumnType.isSymbol(columnType)) {</span>
<span class="fc" id="L5496">                removeFileAndOrLog(ff, offsetFileName(path.trimTo(rootLen), columnName, columnNameTxn));</span>
<span class="fc" id="L5497">                removeFileAndOrLog(ff, charFileName(path.trimTo(rootLen), columnName, columnNameTxn));</span>
<span class="fc" id="L5498">                removeFileAndOrLog(ff, keyFileName(path.trimTo(rootLen), columnName, columnNameTxn));</span>
<span class="fc" id="L5499">                removeFileAndOrLog(ff, valueFileName(path.trimTo(rootLen), columnName, columnNameTxn));</span>
            }
        } finally {
<span class="fc" id="L5502">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L5504">    }</span>

    private void removeColumnFilesInPartition(CharSequence columnName, int columnIndex, long partitionTimestamp, long partitionNameTxn) {
<span class="fc bfc" id="L5507" title="All 2 branches covered.">        if (!txWriter.isPartitionReadOnlyByPartitionTimestamp(partitionTimestamp)) {</span>
<span class="fc" id="L5508">            setPathForPartition(path, partitionBy, partitionTimestamp, false);</span>
<span class="fc" id="L5509">            txnPartitionConditionally(path, partitionNameTxn);</span>
<span class="fc" id="L5510">            int plen = path.length();</span>
<span class="fc" id="L5511">            long columnNameTxn = columnVersionWriter.getColumnNameTxn(partitionTimestamp, columnIndex);</span>
<span class="fc" id="L5512">            removeFileAndOrLog(ff, dFile(path, columnName, columnNameTxn));</span>
<span class="fc" id="L5513">            removeFileAndOrLog(ff, iFile(path.trimTo(plen), columnName, columnNameTxn));</span>
<span class="fc" id="L5514">            removeFileAndOrLog(ff, keyFileName(path.trimTo(plen), columnName, columnNameTxn));</span>
<span class="fc" id="L5515">            removeFileAndOrLog(ff, valueFileName(path.trimTo(plen), columnName, columnNameTxn));</span>
<span class="fc" id="L5516">            path.trimTo(rootLen);</span>
<span class="fc" id="L5517">        } else {</span>
<span class="fc" id="L5518">            LOG.critical()</span>
<span class="fc" id="L5519">                    .$(&quot;o3 ignoring removal of column in read-only partition [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L5520">                    .$(&quot;, columnName=&quot;).utf8(columnName)</span>
<span class="fc" id="L5521">                    .$(&quot;, timestamp=&quot;).$ts(partitionTimestamp)</span>
<span class="fc" id="L5522">                    .$();</span>
        }
<span class="fc" id="L5524">    }</span>

    private int removeColumnFromMeta(int index) {
        try {
<span class="fc" id="L5528">            int metaSwapIndex = openMetaSwapFile(ff, ddlMem, path, rootLen, fileOperationRetryCount);</span>
<span class="fc" id="L5529">            int timestampIndex = metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);</span>
<span class="fc" id="L5530">            ddlMem.putInt(columnCount);</span>
<span class="fc" id="L5531">            ddlMem.putInt(partitionBy);</span>

<span class="fc bfc" id="L5533" title="All 2 branches covered.">            if (timestampIndex == index) {</span>
<span class="fc" id="L5534">                ddlMem.putInt(-1);</span>
            } else {
<span class="fc" id="L5536">                ddlMem.putInt(timestampIndex);</span>
            }
<span class="fc" id="L5538">            copyVersionAndLagValues();</span>
<span class="fc" id="L5539">            ddlMem.jumpTo(META_OFFSET_COLUMN_TYPES);</span>

<span class="fc bfc" id="L5541" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L5542" title="All 2 branches covered.">                writeColumnEntry(i, i == index);</span>
            }

<span class="fc" id="L5545">            long nameOffset = getColumnNameOffset(columnCount);</span>
<span class="fc bfc" id="L5546" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L5547">                CharSequence columnName = metaMem.getStr(nameOffset);</span>
<span class="fc" id="L5548">                ddlMem.putStr(columnName);</span>
<span class="fc" id="L5549">                nameOffset += Vm.getStorageLength(columnName);</span>
            }

<span class="fc" id="L5552">            return metaSwapIndex;</span>
        } finally {
<span class="fc" id="L5554">            ddlMem.close();</span>
        }
    }

    private void removeIndexFiles(CharSequence columnName, int columnIndex) {
        try {
<span class="fc bfc" id="L5560" title="All 2 branches covered.">            for (int i = txWriter.getPartitionCount() - 1; i &gt; -1L; i--) {</span>
<span class="fc" id="L5561">                long partitionTimestamp = txWriter.getPartitionTimestamp(i);</span>
<span class="fc" id="L5562">                long partitionNameTxn = txWriter.getPartitionNameTxn(i);</span>
<span class="fc" id="L5563">                removeIndexFilesInPartition(columnName, columnIndex, partitionTimestamp, partitionNameTxn);</span>
            }
<span class="fc bfc" id="L5565" title="All 2 branches covered.">            if (!PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L5566">                removeColumnFilesInPartition(columnName, columnIndex, txWriter.getLastPartitionTimestamp(), -1L);</span>
            }
        } finally {
<span class="fc" id="L5569">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L5571">    }</span>

    private void removeIndexFilesInPartition(CharSequence columnName, int columnIndex, long partitionTimestamp, long partitionNameTxn) {
<span class="fc" id="L5574">        setPathForPartition(path, partitionBy, partitionTimestamp, false);</span>
<span class="fc" id="L5575">        txnPartitionConditionally(path, partitionNameTxn);</span>
<span class="fc" id="L5576">        int plen = path.length();</span>
<span class="fc" id="L5577">        long columnNameTxn = columnVersionWriter.getColumnNameTxn(partitionTimestamp, columnIndex);</span>
<span class="fc" id="L5578">        removeFileAndOrLog(ff, keyFileName(path.trimTo(plen), columnName, columnNameTxn));</span>
<span class="fc" id="L5579">        removeFileAndOrLog(ff, valueFileName(path.trimTo(plen), columnName, columnNameTxn));</span>
<span class="fc" id="L5580">        path.trimTo(rootLen);</span>
<span class="fc" id="L5581">    }</span>

    private void removeLastColumn() {
<span class="fc" id="L5584">        removeColumn(columnCount - 1);</span>
<span class="fc" id="L5585">    }</span>

    private void removeMetaFile() {
        try {
<span class="fc" id="L5589">            path.concat(META_FILE_NAME).$();</span>
<span class="pc bpc" id="L5590" title="1 of 4 branches missed.">            if (ff.exists(path) &amp;&amp; !ff.remove(path)) {</span>
                // On Windows opened file cannot be removed
                // but can be renamed
<span class="fc" id="L5593">                other.concat(META_FILE_NAME).put('.').put(configuration.getMicrosecondClock().getTicks()).$();</span>
<span class="fc bfc" id="L5594" title="All 2 branches covered.">                if (ff.rename(path, other) != FILES_RENAME_OK) {</span>
<span class="fc" id="L5595">                    LOG.error().$(&quot;could not remove [path=&quot;).$(path).$(']').$();</span>
<span class="fc" id="L5596">                    throw CairoException.critical(ff.errno()).put(&quot;Recovery failed. Cannot remove: &quot;).put(path);</span>
                }
            }
        } finally {
<span class="fc" id="L5600">            path.trimTo(rootLen);</span>
<span class="fc" id="L5601">            other.trimTo(rootLen);</span>
        }
<span class="fc" id="L5603">    }</span>

    private void removeNonAttachedPartitions() {
<span class="fc" id="L5606">        LOG.info().$(&quot;purging non attached partitions [path=&quot;).$(path.$()).I$();</span>
        try {
<span class="fc" id="L5608">            ff.iterateDir(path.$(), removePartitionDirsNotAttached);</span>
        } finally {
<span class="fc" id="L5610">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L5612">    }</span>

    private void removePartitionDirectories() {
        try {
<span class="fc" id="L5616">            ff.iterateDir(path.$(), removePartitionDirectories);</span>
        } finally {
<span class="fc" id="L5618">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L5620">    }</span>

    private void removePartitionDirectories0(long pUtf8NameZ, int type) {
<span class="fc" id="L5623">        int checkedType = ff.typeDirOrSoftLinkDirNoDots(path, rootLen, pUtf8NameZ, type, fileNameSink);</span>
<span class="fc bfc" id="L5624" title="All 2 branches covered.">        if (checkedType != Files.DT_UNKNOWN &amp;&amp;</span>
<span class="fc bfc" id="L5625" title="All 2 branches covered.">                !Chars.endsWith(fileNameSink, DETACHED_DIR_MARKER) &amp;&amp;</span>
<span class="fc bfc" id="L5626" title="All 2 branches covered.">                !Chars.startsWith(fileNameSink, WAL_NAME_BASE) &amp;&amp;</span>
<span class="fc bfc" id="L5627" title="All 2 branches covered.">                !Chars.startsWith(fileNameSink, SEQ_DIR)) {</span>
<span class="fc" id="L5628">            ff.unlinkOrRemove(path, checkedType, LOG);</span>
<span class="fc" id="L5629">            path.trimTo(rootLen).$();</span>
        }
<span class="fc" id="L5631">    }</span>

    private void removePartitionDirsNotAttached(long pUtf8NameZ, int type) {
        // Do not remove detached partitions, they are probably about to be attached
        // Do not remove wal and sequencer directories either
<span class="fc" id="L5636">        int checkedType = ff.typeDirOrSoftLinkDirNoDots(path, rootLen, pUtf8NameZ, type, fileNameSink);</span>
<span class="fc bfc" id="L5637" title="All 2 branches covered.">        if (checkedType != Files.DT_UNKNOWN &amp;&amp;</span>
<span class="fc bfc" id="L5638" title="All 2 branches covered.">                !Chars.endsWith(fileNameSink, DETACHED_DIR_MARKER) &amp;&amp;</span>
<span class="fc bfc" id="L5639" title="All 2 branches covered.">                !Chars.startsWith(fileNameSink, WAL_NAME_BASE) &amp;&amp;</span>
<span class="fc bfc" id="L5640" title="All 2 branches covered.">                !Chars.startsWith(fileNameSink, SEQ_DIR) &amp;&amp;</span>
<span class="pc bpc" id="L5641" title="1 of 2 branches missed.">                !Chars.startsWith(fileNameSink, SEQ_DIR_DEPRECATED) &amp;&amp;</span>
<span class="fc bfc" id="L5642" title="All 2 branches covered.">                !Chars.endsWith(fileNameSink, configuration.getAttachPartitionSuffix())</span>
        ) {
            try {
<span class="fc" id="L5645">                long txn = 0;</span>
<span class="fc" id="L5646">                int txnSep = Chars.indexOf(fileNameSink, '.');</span>
<span class="fc bfc" id="L5647" title="All 2 branches covered.">                if (txnSep &lt; 0) {</span>
<span class="fc" id="L5648">                    txnSep = fileNameSink.length();</span>
                } else {
<span class="fc" id="L5650">                    txn = Numbers.parseLong(fileNameSink, txnSep + 1, fileNameSink.length());</span>
                }
<span class="fc" id="L5652">                long dirTimestamp = partitionDirFmt.parse(fileNameSink, 0, txnSep, null);</span>
<span class="fc bfc" id="L5653" title="All 2 branches covered.">                if (txn &lt;= txWriter.txn &amp;&amp;</span>
<span class="pc bpc" id="L5654" title="1 of 4 branches missed.">                        (txWriter.attachedPartitionsContains(dirTimestamp) || txWriter.isActivePartition(dirTimestamp))) {</span>
<span class="fc" id="L5655">                    return;</span>
                }
<span class="fc" id="L5657">                ff.unlinkOrRemove(path, checkedType, LOG);</span>
<span class="fc" id="L5658">                path.trimTo(rootLen).$();</span>
<span class="fc" id="L5659">            } catch (NumericException ignore) {</span>
                // not a date?
                // ignore exception and leave the directory
<span class="fc" id="L5662">                path.trimTo(rootLen);</span>
<span class="fc" id="L5663">                path.concat(pUtf8NameZ).$();</span>
<span class="fc" id="L5664">                LOG.error().$(&quot;invalid partition directory inside table folder: &quot;).utf8(path).$();</span>
<span class="fc" id="L5665">            }</span>
        }
<span class="fc" id="L5667">    }</span>

    private void removeSymbolMapFilesQuiet(CharSequence name, long columnNamTxn) {
        try {
<span class="fc" id="L5671">            removeFileAndOrLog(ff, offsetFileName(path.trimTo(rootLen), name, columnNamTxn));</span>
<span class="fc" id="L5672">            removeFileAndOrLog(ff, charFileName(path.trimTo(rootLen), name, columnNamTxn));</span>
<span class="fc" id="L5673">            removeFileAndOrLog(ff, keyFileName(path.trimTo(rootLen), name, columnNamTxn));</span>
<span class="fc" id="L5674">            removeFileAndOrLog(ff, valueFileName(path.trimTo(rootLen), name, columnNamTxn));</span>
        } finally {
<span class="fc" id="L5676">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L5678">    }</span>

    private void removeSymbolMapWriter(int index) {
<span class="fc" id="L5681">        MapWriter writer = symbolMapWriters.getAndSetQuick(index, NullMapWriter.INSTANCE);</span>
<span class="fc bfc" id="L5682" title="All 4 branches covered.">        if (writer != null &amp;&amp; writer != NullMapWriter.INSTANCE) {</span>
<span class="fc" id="L5683">            int symColIndex = denseSymbolMapWriters.remove(writer);</span>
            // Shift all subsequent symbol indexes by 1 back
<span class="fc bfc" id="L5685" title="All 2 branches covered.">            while (symColIndex &lt; denseSymbolMapWriters.size()) {</span>
<span class="fc" id="L5686">                MapWriter w = denseSymbolMapWriters.getQuick(symColIndex);</span>
<span class="fc" id="L5687">                w.setSymbolIndexInTxWriter(symColIndex);</span>
<span class="fc" id="L5688">                symColIndex++;</span>
<span class="fc" id="L5689">            }</span>
<span class="fc" id="L5690">            Misc.freeIfCloseable(writer);</span>
        }
<span class="fc" id="L5692">    }</span>

    private int rename(int retries) {
        try {
<span class="fc" id="L5696">            int index = 0;</span>
<span class="fc" id="L5697">            other.concat(META_PREV_FILE_NAME).$();</span>
<span class="fc" id="L5698">            path.concat(META_FILE_NAME).$();</span>
<span class="fc" id="L5699">            int l = other.length();</span>

            do {
<span class="fc bfc" id="L5702" title="All 2 branches covered.">                if (index &gt; 0) {</span>
<span class="fc" id="L5703">                    other.trimTo(l);</span>
<span class="fc" id="L5704">                    other.put('.').put(index);</span>
<span class="fc" id="L5705">                    other.$();</span>
                }

<span class="fc bfc" id="L5708" title="All 4 branches covered.">                if (ff.exists(other) &amp;&amp; !ff.remove(other)) {</span>
<span class="fc" id="L5709">                    LOG.info().$(&quot;could not remove target of rename '&quot;).$(path).$(&quot;' to '&quot;).$(other).$(&quot; [errno=&quot;).$(ff.errno()).I$();</span>
<span class="fc" id="L5710">                    index++;</span>
<span class="fc" id="L5711">                    continue;</span>
                }

<span class="fc bfc" id="L5714" title="All 2 branches covered.">                if (ff.rename(path, other) != FILES_RENAME_OK) {</span>
<span class="fc" id="L5715">                    LOG.info().$(&quot;could not rename '&quot;).$(path).$(&quot;' to '&quot;).$(other).$(&quot; [errno=&quot;).$(ff.errno()).I$();</span>
<span class="fc" id="L5716">                    index++;</span>
<span class="fc" id="L5717">                    continue;</span>
                }

<span class="fc" id="L5720">                return index;</span>

<span class="fc bfc" id="L5722" title="All 2 branches covered.">            } while (index &lt; retries);</span>

<span class="fc" id="L5724">            throw CairoException.critical(0).put(&quot;could not rename &quot;).put(path).put(&quot;. Max number of attempts reached [&quot;).put(index).put(&quot;]. Last target was: &quot;).put(other);</span>
        } finally {
<span class="fc" id="L5726">            path.trimTo(rootLen);</span>
<span class="fc" id="L5727">            other.trimTo(rootLen);</span>
        }
    }

    private void renameColumnFiles(CharSequence columnName, int columnIndex, CharSequence newName, int columnType) {
        try {
<span class="fc bfc" id="L5733" title="All 2 branches covered.">            for (int i = txWriter.getPartitionCount() - 1; i &gt; -1L; i--) {</span>
<span class="fc" id="L5734">                long partitionTimestamp = txWriter.getPartitionTimestamp(i);</span>
<span class="fc" id="L5735">                long partitionNameTxn = txWriter.getPartitionNameTxn(i);</span>
<span class="fc" id="L5736">                renameColumnFiles(columnName, columnIndex, newName, partitionTimestamp, partitionNameTxn);</span>
            }
<span class="fc bfc" id="L5738" title="All 2 branches covered.">            if (!PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L5739">                renameColumnFiles(columnName, columnIndex, newName, txWriter.getLastPartitionTimestamp(), -1L);</span>
            }

<span class="fc" id="L5742">            long columnNameTxn = columnVersionWriter.getDefaultColumnNameTxn(columnIndex);</span>
<span class="fc bfc" id="L5743" title="All 2 branches covered.">            if (ColumnType.isSymbol(columnType)) {</span>
<span class="fc" id="L5744">                renameFileOrLog(ff, offsetFileName(path.trimTo(rootLen), columnName, columnNameTxn), offsetFileName(other.trimTo(rootLen), newName, columnNameTxn));</span>
<span class="fc" id="L5745">                renameFileOrLog(ff, charFileName(path.trimTo(rootLen), columnName, columnNameTxn), charFileName(other.trimTo(rootLen), newName, columnNameTxn));</span>
<span class="fc" id="L5746">                renameFileOrLog(ff, keyFileName(path.trimTo(rootLen), columnName, columnNameTxn), keyFileName(other.trimTo(rootLen), newName, columnNameTxn));</span>
<span class="fc" id="L5747">                renameFileOrLog(ff, valueFileName(path.trimTo(rootLen), columnName, columnNameTxn), valueFileName(other.trimTo(rootLen), newName, columnNameTxn));</span>
            }
        } finally {
<span class="fc" id="L5750">            path.trimTo(rootLen);</span>
<span class="fc" id="L5751">            other.trimTo(rootLen);</span>
        }
<span class="fc" id="L5753">    }</span>

    private void renameColumnFiles(CharSequence columnName, int columnIndex, CharSequence newName, long partitionTimestamp, long partitionNameTxn) {
<span class="fc" id="L5756">        setPathForPartition(path, partitionBy, partitionTimestamp, false);</span>
<span class="fc" id="L5757">        setPathForPartition(other, partitionBy, partitionTimestamp, false);</span>
<span class="fc" id="L5758">        txnPartitionConditionally(path, partitionNameTxn);</span>
<span class="fc" id="L5759">        txnPartitionConditionally(other, partitionNameTxn);</span>
<span class="fc" id="L5760">        int plen = path.length();</span>
<span class="fc" id="L5761">        long columnNameTxn = columnVersionWriter.getColumnNameTxn(partitionTimestamp, columnIndex);</span>
<span class="fc" id="L5762">        renameFileOrLog(ff, dFile(path.trimTo(plen), columnName, columnNameTxn), dFile(other.trimTo(plen), newName, columnNameTxn));</span>
<span class="fc" id="L5763">        renameFileOrLog(ff, iFile(path.trimTo(plen), columnName, columnNameTxn), iFile(other.trimTo(plen), newName, columnNameTxn));</span>
<span class="fc" id="L5764">        renameFileOrLog(ff, keyFileName(path.trimTo(plen), columnName, columnNameTxn), keyFileName(other.trimTo(plen), newName, columnNameTxn));</span>
<span class="fc" id="L5765">        renameFileOrLog(ff, valueFileName(path.trimTo(plen), columnName, columnNameTxn), valueFileName(other.trimTo(plen), newName, columnNameTxn));</span>
<span class="fc" id="L5766">        path.trimTo(rootLen);</span>
<span class="fc" id="L5767">        other.trimTo(rootLen);</span>
<span class="fc" id="L5768">    }</span>

    private int renameColumnFromMeta(int index, CharSequence newName) {
        try {
<span class="fc" id="L5772">            int metaSwapIndex = openMetaSwapFile(ff, ddlMem, path, rootLen, fileOperationRetryCount);</span>
<span class="fc" id="L5773">            int timestampIndex = metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);</span>
<span class="fc" id="L5774">            ddlMem.putInt(columnCount);</span>
<span class="fc" id="L5775">            ddlMem.putInt(partitionBy);</span>
<span class="fc" id="L5776">            ddlMem.putInt(timestampIndex);</span>
<span class="fc" id="L5777">            copyVersionAndLagValues();</span>
<span class="fc" id="L5778">            ddlMem.jumpTo(META_OFFSET_COLUMN_TYPES);</span>

<span class="fc bfc" id="L5780" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L5781">                writeColumnEntry(i, false);</span>
            }

<span class="fc" id="L5784">            long nameOffset = getColumnNameOffset(columnCount);</span>
<span class="fc bfc" id="L5785" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L5786">                CharSequence columnName = metaMem.getStr(nameOffset);</span>
<span class="fc" id="L5787">                nameOffset += Vm.getStorageLength(columnName);</span>

<span class="pc bpc" id="L5789" title="1 of 4 branches missed.">                if (i == index &amp;&amp; getColumnType(metaMem, i) &gt; 0) {</span>
<span class="fc" id="L5790">                    columnName = newName;</span>
                }
<span class="fc" id="L5792">                ddlMem.putStr(columnName);</span>
            }

<span class="fc" id="L5795">            return metaSwapIndex;</span>
        } finally {
<span class="fc" id="L5797">            ddlMem.close();</span>
        }
    }

    private void renameMetaToMetaPrev(CharSequence columnName) {
        try {
<span class="fc" id="L5803">            this.metaPrevIndex = rename(fileOperationRetryCount);</span>
<span class="fc" id="L5804">        } catch (CairoException e) {</span>
<span class="nc" id="L5805">            runFragile(RECOVER_FROM_META_RENAME_FAILURE, columnName, e);</span>
<span class="fc" id="L5806">        }</span>
<span class="fc" id="L5807">    }</span>

    private void renameSwapMetaToMeta(CharSequence columnName) {
        // rename _meta.swp to _meta
        try {
<span class="fc" id="L5812">            restoreMetaFrom(META_SWAP_FILE_NAME, metaSwapIndex);</span>
<span class="fc" id="L5813">        } catch (CairoException e) {</span>
<span class="nc" id="L5814">            runFragile(RECOVER_FROM_SWAP_RENAME_FAILURE, columnName, e);</span>
<span class="fc" id="L5815">        }</span>
<span class="fc" id="L5816">    }</span>

    private long repairDataGaps(final long timestamp) {
<span class="fc bfc" id="L5819" title="All 4 branches covered.">        if (txWriter.getMaxTimestamp() != Numbers.LONG_NaN &amp;&amp; PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L5820">            long fixedRowCount = 0;</span>
<span class="fc" id="L5821">            long lastTimestamp = -1;</span>
<span class="fc" id="L5822">            long transientRowCount = this.txWriter.getTransientRowCount();</span>
<span class="fc" id="L5823">            long maxTimestamp = this.txWriter.getMaxTimestamp();</span>
            try {
<span class="fc" id="L5825">                final long tsLimit = partitionFloorMethod.floor(this.txWriter.getMaxTimestamp());</span>
<span class="fc bfc" id="L5826" title="All 2 branches covered.">                for (long ts = getPartitionLo(txWriter.getMinTimestamp()); ts &lt; tsLimit; ts = partitionCeilMethod.ceil(ts)) {</span>
<span class="fc" id="L5827">                    path.trimTo(rootLen);</span>
<span class="fc" id="L5828">                    setStateForTimestamp(path, ts, false);</span>
<span class="fc" id="L5829">                    int p = path.length();</span>

<span class="fc" id="L5831">                    long partitionSize = txWriter.getPartitionSizeByPartitionTimestamp(ts);</span>
<span class="fc bfc" id="L5832" title="All 4 branches covered.">                    if (partitionSize &gt;= 0 &amp;&amp; ff.exists(path.$())) {</span>
<span class="fc" id="L5833">                        fixedRowCount += partitionSize;</span>
<span class="fc" id="L5834">                        lastTimestamp = ts;</span>
                    } else {
<span class="fc" id="L5836">                        Path other = Path.getThreadLocal2(path.trimTo(p).$());</span>
<span class="fc" id="L5837">                        TableUtils.oldPartitionName(other, getTxn());</span>
<span class="pc bpc" id="L5838" title="1 of 2 branches missed.">                        if (ff.exists(other.$())) {</span>
<span class="nc bnc" id="L5839" title="All 2 branches missed.">                            if (ff.rename(other, path) != FILES_RENAME_OK) {</span>
<span class="nc" id="L5840">                                LOG.error().$(&quot;could not rename [from=&quot;).$(other).$(&quot;, to=&quot;).$(path).I$();</span>
<span class="nc" id="L5841">                                throw new CairoError(&quot;could not restore directory, see log for details&quot;);</span>
                            } else {
<span class="nc" id="L5843">                                LOG.info().$(&quot;restored [path=&quot;).$(path).I$();</span>
                            }
                        } else {
<span class="fc" id="L5846">                            LOG.debug().$(&quot;missing partition [name=&quot;).$(path.trimTo(p).$()).I$();</span>
                        }
                    }
                }

<span class="fc bfc" id="L5851" title="All 2 branches covered.">                if (lastTimestamp &gt; -1) {</span>
<span class="fc" id="L5852">                    path.trimTo(rootLen);</span>
<span class="fc" id="L5853">                    setStateForTimestamp(path, tsLimit, false);</span>
<span class="fc bfc" id="L5854" title="All 2 branches covered.">                    if (!ff.exists(path.$())) {</span>
<span class="fc" id="L5855">                        Path other = Path.getThreadLocal2(path);</span>
<span class="fc" id="L5856">                        TableUtils.oldPartitionName(other, getTxn());</span>
<span class="pc bpc" id="L5857" title="1 of 2 branches missed.">                        if (ff.exists(other.$())) {</span>
<span class="nc bnc" id="L5858" title="All 2 branches missed.">                            if (ff.rename(other, path) != FILES_RENAME_OK) {</span>
<span class="nc" id="L5859">                                LOG.error().$(&quot;could not rename [from=&quot;).$(other).$(&quot;, to=&quot;).$(path).I$();</span>
<span class="nc" id="L5860">                                throw new CairoError(&quot;could not restore directory, see log for details&quot;);</span>
                            } else {
<span class="nc" id="L5862">                                LOG.info().$(&quot;restored [path=&quot;).$(path).I$();</span>
                            }
                        } else {
<span class="fc" id="L5865">                            LOG.error().$(&quot;last partition does not exist [name=&quot;).$(path).I$();</span>
                            // ok, create last partition we discovered the active
                            // 1. read its size
<span class="fc" id="L5868">                            path.trimTo(rootLen);</span>
<span class="fc" id="L5869">                            setStateForTimestamp(path, lastTimestamp, false);</span>
<span class="fc" id="L5870">                            int p = path.length();</span>
<span class="fc" id="L5871">                            transientRowCount = txWriter.getPartitionSizeByPartitionTimestamp(lastTimestamp);</span>


                            // 2. read max timestamp
<span class="fc" id="L5875">                            TableUtils.dFile(path.trimTo(p), metadata.getColumnName(metadata.getTimestampIndex()), COLUMN_NAME_TXN_NONE);</span>
<span class="fc" id="L5876">                            maxTimestamp = TableUtils.readLongAtOffset(ff, path, tempMem16b, (transientRowCount - 1) * Long.BYTES);</span>
<span class="fc" id="L5877">                            fixedRowCount -= transientRowCount;</span>
<span class="fc" id="L5878">                            txWriter.removeAttachedPartitions(txWriter.getMaxTimestamp());</span>
<span class="fc" id="L5879">                            LOG.info()</span>
<span class="fc" id="L5880">                                    .$(&quot;updated active partition [name=&quot;).$(path.trimTo(p).$())</span>
<span class="fc" id="L5881">                                    .$(&quot;, maxTimestamp=&quot;).$ts(maxTimestamp)</span>
<span class="fc" id="L5882">                                    .$(&quot;, transientRowCount=&quot;).$(transientRowCount)</span>
<span class="fc" id="L5883">                                    .$(&quot;, fixedRowCount=&quot;).$(txWriter.getFixedRowCount())</span>
<span class="fc" id="L5884">                                    .I$();</span>
                        }
                    }
                }
            } finally {
<span class="fc" id="L5889">                path.trimTo(rootLen);</span>
            }

<span class="fc" id="L5892">            final long expectedSize = txWriter.unsafeReadFixedRowCount();</span>
<span class="pc bpc" id="L5893" title="1 of 4 branches missed.">            if (expectedSize != fixedRowCount || maxTimestamp != this.txWriter.getMaxTimestamp()) {</span>
<span class="fc" id="L5894">                LOG.info()</span>
<span class="fc" id="L5895">                        .$(&quot;actual table size has been adjusted [name=`&quot;).utf8(tableToken.getTableName()).$('`')</span>
<span class="fc" id="L5896">                        .$(&quot;, expectedFixedSize=&quot;).$(expectedSize)</span>
<span class="fc" id="L5897">                        .$(&quot;, actualFixedSize=&quot;).$(fixedRowCount)</span>
<span class="fc" id="L5898">                        .I$();</span>

<span class="fc" id="L5900">                txWriter.reset(</span>
                        fixedRowCount,
                        transientRowCount,
                        maxTimestamp,
                        defaultCommitMode,
                        denseSymbolMapWriters
                );
<span class="fc" id="L5907">                return maxTimestamp;</span>
            }
        }

<span class="fc" id="L5911">        return timestamp;</span>
    }

    private void repairMetaRename(int index) {
        try {
<span class="fc" id="L5916">            path.concat(META_PREV_FILE_NAME);</span>
<span class="fc bfc" id="L5917" title="All 2 branches covered.">            if (index &gt; 0) {</span>
<span class="fc" id="L5918">                path.put('.').put(index);</span>
            }
<span class="fc" id="L5920">            path.$();</span>

<span class="pc bpc" id="L5922" title="1 of 2 branches missed.">            if (ff.exists(path)) {</span>
<span class="fc" id="L5923">                LOG.info().$(&quot;Repairing metadata from: &quot;).$(path).$();</span>
<span class="fc bfc" id="L5924" title="All 4 branches covered.">                if (ff.exists(other.concat(META_FILE_NAME).$()) &amp;&amp; !ff.remove(other)) {</span>
<span class="fc" id="L5925">                    throw CairoException.critical(ff.errno()).put(&quot;Repair failed. Cannot replace &quot;).put(other);</span>
                }

<span class="fc bfc" id="L5928" title="All 2 branches covered.">                if (ff.rename(path, other) != FILES_RENAME_OK) {</span>
<span class="fc" id="L5929">                    throw CairoException.critical(ff.errno()).put(&quot;Repair failed. Cannot rename &quot;).put(path).put(&quot; -&gt; &quot;).put(other);</span>
                }
            }
        } finally {
<span class="fc" id="L5933">            path.trimTo(rootLen);</span>
<span class="fc" id="L5934">            other.trimTo(rootLen);</span>
        }

<span class="fc" id="L5937">        clearTodoLog();</span>
<span class="fc" id="L5938">    }</span>

    private void repairTruncate() {
<span class="nc" id="L5941">        LOG.info().$(&quot;repairing abnormally terminated truncate on &quot;).$(path).$();</span>
<span class="nc bnc" id="L5942" title="All 2 branches missed.">        if (PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="nc" id="L5943">            removePartitionDirectories();</span>
        }
<span class="nc" id="L5945">        txWriter.truncate(columnVersionWriter.getVersion());</span>
<span class="nc" id="L5946">        clearTodoLog();</span>
<span class="nc" id="L5947">    }</span>

    private void resizeColumnTopSink(long o3TimestampMin, long o3TimestampMax) {
<span class="fc" id="L5950">        long maxPartitionsAffected = (o3TimestampMax - o3TimestampMin) / PartitionBy.getPartitionTimeIntervalFloor(partitionBy) + 2;</span>
<span class="fc" id="L5951">        long size = maxPartitionsAffected * (metadata.getColumnCount() + 1);</span>
<span class="fc bfc" id="L5952" title="All 2 branches covered.">        if (o3ColumnTopSink == null) {</span>
<span class="fc" id="L5953">            o3ColumnTopSink = new DirectLongList(size, MemoryTag.NATIVE_O3);</span>
        }
<span class="fc" id="L5955">        o3ColumnTopSink.setCapacity(size);</span>
<span class="fc" id="L5956">        o3ColumnTopSink.setPos(size);</span>
<span class="fc" id="L5957">        o3ColumnTopSink.zero(-1L);</span>
<span class="fc" id="L5958">    }</span>

    private void resizePartitionUpdateSink(long o3TimestampMin, long o3TimestampMax) {
<span class="fc" id="L5961">        int maxPartitionsAffected = (int) ((o3TimestampMax - o3TimestampMin) / PartitionBy.getPartitionTimeIntervalFloor(partitionBy) + 2);</span>
<span class="fc" id="L5962">        int size = maxPartitionsAffected * PARTITION_UPDATE_SINK_ENTRY_SIZE;</span>
<span class="fc bfc" id="L5963" title="All 2 branches covered.">        if (o3PartitionUpdateSink == null) {</span>
<span class="fc" id="L5964">            o3PartitionUpdateSink = new DirectLongList(size, MemoryTag.NATIVE_O3);</span>
        }
<span class="fc" id="L5966">        o3PartitionUpdateSink.setCapacity(size);</span>
<span class="fc" id="L5967">        o3PartitionUpdateSink.setPos(size);</span>
<span class="fc" id="L5968">        o3PartitionUpdateSink.zero(-1);</span>
<span class="fc" id="L5969">        o3PartitionUpdateSink.set(0, partitionFloorMethod.floor(o3TimestampMin));</span>
<span class="fc" id="L5970">    }</span>

    private void restoreMetaFrom(CharSequence fromBase, int fromIndex) {
        try {
<span class="fc" id="L5974">            path.concat(fromBase);</span>
<span class="fc bfc" id="L5975" title="All 2 branches covered.">            if (fromIndex &gt; 0) {</span>
<span class="fc" id="L5976">                path.put('.').put(fromIndex);</span>
            }
<span class="fc" id="L5978">            path.$();</span>

<span class="fc" id="L5980">            TableUtils.renameOrFail(ff, path, other.concat(META_FILE_NAME).$());</span>
        } finally {
<span class="fc" id="L5982">            path.trimTo(rootLen);</span>
<span class="fc" id="L5983">            other.trimTo(rootLen);</span>
        }
<span class="fc" id="L5985">    }</span>

    private void rollbackIndexes() {
<span class="fc" id="L5988">        final long maxRow = txWriter.getTransientRowCount() - 1;</span>
<span class="fc bfc" id="L5989" title="All 2 branches covered.">        for (int i = 0, n = denseIndexers.size(); i &lt; n; i++) {</span>
<span class="fc" id="L5990">            ColumnIndexer indexer = denseIndexers.getQuick(i);</span>
<span class="fc" id="L5991">            int fd = indexer.getFd();</span>
<span class="pc bpc" id="L5992" title="1 of 2 branches missed.">            if (fd &gt; -1) {</span>
<span class="fc" id="L5993">                LOG.info().$(&quot;recovering index [fd=&quot;).$(fd).I$();</span>
<span class="fc" id="L5994">                indexer.rollback(maxRow);</span>
            }
        }
<span class="fc" id="L5997">    }</span>

    private void rollbackSymbolTables() {
<span class="fc" id="L6000">        int expectedMapWriters = txWriter.unsafeReadSymbolColumnCount();</span>
<span class="fc bfc" id="L6001" title="All 2 branches covered.">        for (int i = 0; i &lt; expectedMapWriters; i++) {</span>
<span class="fc" id="L6002">            denseSymbolMapWriters.getQuick(i).rollback(txWriter.unsafeReadSymbolWriterIndexOffset(i));</span>
        }
<span class="fc" id="L6004">    }</span>

    private void rowAppend(ObjList&lt;Runnable&gt; activeNullSetters) {
<span class="fc bfc" id="L6007" title="All 2 branches covered.">        if ((masterRef &amp; 1) != 0) {</span>
<span class="fc bfc" id="L6008" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L6009" title="All 2 branches covered.">                if (rowValueIsNotNull.getQuick(i) &lt; masterRef) {</span>
<span class="fc" id="L6010">                    activeNullSetters.getQuick(i).run();</span>
                }
            }
<span class="fc" id="L6013">            masterRef++;</span>
        }
<span class="fc" id="L6015">    }</span>

    private void runFragile(FragileCode fragile, CharSequence columnName, CairoException e) {
        try {
<span class="fc" id="L6019">            fragile.run(columnName);</span>
<span class="fc" id="L6020">        } catch (CairoException e2) {</span>
<span class="fc" id="L6021">            LOG.error().$(&quot;DOUBLE ERROR: 1st: {&quot;).$((Sinkable) e).$('}').$();</span>
<span class="nc" id="L6022">            throwDistressException(e2);</span>
<span class="fc" id="L6023">        }</span>
<span class="fc" id="L6024">        throw e;</span>
    }

    private void safeDeletePartitionDir(long timestamp, long partitionNameTxn) {
        // Call O3 methods to remove check TxnScoreboard and remove partition directly
<span class="fc" id="L6029">        partitionRemoveCandidates.clear();</span>
<span class="fc" id="L6030">        partitionRemoveCandidates.add(timestamp, partitionNameTxn);</span>
<span class="fc" id="L6031">        processPartitionRemoveCandidates();</span>
<span class="fc" id="L6032">    }</span>

    private void setAppendPosition(final long position, boolean doubleAllocate) {
<span class="fc bfc" id="L6035" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
            // stop calculating oversize as soon as we find first over-sized column
<span class="fc" id="L6037">            setColumnSize(i, position, doubleAllocate);</span>
        }
<span class="fc" id="L6039">    }</span>

    private void setColumnSize(int columnIndex, long size, boolean doubleAllocate) {
        try {
<span class="fc" id="L6043">            MemoryMA mem1 = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L6044">            MemoryMA mem2 = getSecondaryColumn(columnIndex);</span>
<span class="fc" id="L6045">            int type = metadata.getColumnType(columnIndex);</span>
<span class="fc bfc" id="L6046" title="All 2 branches covered.">            if (type &gt; 0) { // Not deleted</span>
<span class="fc" id="L6047">                final long pos = size - columnTops.getQuick(columnIndex);</span>
<span class="fc bfc" id="L6048" title="All 2 branches covered.">                if (pos &gt; 0) {</span>
                    // subtract column top
                    final long m1pos;
<span class="fc bfc" id="L6051" title="All 2 branches covered.">                    switch (ColumnType.tagOf(type)) {</span>
                        case ColumnType.BINARY:
                        case ColumnType.STRING:
<span class="pc bpc" id="L6054" title="1 of 2 branches missed.">                            assert mem2 != null;</span>
<span class="fc bfc" id="L6055" title="All 2 branches covered.">                            if (doubleAllocate) {</span>
<span class="fc" id="L6056">                                mem2.allocate(pos * Long.BYTES + Long.BYTES);</span>
                            }
                            // Jump to the number of records written to read length of var column correctly
<span class="fc" id="L6059">                            mem2.jumpTo(pos * Long.BYTES);</span>
<span class="fc" id="L6060">                            m1pos = Unsafe.getUnsafe().getLong(mem2.getAppendAddress());</span>
                            // Jump to the end of file to correctly trim the file
<span class="fc" id="L6062">                            mem2.jumpTo((pos + 1) * Long.BYTES);</span>
<span class="fc" id="L6063">                            break;</span>
                        default:
<span class="fc" id="L6065">                            m1pos = pos &lt;&lt; ColumnType.pow2SizeOf(type);</span>
                            break;
                    }
<span class="fc bfc" id="L6068" title="All 2 branches covered.">                    if (doubleAllocate) {</span>
<span class="fc" id="L6069">                        mem1.allocate(m1pos);</span>
                    }
<span class="fc" id="L6071">                    mem1.jumpTo(m1pos);</span>
<span class="fc" id="L6072">                } else {</span>
<span class="fc" id="L6073">                    mem1.jumpTo(0);</span>
<span class="fc bfc" id="L6074" title="All 2 branches covered.">                    if (mem2 != null) {</span>
<span class="fc" id="L6075">                        mem2.jumpTo(0);</span>
<span class="fc" id="L6076">                        mem2.putLong(0);</span>
                    }
                }
            }
<span class="fc" id="L6080">        } catch (CairoException e) {</span>
<span class="nc" id="L6081">            throwDistressException(e);</span>
<span class="fc" id="L6082">        }</span>
<span class="fc" id="L6083">    }</span>

    private void setO3AppendPosition(final long position) {
<span class="fc bfc" id="L6086" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L6087">            int columnType = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L6088" title="All 2 branches covered.">            if (columnType &gt; 0) {</span>
<span class="fc" id="L6089">                o3SetAppendOffset(i, columnType, position);</span>
            }
        }
<span class="fc" id="L6092">    }</span>

    private void setRowValueNotNull(int columnIndex) {
<span class="pc bpc" id="L6095" title="1 of 2 branches missed.">        assert rowValueIsNotNull.getQuick(columnIndex) != masterRef;</span>
<span class="fc" id="L6096">        rowValueIsNotNull.setQuick(columnIndex, masterRef);</span>
<span class="fc" id="L6097">    }</span>

    /**
     * Sets path member variable to partition directory for the given timestamp and
     * partitionLo and partitionHi to partition interval in millis. These values are
     * determined based on input timestamp and value of partitionBy. For any given
     * timestamp this method will determine either day, month or year interval timestamp falls to.
     * Partition directory name is ISO string of interval start.
     * &lt;p&gt;
     * Because this method modifies &quot;path&quot; member variable, be sure path is trimmed to original
     * state within try..finally block.
     *
     * @param path                    path instance to modify
     * @param timestamp               to determine interval for
     * @param updatePartitionInterval flag indicating that partition interval partitionLo and
     */
    private void setStateForTimestamp(Path path, long timestamp, boolean updatePartitionInterval) {
<span class="fc" id="L6114">        final long partitionTimestampHi = TableUtils.setPathForPartition(path, partitionBy, timestamp, true);</span>
        // When partition is create a txn name must always be set to purge dropped partitions.
        // When partition is created outside O3 merge use `txn-1` as the version
<span class="fc bfc" id="L6117" title="All 2 branches covered.">        long partitionTxnName = PartitionBy.isPartitioned(partitionBy) ? txWriter.getTxn() - 1 : -1;</span>
<span class="fc" id="L6118">        TableUtils.txnPartitionConditionally(</span>
                path,
<span class="fc" id="L6120">                txWriter.getPartitionNameTxnByPartitionTimestamp(partitionTimestampHi, partitionTxnName)</span>
        );
<span class="fc bfc" id="L6122" title="All 2 branches covered.">        if (updatePartitionInterval) {</span>
<span class="fc" id="L6123">            this.partitionTimestampHi = partitionTimestampHi;</span>
        }
<span class="fc" id="L6125">    }</span>

    private void swapMetaFile(CharSequence columnName) {
        // close _meta so we can rename it
<span class="fc" id="L6129">        metaMem.close();</span>
        // validate new meta
<span class="fc" id="L6131">        validateSwapMeta(columnName);</span>
        // rename _meta to _meta.prev
<span class="fc" id="L6133">        renameMetaToMetaPrev(columnName);</span>
        // after we moved _meta to _meta.prev
        // we have to have _todo to restore _meta should anything go wrong
<span class="fc" id="L6136">        writeRestoreMetaTodo(columnName);</span>
        // rename _meta.swp to -_meta
<span class="fc" id="L6138">        renameSwapMetaToMeta(columnName);</span>
        try {
            // open _meta file
<span class="fc" id="L6141">            openMetaFile(ff, path, rootLen, metaMem);</span>
            // remove _todo
<span class="fc" id="L6143">            clearTodoLog();</span>
<span class="nc" id="L6144">        } catch (CairoException e) {</span>
<span class="nc" id="L6145">            throwDistressException(e);</span>
<span class="fc" id="L6146">        }</span>
<span class="fc" id="L6147">        bumpStructureVersion();</span>
<span class="fc" id="L6148">    }</span>

    private void swapO3ColumnsExcept(int timestampIndex) {
<span class="fc" id="L6151">        ObjList&lt;MemoryCARW&gt; temp = o3MemColumns;</span>
<span class="fc" id="L6152">        o3MemColumns = o3MemColumns2;</span>
<span class="fc" id="L6153">        o3MemColumns2 = temp;</span>

        // Swap timestamp column back, timestamp column is not sorted, it's the sort key.
<span class="fc" id="L6156">        final int timestampMemoryIndex = getPrimaryColumnIndex(timestampIndex);</span>
<span class="fc" id="L6157">        o3MemColumns2.setQuick(</span>
                timestampMemoryIndex,
<span class="fc" id="L6159">                o3MemColumns.getAndSetQuick(timestampMemoryIndex, o3MemColumns2.getQuick(timestampMemoryIndex))</span>
        );
<span class="fc" id="L6161">        o3Columns = o3MemColumns;</span>
<span class="fc" id="L6162">        activeColumns = o3MemColumns;</span>

<span class="fc" id="L6164">        ObjList&lt;Runnable&gt; tempNullSetters = o3NullSetters;</span>
<span class="fc" id="L6165">        o3NullSetters = o3NullSetters2;</span>
<span class="fc" id="L6166">        o3NullSetters2 = tempNullSetters;</span>
<span class="fc" id="L6167">        activeNullSetters = o3NullSetters;</span>
<span class="fc" id="L6168">    }</span>

    private void switchPartition(long timestamp) {
        // Before partition can be switched we need to index records
        // added so far. Index writers will start point to different
        // files after switch.
<span class="fc" id="L6174">        updateIndexes();</span>
<span class="fc" id="L6175">        txWriter.switchPartitions(timestamp);</span>
<span class="fc" id="L6176">        openPartition(timestamp);</span>
<span class="fc" id="L6177">        setAppendPosition(0, false);</span>
<span class="fc" id="L6178">    }</span>

    private void syncColumns(int commitMode) {
<span class="fc bfc" id="L6181" title="All 2 branches covered.">        final boolean async = commitMode == CommitMode.ASYNC;</span>
<span class="fc bfc" id="L6182" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L6183">            columns.getQuick(i * 2).sync(async);</span>
<span class="fc" id="L6184">            final MemoryMA m2 = columns.getQuick(i * 2 + 1);</span>
<span class="fc bfc" id="L6185" title="All 2 branches covered.">            if (m2 != null) {</span>
<span class="fc" id="L6186">                m2.sync(false);</span>
            }
        }
<span class="fc" id="L6189">    }</span>

    private void throwDistressException(CairoException cause) {
<span class="fc" id="L6192">        LOG.critical().$(&quot;writer error [table=&quot;).utf8(tableToken.getTableName()).$(&quot;, e=&quot;).$((Sinkable) cause).I$();</span>
<span class="fc" id="L6193">        distressed = true;</span>
<span class="fc" id="L6194">        throw new CairoError(cause);</span>
    }

    private void updateIndexes() {
<span class="fc bfc" id="L6198" title="All 4 branches covered.">        if (indexCount == 0 || avoidIndexOnCommit) {</span>
<span class="fc" id="L6199">            avoidIndexOnCommit = false;</span>
<span class="fc" id="L6200">            return;</span>
        }
<span class="fc" id="L6202">        updateIndexesSlow();</span>
<span class="fc" id="L6203">    }</span>

    private void updateIndexesParallel(long lo, long hi) {
<span class="fc" id="L6206">        indexSequences.clear();</span>
<span class="fc" id="L6207">        indexLatch.setCount(indexCount);</span>
<span class="fc" id="L6208">        final int nParallelIndexes = indexCount - 1;</span>
<span class="fc" id="L6209">        final Sequence indexPubSequence = this.messageBus.getIndexerPubSequence();</span>
<span class="fc" id="L6210">        final RingQueue&lt;ColumnIndexerTask&gt; indexerQueue = this.messageBus.getIndexerQueue();</span>

<span class="fc" id="L6212">        LOG.info().$(&quot;parallel indexing [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L6213">                .$(&quot;, indexCount=&quot;).$(indexCount)</span>
<span class="fc" id="L6214">                .$(&quot;, rowCount=&quot;).$(hi - lo)</span>
<span class="fc" id="L6215">                .I$();</span>
<span class="fc" id="L6216">        int serialIndexCount = 0;</span>

        // we are going to index last column in this thread while other columns are on the queue
        OUT:
<span class="fc bfc" id="L6220" title="All 2 branches covered.">        for (int i = 0; i &lt; nParallelIndexes; i++) {</span>

<span class="fc" id="L6222">            long cursor = indexPubSequence.next();</span>
<span class="fc bfc" id="L6223" title="All 2 branches covered.">            if (cursor == -1) {</span>
                // queue is full, process index in the current thread
<span class="fc" id="L6225">                indexAndCountDown(denseIndexers.getQuick(i), lo, hi, indexLatch);</span>
<span class="fc" id="L6226">                serialIndexCount++;</span>
<span class="fc" id="L6227">                continue;</span>
            }

<span class="fc bfc" id="L6230" title="All 2 branches covered.">            if (cursor == -2) {</span>
                // CAS issue, retry
                do {
<span class="fc" id="L6233">                    Os.pause();</span>
<span class="fc" id="L6234">                    cursor = indexPubSequence.next();</span>
<span class="fc bfc" id="L6235" title="All 2 branches covered.">                    if (cursor == -1) {</span>
<span class="fc" id="L6236">                        indexAndCountDown(denseIndexers.getQuick(i), lo, hi, indexLatch);</span>
<span class="fc" id="L6237">                        serialIndexCount++;</span>
<span class="fc" id="L6238">                        continue OUT;</span>
                    }
<span class="pc bpc" id="L6240" title="1 of 2 branches missed.">                } while (cursor &lt; 0);</span>
            }

<span class="fc" id="L6243">            final ColumnIndexerTask queueItem = indexerQueue.get(cursor);</span>
<span class="fc" id="L6244">            final ColumnIndexer indexer = denseIndexers.getQuick(i);</span>
<span class="fc" id="L6245">            final long sequence = indexer.getSequence();</span>
<span class="fc" id="L6246">            queueItem.indexer = indexer;</span>
<span class="fc" id="L6247">            queueItem.lo = lo;</span>
<span class="fc" id="L6248">            queueItem.hi = hi;</span>
<span class="fc" id="L6249">            queueItem.countDownLatch = indexLatch;</span>
<span class="fc" id="L6250">            queueItem.sequence = sequence;</span>
<span class="fc" id="L6251">            indexSequences.add(sequence);</span>
<span class="fc" id="L6252">            indexPubSequence.done(cursor);</span>
        }

        // index last column while other columns are brewing on the queue
<span class="fc" id="L6256">        indexAndCountDown(denseIndexers.getQuick(indexCount - 1), lo, hi, indexLatch);</span>
<span class="fc" id="L6257">        serialIndexCount++;</span>

        // At this point we have re-indexed our column and if things are flowing nicely
        // all other columns should have been done by other threads. Instead of actually
        // waiting we gracefully check latch count.
<span class="fc bfc" id="L6262" title="All 2 branches covered.">        if (!indexLatch.await(configuration.getWorkStealTimeoutNanos())) {</span>
            // other columns are still in-flight, we must attempt to steal work from other threads
<span class="fc bfc" id="L6264" title="All 2 branches covered.">            for (int i = 0; i &lt; nParallelIndexes; i++) {</span>
<span class="fc" id="L6265">                ColumnIndexer indexer = denseIndexers.getQuick(i);</span>
<span class="fc bfc" id="L6266" title="All 2 branches covered.">                if (indexer.tryLock(indexSequences.getQuick(i))) {</span>
<span class="fc" id="L6267">                    indexAndCountDown(indexer, lo, hi, indexLatch);</span>
<span class="fc" id="L6268">                    serialIndexCount++;</span>
                }
            }
            // wait for the ones we cannot steal
<span class="fc" id="L6272">            indexLatch.await();</span>
        }

        // reset lock on completed indexers
<span class="fc" id="L6276">        boolean distressed = false;</span>
<span class="fc bfc" id="L6277" title="All 2 branches covered.">        for (int i = 0; i &lt; indexCount; i++) {</span>
<span class="fc" id="L6278">            ColumnIndexer indexer = denseIndexers.getQuick(i);</span>
<span class="fc" id="L6279">            distressed = distressed | indexer.isDistressed();</span>
        }

<span class="fc bfc" id="L6282" title="All 2 branches covered.">        if (distressed) {</span>
<span class="nc" id="L6283">            throwDistressException(null);</span>
        }

<span class="fc" id="L6286">        LOG.info().$(&quot;parallel indexing done [serialCount=&quot;).$(serialIndexCount).I$();</span>
<span class="fc" id="L6287">    }</span>

    private void updateIndexesSerially(long lo, long hi) {
<span class="fc" id="L6290">        LOG.info().$(&quot;serial indexing [table=&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L6291">                .$(&quot;, indexCount=&quot;).$(indexCount)</span>
<span class="fc" id="L6292">                .$(&quot;, rowCount=&quot;).$(hi - lo)</span>
<span class="fc" id="L6293">                .I$();</span>
<span class="fc bfc" id="L6294" title="All 2 branches covered.">        for (int i = 0, n = denseIndexers.size(); i &lt; n; i++) {</span>
            try {
<span class="fc" id="L6296">                denseIndexers.getQuick(i).refreshSourceAndIndex(lo, hi);</span>
<span class="fc" id="L6297">            } catch (CairoException e) {</span>
                // this is pretty severe, we hit some sort of limit
<span class="nc" id="L6299">                throwDistressException(e);</span>
<span class="fc" id="L6300">            }</span>
        }
<span class="fc" id="L6302">        LOG.info().$(&quot;serial indexing done [table=&quot;).utf8(tableToken.getTableName()).I$();</span>
<span class="fc" id="L6303">    }</span>

    private void updateIndexesSlow() {
<span class="fc" id="L6306">        final long hi = txWriter.getTransientRowCount();</span>
<span class="fc bfc" id="L6307" title="All 2 branches covered.">        final long lo = txWriter.getAppendedPartitionCount() == 1 ? hi - txWriter.getLastTxSize() : 0;</span>
<span class="pc bpc" id="L6308" title="1 of 6 branches missed.">        if (indexCount &gt; 1 &amp;&amp; parallelIndexerEnabled &amp;&amp; hi - lo &gt; configuration.getParallelIndexThreshold()) {</span>
<span class="fc" id="L6309">            updateIndexesParallel(lo, hi);</span>
        } else {
<span class="fc" id="L6311">            updateIndexesSerially(lo, hi);</span>
        }
<span class="fc" id="L6313">    }</span>

    private void updateMaxTimestamp(long timestamp) {
<span class="fc" id="L6316">        txWriter.updateMaxTimestamp(timestamp);</span>
<span class="fc" id="L6317">        this.timestampSetter.accept(timestamp);</span>
<span class="fc" id="L6318">    }</span>

    private void updateMetaStructureVersion() {
        try {
<span class="fc" id="L6322">            copyMetadataAndUpdateVersion();</span>
<span class="fc" id="L6323">            finishMetaSwapUpdate();</span>
<span class="fc" id="L6324">            clearTodoLog();</span>
        } finally {
<span class="fc" id="L6326">            ddlMem.close();</span>
        }
<span class="fc" id="L6328">    }</span>

    private void updateO3ColumnTops() {
<span class="fc" id="L6331">        int columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L6332">        int increment = columnCount + 1;</span>

<span class="fc bfc" id="L6334" title="All 2 branches covered.">        for (int partitionOffset = 0, n = (int) o3ColumnTopSink.size(); partitionOffset &lt; n; partitionOffset += increment) {</span>
<span class="fc" id="L6335">            long partitionTimestamp = o3ColumnTopSink.get(partitionOffset);</span>
<span class="fc bfc" id="L6336" title="All 2 branches covered.">            if (partitionTimestamp &gt; -1) {</span>
<span class="fc bfc" id="L6337" title="All 2 branches covered.">                for (int column = 0; column &lt; columnCount; column++) {</span>
<span class="fc" id="L6338">                    long colTop = o3ColumnTopSink.get(partitionOffset + column + 1);</span>
<span class="fc bfc" id="L6339" title="All 2 branches covered.">                    if (colTop &gt; -1L) {</span>
                        // Upsert even when colTop value is 0.
                        // TableReader uses the record to determine if the column is supposed to be present for the partition.
<span class="fc" id="L6342">                        columnVersionWriter.upsertColumnTop(partitionTimestamp, column, colTop);</span>
                    }
                }
            }
        }
<span class="fc" id="L6347">    }</span>

    private void validateSwapMeta(CharSequence columnName) {
        try {
            try {
<span class="fc" id="L6352">                path.concat(META_SWAP_FILE_NAME);</span>
<span class="fc bfc" id="L6353" title="All 2 branches covered.">                if (metaSwapIndex &gt; 0) {</span>
<span class="fc" id="L6354">                    path.put('.').put(metaSwapIndex);</span>
                }
<span class="fc" id="L6356">                metaMem.smallFile(ff, path.$(), MemoryTag.MMAP_TABLE_WRITER);</span>
<span class="fc" id="L6357">                validationMap.clear();</span>
<span class="fc" id="L6358">                validateMeta(metaMem, validationMap, ColumnType.VERSION);</span>
            } finally {
<span class="fc" id="L6360">                metaMem.close();</span>
<span class="fc" id="L6361">                path.trimTo(rootLen);</span>
            }
<span class="fc" id="L6363">        } catch (CairoException e) {</span>
<span class="nc" id="L6364">            runFragile(RECOVER_FROM_META_RENAME_FAILURE, columnName, e);</span>
<span class="fc" id="L6365">        }</span>
<span class="fc" id="L6366">    }</span>

    private void writeColumnEntry(int i, boolean markDeleted) {
<span class="fc" id="L6369">        int columnType = getColumnType(metaMem, i);</span>
        // When column is deleted it's written to metadata with negative type
<span class="fc bfc" id="L6371" title="All 2 branches covered.">        if (markDeleted) {</span>
<span class="fc" id="L6372">            columnType = -Math.abs(columnType);</span>
        }
<span class="fc" id="L6374">        ddlMem.putInt(columnType);</span>

<span class="fc" id="L6376">        long flags = 0;</span>
<span class="fc bfc" id="L6377" title="All 2 branches covered.">        if (isColumnIndexed(metaMem, i)) {</span>
<span class="fc" id="L6378">            flags |= META_FLAG_BIT_INDEXED;</span>
        }

<span class="pc bpc" id="L6381" title="1 of 2 branches missed.">        if (isSequential(metaMem, i)) {</span>
<span class="nc" id="L6382">            flags |= META_FLAG_BIT_SEQUENTIAL;</span>
        }
<span class="fc" id="L6384">        ddlMem.putLong(flags);</span>
<span class="fc" id="L6385">        ddlMem.putInt(getIndexBlockCapacity(metaMem, i));</span>
<span class="fc" id="L6386">        ddlMem.skip(16);</span>
<span class="fc" id="L6387">    }</span>

    private void writeRestoreMetaTodo(CharSequence columnName) {
        try {
<span class="fc" id="L6391">            writeRestoreMetaTodo();</span>
<span class="nc" id="L6392">        } catch (CairoException e) {</span>
<span class="nc" id="L6393">            runFragile(RECOVER_FROM_TODO_WRITE_FAILURE, columnName, e);</span>
<span class="fc" id="L6394">        }</span>
<span class="fc" id="L6395">    }</span>

    private void writeRestoreMetaTodo() {
<span class="fc" id="L6398">        todoMem.putLong(0, ++todoTxn); // write txn, reader will first read txn at offset 24 and then at offset 0</span>
<span class="fc" id="L6399">        Unsafe.getUnsafe().storeFence(); // make sure we do not write hash before writing txn (view from another thread)</span>
<span class="fc" id="L6400">        todoMem.putLong(8, configuration.getDatabaseIdLo()); // write out our instance hashes</span>
<span class="fc" id="L6401">        todoMem.putLong(16, configuration.getDatabaseIdHi());</span>
<span class="fc" id="L6402">        Unsafe.getUnsafe().storeFence();</span>
<span class="fc" id="L6403">        todoMem.putLong(32, 1);</span>
<span class="fc" id="L6404">        todoMem.putLong(40, TODO_RESTORE_META);</span>
<span class="fc" id="L6405">        todoMem.putLong(48, metaPrevIndex);</span>
<span class="fc" id="L6406">        Unsafe.getUnsafe().storeFence();</span>
<span class="fc" id="L6407">        todoMem.putLong(24, todoTxn);</span>
<span class="fc" id="L6408">        todoMem.jumpTo(56);</span>
<span class="fc" id="L6409">    }</span>

    static void indexAndCountDown(ColumnIndexer indexer, long lo, long hi, SOCountDownLatch latch) {
        try {
<span class="fc" id="L6413">            indexer.refreshSourceAndIndex(lo, hi);</span>
<span class="fc" id="L6414">        } catch (CairoException e) {</span>
<span class="fc" id="L6415">            indexer.distress();</span>
<span class="fc" id="L6416">            LOG.critical().$(&quot;index error [fd=&quot;).$(indexer.getFd()).$(']').$('{').$((Sinkable) e).$('}').$();</span>
        } finally {
<span class="fc" id="L6418">            latch.countDown();</span>
        }
<span class="fc" id="L6420">    }</span>

    void closeActivePartition(boolean truncate) {
<span class="fc" id="L6423">        LOG.info().$(&quot;closing last partition [table=&quot;).utf8(tableToken.getTableName()).I$();</span>
<span class="fc" id="L6424">        closeAppendMemoryTruncate(truncate);</span>
<span class="fc" id="L6425">        freeIndexers();</span>
<span class="fc" id="L6426">    }</span>

    void closeActivePartition(long size) {
<span class="fc bfc" id="L6429" title="All 2 branches covered.">        for (int i = 0; i &lt; columnCount; i++) {</span>
            // stop calculating oversize as soon as we find first over-sized column
<span class="fc" id="L6431">            setColumnSize(i, size, false);</span>
<span class="fc" id="L6432">            Misc.free(getPrimaryColumn(i));</span>
<span class="fc" id="L6433">            Misc.free(getSecondaryColumn(i));</span>
        }
<span class="fc" id="L6435">        Misc.freeObjList(denseIndexers);</span>
<span class="fc" id="L6436">        denseIndexers.clear();</span>
<span class="fc" id="L6437">    }</span>

    BitmapIndexWriter getBitmapIndexWriter(int columnIndex) {
<span class="fc" id="L6440">        return indexers.getQuick(columnIndex).getWriter();</span>
    }

    long getColumnTop(int columnIndex) {
<span class="fc" id="L6444">        return columnTops.getQuick(columnIndex);</span>
    }

    ColumnVersionReader getColumnVersionReader() {
<span class="fc" id="L6448">        return columnVersionWriter;</span>
    }

    CairoConfiguration getConfiguration() {
<span class="fc" id="L6452">        return configuration;</span>
    }

    Sequence getO3CopyPubSeq() {
<span class="fc" id="L6456">        return messageBus.getO3CopyPubSeq();</span>
    }

    RingQueue&lt;O3CopyTask&gt; getO3CopyQueue() {
<span class="fc" id="L6460">        return messageBus.getO3CopyQueue();</span>
    }

    Sequence getO3OpenColumnPubSeq() {
<span class="fc" id="L6464">        return messageBus.getO3OpenColumnPubSeq();</span>
    }

    RingQueue&lt;O3OpenColumnTask&gt; getO3OpenColumnQueue() {
<span class="fc" id="L6468">        return messageBus.getO3OpenColumnQueue();</span>
    }

    long getPartitionNameTxnByIndex(int index) {
<span class="fc" id="L6472">        return txWriter.getPartitionNameTxnByIndex(index);</span>
    }

    long getPartitionSizeByIndex(int index) {
<span class="fc" id="L6476">        return txWriter.getPartitionSizeByIndex(index);</span>
    }

    TxReader getTxReader() {
<span class="fc" id="L6480">        return txWriter;</span>
    }

    boolean isSymbolMapWriterCached(int columnIndex) {
<span class="fc" id="L6484">        return symbolMapWriters.getQuick(columnIndex).isCached();</span>
    }

    void o3ClockDownPartitionUpdateCount() {
<span class="fc" id="L6488">        o3PartitionUpdRemaining.decrementAndGet();</span>
<span class="fc" id="L6489">    }</span>

    void o3CountDownDoneLatch() {
<span class="fc" id="L6492">        o3DoneLatch.countDown();</span>
<span class="fc" id="L6493">    }</span>

    void o3NotifyPartitionUpdate(
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            long srcOooPartitionLo,
            long srcOooPartitionHi,
            boolean partitionMutates,
            long srcOooMax,
            long srcDataMax
    ) {
<span class="fc" id="L6505">        long basePartitionTs = o3PartitionUpdateSink.get(0);</span>
<span class="fc" id="L6506">        int partitionSinkIndex = (int) ((partitionTimestamp - basePartitionTs) / PartitionBy.getPartitionTimeIntervalFloor(partitionBy));</span>
<span class="fc" id="L6507">        int offset = partitionSinkIndex * PARTITION_UPDATE_SINK_ENTRY_SIZE;</span>

<span class="fc" id="L6509">        o3PartitionUpdateSink.set(offset, partitionTimestamp);</span>
<span class="fc" id="L6510">        o3PartitionUpdateSink.set(offset + 1, timestampMin);</span>
<span class="fc" id="L6511">        o3PartitionUpdateSink.set(offset + 2, timestampMax);</span>
<span class="fc" id="L6512">        o3PartitionUpdateSink.set(offset + 3, srcOooPartitionLo);</span>
<span class="fc" id="L6513">        o3PartitionUpdateSink.set(offset + 4, srcOooPartitionHi);</span>
<span class="fc bfc" id="L6514" title="All 2 branches covered.">        o3PartitionUpdateSink.set(offset + 5, partitionMutates ? 1 : 0);</span>
<span class="fc" id="L6515">        o3PartitionUpdateSink.set(offset + 6, srcOooMax);</span>
<span class="fc" id="L6516">        o3PartitionUpdateSink.set(offset + 7, srcDataMax);</span>

<span class="fc" id="L6518">        o3ClockDownPartitionUpdateCount();</span>
<span class="fc" id="L6519">    }</span>

    boolean preferDirectIO() {
<span class="fc" id="L6522">        return directIOFlag;</span>
    }

    void purgeUnusedPartitions() {
<span class="fc bfc" id="L6526" title="All 2 branches covered.">        if (PartitionBy.isPartitioned(partitionBy)) {</span>
<span class="fc" id="L6527">            removeNonAttachedPartitions();</span>
        }
<span class="fc" id="L6529">    }</span>

    void rowCancel() {
<span class="fc bfc" id="L6532" title="All 2 branches covered.">        if ((masterRef &amp; 1) == 0) {</span>
<span class="fc" id="L6533">            return;</span>
        }

<span class="fc bfc" id="L6536" title="All 2 branches covered.">        if (hasO3()) {</span>
<span class="fc" id="L6537">            final long o3RowCount = getO3RowCount0();</span>
<span class="fc bfc" id="L6538" title="All 2 branches covered.">            if (o3RowCount &gt; 0) {</span>
                // O3 mode and there are some rows.
<span class="fc" id="L6540">                masterRef--;</span>
<span class="fc" id="L6541">                setO3AppendPosition(o3RowCount);</span>
            } else {
                // Cancelling first row in o3, reverting to non-o3
<span class="fc" id="L6544">                setO3AppendPosition(0);</span>
<span class="fc" id="L6545">                masterRef--;</span>
<span class="fc" id="L6546">                clearO3();</span>
            }
<span class="fc" id="L6548">            rowValueIsNotNull.fill(0, columnCount, masterRef);</span>
<span class="fc" id="L6549">            return;</span>
        }

<span class="fc" id="L6552">        long dirtyMaxTimestamp = txWriter.getMaxTimestamp();</span>
<span class="fc" id="L6553">        long dirtyTransientRowCount = txWriter.getTransientRowCount();</span>
<span class="fc" id="L6554">        long rollbackToMaxTimestamp = txWriter.cancelToMaxTimestamp();</span>
<span class="fc" id="L6555">        long rollbackToTransientRowCount = txWriter.cancelToTransientRowCount();</span>

        // dirty timestamp should be 1 because newRow() increments it
<span class="fc bfc" id="L6558" title="All 2 branches covered.">        if (dirtyTransientRowCount == 1) {</span>
<span class="fc bfc" id="L6559" title="All 2 branches covered.">            if (PartitionBy.isPartitioned(partitionBy)) {</span>
                // we have to undo creation of partition
<span class="fc" id="L6561">                closeActivePartition(false);</span>
<span class="pc bpc" id="L6562" title="1 of 2 branches missed.">                if (removeDirOnCancelRow) {</span>
                    try {
<span class="fc" id="L6564">                        setStateForTimestamp(path, dirtyMaxTimestamp, false);</span>
                        int errno;
<span class="fc bfc" id="L6566" title="All 2 branches covered.">                        if ((errno = ff.rmdir(path.$())) != 0) {</span>
<span class="fc" id="L6567">                            throw CairoException.critical(errno).put(&quot;Cannot remove directory: &quot;).put(path);</span>
                        }
<span class="fc" id="L6569">                        removeDirOnCancelRow = false;</span>
                    } finally {
<span class="fc" id="L6571">                        path.trimTo(rootLen);</span>
                    }
                }

                // open old partition
<span class="fc bfc" id="L6576" title="All 2 branches covered.">                if (rollbackToMaxTimestamp &gt; Long.MIN_VALUE) {</span>
                    try {
<span class="fc" id="L6578">                        openPartition(rollbackToMaxTimestamp);</span>
<span class="fc" id="L6579">                        setAppendPosition(rollbackToTransientRowCount, false);</span>
<span class="fc" id="L6580">                    } catch (Throwable e) {</span>
<span class="fc" id="L6581">                        freeColumns(false);</span>
<span class="fc" id="L6582">                        throw e;</span>
<span class="fc" id="L6583">                    }</span>
                } else {
<span class="fc" id="L6585">                    rowAction = ROW_ACTION_OPEN_PARTITION;</span>
                }

                // undo counts
<span class="fc" id="L6589">                removeDirOnCancelRow = true;</span>
<span class="fc" id="L6590">                txWriter.cancelRow();</span>
            } else {
<span class="fc" id="L6592">                txWriter.cancelRow();</span>
                // we only have one partition, jump to start on every column
<span class="fc bfc" id="L6594" title="All 2 branches covered.">                for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L6595">                    getPrimaryColumn(i).jumpTo(0L);</span>
<span class="fc" id="L6596">                    MemoryMA mem = getSecondaryColumn(i);</span>
<span class="fc bfc" id="L6597" title="All 2 branches covered.">                    if (mem != null) {</span>
<span class="fc" id="L6598">                        mem.jumpTo(0L);</span>
<span class="fc" id="L6599">                        mem.putLong(0L);</span>
                    }
                }
            }
        } else {
<span class="fc" id="L6604">            txWriter.cancelRow();</span>
            // we are staying within same partition, prepare append positions for row count
<span class="fc bfc" id="L6606" title="All 2 branches covered.">            boolean rowChanged = metadata.getTimestampIndex() &gt;= 0; // adding new row already writes timestamp</span>
<span class="fc bfc" id="L6607" title="All 2 branches covered.">            if (!rowChanged) {</span>
                // verify if any of the columns have been changed
                // if not - we don't have to do
<span class="fc bfc" id="L6610" title="All 2 branches covered.">                for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc bfc" id="L6611" title="All 2 branches covered.">                    if (rowValueIsNotNull.getQuick(i) == masterRef) {</span>
<span class="fc" id="L6612">                        rowChanged = true;</span>
<span class="fc" id="L6613">                        break;</span>
                    }
                }
            }

            // is no column has been changed we take easy option and do nothing
<span class="fc bfc" id="L6619" title="All 2 branches covered.">            if (rowChanged) {</span>
<span class="fc" id="L6620">                setAppendPosition(dirtyTransientRowCount - 1, false);</span>
            }
        }
<span class="fc" id="L6623">        rowValueIsNotNull.fill(0, columnCount, --masterRef);</span>
<span class="fc" id="L6624">        txWriter.transientRowCount--;</span>
<span class="fc" id="L6625">    }</span>

    @FunctionalInterface
    public interface ExtensionListener {
        void onTableExtended(long timestamp);
    }

    @FunctionalInterface
    private interface FragileCode {
        void run(CharSequence columnName);
    }

    @FunctionalInterface
    public interface O3ColumnUpdateMethod {
        void run(
                int columnIndex,
                final int columnType,
                long mergedTimestampsAddr,
                long row1Count,
                long row2CountLo,
                long row2CountHi
        );
    }

    public interface Row {

        void append();

        void cancel();

        void putBin(int columnIndex, long address, long len);

        void putBin(int columnIndex, BinarySequence sequence);

        void putBool(int columnIndex, boolean value);

        void putByte(int columnIndex, byte value);

        void putChar(int columnIndex, char value);

        default void putDate(int columnIndex, long value) {
<span class="fc" id="L6666">            putLong(columnIndex, value);</span>
<span class="fc" id="L6667">        }</span>

        void putDouble(int columnIndex, double value);

        void putFloat(int columnIndex, float value);

        void putGeoHash(int columnIndex, long value);

        void putGeoHashDeg(int index, double lat, double lon);

        void putGeoStr(int columnIndex, CharSequence value);

        void putInt(int columnIndex, int value);

        void putLong(int columnIndex, long value);

        void putLong128(int columnIndex, long lo, long hi);

        void putLong256(int columnIndex, long l0, long l1, long l2, long l3);

        void putLong256(int columnIndex, Long256 value);

        void putLong256(int columnIndex, CharSequence hexString);

        void putLong256(int columnIndex, @NotNull CharSequence hexString, int start, int end);

        void putShort(int columnIndex, short value);

        void putStr(int columnIndex, CharSequence value);

        void putStr(int columnIndex, char value);

        void putStr(int columnIndex, CharSequence value, int pos, int len);

        /**
         * Writes UTF8-encoded string to WAL. As the name of the function suggest the storage format is
         * expected to be UTF16. The function must re-encode string from UTF8 to UTF16 before storing.
         *
         * @param columnIndex      index of the column we are writing to
         * @param value            UTF8 bytes represented as CharSequence interface.
         *                         On this interface getChar() returns a byte, not complete character.
         * @param hasNonAsciiChars helper flag to indicate implementation if all bytes can be assumed as ASCII.
         *                         &quot;true&quot; here indicates that UTF8 decoding is compulsory.
         */
        void putStrUtf8AsUtf16(int columnIndex, DirectByteCharSequence value, boolean hasNonAsciiChars);

        void putSym(int columnIndex, CharSequence value);

        void putSym(int columnIndex, char value);

        default void putSymIndex(int columnIndex, int key) {
<span class="fc" id="L6718">            putInt(columnIndex, key);</span>
<span class="fc" id="L6719">        }</span>

        default void putSymUtf8(int columnIndex, DirectByteCharSequence value, boolean hasNonAsciiChars) {
<span class="fc" id="L6722">            throw new UnsupportedOperationException();</span>
        }

        default void putTimestamp(int columnIndex, long value) {
<span class="fc" id="L6726">            putLong(columnIndex, value);</span>
<span class="fc" id="L6727">        }</span>

        void putUuid(int columnIndex, CharSequence uuid);
    }

    private static class NoOpRow implements Row {
        @Override
        public void append() {
            // no-op
<span class="fc" id="L6736">        }</span>

        @Override
        public void cancel() {
            // no-op
<span class="nc" id="L6741">        }</span>

        @Override
        public void putBin(int columnIndex, long address, long len) {
            // no-op
<span class="nc" id="L6746">        }</span>

        @Override
        public void putBin(int columnIndex, BinarySequence sequence) {
            // no-op
<span class="nc" id="L6751">        }</span>

        @Override
        public void putBool(int columnIndex, boolean value) {
            // no-op
<span class="nc" id="L6756">        }</span>

        @Override
        public void putByte(int columnIndex, byte value) {
            // no-op
<span class="nc" id="L6761">        }</span>

        @Override
        public void putChar(int columnIndex, char value) {
            // no-op
<span class="nc" id="L6766">        }</span>

        @Override
        public void putDate(int columnIndex, long value) {
            // no-op
<span class="nc" id="L6771">        }</span>

        @Override
        public void putDouble(int columnIndex, double value) {
            // no-op
<span class="nc" id="L6776">        }</span>

        @Override
        public void putFloat(int columnIndex, float value) {
            // no-op
<span class="nc" id="L6781">        }</span>

        @Override
        public void putGeoHash(int columnIndex, long value) {
            // no-op
<span class="nc" id="L6786">        }</span>

        @Override
        public void putGeoHashDeg(int index, double lat, double lon) {
            // no-op
<span class="nc" id="L6791">        }</span>

        @Override
        public void putGeoStr(int columnIndex, CharSequence value) {

<span class="nc" id="L6796">        }</span>

        @Override
        public void putInt(int columnIndex, int value) {
            // no-op
<span class="fc" id="L6801">        }</span>

        @Override
        public void putLong(int columnIndex, long value) {
            // no-op
<span class="fc" id="L6806">        }</span>

        @Override
        public void putLong128(int columnIndex, long lo, long hi) {
            // no-op
<span class="nc" id="L6811">        }</span>

        @Override
        public void putLong256(int columnIndex, long l0, long l1, long l2, long l3) {
            // no-op
<span class="nc" id="L6816">        }</span>

        @Override
        public void putLong256(int columnIndex, Long256 value) {
            // no-op
<span class="nc" id="L6821">        }</span>

        @Override
        public void putLong256(int columnIndex, CharSequence hexString) {
            // no-op
<span class="nc" id="L6826">        }</span>

        @Override
        public void putLong256(int columnIndex, @NotNull CharSequence hexString, int start, int end) {
            // no-op
<span class="nc" id="L6831">        }</span>

        @Override
        public void putShort(int columnIndex, short value) {
            // no-op
<span class="nc" id="L6836">        }</span>

        @Override
        public void putStr(int columnIndex, CharSequence value) {
            // no-op
<span class="nc" id="L6841">        }</span>

        @Override
        public void putStr(int columnIndex, char value) {
            // no-op
<span class="nc" id="L6846">        }</span>

        @Override
        public void putStr(int columnIndex, CharSequence value, int pos, int len) {
            // no-op
<span class="nc" id="L6851">        }</span>

        @Override
        public void putStrUtf8AsUtf16(int columnIndex, DirectByteCharSequence value, boolean hasNonAsciiChars) {
            // no-op
<span class="nc" id="L6856">        }</span>

        @Override
        public void putSym(int columnIndex, CharSequence value) {
            // no-op
<span class="nc" id="L6861">        }</span>

        @Override
        public void putSym(int columnIndex, char value) {
            // no-op
<span class="fc" id="L6866">        }</span>

        @Override
        public void putSymIndex(int columnIndex, int key) {
            // no-op
<span class="nc" id="L6871">        }</span>

        @Override
        public void putSymUtf8(int columnIndex, DirectByteCharSequence value, boolean hasNonAsciiChars) {
            // no-op
<span class="nc" id="L6876">        }</span>

        @Override
        public void putTimestamp(int columnIndex, long value) {
            // no-op
<span class="nc" id="L6881">        }</span>

        @Override
        public void putUuid(int columnIndex, CharSequence uuid) {

<span class="nc" id="L6886">        }</span>
    }

<span class="fc" id="L6889">    private class RowImpl implements Row {</span>
        @Override
        public void append() {
<span class="fc" id="L6892">            rowAppend(activeNullSetters);</span>
<span class="fc" id="L6893">        }</span>

        @Override
        public void cancel() {
<span class="fc" id="L6897">            rowCancel();</span>
<span class="fc" id="L6898">        }</span>

        @Override
        public void putBin(int columnIndex, long address, long len) {
<span class="fc" id="L6902">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putBin(address, len));</span>
<span class="fc" id="L6903">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6904">        }</span>

        @Override
        public void putBin(int columnIndex, BinarySequence sequence) {
<span class="fc" id="L6908">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putBin(sequence));</span>
<span class="fc" id="L6909">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6910">        }</span>

        @Override
        public void putBool(int columnIndex, boolean value) {
<span class="fc" id="L6914">            getPrimaryColumn(columnIndex).putBool(value);</span>
<span class="fc" id="L6915">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6916">        }</span>

        @Override
        public void putByte(int columnIndex, byte value) {
<span class="fc" id="L6920">            getPrimaryColumn(columnIndex).putByte(value);</span>
<span class="fc" id="L6921">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6922">        }</span>

        @Override
        public void putChar(int columnIndex, char value) {
<span class="fc" id="L6926">            getPrimaryColumn(columnIndex).putChar(value);</span>
<span class="fc" id="L6927">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6928">        }</span>

        @Override
        public void putDouble(int columnIndex, double value) {
<span class="fc" id="L6932">            getPrimaryColumn(columnIndex).putDouble(value);</span>
<span class="fc" id="L6933">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6934">        }</span>

        @Override
        public void putFloat(int columnIndex, float value) {
<span class="fc" id="L6938">            getPrimaryColumn(columnIndex).putFloat(value);</span>
<span class="fc" id="L6939">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6940">        }</span>

        @Override
        public void putGeoHash(int index, long value) {
<span class="fc" id="L6944">            int type = metadata.getColumnType(index);</span>
<span class="fc" id="L6945">            WriterRowUtils.putGeoHash(index, value, type, this);</span>
<span class="fc" id="L6946">        }</span>

        @Override
        public void putGeoHashDeg(int index, double lat, double lon) {
<span class="fc" id="L6950">            int type = metadata.getColumnType(index);</span>
<span class="fc" id="L6951">            WriterRowUtils.putGeoHash(index, GeoHashes.fromCoordinatesDegUnsafe(lat, lon, ColumnType.getGeoHashBits(type)), type, this);</span>
<span class="fc" id="L6952">        }</span>

        @Override
        public void putGeoStr(int index, CharSequence hash) {
<span class="fc" id="L6956">            final int type = metadata.getColumnType(index);</span>
<span class="fc" id="L6957">            WriterRowUtils.putGeoStr(index, hash, type, this);</span>
<span class="fc" id="L6958">        }</span>

        @Override
        public void putInt(int columnIndex, int value) {
<span class="fc" id="L6962">            getPrimaryColumn(columnIndex).putInt(value);</span>
<span class="fc" id="L6963">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6964">        }</span>

        @Override
        public void putLong(int columnIndex, long value) {
<span class="fc" id="L6968">            getPrimaryColumn(columnIndex).putLong(value);</span>
<span class="fc" id="L6969">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6970">        }</span>

        @Override
        public void putLong128(int columnIndex, long lo, long hi) {
<span class="fc" id="L6974">            MemoryA primaryColumn = getPrimaryColumn(columnIndex);</span>
<span class="fc" id="L6975">            primaryColumn.putLong(lo);</span>
<span class="fc" id="L6976">            primaryColumn.putLong(hi);</span>
<span class="fc" id="L6977">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6978">        }</span>

        @Override
        public void putLong256(int columnIndex, long l0, long l1, long l2, long l3) {
<span class="fc" id="L6982">            getPrimaryColumn(columnIndex).putLong256(l0, l1, l2, l3);</span>
<span class="fc" id="L6983">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6984">        }</span>

        @Override
        public void putLong256(int columnIndex, Long256 value) {
<span class="fc" id="L6988">            getPrimaryColumn(columnIndex).putLong256(value.getLong0(), value.getLong1(), value.getLong2(), value.getLong3());</span>
<span class="fc" id="L6989">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6990">        }</span>

        @Override
        public void putLong256(int columnIndex, CharSequence hexString) {
<span class="fc" id="L6994">            getPrimaryColumn(columnIndex).putLong256(hexString);</span>
<span class="fc" id="L6995">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L6996">        }</span>

        @Override
        public void putLong256(int columnIndex, @NotNull CharSequence hexString, int start, int end) {
<span class="fc" id="L7000">            getPrimaryColumn(columnIndex).putLong256(hexString, start, end);</span>
<span class="fc" id="L7001">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L7002">        }</span>

        @Override
        public void putShort(int columnIndex, short value) {
<span class="fc" id="L7006">            getPrimaryColumn(columnIndex).putShort(value);</span>
<span class="fc" id="L7007">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L7008">        }</span>

        @Override
        public void putStr(int columnIndex, CharSequence value) {
<span class="fc" id="L7012">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putStr(value));</span>
<span class="fc" id="L7013">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L7014">        }</span>

        @Override
        public void putStr(int columnIndex, char value) {
<span class="fc" id="L7018">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putStr(value));</span>
<span class="fc" id="L7019">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L7020">        }</span>

        @Override
        public void putStr(int columnIndex, CharSequence value, int pos, int len) {
<span class="fc" id="L7024">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putStr(value, pos, len));</span>
<span class="fc" id="L7025">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L7026">        }</span>

        @Override
        public void putStrUtf8AsUtf16(int columnIndex, DirectByteCharSequence value, boolean hasNonAsciiChars) {
<span class="fc" id="L7030">            getSecondaryColumn(columnIndex).putLong(getPrimaryColumn(columnIndex).putStrUtf8AsUtf16(value, hasNonAsciiChars));</span>
<span class="fc" id="L7031">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L7032">        }</span>

        @Override
        public void putSym(int columnIndex, CharSequence value) {
<span class="fc" id="L7036">            getPrimaryColumn(columnIndex).putInt(symbolMapWriters.getQuick(columnIndex).put(value));</span>
<span class="fc" id="L7037">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L7038">        }</span>

        @Override
        public void putSym(int columnIndex, char value) {
<span class="fc" id="L7042">            getPrimaryColumn(columnIndex).putInt(symbolMapWriters.getQuick(columnIndex).put(value));</span>
<span class="fc" id="L7043">            setRowValueNotNull(columnIndex);</span>
<span class="fc" id="L7044">        }</span>

        @Override
        public void putUuid(int columnIndex, CharSequence uuidStr) {
<span class="fc" id="L7048">            SqlUtil.implicitCastStrAsUuid(uuidStr, uuid);</span>
<span class="fc" id="L7049">            putLong128(columnIndex, uuid.getLo(), uuid.getHi());</span>
<span class="fc" id="L7050">        }</span>

        private MemoryA getPrimaryColumn(int columnIndex) {
<span class="fc" id="L7053">            return activeColumns.getQuick(getPrimaryColumnIndex(columnIndex));</span>
        }

        private MemoryA getSecondaryColumn(int columnIndex) {
<span class="fc" id="L7057">            return activeColumns.getQuick(getSecondaryColumnIndex(columnIndex));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>