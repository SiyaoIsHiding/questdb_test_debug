<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>O3PartitionJob.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">O3PartitionJob.java</span></div><h1>O3PartitionJob.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.MessageBus;
import io.questdb.cairo.sql.RecordMetadata;
import io.questdb.cairo.sql.TableRecordMetadata;
import io.questdb.cairo.vm.api.MemoryCR;
import io.questdb.cairo.vm.api.MemoryMA;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.mp.AbstractQueueConsumerJob;
import io.questdb.mp.Sequence;
import io.questdb.std.*;
import io.questdb.std.str.Path;
import io.questdb.tasks.O3OpenColumnTask;
import io.questdb.tasks.O3PartitionTask;

import java.util.concurrent.atomic.AtomicInteger;

import static io.questdb.cairo.O3OpenColumnJob.*;
import static io.questdb.cairo.TableUtils.*;
import static io.questdb.cairo.TableWriter.*;

public class O3PartitionJob extends AbstractQueueConsumerJob&lt;O3PartitionTask&gt; {

<span class="fc" id="L49">    private static final Log LOG = LogFactory.getLog(O3PartitionJob.class);</span>

    public O3PartitionJob(MessageBus messageBus) {
<span class="fc" id="L52">        super(messageBus.getO3PartitionQueue(), messageBus.getO3PartitionSubSeq());</span>
<span class="fc" id="L53">    }</span>

    public static void processPartition(
            Path pathToTable,
            int partitionBy,
            ObjList&lt;MemoryMA&gt; columns,
            ReadOnlyObjList&lt;? extends MemoryCR&gt; oooColumns,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long o3TimestampMin,
            long o3TimestampMax,
            long partitionTimestamp,
            long maxTimestamp,
            long srcDataMax,
            long srcDataTxn,
            boolean last,
            long txn,
            long sortedTimestampsAddr,
            TableWriter tableWriter,
            AtomicInteger columnCounter,
            O3Basket o3Basket,
            long colTopSinkAddr
    ) {
        // is out of order data hitting the last partition?
        // if so we do not need to re-open files and write to existing file descriptors
<span class="fc" id="L79">        final long o3TimestampLo = getTimestampIndexValue(sortedTimestampsAddr, srcOooLo);</span>
<span class="fc" id="L80">        final RecordMetadata metadata = tableWriter.getMetadata();</span>
<span class="fc" id="L81">        final int timestampIndex = metadata.getTimestampIndex();</span>
<span class="fc" id="L82">        final Path path = Path.getThreadLocal(pathToTable);</span>
<span class="fc" id="L83">        TableUtils.setPathForPartition(path, partitionBy, o3TimestampLo, false);</span>
<span class="fc" id="L84">        final int pplen = path.length();</span>
<span class="fc" id="L85">        TableUtils.txnPartitionConditionally(path, srcDataTxn);</span>
<span class="fc" id="L86">        final int plen = path.length();</span>
<span class="fc" id="L87">        int srcTimestampFd = 0;</span>
        long dataTimestampLo;
        long dataTimestampHi;
<span class="fc" id="L90">        final FilesFacade ff = tableWriter.getFilesFacade();</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (srcDataMax &lt; 1) {</span>

            // This has to be a brand new partition for any of three cases:
            // - This partition is above min partition of the table.
            // - This partition is below max partition of the table.
            // - This is last partition that is empty.
            // pure OOO data copy into new partition

<span class="pc bpc" id="L100" title="1 of 2 branches missed.">            if (!last) {</span>
                try {
<span class="fc" id="L102">                    LOG.debug().$(&quot;would create [path=&quot;).utf8(path.slash$()).I$();</span>
<span class="fc" id="L103">                    createDirsOrFail(ff, path, tableWriter.getConfiguration().getMkDirMode());</span>
<span class="fc" id="L104">                } catch (Throwable e) {</span>
<span class="fc" id="L105">                    LOG.error().$(&quot;process new partition error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L106">                            .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L107">                            .I$();</span>
<span class="fc" id="L108">                    tableWriter.o3BumpErrorCount();</span>
<span class="fc" id="L109">                    tableWriter.o3ClockDownPartitionUpdateCount();</span>
<span class="fc" id="L110">                    tableWriter.o3CountDownDoneLatch();</span>
<span class="fc" id="L111">                    throw e;</span>
<span class="fc" id="L112">                }</span>
            }

<span class="fc" id="L115">            publishOpenColumnTasks(</span>
                    txn,
                    columns,
                    oooColumns,
                    pathToTable,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    o3TimestampMin,
                    o3TimestampMax,
                    o3TimestampLo,
                    partitionTimestamp,
                    // below parameters are unused by this type of append
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    srcDataTxn,
                    OPEN_NEW_PARTITION_FOR_APPEND,
                    0,  // timestamp fd
                    0,
                    0,
                    timestampIndex,
                    sortedTimestampsAddr,
                    tableWriter,
                    columnCounter,
                    o3Basket,
                    colTopSinkAddr
            );
        } else {
<span class="fc" id="L153">            long srcTimestampAddr = 0;</span>
<span class="fc" id="L154">            long srcTimestampSize = 0;</span>
            int prefixType;
            long prefixLo;
            long prefixHi;
            int mergeType;
            long mergeDataLo;
            long mergeDataHi;
            long mergeO3Lo;
            long mergeO3Hi;
            int suffixType;
            long suffixLo;
            long suffixHi;
            final int openColumnMode;

            try {
                // out of order is hitting existing partition
                // partitionTimestamp is in fact a ceil of ooo timestamp value for the given partition
                // so this check is for matching ceilings
<span class="fc bfc" id="L172" title="All 2 branches covered.">                if (last) {</span>
<span class="fc" id="L173">                    dataTimestampHi = maxTimestamp;</span>
<span class="fc" id="L174">                    srcTimestampSize = srcDataMax * 8L;</span>
                    // negative fd indicates descriptor reuse
<span class="fc" id="L176">                    srcTimestampFd = -columns.getQuick(getPrimaryColumnIndex(timestampIndex)).getFd();</span>
<span class="fc" id="L177">                    srcTimestampAddr = mapRW(ff, -srcTimestampFd, srcTimestampSize, MemoryTag.MMAP_O3);</span>
                } else {
<span class="fc" id="L179">                    srcTimestampSize = srcDataMax * 8L;</span>
                    // out of order data is going into archive partition
                    // we need to read &quot;low&quot; and &quot;high&quot; boundaries of the partition. &quot;low&quot; being oldest timestamp
                    // and &quot;high&quot; being newest

<span class="fc" id="L184">                    dFile(path.trimTo(plen), metadata.getColumnName(timestampIndex), COLUMN_NAME_TXN_NONE);</span>

                    // also track the fd that we need to eventually close
<span class="fc" id="L187">                    srcTimestampFd = openRW(ff, path, LOG, tableWriter.getConfiguration().getWriterFileOpenOpts());</span>
<span class="fc" id="L188">                    srcTimestampAddr = mapRW(ff, srcTimestampFd, srcTimestampSize, MemoryTag.MMAP_O3);</span>
<span class="fc" id="L189">                    dataTimestampHi = Unsafe.getUnsafe().getLong(srcTimestampAddr + srcTimestampSize - Long.BYTES);</span>
                }
<span class="fc" id="L191">                dataTimestampLo = Unsafe.getUnsafe().getLong(srcTimestampAddr);</span>


                // create copy jobs
                // we will have maximum of 3 stages:
                // - prefix data
                // - merge job
                // - suffix data
                //
                // prefix and suffix can be sourced either from OO fully or from Data (written to disk) fully
                // so for prefix and suffix we will need a flag indicating source of the data
                // as well as range of rows in that source

<span class="fc" id="L204">                prefixType = O3_BLOCK_NONE;</span>
<span class="fc" id="L205">                prefixLo = -1;</span>
<span class="fc" id="L206">                prefixHi = -1;</span>
<span class="fc" id="L207">                mergeType = O3_BLOCK_NONE;</span>
<span class="fc" id="L208">                mergeDataLo = -1;</span>
<span class="fc" id="L209">                mergeDataHi = -1;</span>
<span class="fc" id="L210">                mergeO3Lo = -1;</span>
<span class="fc" id="L211">                mergeO3Hi = -1;</span>
<span class="fc" id="L212">                suffixType = O3_BLOCK_NONE;</span>
<span class="fc" id="L213">                suffixLo = -1;</span>
<span class="fc" id="L214">                suffixHi = -1;</span>

<span class="pc bpc" id="L216" title="2 of 4 branches missed.">                assert srcTimestampFd != -1 &amp;&amp; srcTimestampFd != 1;</span>

                int branch;

<span class="fc bfc" id="L220" title="All 2 branches covered.">                if (o3TimestampLo &gt; dataTimestampLo) {</span>
                    //   +------+
                    //   | data |  +-----+
                    //   |      |  | OOO |
                    //   |      |  |     |

<span class="fc bfc" id="L226" title="All 2 branches covered.">                    if (o3TimestampLo &gt;= dataTimestampHi) {</span>

                        // +------+
                        // | data |
                        // |      |
                        // +------+
                        //
                        //           +-----+
                        //           | OOO |
                        //           |     |
                        //
<span class="fc" id="L237">                        branch = 1;</span>
<span class="fc" id="L238">                        suffixType = O3_BLOCK_O3;</span>
<span class="fc" id="L239">                        suffixLo = srcOooLo;</span>
<span class="fc" id="L240">                        suffixHi = srcOooHi;</span>
                    } else {

                        //
                        // +------+
                        // |      |
                        // |      | +-----+
                        // | data | | OOO |
                        // +------+

<span class="fc" id="L250">                        prefixType = O3_BLOCK_DATA;</span>
<span class="fc" id="L251">                        prefixLo = 0;</span>
<span class="fc" id="L252">                        prefixHi = Vect.boundedBinarySearch64Bit(</span>
                                srcTimestampAddr,
                                o3TimestampLo,
                                0,
                                srcDataMax - 1,
                                BinarySearch.SCAN_DOWN
                        );
<span class="fc" id="L259">                        mergeDataLo = prefixHi + 1;</span>
<span class="fc" id="L260">                        mergeO3Lo = srcOooLo;</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">                        if (o3TimestampMax &lt; dataTimestampHi) {</span>

                            //
                            // |      | +-----+
                            // | data | | OOO |
                            // |      | +-----+
                            // +------+

<span class="fc" id="L270">                            branch = 2;</span>
<span class="fc" id="L271">                            mergeO3Hi = srcOooHi;</span>
<span class="fc" id="L272">                            mergeDataHi = Vect.boundedBinarySearch64Bit(</span>
                                    srcTimestampAddr,
                                    o3TimestampMax - 1,
                                    mergeDataLo,
                                    srcDataMax - 1,
                                    BinarySearch.SCAN_DOWN
                            );

<span class="fc bfc" id="L280" title="All 2 branches covered.">                            if (mergeDataLo &gt; mergeDataHi) {</span>
                                // the OO data implodes right between rows of existing data
                                // so we will have both data prefix and suffix and the middle bit

                                // is the out of order
<span class="fc" id="L285">                                mergeType = O3_BLOCK_O3;</span>
                            } else {
<span class="fc" id="L287">                                mergeType = O3_BLOCK_MERGE;</span>
                            }

<span class="fc" id="L290">                            suffixType = O3_BLOCK_DATA;</span>
<span class="fc" id="L291">                            suffixLo = mergeDataHi + 1;</span>
<span class="fc" id="L292">                            suffixHi = srcDataMax - 1;</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                            assert suffixLo &lt;= suffixHi;</span>

<span class="fc bfc" id="L295" title="All 2 branches covered.">                        } else if (o3TimestampMax &gt; dataTimestampHi) {</span>

                            //
                            // |      | +-----+
                            // | data | | OOO |
                            // |      | |     |
                            // +------+ |     |
                            //          |     |
                            //          +-----+

<span class="fc" id="L305">                            branch = 3;</span>
<span class="fc" id="L306">                            mergeO3Hi = Vect.boundedBinarySearchIndexT(</span>
                                    sortedTimestampsAddr,
                                    dataTimestampHi,
                                    srcOooLo,
                                    srcOooHi,
                                    BinarySearch.SCAN_UP
                            );

<span class="fc" id="L314">                            mergeDataHi = srcDataMax - 1;</span>

<span class="fc" id="L316">                            mergeType = O3_BLOCK_MERGE;</span>
<span class="fc" id="L317">                            suffixType = O3_BLOCK_O3;</span>
<span class="fc" id="L318">                            suffixLo = mergeO3Hi + 1;</span>
<span class="fc" id="L319">                            suffixHi = srcOooHi;</span>
                        } else {

                            //
                            // |      | +-----+
                            // | data | | OOO |
                            // |      | |     |
                            // +------+ +-----+
                            //

<span class="fc" id="L329">                            branch = 4;</span>
<span class="fc" id="L330">                            mergeType = O3_BLOCK_MERGE;</span>
<span class="fc" id="L331">                            mergeO3Hi = srcOooHi;</span>
<span class="fc" id="L332">                            mergeDataHi = srcDataMax - 1;</span>
                        }
                    }
                } else {

                    //            +-----+
                    //            | OOO |
                    //
                    //  +------+
                    //  | data |


<span class="fc" id="L344">                    prefixType = O3_BLOCK_O3;</span>
<span class="fc" id="L345">                    prefixLo = srcOooLo;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                    if (dataTimestampLo &lt; o3TimestampMax) {</span>

                        //
                        //  +------+  | OOO |
                        //  | data |  +-----+
                        //  |      |

<span class="fc" id="L353">                        mergeDataLo = 0;</span>
<span class="fc" id="L354">                        prefixHi = Vect.boundedBinarySearchIndexT(</span>
                                sortedTimestampsAddr,
                                dataTimestampLo,
                                srcOooLo,
                                srcOooHi,
                                BinarySearch.SCAN_DOWN
                        );
<span class="fc" id="L361">                        mergeO3Lo = prefixHi + 1;</span>

<span class="fc bfc" id="L363" title="All 2 branches covered.">                        if (o3TimestampMax &lt; dataTimestampHi) {</span>

                            // |      | |     |
                            // |      | | OOO |
                            // | data | +-----+
                            // |      |
                            // +------+

<span class="fc" id="L371">                            branch = 5;</span>
<span class="fc" id="L372">                            mergeType = O3_BLOCK_MERGE;</span>
<span class="fc" id="L373">                            mergeO3Hi = srcOooHi;</span>
<span class="fc" id="L374">                            mergeDataHi = Vect.boundedBinarySearch64Bit(</span>
                                    srcTimestampAddr,
                                    o3TimestampMax,
                                    0,
                                    srcDataMax - 1,
                                    BinarySearch.SCAN_DOWN
                            );

<span class="fc" id="L382">                            suffixLo = mergeDataHi + 1;</span>
<span class="fc" id="L383">                            suffixType = O3_BLOCK_DATA;</span>
<span class="fc" id="L384">                            suffixHi = srcDataMax - 1;</span>

<span class="fc bfc" id="L386" title="All 2 branches covered.">                        } else if (o3TimestampMax &gt; dataTimestampHi) {</span>

                            // |      | |     |
                            // |      | | OOO |
                            // | data | |     |
                            // +------+ |     |
                            //          +-----+

<span class="fc" id="L394">                            branch = 6;</span>
<span class="fc" id="L395">                            mergeDataHi = srcDataMax - 1;</span>
<span class="fc" id="L396">                            mergeO3Hi = Vect.boundedBinarySearchIndexT(</span>
                                    sortedTimestampsAddr,
                                    dataTimestampHi - 1,
                                    mergeO3Lo,
                                    srcOooHi,
                                    BinarySearch.SCAN_DOWN
                            );

<span class="fc bfc" id="L404" title="All 2 branches covered.">                            if (mergeO3Lo &gt; mergeO3Hi) {</span>
<span class="fc" id="L405">                                mergeType = O3_BLOCK_DATA;</span>
                            } else {
<span class="fc" id="L407">                                mergeType = O3_BLOCK_MERGE;</span>
                            }

<span class="fc bfc" id="L410" title="All 2 branches covered.">                            if (mergeO3Hi &lt; srcOooHi) {</span>
<span class="fc" id="L411">                                suffixLo = mergeO3Hi + 1;</span>
<span class="fc" id="L412">                                suffixType = O3_BLOCK_O3;</span>
<span class="fc" id="L413">                                suffixHi = Math.max(suffixLo, srcOooHi);</span>
                            }
                        } else {

                            // |      | |     |
                            // |      | | OOO |
                            // | data | |     |
                            // +------+ +-----+

<span class="fc" id="L422">                            branch = 7;</span>
<span class="fc" id="L423">                            mergeType = O3_BLOCK_MERGE;</span>
<span class="fc" id="L424">                            mergeO3Hi = srcOooHi;</span>
<span class="fc" id="L425">                            mergeDataHi = srcDataMax - 1;</span>
                        }
                    } else {
                        //            +-----+
                        //            | OOO |
                        //            +-----+
                        //
                        //  +------+
                        //  | data |
                        //
<span class="fc" id="L435">                        branch = 8;</span>
<span class="fc" id="L436">                        prefixHi = srcOooHi;</span>
<span class="fc" id="L437">                        suffixType = O3_BLOCK_DATA;</span>
<span class="fc" id="L438">                        suffixLo = 0;</span>
<span class="fc" id="L439">                        suffixHi = srcDataMax - 1;</span>
                    }
                }

<span class="fc" id="L443">                LOG.debug()</span>
<span class="fc" id="L444">                        .$(&quot;o3 merge [branch=&quot;).$(branch)</span>
<span class="fc" id="L445">                        .$(&quot;, prefixType=&quot;).$(prefixType)</span>
<span class="fc" id="L446">                        .$(&quot;, prefixLo=&quot;).$(prefixLo)</span>
<span class="fc" id="L447">                        .$(&quot;, prefixHi=&quot;).$(prefixHi)</span>
<span class="fc" id="L448">                        .$(&quot;, o3TimestampLo=&quot;).$ts(o3TimestampLo)</span>
<span class="fc" id="L449">                        .$(&quot;, o3TimestampMin=&quot;).$ts(o3TimestampMin)</span>
<span class="fc" id="L450">                        .$(&quot;, o3TimestampMax=&quot;).$ts(o3TimestampMax)</span>
<span class="fc" id="L451">                        .$(&quot;, dataTimestampLo=&quot;).$ts(dataTimestampLo)</span>
<span class="fc" id="L452">                        .$(&quot;, dataTimestampHi=&quot;).$ts(dataTimestampHi)</span>
<span class="fc" id="L453">                        .$(&quot;, partitionTimestamp=&quot;).$ts(partitionTimestamp)</span>
<span class="fc" id="L454">                        .$(&quot;, srcDataMax=&quot;).$(srcDataMax)</span>
<span class="fc" id="L455">                        .$(&quot;, mergeType=&quot;).$(mergeType)</span>
<span class="fc" id="L456">                        .$(&quot;, mergeDataLo=&quot;).$(mergeDataLo)</span>
<span class="fc" id="L457">                        .$(&quot;, mergeDataHi=&quot;).$(mergeDataHi)</span>
<span class="fc" id="L458">                        .$(&quot;, mergeO3Lo=&quot;).$(mergeO3Lo)</span>
<span class="fc" id="L459">                        .$(&quot;, mergeO3Hi=&quot;).$(mergeO3Hi)</span>
<span class="fc" id="L460">                        .$(&quot;, suffixType=&quot;).$(suffixType)</span>
<span class="fc" id="L461">                        .$(&quot;, suffixLo=&quot;).$(suffixLo)</span>
<span class="fc" id="L462">                        .$(&quot;, suffixHi=&quot;).$(suffixHi)</span>
<span class="fc" id="L463">                        .$(&quot;, table=&quot;).$(pathToTable)</span>
<span class="fc" id="L464">                        .I$();</span>

<span class="fc bfc" id="L466" title="All 2 branches covered.">                if (prefixType == O3_BLOCK_NONE) {</span>
                    // We do not need to create a copy of partition when we simply need to append
                    // existing the one.
<span class="fc" id="L469">                    openColumnMode = OPEN_MID_PARTITION_FOR_APPEND;</span>
                } else {
<span class="fc" id="L471">                    txnPartition(path.trimTo(pplen), txn);</span>
<span class="fc" id="L472">                    createDirsOrFail(ff, path.slash$(), tableWriter.getConfiguration().getMkDirMode());</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">                    if (last) {</span>
<span class="fc" id="L474">                        openColumnMode = OPEN_LAST_PARTITION_FOR_MERGE;</span>
                    } else {
<span class="fc" id="L476">                        openColumnMode = OPEN_MID_PARTITION_FOR_MERGE;</span>
                    }
                }
<span class="fc" id="L479">            } catch (Throwable e) {</span>
<span class="fc" id="L480">                LOG.error().$(&quot;process existing partition error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L481">                        .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L482">                        .I$();</span>
<span class="fc" id="L483">                O3Utils.unmap(ff, srcTimestampAddr, srcTimestampSize);</span>
<span class="fc" id="L484">                O3Utils.close(ff, srcTimestampFd);</span>
<span class="fc" id="L485">                tableWriter.o3BumpErrorCount();</span>
<span class="fc" id="L486">                tableWriter.o3ClockDownPartitionUpdateCount();</span>
<span class="fc" id="L487">                tableWriter.o3CountDownDoneLatch();</span>
<span class="fc" id="L488">                throw e;</span>
<span class="fc" id="L489">            }</span>

            // Compute max timestamp as maximum of out of order data and
            // data in existing partition.
            // When partition is new, the data timestamp is MIN_LONG
<span class="fc" id="L494">            final long timestampMax = Math.max(o3TimestampMax, dataTimestampHi);</span>

<span class="fc" id="L496">            publishOpenColumnTasks(</span>
                    txn,
                    columns,
                    oooColumns,
                    pathToTable,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    o3TimestampMin,
                    timestampMax, // &lt;-- this is max of OOO and data chunk
                    o3TimestampLo,
                    partitionTimestamp,
                    prefixType,
                    prefixLo,
                    prefixHi,
                    mergeType,
                    mergeDataLo,
                    mergeDataHi,
                    mergeO3Lo,
                    mergeO3Hi,
                    suffixType,
                    suffixLo,
                    suffixHi,
                    srcDataMax,
                    srcDataTxn,
                    openColumnMode,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    timestampIndex,
                    sortedTimestampsAddr,
                    tableWriter,
                    columnCounter,
                    o3Basket,
                    colTopSinkAddr
            );
        }
<span class="fc" id="L533">    }</span>

    public static void processPartition(
            O3PartitionTask task,
            long cursor,
            Sequence subSeq
    ) {
        // find &quot;current&quot; partition boundary in the out-of-order data
        // once we know the boundary we can move on to calculating another one
        // srcOooHi is index inclusive of value
<span class="fc" id="L543">        final Path pathToTable = task.getPathToTable();</span>
<span class="fc" id="L544">        final int partitionBy = task.getPartitionBy();</span>
<span class="fc" id="L545">        final ObjList&lt;MemoryMA&gt; columns = task.getColumns();</span>
<span class="fc" id="L546">        final ReadOnlyObjList&lt;? extends MemoryCR&gt; oooColumns = task.getO3Columns();</span>
<span class="fc" id="L547">        final long srcOooLo = task.getSrcOooLo();</span>
<span class="fc" id="L548">        final long srcOooHi = task.getSrcOooHi();</span>
<span class="fc" id="L549">        final long srcOooMax = task.getSrcOooMax();</span>
<span class="fc" id="L550">        final long oooTimestampMin = task.getOooTimestampMin();</span>
<span class="fc" id="L551">        final long oooTimestampMax = task.getOooTimestampMax();</span>
<span class="fc" id="L552">        final long partitionTimestamp = task.getPartitionTimestamp();</span>
<span class="fc" id="L553">        final long maxTimestamp = task.getMaxTimestamp();</span>
<span class="fc" id="L554">        final long srcDataMax = task.getSrcDataMax();</span>
<span class="fc" id="L555">        final long srcDataTxn = task.getSrcNameTxn();</span>
<span class="fc" id="L556">        final boolean last = task.isLast();</span>
<span class="fc" id="L557">        final long txn = task.getTxn();</span>
<span class="fc" id="L558">        final long sortedTimestampsAddr = task.getSortedTimestampsAddr();</span>
<span class="fc" id="L559">        final TableWriter tableWriter = task.getTableWriter();</span>
<span class="fc" id="L560">        final AtomicInteger columnCounter = task.getColumnCounter();</span>
<span class="fc" id="L561">        final O3Basket o3Basket = task.getO3Basket();</span>
<span class="fc" id="L562">        final long colTopSinkAddr = task.getColTopSinkAddr();</span>

<span class="fc" id="L564">        subSeq.done(cursor);</span>

<span class="fc" id="L566">        processPartition(</span>
                pathToTable,
                partitionBy,
                columns,
                oooColumns,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                oooTimestampMin,
                oooTimestampMax,
                partitionTimestamp,
                maxTimestamp,
                srcDataMax,
                srcDataTxn,
                last,
                txn,
                sortedTimestampsAddr,
                tableWriter,
                columnCounter,
                o3Basket,
                colTopSinkAddr
        );
<span class="fc" id="L588">    }</span>

    private static long createMergeIndex(
            long srcDataTimestampAddr,
            long sortedTimestampsAddr,
            long mergeDataLo,
            long mergeDataHi,
            long mergeOOOLo,
            long mergeOOOHi,
            long indexSize
    ) {
        // Create &quot;index&quot; for existing timestamp column. When we reshuffle timestamps during merge we will
        // have to go back and find data rows we need to move accordingly
<span class="fc" id="L601">        final long index = Unsafe.malloc(indexSize, MemoryTag.NATIVE_O3);</span>
        try {
<span class="fc" id="L603">            Vect.makeTimestampIndex(srcDataTimestampAddr, mergeDataLo, mergeDataHi, index);</span>
<span class="fc" id="L604">            long ptr = Vect.mergeTwoLongIndexesAsc(</span>
                    index,
                    mergeDataHi - mergeDataLo + 1,
                    sortedTimestampsAddr + mergeOOOLo * 16,
                    mergeOOOHi - mergeOOOLo + 1
            );
<span class="fc" id="L610">            Unsafe.recordMemAlloc(indexSize, MemoryTag.NATIVE_O3);</span>
<span class="fc" id="L611">            return ptr;</span>
        } finally {
<span class="fc" id="L613">            Unsafe.free(index, indexSize, MemoryTag.NATIVE_O3);</span>
        }
    }

    private static void publishOpenColumnTaskContended(
            long cursor,
            int openColumnMode,
            Path pathToTable,
            CharSequence columnName,
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long oooTimestampMin,
            long oooTimestampMax,
            long oooTimestampLo,
            long partitionTimestamp,
            long srcDataTop,
            long srcDataMax,
            long srcDataTxn,
            long txn,
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeDataLo,
            long mergeDataHi,
            long mergeOOOLo,
            long mergeOOOHi,
            int suffixType,
            long suffixLo,
            long suffixHi,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int indexBlockCapacity,
            int activeFixFd,
            int activeVarFd,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long colTopSinkAddr,
            int columnIndex,
            long columnNameTxn
    ) {
<span class="fc bfc" id="L663" title="All 2 branches covered.">        while (cursor == -2) {</span>
<span class="fc" id="L664">            cursor = tableWriter.getO3OpenColumnPubSeq().next();</span>
        }

<span class="fc bfc" id="L667" title="All 2 branches covered.">        if (cursor &gt; -1) {</span>
<span class="fc" id="L668">            publishOpenColumnTaskHarmonized(</span>
                    cursor,
                    openColumnMode,
                    pathToTable,
                    columnName,
                    columnCounter,
                    partCounter,
                    columnType,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcOooFixAddr,
                    srcOooVarAddr,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    oooTimestampMin,
                    oooTimestampMax,
                    oooTimestampLo,
                    partitionTimestamp,
                    srcDataTop,
                    srcDataMax,
                    srcDataTxn,
                    txn,
                    prefixType,
                    prefixLo,
                    prefixHi,
                    mergeType,
                    mergeDataLo,
                    mergeDataHi,
                    mergeOOOLo,
                    mergeOOOHi,
                    suffixType,
                    suffixLo,
                    suffixHi,
                    indexBlockCapacity,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    activeFixFd,
                    activeVarFd,
                    tableWriter,
                    indexWriter,
                    colTopSinkAddr,
                    columnIndex,
                    columnNameTxn
            );
        } else {
<span class="fc" id="L715">            O3OpenColumnJob.openColumn(</span>
                    openColumnMode,
                    pathToTable,
                    columnName,
                    columnCounter,
                    partCounter,
                    columnType,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcOooFixAddr,
                    srcOooVarAddr,
                    srcOooLo,
                    srcOooHi,
                    srcOooMax,
                    oooTimestampMin,
                    oooTimestampMax,
                    oooTimestampLo,
                    partitionTimestamp,
                    srcDataTop,
                    srcDataMax,
                    srcDataTxn,
                    txn,
                    prefixType,
                    prefixLo,
                    prefixHi,
                    mergeType,
                    mergeOOOLo,
                    mergeOOOHi,
                    mergeDataLo,
                    mergeDataHi,
                    suffixType,
                    suffixLo,
                    suffixHi,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    indexBlockCapacity,
                    activeFixFd,
                    activeVarFd,
                    tableWriter,
                    indexWriter,
                    colTopSinkAddr,
                    columnIndex,
                    columnNameTxn
            );
        }
<span class="fc" id="L761">    }</span>

    private static void publishOpenColumnTaskHarmonized(
            long cursor,
            int openColumnMode,
            Path pathToTable,
            CharSequence columnName,
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            int columnType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long oooTimestampMin,
            long oooTimestampMax,
            long oooTimestampLo,
            long partitionTimestamp,
            long srcDataTop,
            long srcDataMax,
            long srcDataTxn,
            long txn,
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeDataLo,
            long mergeDataHi,
            long mergeOOOLo,
            long mergeOOOHi,
            int suffixType,
            long suffixLo,
            long suffixHi,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int activeFixFd,
            int activeVarFd,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            long colTopSinkAddr,
            int columnIndex,
            long columnNameTxn
    ) {
<span class="fc" id="L809">        final O3OpenColumnTask openColumnTask = tableWriter.getO3OpenColumnQueue().get(cursor);</span>
<span class="fc" id="L810">        openColumnTask.of(</span>
                openColumnMode,
                pathToTable,
                columnName,
                columnCounter,
                partCounter,
                columnType,
                timestampMergeIndexAddr,
                timestampMergeIndexSize,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                oooTimestampMin,
                oooTimestampMax,
                oooTimestampLo,
                partitionTimestamp,
                srcDataTop,
                srcDataMax,
                srcDataTxn,
                txn,
                prefixType,
                prefixLo,
                prefixHi,
                mergeType,
                mergeDataLo,
                mergeDataHi,
                mergeOOOLo,
                mergeOOOHi,
                suffixType,
                suffixLo,
                suffixHi,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                indexBlockCapacity,
                activeFixFd,
                activeVarFd,
                tableWriter,
                indexWriter,
                colTopSinkAddr,
                columnIndex,
                columnNameTxn
        );
<span class="fc" id="L855">        tableWriter.getO3OpenColumnPubSeq().done(cursor);</span>
<span class="fc" id="L856">    }</span>

    private static void publishOpenColumnTasks(
            long txn,
            ObjList&lt;MemoryMA&gt; columns,
            ReadOnlyObjList&lt;? extends MemoryCR&gt; oooColumns,
            Path pathToTable,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long oooTimestampMin,
            long oooTimestampMax,
            long oooTimestampLo,
            long partitionTimestamp,
            int prefixType,
            long prefixLo,
            long prefixHi,
            int mergeType,
            long mergeDataLo,
            long mergeDataHi,
            long mergeOOOLo,
            long mergeOOOHi,
            int suffixType,
            long suffixLo,
            long suffixHi,
            long srcDataMax,
            long srcDataTxn,
            int openColumnMode,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int timestampIndex,
            long sortedTimestampsAddr,
            TableWriter tableWriter,
            AtomicInteger columnCounter,
            O3Basket o3Basket,
            long colTopSinkAddr
    ) {
        // Number of rows to insert from the O3 segment into this partition.
<span class="fc" id="L895">        final long srcOooBatchRowSize = srcOooHi - srcOooLo + 1;</span>

<span class="fc" id="L897">        tableWriter.addPhysicallyWrittenRows(</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">                O3OpenColumnJob.isOpenColumnModeForAppend(openColumnMode)</span>
<span class="fc" id="L899">                        ? srcOooBatchRowSize</span>
<span class="fc" id="L900">                        : srcDataMax + srcOooBatchRowSize</span>
        );

<span class="fc" id="L903">        LOG.debug().$(&quot;partition [ts=&quot;).$ts(oooTimestampLo).I$();</span>

        final long timestampMergeIndexAddr;
        final long timestampMergeIndexSize;
<span class="fc bfc" id="L907" title="All 2 branches covered.">        if (mergeType == O3_BLOCK_MERGE) {</span>
<span class="fc" id="L908">            timestampMergeIndexSize = (mergeDataHi - mergeDataLo + 1) * TIMESTAMP_MERGE_ENTRY_BYTES;</span>
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">            assert timestampMergeIndexSize &gt; 0; // avoid SIGSEGV</span>

<span class="fc" id="L911">            timestampMergeIndexAddr = createMergeIndex(</span>
                    srcTimestampAddr,
                    sortedTimestampsAddr,
                    mergeDataLo,
                    mergeDataHi,
                    mergeOOOLo,
                    mergeOOOHi,
                    timestampMergeIndexSize
            );
        } else {
<span class="fc" id="L921">            timestampMergeIndexAddr = 0;</span>
<span class="fc" id="L922">            timestampMergeIndexSize = 0;</span>
        }

<span class="fc" id="L925">        final TableRecordMetadata metadata = tableWriter.getMetadata();</span>
<span class="fc" id="L926">        final int columnCount = metadata.getColumnCount();</span>
<span class="fc" id="L927">        columnCounter.set(TableUtils.compressColumnCount(metadata));</span>
<span class="fc" id="L928">        int columnsInFlight = columnCount;</span>
<span class="fc bfc" id="L929" title="All 4 branches covered.">        if (openColumnMode == OPEN_LAST_PARTITION_FOR_MERGE || openColumnMode == OPEN_MID_PARTITION_FOR_MERGE) {</span>
            // Partition will be re-written. Jobs will set new column top values but by default they are 0
<span class="fc" id="L931">            Vect.memset(colTopSinkAddr, (long) Long.BYTES * columnCount, 0);</span>
        }

        try {
<span class="fc bfc" id="L935" title="All 2 branches covered.">            for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="fc" id="L936">                final int columnType = metadata.getColumnType(i);</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">                if (columnType &lt; 0) {</span>
<span class="fc" id="L938">                    continue;</span>
                }
<span class="fc" id="L940">                final int colOffset = TableWriter.getPrimaryColumnIndex(i);</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">                final boolean notTheTimestamp = i != timestampIndex;</span>
<span class="fc" id="L942">                final MemoryCR oooMem1 = oooColumns.getQuick(colOffset);</span>
<span class="fc" id="L943">                final MemoryCR oooMem2 = oooColumns.getQuick(colOffset + 1);</span>
<span class="fc" id="L944">                final MemoryMA mem1 = columns.getQuick(colOffset);</span>
<span class="fc" id="L945">                final MemoryMA mem2 = columns.getQuick(colOffset + 1);</span>
                final int activeFixFd;
                final int activeVarFd;
                final long srcDataTop;
                final long srcOooFixAddr;
                final long srcOooVarAddr;
<span class="fc bfc" id="L951" title="All 2 branches covered.">                if (!ColumnType.isVariableLength(columnType)) {</span>
<span class="fc" id="L952">                    activeFixFd = mem1.getFd();</span>
<span class="fc" id="L953">                    activeVarFd = 0;</span>
<span class="fc" id="L954">                    srcOooFixAddr = oooMem1.addressOf(0);</span>
<span class="fc" id="L955">                    srcOooVarAddr = 0;</span>
                } else {
<span class="fc" id="L957">                    activeFixFd = mem2.getFd();</span>
<span class="fc" id="L958">                    activeVarFd = mem1.getFd();</span>
<span class="fc" id="L959">                    srcOooFixAddr = oooMem2.addressOf(0);</span>
<span class="fc" id="L960">                    srcOooVarAddr = oooMem1.addressOf(0);</span>
                }

<span class="fc" id="L963">                final CharSequence columnName = metadata.getColumnName(i);</span>
<span class="fc" id="L964">                final boolean isIndexed = metadata.isColumnIndexed(i);</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">                final int indexBlockCapacity = isIndexed ? metadata.getIndexValueBlockCapacity(i) : -1;</span>
<span class="pc bpc" id="L966" title="1 of 4 branches missed.">                if (openColumnMode == OPEN_LAST_PARTITION_FOR_APPEND || openColumnMode == OPEN_LAST_PARTITION_FOR_MERGE) {</span>
<span class="fc" id="L967">                    srcDataTop = tableWriter.getColumnTop(i);</span>
                } else {
<span class="fc" id="L969">                    srcDataTop = -1; // column open job will have to find out if top exists and its value</span>
                }

                final BitmapIndexWriter indexWriter;
<span class="fc bfc" id="L973" title="All 2 branches covered.">                if (isIndexed) {</span>
<span class="fc" id="L974">                    indexWriter = o3Basket.nextIndexer();</span>
                } else {
<span class="fc" id="L976">                    indexWriter = null;</span>
                }

                try {
<span class="fc" id="L980">                    final long cursor = tableWriter.getO3OpenColumnPubSeq().next();</span>
<span class="fc" id="L981">                    final long columnNameTxn = tableWriter.getColumnNameTxn(partitionTimestamp, i);</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">                    if (cursor &gt; -1) {</span>
<span class="fc" id="L983">                        publishOpenColumnTaskHarmonized(</span>
                                cursor,
                                openColumnMode,
                                pathToTable,
                                columnName,
                                columnCounter,
<span class="fc" id="L989">                                o3Basket.nextPartCounter(),</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">                                notTheTimestamp ? columnType : ColumnType.setDesignatedTimestampBit(columnType, true),</span>
                                timestampMergeIndexAddr,
                                timestampMergeIndexSize,
                                srcOooFixAddr,
                                srcOooVarAddr,
                                srcOooLo,
                                srcOooHi,
                                srcOooMax,
                                oooTimestampMin,
                                oooTimestampMax,
                                oooTimestampLo,
                                partitionTimestamp,
                                srcDataTop,
                                srcDataMax,
                                srcDataTxn,
                                txn,
                                prefixType,
                                prefixLo,
                                prefixHi,
                                mergeType,
                                mergeDataLo,
                                mergeDataHi,
                                mergeOOOLo,
                                mergeOOOHi,
                                suffixType,
                                suffixLo,
                                suffixHi,
                                indexBlockCapacity,
                                srcTimestampFd,
                                srcTimestampAddr,
                                srcTimestampSize,
                                activeFixFd,
                                activeVarFd,
                                tableWriter,
                                indexWriter,
                                colTopSinkAddr + (long) i * Long.BYTES,
                                i,
                                columnNameTxn
                        );
                    } else {
<span class="fc" id="L1030">                        publishOpenColumnTaskContended(</span>
                                cursor,
                                openColumnMode,
                                pathToTable,
                                columnName,
                                columnCounter,
<span class="fc" id="L1036">                                o3Basket.nextPartCounter(),</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">                                notTheTimestamp ? columnType : ColumnType.setDesignatedTimestampBit(columnType, true),</span>
                                timestampMergeIndexAddr,
                                timestampMergeIndexSize,
                                srcOooFixAddr,
                                srcOooVarAddr,
                                srcOooLo,
                                srcOooHi,
                                srcOooMax,
                                oooTimestampMin,
                                oooTimestampMax,
                                oooTimestampLo,
                                partitionTimestamp,
                                srcDataTop,
                                srcDataMax,
                                srcDataTxn,
                                txn,
                                prefixType,
                                prefixLo,
                                prefixHi,
                                mergeType,
                                mergeDataLo,
                                mergeDataHi,
                                mergeOOOLo,
                                mergeOOOHi,
                                suffixType,
                                suffixLo,
                                suffixHi,
                                srcTimestampFd,
                                srcTimestampAddr,
                                srcTimestampSize,
                                indexBlockCapacity,
                                activeFixFd,
                                activeVarFd,
                                tableWriter,
                                indexWriter,
                                colTopSinkAddr + (long) i * Long.BYTES,
                                i,
                                columnNameTxn
                        );
                    }
<span class="fc" id="L1077">                } catch (Throwable e) {</span>
<span class="fc" id="L1078">                    tableWriter.o3BumpErrorCount();</span>
<span class="fc" id="L1079">                    LOG.error().$(&quot;open column error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L1080">                            .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L1081">                            .I$();</span>
<span class="fc" id="L1082">                    columnsInFlight = i + 1;</span>
<span class="fc" id="L1083">                    throw e;</span>
<span class="fc" id="L1084">                }</span>
            }
        } finally {
<span class="fc" id="L1087">            final int delta = columnsInFlight - columnCount;</span>
<span class="fc" id="L1088">            LOG.debug().$(&quot;idle [delta=&quot;).$(delta).I$();</span>
<span class="pc bpc" id="L1089" title="1 of 4 branches missed.">            if (delta &lt; 0 &amp;&amp; columnCounter.addAndGet(delta) == 0) {</span>
<span class="fc" id="L1090">                O3CopyJob.closeColumnIdleQuick(</span>
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        tableWriter
                );
            }
        }
<span class="fc" id="L1100">    }</span>

    @Override
    protected boolean doRun(int workerId, long cursor, RunStatus runStatus) {
<span class="fc" id="L1104">        processPartition(queue.get(cursor), cursor, subSeq);</span>
<span class="fc" id="L1105">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>