<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>O3CopyJob.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">O3CopyJob.java</span></div><h1>O3CopyJob.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.MessageBus;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.mp.AbstractQueueConsumerJob;
import io.questdb.mp.Sequence;
import io.questdb.std.FilesFacade;
import io.questdb.std.Misc;
import io.questdb.std.Unsafe;
import io.questdb.std.Vect;
import io.questdb.tasks.O3CopyTask;
import org.jetbrains.annotations.Nullable;

import java.util.concurrent.atomic.AtomicInteger;

import static io.questdb.cairo.TableWriter.*;

public class O3CopyJob extends AbstractQueueConsumerJob&lt;O3CopyTask&gt; {
<span class="fc" id="L44">    private static final Log LOG = LogFactory.getLog(O3CopyJob.class);</span>

    public O3CopyJob(MessageBus messageBus) {
<span class="fc" id="L47">        super(messageBus.getO3CopyQueue(), messageBus.getO3CopySubSeq());</span>
<span class="fc" id="L48">    }</span>

    public static void copy(
            AtomicInteger columnCounter,
            @Nullable AtomicInteger partCounter,
            int columnType,
            int blockType,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixOffset,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarOffset,
            long srcDataVarSize,
            long srcDataLo,
            long srcDataHi,
            long srcDataTop,
            long srcDataMax,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long srcOooMax,
            long srcOooPartitionLo,
            long srcOooPartitionHi,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp, // &lt;-- this is used to determine if partition is last or not as well as partition dir
            int dstFixFd,
            long dstFixAddr,
            long dstFixOffset,
            long dstFixFileOffset,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarOffset,
            long dstVarOffsetEnd,
            long dstVarAdjust,
            long dstVarSize,
            int dstKFd,
            int dstVFd,
            long dstIndexOffset,
            long dstIndexAdjust,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            boolean partitionMutates,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter
    ) {
<span class="fc" id="L102">        final boolean directIoFlag = tableWriter.preferDirectIO();</span>

<span class="fc" id="L104">        LOG.debug().$(&quot;o3 copy [blockType=&quot;).$(blockType)</span>
<span class="fc" id="L105">                .$(&quot;, columnType=&quot;).$(columnType)</span>
<span class="fc" id="L106">                .$(&quot;, dstFixFd=&quot;).$(dstFixFd)</span>
<span class="fc" id="L107">                .$(&quot;, dstFixSize=&quot;).$(dstFixSize)</span>
<span class="fc" id="L108">                .$(&quot;, dstFixOffset=&quot;).$(dstFixOffset)</span>
<span class="fc" id="L109">                .$(&quot;, dstVarFd=&quot;).$(dstVarFd)</span>
<span class="fc" id="L110">                .$(&quot;, dstVarSize=&quot;).$(dstVarSize)</span>
<span class="fc" id="L111">                .$(&quot;, dstVarOffset=&quot;).$(dstVarOffset)</span>
<span class="fc" id="L112">                .$(&quot;, srcDataLo=&quot;).$(srcDataLo)</span>
<span class="fc" id="L113">                .$(&quot;, srcDataHi=&quot;).$(srcDataHi)</span>
<span class="fc" id="L114">                .$(&quot;, srcDataMax=&quot;).$(srcDataMax)</span>
<span class="fc" id="L115">                .$(&quot;, srcOooLo=&quot;).$(srcOooLo)</span>
<span class="fc" id="L116">                .$(&quot;, srcOooHi=&quot;).$(srcOooHi)</span>
<span class="fc" id="L117">                .$(&quot;, srcOooMax=&quot;).$(srcOooMax)</span>
<span class="fc" id="L118">                .$(&quot;, srcOooPartitionLo=&quot;).$(srcOooPartitionLo)</span>
<span class="fc" id="L119">                .$(&quot;, srcOooPartitionHi=&quot;).$(srcOooPartitionHi)</span>
<span class="fc" id="L120">                .$(&quot;, directIoFlag=&quot;).$(directIoFlag)</span>
<span class="fc" id="L121">                .I$();</span>

        try {
<span class="pc bpc" id="L124" title="1 of 4 branches missed.">            switch (blockType) {</span>
                case O3_BLOCK_MERGE:
<span class="fc" id="L126">                    mergeCopy(</span>
                            columnType,
                            timestampMergeIndexAddr,
                            // this is a hack, when we have column top we can have only of the two:
                            // srcDataFixOffset, when we had to shift data to back-fill nulls or
                            // srcDataTopOffset - if we kept the column top
                            // when one value is present the other will be 0
                            srcDataFixAddr + srcDataFixOffset - srcDataTop,
                            srcDataVarAddr + srcDataVarOffset,
                            srcDataLo,
                            srcDataHi,
                            srcOooFixAddr,
                            srcOooVarAddr,
                            srcOooLo,
                            srcOooHi,
                            dstFixAddr + dstFixOffset,
                            dstVarAddr,
                            dstVarOffset,
                            dstVarOffsetEnd
                    );
<span class="fc" id="L146">                    break;</span>
                case O3_BLOCK_O3:
<span class="fc" id="L148">                    copyO3(</span>
<span class="fc" id="L149">                            tableWriter.getFilesFacade(),</span>
                            columnType,
                            srcOooFixAddr,
                            srcOooVarAddr,
                            srcOooLo,
                            srcOooHi,
                            dstFixFd,
                            dstFixAddr + dstFixOffset,
                            dstFixFileOffset,
                            dstVarAddr,
                            dstVarFd,
                            dstVarOffset,
                            dstVarAdjust,
                            dstVarSize,
                            directIoFlag
                    );
<span class="fc" id="L165">                    break;</span>
                case O3_BLOCK_DATA:
<span class="fc" id="L167">                    copyData(</span>
<span class="fc" id="L168">                            tableWriter.getFilesFacade(),</span>
                            columnType,
                            srcDataFixAddr + srcDataFixOffset,
                            srcDataVarAddr + srcDataVarOffset,
                            srcDataLo,
                            srcDataHi,
                            dstFixAddr + dstFixOffset,
                            dstFixFd,
                            dstFixFileOffset,
                            dstVarAddr,
                            dstVarFd,
                            dstVarOffset,
                            dstVarAdjust,
                            dstVarSize,
                            directIoFlag
                    );
<span class="fc" id="L184">                    break;</span>
                default:
                    break;
            }
<span class="fc" id="L188">        } catch (Throwable th) {</span>
<span class="fc" id="L189">            FilesFacade ff = tableWriter.getFilesFacade();</span>
<span class="fc" id="L190">            O3Utils.unmapAndClose(ff, srcDataFixFd, srcDataFixAddr, srcDataFixSize);</span>
<span class="fc" id="L191">            O3Utils.unmapAndClose(ff, srcDataVarFd, srcDataVarAddr, srcDataVarSize);</span>
<span class="fc" id="L192">            O3Utils.unmapAndClose(ff, dstFixFd, dstFixAddr, dstFixSize);</span>
<span class="fc" id="L193">            O3Utils.unmapAndClose(ff, dstVarFd, dstVarAddr, dstVarSize);</span>

<span class="fc" id="L195">            closeColumnIdle(</span>
                    columnCounter,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    tableWriter
            );
<span class="fc" id="L204">            throw th;</span>
<span class="fc" id="L205">        }</span>

<span class="fc" id="L207">        copyTail(</span>
                columnCounter,
                partCounter,
                timestampMergeIndexAddr,
                timestampMergeIndexSize,
                srcDataFixFd,
                srcDataFixAddr,
                srcDataFixSize,
                srcDataVarFd,
                srcDataVarAddr,
                srcDataVarSize,
                srcDataMax,
                srcOooMax,
                srcOooPartitionLo,
                srcOooPartitionHi,
                timestampMin,
                timestampMax,
                partitionTimestamp,
                dstFixFd,
                dstFixAddr,
                dstFixSize,
                dstVarFd,
                dstVarAddr,
                dstVarSize,
                dstKFd,
                dstVFd,
                dstIndexOffset,
                dstIndexAdjust,
                indexBlockCapacity,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                partitionMutates,
                tableWriter,
                indexWriter
        );
<span class="fc" id="L243">    }</span>

    public static void copy(O3CopyTask task, long cursor, Sequence subSeq) {
<span class="fc" id="L246">        final AtomicInteger columnCounter = task.getColumnCounter();</span>
<span class="fc" id="L247">        final AtomicInteger partCounter = task.getPartCounter();</span>
<span class="fc" id="L248">        final int columnType = task.getColumnType();</span>
<span class="fc" id="L249">        final int blockType = task.getBlockType();</span>
<span class="fc" id="L250">        final long timestampMergeIndexAddr = task.getTimestampMergeIndexAddr();</span>
<span class="fc" id="L251">        final long timestampMergeIndexSize = task.getTimestampMergeIndexSize();</span>
<span class="fc" id="L252">        final int srcDataFixFd = task.getSrcDataFixFd();</span>
<span class="fc" id="L253">        final long srcDataFixAddr = task.getSrcDataFixAddr();</span>
<span class="fc" id="L254">        final long srcDataFixOffset = task.getSrcDataFixOffset();</span>
<span class="fc" id="L255">        final long srcDataFixSize = task.getSrcDataFixSize();</span>
<span class="fc" id="L256">        final int srcDataVarFd = task.getSrcDataVarFd();</span>
<span class="fc" id="L257">        final long srcDataVarAddr = task.getSrcDataVarAddr();</span>
<span class="fc" id="L258">        final long srcDataVarOffset = task.getSrcDataVarOffset();</span>
<span class="fc" id="L259">        final long srcDataVarSize = task.getSrcDataVarSize();</span>
<span class="fc" id="L260">        final long srcDataTop = task.getSrcDataTop();</span>
<span class="fc" id="L261">        final long srcDataLo = task.getSrcDataLo();</span>
<span class="fc" id="L262">        final long srcDataMax = task.getSrcDataMax();</span>
<span class="fc" id="L263">        final long srcDataHi = task.getSrcDataHi();</span>
<span class="fc" id="L264">        final long srcOooFixAddr = task.getSrcOooFixAddr();</span>
<span class="fc" id="L265">        final long srcOooVarAddr = task.getSrcOooVarAddr();</span>
<span class="fc" id="L266">        final long srcOooLo = task.getSrcOooLo();</span>
<span class="fc" id="L267">        final long srcOooHi = task.getSrcOooHi();</span>
<span class="fc" id="L268">        final long srcOooMax = task.getSrcOooMax();</span>
<span class="fc" id="L269">        final long srcOooPartitionLo = task.getSrcOooPartitionLo();</span>
<span class="fc" id="L270">        final long srcOooPartitionHi = task.getSrcOooPartitionHi();</span>
<span class="fc" id="L271">        final long timestampMin = task.getTimestampMin();</span>
<span class="fc" id="L272">        final long timestampMax = task.getTimestampMax();</span>
<span class="fc" id="L273">        final long partitionTimestamp = task.getPartitionTimestamp();</span>
<span class="fc" id="L274">        final int dstFixFd = task.getDstFixFd();</span>
<span class="fc" id="L275">        final long dstFixAddr = task.getDstFixAddr();</span>
<span class="fc" id="L276">        final long dstFixOffset = task.getDstFixOffset();</span>
<span class="fc" id="L277">        final long dstFixFileOffset = task.getDstFixFileOffset();</span>
<span class="fc" id="L278">        final long dstFixSize = task.getDstFixSize();</span>
<span class="fc" id="L279">        final int dstVarFd = task.getDstVarFd();</span>
<span class="fc" id="L280">        final long dstVarAddr = task.getDstVarAddr();</span>
<span class="fc" id="L281">        final long dstVarOffset = task.getDstVarOffset();</span>
<span class="fc" id="L282">        final long dstVarOffsetEnd = task.getDstVarOffsetEnd();</span>
<span class="fc" id="L283">        final long dstVarAdjust = task.getDstVarAdjust();</span>
<span class="fc" id="L284">        final long dstVarSize = task.getDstVarSize();</span>
<span class="fc" id="L285">        final int dstKFd = task.getDstKFd();</span>
<span class="fc" id="L286">        final int dskVFd = task.getDstVFd();</span>
<span class="fc" id="L287">        final long dstIndexOffset = task.getDstIndexOffset();</span>
<span class="fc" id="L288">        final long dstIndexAdjust = task.getDstIndexAdjust();</span>
<span class="fc" id="L289">        final int indexBlockCapacity = task.getIndexBlockCapacity();</span>
<span class="fc" id="L290">        final int srcTimestampFd = task.getSrcTimestampFd();</span>
<span class="fc" id="L291">        final long srcTimestampAddr = task.getSrcTimestampAddr();</span>
<span class="fc" id="L292">        final long srcTimestampSize = task.getSrcTimestampSize();</span>
<span class="fc" id="L293">        final boolean partitionMutates = task.isPartitionMutates();</span>
<span class="fc" id="L294">        final TableWriter tableWriter = task.getTableWriter();</span>
<span class="fc" id="L295">        final BitmapIndexWriter indexWriter = task.getIndexWriter();</span>

<span class="fc" id="L297">        subSeq.done(cursor);</span>

<span class="fc" id="L299">        copy(</span>
                columnCounter,
                partCounter,
                columnType,
                blockType,
                timestampMergeIndexAddr,
                timestampMergeIndexSize,
                srcDataFixFd,
                srcDataFixAddr,
                srcDataFixOffset,
                srcDataFixSize,
                srcDataVarFd,
                srcDataVarAddr,
                srcDataVarOffset,
                srcDataVarSize,
                srcDataLo,
                srcDataHi,
                srcDataTop,
                srcDataMax,
                srcOooFixAddr,
                srcOooVarAddr,
                srcOooLo,
                srcOooHi,
                srcOooMax,
                srcOooPartitionLo,
                srcOooPartitionHi,
                timestampMin,
                timestampMax,
                partitionTimestamp,
                dstFixFd,
                dstFixAddr,
                dstFixOffset,
                dstFixFileOffset,
                dstFixSize,
                dstVarFd,
                dstVarAddr,
                dstVarOffset,
                dstVarOffsetEnd,
                dstVarAdjust,
                dstVarSize,
                dstKFd,
                dskVFd,
                dstIndexOffset,
                dstIndexAdjust,
                indexBlockCapacity,
                srcTimestampFd,
                srcTimestampAddr,
                srcTimestampSize,
                partitionMutates,
                tableWriter,
                indexWriter
        );
<span class="fc" id="L351">    }</span>

    private static void copyData(
            FilesFacade ff,
            int columnType,
            long srcFixAddr,
            long srcVarAddr,
            long srcLo,
            long srcHi,
            long dstFixAddr,
            int dstFixFd,
            long dstFixFileOffset,
            long dstVarAddr,
            int dstVarFd,
            long dstVarOffset,
            long dstVarAdjust,
            long dstVarSize,
            boolean directIoFlag
    ) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.STRING:
            case ColumnType.BINARY:
<span class="fc" id="L373">                copyVarSizeCol(</span>
                        ff,
                        srcFixAddr,
                        srcVarAddr,
                        srcLo,
                        srcHi,
                        dstFixAddr,
                        dstFixFd,
                        dstFixFileOffset,
                        dstVarAddr,
                        dstVarFd,
                        dstVarOffset,
                        dstVarAdjust,
                        dstVarSize,
                        directIoFlag
                );
<span class="fc" id="L389">                break;</span>
            default:
<span class="fc" id="L391">                copyFixedSizeCol(</span>
                        ff,
                        srcFixAddr,
                        srcLo,
                        srcHi,
                        dstFixAddr,
                        dstFixFileOffset,
                        dstFixFd,
<span class="fc" id="L399">                        ColumnType.pow2SizeOf(Math.abs(columnType)),</span>
                        directIoFlag
                );
                break;
        }
<span class="fc" id="L404">    }</span>

    private static void copyFixedSizeCol(
            FilesFacade ff,
            long src,
            long srcLo,
            long srcHi,
            long dstFixAddr,
            long dstFixFileOffset,
            int dstFd,
            final int shl,
            boolean directIoFlag
    ) {
<span class="fc" id="L417">        final long len = (srcHi - srcLo + 1) &lt;&lt; shl;</span>
<span class="fc" id="L418">        final long fromAddress = src + (srcLo &lt;&lt; shl);</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (directIoFlag) {</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">            if (ff.write(Math.abs(dstFd), fromAddress, len, dstFixFileOffset) != len) {</span>
<span class="fc" id="L421">                throw CairoException.critical(ff.errno()).put(&quot;cannot copy fixed column prefix [fd=&quot;)</span>
<span class="fc" id="L422">                        .put(dstFd).put(&quot;, len=&quot;).put(len).put(&quot;, offset=&quot;).put(fromAddress).put(']');</span>
            }
        } else {
<span class="nc" id="L425">            Vect.memcpy(dstFixAddr, fromAddress, len);</span>
        }
<span class="fc" id="L427">    }</span>

    private static void copyTail(
            AtomicInteger columnCounter,
            @Nullable AtomicInteger partCounter,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarSize,
            long srcDataMax,
            long srcOooMax,
            long srcOooPartitionLo,
            long srcOooPartitionHi,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            int dstFixFd,
            long dstFixAddr,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarSize,
            int dstKFd,
            int dstVFd,
            long dstIndexOffset,
            long dstIndexAdjust,
            int indexBlockCapacity,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            boolean partitionMutates,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter
    ) {
<span class="fc bfc" id="L465" title="All 4 branches covered.">        if (partCounter == null || partCounter.decrementAndGet() == 0) {</span>
<span class="fc" id="L466">            final FilesFacade ff = tableWriter.getFilesFacade();</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            if (indexBlockCapacity &gt; -1) {</span>
<span class="fc" id="L468">                updateIndex(</span>
                        columnCounter,
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataFixFd,
                        srcDataFixAddr,
                        srcDataFixSize,
                        srcDataVarFd,
                        srcDataVarAddr,
                        srcDataVarSize,
                        dstFixFd,
                        dstFixAddr,
<span class="fc" id="L480">                        Math.abs(dstFixSize),</span>
                        dstVarFd,
                        dstVarAddr,
<span class="fc" id="L483">                        Math.abs(dstVarSize),</span>
                        dstKFd,
                        dstVFd,
                        dstIndexOffset,
                        dstIndexAdjust,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        tableWriter,
                        indexWriter,
                        indexBlockCapacity
                );
            }

            // unmap memory
<span class="fc" id="L498">            O3Utils.unmapAndClose(ff, srcDataFixFd, srcDataFixAddr, srcDataFixSize);</span>
<span class="fc" id="L499">            O3Utils.unmapAndClose(ff, srcDataVarFd, srcDataVarAddr, srcDataVarSize);</span>
<span class="fc" id="L500">            O3Utils.unmapAndClose(ff, dstFixFd, dstFixAddr, dstFixSize);</span>
<span class="fc" id="L501">            O3Utils.unmapAndClose(ff, dstVarFd, dstVarAddr, dstVarSize);</span>

<span class="fc" id="L503">            final int columnsRemaining = columnCounter.decrementAndGet();</span>
<span class="fc" id="L504">            LOG.debug()</span>
<span class="fc" id="L505">                    .$(&quot;organic [columnsRemaining=&quot;).$(columnsRemaining)</span>
<span class="fc" id="L506">                    .I$();</span>

<span class="fc bfc" id="L508" title="All 2 branches covered.">            if (columnsRemaining == 0) {</span>
<span class="fc" id="L509">                updatePartition(</span>
                        timestampMergeIndexAddr,
                        timestampMergeIndexSize,
                        srcDataMax,
                        srcOooMax,
                        srcOooPartitionLo,
                        srcOooPartitionHi,
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcTimestampFd,
                        srcTimestampAddr,
                        srcTimestampSize,
                        partitionMutates,
                        tableWriter
                );
            }
        }
<span class="fc" id="L527">    }</span>

    private static void copyVarSizeCol(
            FilesFacade ff,
            long srcFixAddr,
            long srcVarAddr,
            long srcLo,
            long srcHi,
            long dstFixAddr,
            int dstFixFd,
            long dstFixFileOffset,
            long dstVarAddr,
            int dstVarFd,
            long dstVarOffset,
            long dstVarAdjust,
            long dstVarSize,
            boolean directIoFlag
    ) {
<span class="fc" id="L545">        final long lo = O3Utils.findVarOffset(srcFixAddr, srcLo);</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        assert lo &gt;= 0;</span>
<span class="fc" id="L547">        final long hi = O3Utils.findVarOffset(srcFixAddr, srcHi + 1);</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">        assert hi &gt;= lo;</span>
        // copy this before it changes
<span class="fc" id="L550">        final long len = hi - lo;</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">        assert len &lt;= Math.abs(dstVarSize) - dstVarOffset;</span>
<span class="fc" id="L552">        final long offset = dstVarOffset + dstVarAdjust;</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (directIoFlag) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">            if (ff.write(Math.abs(dstVarFd), srcVarAddr + lo, len, offset) != len) {</span>
<span class="fc" id="L555">                throw CairoException.critical(ff.errno()).put(&quot;cannot copy var data column prefix [fd=&quot;).put(dstVarFd).put(&quot;, offset=&quot;).put(offset).put(&quot;, len=&quot;).put(len).put(']');</span>
            }
        } else {
<span class="nc" id="L558">            Vect.memcpy(dstVarAddr + dstVarOffset, srcVarAddr + lo, len);</span>
        }
<span class="fc bfc" id="L560" title="All 2 branches covered.">        if (lo == offset) {</span>
<span class="fc" id="L561">            copyFixedSizeCol(</span>
                    ff,
                    srcFixAddr,
                    srcLo,
                    srcHi + 1,
                    dstFixAddr,
                    dstFixFileOffset,
                    dstFixFd,
                    3,
                    directIoFlag
            );
        } else {
<span class="fc" id="L573">            O3Utils.shiftCopyFixedSizeColumnData(lo - offset, srcFixAddr, srcLo, srcHi + 1, dstFixAddr);</span>
        }
<span class="fc" id="L575">    }</span>

    private static void mergeCopy(
            int columnType,
            long timestampMergeIndexAddr,
            long srcDataFixAddr,
            long srcDataVarAddr,
            long srcDataLo,
            long srcDataHi,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            long dstFixAddr,
            long dstVarAddr,
            long dstVarOffset,
            long dstVarOffsetEnd
    ) {
<span class="fc" id="L593">        final long rowCount = srcOooHi - srcOooLo + 1 + srcDataHi - srcDataLo + 1;</span>
<span class="pc bpc" id="L594" title="1 of 10 branches missed.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.BOOLEAN:
            case ColumnType.BYTE:
            case ColumnType.GEOBYTE:
<span class="fc" id="L598">                Vect.mergeShuffle8Bit(srcDataFixAddr, srcOooFixAddr, dstFixAddr, timestampMergeIndexAddr, rowCount);</span>
<span class="fc" id="L599">                break;</span>
            case ColumnType.SHORT:
            case ColumnType.CHAR:
            case ColumnType.GEOSHORT:
<span class="fc" id="L603">                Vect.mergeShuffle16Bit(srcDataFixAddr, srcOooFixAddr, dstFixAddr, timestampMergeIndexAddr, rowCount);</span>
<span class="fc" id="L604">                break;</span>
            case ColumnType.STRING:
<span class="fc" id="L606">                Vect.oooMergeCopyStrColumn(</span>
                        timestampMergeIndexAddr,
                        rowCount,
                        srcDataFixAddr,
                        srcDataVarAddr,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        dstFixAddr,
                        dstVarAddr,
                        dstVarOffset
                );
                // multiple threads could be writing to this location as var index segments overlap,
                // but they will be writing the same value
<span class="fc" id="L619">                Unsafe.getUnsafe().putLong(dstFixAddr + rowCount * 8, dstVarOffsetEnd);</span>
<span class="fc" id="L620">                break;</span>
            case ColumnType.BINARY:
<span class="fc" id="L622">                Vect.oooMergeCopyBinColumn(</span>
                        timestampMergeIndexAddr,
                        rowCount,
                        srcDataFixAddr,
                        srcDataVarAddr,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        dstFixAddr,
                        dstVarAddr,
                        dstVarOffset
                );
<span class="fc" id="L633">                Unsafe.getUnsafe().putLong(dstFixAddr + rowCount * 8, dstVarOffsetEnd);</span>
<span class="fc" id="L634">                break;</span>
            case ColumnType.INT:
            case ColumnType.FLOAT:
            case ColumnType.SYMBOL:
            case ColumnType.GEOINT:
<span class="fc" id="L639">                Vect.mergeShuffle32Bit(srcDataFixAddr, srcOooFixAddr, dstFixAddr, timestampMergeIndexAddr, rowCount);</span>
<span class="fc" id="L640">                break;</span>
            case ColumnType.DOUBLE:
            case ColumnType.LONG:
            case ColumnType.DATE:
            case ColumnType.GEOLONG:
<span class="fc" id="L645">                Vect.mergeShuffle64Bit(srcDataFixAddr, srcOooFixAddr, dstFixAddr, timestampMergeIndexAddr, rowCount);</span>
<span class="fc" id="L646">                break;</span>
            case ColumnType.TIMESTAMP:
<span class="fc" id="L648">                final boolean designated = ColumnType.isDesignatedTimestamp(columnType);</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">                if (designated) {</span>
<span class="fc" id="L650">                    Vect.oooCopyIndex(timestampMergeIndexAddr, rowCount, dstFixAddr);</span>
                } else {
<span class="fc" id="L652">                    Vect.mergeShuffle64Bit(srcDataFixAddr, srcOooFixAddr, dstFixAddr, timestampMergeIndexAddr, rowCount);</span>
                }
<span class="fc" id="L654">                break;</span>
            case ColumnType.UUID:
            case ColumnType.LONG128:
<span class="fc" id="L657">                Vect.mergeShuffle128Bit(srcDataFixAddr, srcOooFixAddr, dstFixAddr, timestampMergeIndexAddr, rowCount);</span>
<span class="fc" id="L658">                break;</span>
            case ColumnType.LONG256:
<span class="fc" id="L660">                Vect.mergeShuffle256Bit(srcDataFixAddr, srcOooFixAddr, dstFixAddr, timestampMergeIndexAddr, rowCount);</span>
<span class="fc" id="L661">                break;</span>
            default:
                break;
        }
<span class="fc" id="L665">    }</span>

    private static void updateIndex(
            AtomicInteger columnCounter,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarSize,
            int dstFixFd,
            long dstFixAddr,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarSize,
            int dstKFd,
            int dstVFd,
            long dstIndexOffset,
            long dstIndexAdjust,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            TableWriter tableWriter,
            BitmapIndexWriter indexWriter,
            int indexBlockCapacity
    ) {
        // dstKFd &amp; dstVFd are closed by the indexer
        try {
<span class="fc" id="L696">            long row = dstIndexOffset / Integer.BYTES;</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">            boolean closed = !indexWriter.isOpen();</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">            if (closed) {</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">                indexWriter.of(tableWriter.getConfiguration(), dstKFd, dstVFd, row == 0, indexBlockCapacity);</span>
            }
            try {
<span class="fc" id="L702">                updateIndex(dstFixAddr, dstFixSize, indexWriter, dstIndexOffset / Integer.BYTES, dstIndexAdjust);</span>
            } finally {
<span class="fc bfc" id="L704" title="All 2 branches covered.">                if (closed) {</span>
<span class="fc" id="L705">                    Misc.free(indexWriter);</span>
                }
            }
<span class="fc" id="L708">        } catch (Throwable e) {</span>
<span class="fc" id="L709">            LOG.error()</span>
<span class="fc" id="L710">                    .$(&quot;index error [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L711">                    .$(&quot;, e=&quot;).$(e)</span>
<span class="fc" id="L712">                    .I$();</span>
<span class="fc" id="L713">            tableWriter.o3BumpErrorCount();</span>
<span class="fc" id="L714">            copyIdleQuick(</span>
                    columnCounter,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcDataFixFd,
                    srcDataFixAddr,
                    srcDataFixSize,
                    srcDataVarFd,
                    srcDataVarAddr,
                    srcDataVarSize,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    dstFixFd,
                    dstFixAddr,
                    dstFixSize,
                    dstVarFd,
                    dstVarAddr,
                    dstVarSize,
                    0,
                    0,
                    tableWriter
            );
<span class="fc" id="L737">            throw e;</span>
<span class="fc" id="L738">        }</span>
<span class="fc" id="L739">    }</span>

    private static void updateIndex(long dstFixAddr, long dstFixSize, BitmapIndexWriter w, long row, long rowAdjust) {
<span class="fc" id="L742">        w.rollbackConditionally(row + rowAdjust);</span>
<span class="fc" id="L743">        final long count = dstFixSize / Integer.BYTES;</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">        for (; row &lt; count; row++) {</span>
<span class="fc" id="L745">            w.add(TableUtils.toIndexKey(Unsafe.getUnsafe().getInt(dstFixAddr + row * Integer.BYTES)), row + rowAdjust);</span>
        }
<span class="fc" id="L747">        w.setMaxValue(count - 1);</span>
<span class="fc" id="L748">    }</span>

    // lowest timestamp of partition where data is headed

    private static void updatePartition(
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            long srcDataMax,
            long srcOooMax,
            long srcOooPartitionLo,
            long srcOooPartitionHi,
            long timestampMin,
            long timestampMax,
            long partitionTimestamp,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            boolean partitionMutates,
            TableWriter tableWriter
    ) {
<span class="fc" id="L768">        final FilesFacade ff = tableWriter.getFilesFacade();</span>
<span class="fc" id="L769">        O3Utils.unmap(ff, srcTimestampAddr, srcTimestampSize);</span>
        try {
            try {
<span class="fc" id="L772">                O3Utils.close(ff, srcTimestampFd);</span>
            } finally {
<span class="fc" id="L774">                tableWriter.o3NotifyPartitionUpdate(</span>
                        timestampMin,
                        timestampMax,
                        partitionTimestamp,
                        srcOooPartitionLo,
                        srcOooPartitionHi,
                        partitionMutates,
                        srcOooMax,
                        srcDataMax
                );
            }
        } finally {
<span class="fc bfc" id="L786" title="All 2 branches covered.">            if (timestampMergeIndexAddr != 0) {</span>
<span class="fc" id="L787">                Vect.freeMergedIndex(timestampMergeIndexAddr, timestampMergeIndexSize);</span>
            }
<span class="fc" id="L789">            tableWriter.o3CountDownDoneLatch();</span>
        }
<span class="fc" id="L791">    }</span>

    static void closeColumnIdle(
            AtomicInteger columnCounter,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            TableWriter tableWriter
    ) {
<span class="fc" id="L802">        final int columnsRemaining = columnCounter.decrementAndGet();</span>
<span class="fc" id="L803">        LOG.debug()</span>
<span class="fc" id="L804">                .$(&quot;idle [table=&quot;).utf8(tableWriter.getTableToken().getTableName())</span>
<span class="fc" id="L805">                .$(&quot;, columnsRemaining=&quot;).$(columnsRemaining)</span>
<span class="fc" id="L806">                .I$();</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">        if (columnsRemaining == 0) {</span>
<span class="fc" id="L808">            closeColumnIdleQuick(</span>
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    tableWriter
            );
        }
<span class="fc" id="L817">    }</span>

    static void closeColumnIdleQuick(
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            TableWriter tableWriter
    ) {
        try {
<span class="fc" id="L828">            final FilesFacade ff = tableWriter.getFilesFacade();</span>
<span class="fc" id="L829">            O3Utils.unmap(ff, srcTimestampAddr, srcTimestampSize);</span>
<span class="fc" id="L830">            O3Utils.close(ff, srcTimestampFd);</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">            if (timestampMergeIndexAddr != 0) {</span>
<span class="fc" id="L832">                Vect.freeMergedIndex(timestampMergeIndexAddr, timestampMergeIndexSize);</span>
            }
        } finally {
<span class="fc" id="L835">            tableWriter.o3ClockDownPartitionUpdateCount();</span>
<span class="fc" id="L836">            tableWriter.o3CountDownDoneLatch();</span>
        }
<span class="fc" id="L838">    }</span>

    static void copyIdle(
            AtomicInteger columnCounter,
            AtomicInteger partCounter,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarSize,
            int dstFixFd,
            long dstFixAddr,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarSize,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int dstKFd,
            int dstVFd,
            TableWriter tableWriter
    ) {
<span class="fc bfc" id="L864" title="All 4 branches covered.">        if (partCounter == null || partCounter.decrementAndGet() == 0) {</span>
            // unmap memory
<span class="fc" id="L866">            copyIdleQuick(</span>
                    columnCounter,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcDataFixFd,
                    srcDataFixAddr,
                    srcDataFixSize,
                    srcDataVarFd,
                    srcDataVarAddr,
                    srcDataVarSize,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    dstFixFd,
                    dstFixAddr,
                    dstFixSize,
                    dstVarFd,
                    dstVarAddr,
                    dstVarSize,
                    dstKFd,
                    dstVFd,
                    tableWriter
            );
        }
<span class="fc" id="L890">    }</span>

    static void copyIdleQuick(
            AtomicInteger columnCounter,
            long timestampMergeIndexAddr,
            long timestampMergeIndexSize,
            int srcDataFixFd,
            long srcDataFixAddr,
            long srcDataFixSize,
            int srcDataVarFd,
            long srcDataVarAddr,
            long srcDataVarSize,
            int srcTimestampFd,
            long srcTimestampAddr,
            long srcTimestampSize,
            int dstFixFd,
            long dstFixAddr,
            long dstFixSize,
            int dstVarFd,
            long dstVarAddr,
            long dstVarSize,
            int dstKFd,
            int dstVFd,
            TableWriter tableWriter
    ) {
        try {
<span class="fc" id="L916">            final FilesFacade ff = tableWriter.getFilesFacade();</span>
<span class="fc" id="L917">            O3Utils.unmapAndClose(ff, srcDataFixFd, srcDataFixAddr, srcDataFixSize);</span>
<span class="fc" id="L918">            O3Utils.unmapAndClose(ff, srcDataVarFd, srcDataVarAddr, srcDataVarSize);</span>
<span class="fc" id="L919">            O3Utils.unmapAndClose(ff, dstFixFd, dstFixAddr, dstFixSize);</span>
<span class="fc" id="L920">            O3Utils.unmapAndClose(ff, dstVarFd, dstVarAddr, dstVarSize);</span>
<span class="fc" id="L921">            O3Utils.close(ff, dstKFd);</span>
<span class="fc" id="L922">            O3Utils.close(ff, dstVFd);</span>
        } finally {
<span class="fc" id="L924">            closeColumnIdle(</span>
                    columnCounter,
                    timestampMergeIndexAddr,
                    timestampMergeIndexSize,
                    srcTimestampFd,
                    srcTimestampAddr,
                    srcTimestampSize,
                    tableWriter
            );
        }
<span class="fc" id="L934">    }</span>

    static void copyO3(
            FilesFacade ff,
            int columnType,
            long srcOooFixAddr,
            long srcOooVarAddr,
            long srcOooLo,
            long srcOooHi,
            int dstFixFd,
            long dstFixAddr,
            long dstFixFileOffset,
            long dstVarAddr,
            int dstVarFd,
            long dstVarOffset,
            long dstVarAdjust,
            long dstVarSize,
            boolean directIoFlag
    ) {
<span class="pc bpc" id="L953" title="1 of 9 branches missed.">        switch (ColumnType.tagOf(columnType)) {</span>
            case ColumnType.STRING:
            case ColumnType.BINARY:
                // we can find out the edge of string column in one of two ways
                // 1. if srcOooHi is at the limit of the page - we need to copy the whole page of strings
                // 2  if there are more items behind srcOooHi we can get offset of srcOooHi+1
<span class="fc" id="L959">                copyVarSizeCol(</span>
                        ff,
                        srcOooFixAddr,
                        srcOooVarAddr,
                        srcOooLo,
                        srcOooHi,
                        dstFixAddr,
                        dstFixFd,
                        dstFixFileOffset,
                        dstVarAddr,
                        dstVarFd,
                        dstVarOffset,
                        dstVarAdjust,
                        dstVarSize,
                        directIoFlag
                );
<span class="fc" id="L975">                break;</span>
            case ColumnType.BOOLEAN:
            case ColumnType.BYTE:
            case ColumnType.GEOBYTE:
<span class="fc" id="L979">                copyFixedSizeCol(</span>
                        ff,
                        srcOooFixAddr,
                        srcOooLo,
                        srcOooHi,
                        dstFixAddr,
                        dstFixFileOffset,
                        dstFixFd,
                        0,
                        directIoFlag
                );
<span class="fc" id="L990">                break;</span>
            case ColumnType.CHAR:
            case ColumnType.SHORT:
            case ColumnType.GEOSHORT:
<span class="fc" id="L994">                copyFixedSizeCol(</span>
                        ff,
                        srcOooFixAddr,
                        srcOooLo,
                        srcOooHi,
                        dstFixAddr,
                        dstFixFileOffset,
                        dstFixFd,
                        1,
                        directIoFlag
                );
<span class="fc" id="L1005">                break;</span>
            case ColumnType.INT:
            case ColumnType.FLOAT:
            case ColumnType.SYMBOL:
            case ColumnType.GEOINT:
<span class="fc" id="L1010">                copyFixedSizeCol(</span>
                        ff,
                        srcOooFixAddr,
                        srcOooLo,
                        srcOooHi,
                        dstFixAddr,
                        dstFixFileOffset,
                        dstFixFd,
                        2,
                        directIoFlag
                );
<span class="fc" id="L1021">                break;</span>
            case ColumnType.LONG:
            case ColumnType.DATE:
            case ColumnType.DOUBLE:
            case ColumnType.GEOLONG:
<span class="fc" id="L1026">                copyFixedSizeCol(</span>
                        ff,
                        srcOooFixAddr,
                        srcOooLo,
                        srcOooHi,
                        dstFixAddr,
                        dstFixFileOffset,
                        dstFixFd,
                        3,
                        directIoFlag
                );
<span class="fc" id="L1037">                break;</span>
            case ColumnType.TIMESTAMP:
<span class="fc" id="L1039">                final boolean designated = ColumnType.isDesignatedTimestamp(columnType);</span>
<span class="fc bfc" id="L1040" title="All 2 branches covered.">                if (designated) {</span>
<span class="fc" id="L1041">                    O3Utils.copyFromTimestampIndex(srcOooFixAddr, srcOooLo, srcOooHi, dstFixAddr);</span>
                } else {
<span class="fc" id="L1043">                    copyFixedSizeCol(</span>
                            ff,
                            srcOooFixAddr,
                            srcOooLo,
                            srcOooHi,
                            dstFixAddr,
                            dstFixFileOffset,
                            dstFixFd,
                            3,
                            directIoFlag
                    );
                }
<span class="fc" id="L1055">                break;</span>
            case ColumnType.UUID:
            case ColumnType.LONG128:
<span class="fc" id="L1058">                copyFixedSizeCol(</span>
                        ff,
                        srcOooFixAddr,
                        srcOooLo,
                        srcOooHi,
                        dstFixAddr,
                        dstFixFileOffset,
                        dstFixFd,
                        4,
                        directIoFlag
                );
<span class="fc" id="L1069">                break;</span>
            case ColumnType.LONG256:
<span class="fc" id="L1071">                copyFixedSizeCol(</span>
                        ff,
                        srcOooFixAddr,
                        srcOooLo,
                        srcOooHi,
                        dstFixAddr,
                        dstFixFileOffset,
                        dstFixFd,
                        5,
                        directIoFlag
                );
<span class="fc" id="L1082">                break;</span>
            default:
                // we have exhausted all supported types in &quot;case&quot; clauses
                break;
        }
<span class="fc" id="L1087">    }</span>

    @Override
    protected boolean doRun(int workerId, long cursor, RunStatus runStatus) {
<span class="fc" id="L1091">        copy(queue.get(cursor), cursor, subSeq);</span>
<span class="fc" id="L1092">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>