<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RebuildColumnBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo</a> &gt; <span class="el_source">RebuildColumnBase.java</span></div><h1>RebuildColumnBase.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo;

import io.questdb.cairo.sql.RecordMetadata;
import io.questdb.std.FilesFacade;
import io.questdb.std.Misc;
import io.questdb.std.Mutable;
import io.questdb.std.datetime.DateFormat;
import io.questdb.std.datetime.millitime.MillisecondClock;
import io.questdb.std.str.Path;
import io.questdb.std.str.StringSink;
import org.jetbrains.annotations.Nullable;

import java.io.Closeable;

import static io.questdb.cairo.TableUtils.TXN_FILE_NAME;
import static io.questdb.cairo.TableUtils.lockName;

<span class="fc" id="L42">public abstract class RebuildColumnBase implements Closeable, Mutable {</span>
    static final int REBUILD_ALL_COLUMNS = -1;
<span class="fc" id="L44">    protected final String unsupportedTableMessage = &quot;Table does not have any indexes&quot;;</span>
<span class="fc" id="L45">    private final StringSink tempStringSink = new StringSink();</span>
    protected CairoConfiguration configuration;
    protected FilesFacade ff;
<span class="fc" id="L48">    protected Path path = new Path();</span>
    protected int rootLen;
<span class="fc" id="L50">    protected String unsupportedColumnMessage = &quot;Wrong column type&quot;;</span>
    private MillisecondClock clock;
    private int lockFd;

    @Override
    public void clear() {
<span class="fc" id="L56">        path.trimTo(0);</span>
<span class="fc" id="L57">        tempStringSink.clear();</span>
<span class="fc" id="L58">    }</span>

    @Override
    public void close() {
<span class="fc" id="L62">        this.path = Misc.free(path);</span>
<span class="fc" id="L63">    }</span>

    public RebuildColumnBase of(CharSequence tablePath, CairoConfiguration configuration) {
<span class="fc" id="L66">        this.path.of(tablePath);</span>
<span class="fc" id="L67">        this.rootLen = tablePath.length();</span>
<span class="fc" id="L68">        this.configuration = configuration;</span>
<span class="fc" id="L69">        this.ff = configuration.getFilesFacade();</span>
<span class="fc" id="L70">        this.clock = configuration.getMillisecondClock();</span>
<span class="fc" id="L71">        return this;</span>
    }

    public void rebuildAll() {
<span class="fc" id="L75">        reindex(null, null);</span>
<span class="fc" id="L76">    }</span>

    public void reindex(
            @Nullable CharSequence partitionName,
            @Nullable CharSequence columnName
    ) {
        try {
<span class="fc" id="L83">            lock(ff);</span>
<span class="fc" id="L84">            path.concat(TableUtils.COLUMN_VERSION_FILE_NAME).$();</span>
<span class="fc" id="L85">            try (ColumnVersionReader columnVersionReader = new ColumnVersionReader().ofRO(ff, path)) {</span>
<span class="fc" id="L86">                final long deadline = clock.getTicks() + configuration.getSpinLockTimeout();</span>
<span class="fc" id="L87">                columnVersionReader.readSafe(clock, deadline);</span>
<span class="fc" id="L88">                path.trimTo(rootLen);</span>
<span class="fc" id="L89">                reindex0(columnVersionReader, partitionName, columnName);</span>
            }
        } finally {
<span class="fc" id="L92">            lockName(path);</span>
<span class="fc" id="L93">            releaseLock(ff);</span>
        }
<span class="fc" id="L95">    }</span>

    public void reindexAfterUpdate(long partitionTimestamp, CharSequence columnName, TableWriter tableWriter) {
<span class="fc" id="L98">        TxReader txReader = tableWriter.getTxReader();</span>
<span class="fc" id="L99">        int partitionIndex = txReader.getPartitionIndex(partitionTimestamp);</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        assert partitionIndex &gt; -1L;</span>

<span class="fc" id="L102">        final RecordMetadata metadata = tableWriter.getMetadata();</span>
<span class="fc" id="L103">        final int columnIndex = tableWriter.getColumnIndex(columnName);</span>
<span class="fc" id="L104">        final int indexValueBlockCapacity = metadata.getIndexValueBlockCapacity(columnIndex);</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        assert indexValueBlockCapacity &gt; 0;</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">        final long partitionSize = partitionIndex == txReader.getPartitionCount() - 1</span>
<span class="fc" id="L108">                ? txReader.getTransientRowCount()</span>
<span class="fc" id="L109">                : txReader.getPartitionSize(partitionIndex);</span>

<span class="fc" id="L111">        long partitionNameTxn = txReader.getPartitionNameTxn(partitionIndex);</span>

<span class="fc" id="L113">        tempStringSink.clear();</span>
<span class="fc" id="L114">        DateFormat partitionDirFormatMethod = PartitionBy.getPartitionDirFormatMethod(tableWriter.getPartitionBy());</span>
<span class="fc" id="L115">        partitionDirFormatMethod.format(partitionTimestamp, null, null, tempStringSink);</span>

<span class="fc" id="L117">        doReindex(</span>
<span class="fc" id="L118">                tableWriter.getColumnVersionReader(),</span>
                // this may not be needed, because table writer's column index is the same
                // as metadata writers' index.
                columnIndex,
                columnName,
                tempStringSink, // partition name
                partitionNameTxn,
                partitionSize,
                partitionTimestamp,
                indexValueBlockCapacity
        );
<span class="fc" id="L129">    }</span>

    public void reindexAllInPartition(CharSequence partitionName) {
<span class="fc" id="L132">        reindex(partitionName, null);</span>
<span class="fc" id="L133">    }</span>

    public void reindexColumn(CharSequence columnName) {
<span class="fc" id="L136">        reindex(null, columnName);</span>
<span class="fc" id="L137">    }</span>

    public void reindexColumn(
            ColumnVersionReader columnVersionReader,
            RecordMetadata metadata,
            int columnIndex,
            CharSequence partitionName,
            long partitionNameTxn,
            long partitionTimestamp,
            long partitionSize
    ) {
<span class="fc" id="L148">        doReindex(</span>
                columnVersionReader,
<span class="fc" id="L150">                metadata.getWriterIndex(columnIndex),</span>
<span class="fc" id="L151">                metadata.getColumnName(columnIndex),</span>
                partitionName,
                partitionNameTxn,
                partitionSize,
                partitionTimestamp,
<span class="fc" id="L156">                metadata.getIndexValueBlockCapacity(columnIndex)</span>
        );
<span class="fc" id="L158">    }</span>

    private void lock(FilesFacade ff) {
        try {
<span class="fc" id="L162">            path.trimTo(rootLen);</span>
<span class="fc" id="L163">            lockName(path);</span>
<span class="fc" id="L164">            this.lockFd = TableUtils.lock(ff, path);</span>
        } finally {
<span class="fc" id="L166">            path.trimTo(rootLen);</span>
        }

<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (this.lockFd == -1) {</span>
<span class="fc" id="L170">            throw CairoException.nonCritical().put(&quot;Cannot lock table: &quot;).put(path.$());</span>
        }
<span class="fc" id="L172">    }</span>

    // this method is not used by UPDATE SQL
    private void reindex0(
            ColumnVersionReader columnVersionReader,
            @Nullable CharSequence partitionName, // will reindex all partitions if partition name is not provided
            @Nullable CharSequence columnName // will reindex all columns if name is not provided
    ) {
<span class="fc" id="L180">        path.trimTo(rootLen).concat(TableUtils.META_FILE_NAME);</span>
<span class="fc" id="L181">        try (TableReaderMetadata metadata = new TableReaderMetadata(configuration)) {</span>
<span class="fc" id="L182">            metadata.load(path.$());</span>
            // Resolve column id if the column name specified
            final int columnIndex;
<span class="fc bfc" id="L185" title="All 2 branches covered.">            if (columnName != null) {</span>
<span class="fc" id="L186">                columnIndex = metadata.getColumnIndex(columnName);</span>
            } else {
<span class="fc" id="L188">                columnIndex = REBUILD_ALL_COLUMNS;</span>
            }

<span class="fc" id="L191">            path.trimTo(rootLen);</span>
<span class="fc" id="L192">            final int partitionBy = metadata.getPartitionBy();</span>
<span class="fc" id="L193">            final DateFormat partitionDirFormatMethod = PartitionBy.getPartitionDirFormatMethod(partitionBy);</span>

<span class="fc" id="L195">            try (TxReader txReader = new TxReader(ff).ofRO(path.concat(TXN_FILE_NAME).$(), partitionBy)) {</span>
<span class="fc" id="L196">                txReader.unsafeLoadAll();</span>
<span class="fc" id="L197">                path.trimTo(rootLen);</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">                if (PartitionBy.isPartitioned(partitionBy)) {</span>
                    // Resolve partition timestamp if partition name specified
<span class="fc bfc" id="L201" title="All 2 branches covered.">                    if (partitionName != null) {</span>
<span class="fc" id="L202">                        final long partitionTimestamp = PartitionBy.parsePartitionDirName(partitionName, partitionBy);</span>
<span class="fc" id="L203">                        int partitionIndex = txReader.findAttachedPartitionIndexByLoTimestamp(partitionTimestamp);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                        if (partitionIndex &gt; -1L) {</span>
<span class="fc" id="L205">                            reindexPartition(</span>
                                    metadata,
                                    columnVersionReader,
                                    txReader,
                                    columnIndex,
                                    partitionIndex,
                                    partitionDirFormatMethod,
                                    partitionTimestamp
                            );
                        }
<span class="fc" id="L215">                    } else {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                        for (int partitionIndex = txReader.getPartitionCount() - 1; partitionIndex &gt; -1; partitionIndex--) {</span>
<span class="fc" id="L217">                            reindexPartition(</span>
                                    metadata,
                                    columnVersionReader,
                                    txReader,
                                    columnIndex,
                                    partitionIndex,
                                    partitionDirFormatMethod,
<span class="fc" id="L224">                                    txReader.getPartitionTimestamp(partitionIndex)</span>
                            );
                        }
                    }
                } else {
                    // reindexing columns in non-partitioned table
<span class="fc" id="L230">                    reindexOneOrAllColumns(</span>
                            metadata,
                            columnVersionReader,
                            columnIndex,
                            partitionDirFormatMethod,
                            -1L,
                            0L,
<span class="fc" id="L237">                            txReader.getTransientRowCount()</span>
                    );
                }
            }
        } finally {
<span class="fc" id="L242">            path.trimTo(rootLen);</span>
        }
<span class="fc" id="L244">    }</span>

    private void reindexOneOrAllColumns(
            RecordMetadata metadata,
            ColumnVersionReader columnVersionReader,
            int columnIndex,
            DateFormat partitionDirFormatMethod,
            long partitionNameTxn,
            long partitionTimestamp,
            long partitionSize
    ) {
<span class="fc" id="L255">        boolean isIndexed = false;</span>
<span class="fc" id="L256">        tempStringSink.clear();</span>
<span class="fc" id="L257">        partitionDirFormatMethod.format(partitionTimestamp, null, null, tempStringSink);</span>

<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (columnIndex == REBUILD_ALL_COLUMNS) {</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            for (int i = 0, n = metadata.getColumnCount(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">                if (isSupportedColumn(metadata, i)) {</span>
<span class="fc" id="L262">                    isIndexed = true;</span>
<span class="fc" id="L263">                    reindexColumn(</span>
                            columnVersionReader,
                            metadata,
                            i,
                            tempStringSink,
                            partitionNameTxn,
                            partitionTimestamp,
                            partitionSize
                    );
                }
            }
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (!isIndexed) {</span>
<span class="fc" id="L275">                throw CairoException.nonCritical().put(unsupportedTableMessage);</span>
            }
        } else {
<span class="fc bfc" id="L278" title="All 2 branches covered.">            if (isSupportedColumn(metadata, columnIndex)) {</span>
<span class="fc" id="L279">                reindexColumn(</span>
                        columnVersionReader,
                        metadata,
                        columnIndex,
                        tempStringSink,
                        partitionNameTxn,
                        partitionTimestamp,
                        partitionSize
                );
            } else {
<span class="fc" id="L289">                throw CairoException.nonCritical().put(unsupportedColumnMessage);</span>
            }
        }
<span class="fc" id="L292">    }</span>

    private void reindexPartition(
            RecordMetadata metadata,
            ColumnVersionReader columnVersionReader,
            TxReader txReader,
            int columnIndex,
            int partitionIndex,
            DateFormat partitionDirFormatMethod,
            long partitionTimestamp
    ) {
<span class="fc bfc" id="L303" title="All 2 branches covered.">        final long partitionSize = partitionIndex == txReader.getPartitionCount() - 1</span>
<span class="fc" id="L304">                ? txReader.getTransientRowCount()</span>
<span class="fc" id="L305">                : txReader.getPartitionSize(partitionIndex);</span>

<span class="fc" id="L307">        reindexOneOrAllColumns(</span>
                metadata,
                columnVersionReader,
                columnIndex,
                partitionDirFormatMethod,
<span class="fc" id="L312">                txReader.getPartitionNameTxn(partitionIndex),</span>
                partitionTimestamp,
                partitionSize
        );
<span class="fc" id="L316">    }</span>

    private void releaseLock(FilesFacade ff) {
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (lockFd != -1L) {</span>
<span class="fc" id="L320">            ff.close(lockFd);</span>
<span class="fc" id="L321">            lockFd = -1;</span>
            try {
<span class="fc" id="L323">                path.trimTo(rootLen);</span>
<span class="fc" id="L324">                lockName(path);</span>
<span class="pc bpc" id="L325" title="2 of 4 branches missed.">                if (ff.exists(path) &amp;&amp; !ff.remove(path)) {</span>
<span class="nc" id="L326">                    throw CairoException.critical(ff.errno()).put(&quot;Cannot remove &quot;).put(path);</span>
                }
            } finally {
<span class="fc" id="L329">                path.trimTo(rootLen);</span>
            }
        }
<span class="fc" id="L332">    }</span>

    abstract protected void doReindex(
            ColumnVersionReader columnVersionReader,
            int columnWriterIndex,
            CharSequence columnName,
            CharSequence partitionName,
            long partitionNameTxn,
            long partitionSize,
            long partitionTimestamp,
            int indexValueBlockCapacity
    );

    protected abstract boolean isSupportedColumn(RecordMetadata metadata, int columnIndex);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>