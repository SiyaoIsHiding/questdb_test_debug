<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WriterPool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo.pool</a> &gt; <span class="el_source">WriterPool.java</span></div><h1>WriterPool.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo.pool;

import io.questdb.MessageBus;
import io.questdb.Metrics;
import io.questdb.cairo.*;
import io.questdb.cairo.pool.ex.EntryLockedException;
import io.questdb.cairo.pool.ex.PoolClosedException;
import io.questdb.cairo.sql.AsyncWriterCommand;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.log.LogRecord;
import io.questdb.std.ConcurrentHashMap;
import io.questdb.std.Os;
import io.questdb.std.Unsafe;
import io.questdb.std.datetime.microtime.MicrosecondClock;
import io.questdb.std.str.Path;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.TestOnly;

import java.util.Iterator;

/**
 * This class maintains cache of open writers to avoid OS overhead of
 * opening and closing files. While doing so it abides by the same
 * rule as non-pooled writers: there can only be one TableWriter instance
 * for any given table name.
 * &lt;p&gt;
 * This implementation is thread-safe. Writer allocated by one thread
 * cannot be used by any other threads until it is released. This factory
 * will be returning NULL when writer is already in use and cached
 * instance of writer otherwise. Writers are released back to pool via
 * standard writer.close() call.
 * &lt;p&gt;
 * Writers that have been idle for some time can be expunged from pool
 * by calling Job.run() method asynchronously. Pool implementation is
 * guaranteeing thread-safety of this method at all times.
 * &lt;p&gt;
 * This factory can be closed via close() call. This method is also
 * thread-safe and is guarantying that all open writers will be eventually
 * closed.
 */
public class WriterPool extends AbstractPool {
<span class="fc" id="L68">    public static final String OWNERSHIP_REASON_NONE = null;</span>
    public static final String OWNERSHIP_REASON_RELEASED = &quot;released&quot;;
    public static final String OWNERSHIP_REASON_UNKNOWN = &quot;unknown&quot;;
    static final String OWNERSHIP_REASON_MISSING = &quot;missing or owned by other process&quot;;
    static final String OWNERSHIP_REASON_WRITER_ERROR = &quot;writer error&quot;;
<span class="fc" id="L73">    private final static long ENTRY_OWNER = Unsafe.getFieldOffset(Entry.class, &quot;owner&quot;);</span>
<span class="fc" id="L74">    private static final Log LOG = LogFactory.getLog(WriterPool.class);</span>
    private static final long QUEUE_PROCESSING_OWNER = -2L;
    private final MicrosecondClock clock;
    private final CairoConfiguration configuration;
<span class="fc" id="L78">    private final ConcurrentHashMap&lt;Entry&gt; entries = new ConcurrentHashMap&lt;&gt;();</span>
    @NotNull
    private final MessageBus messageBus;
    @NotNull
    private final Metrics metrics;
    private final CharSequence root;

    /**
     * Pool constructor. WriterPool root directory is passed via configuration.
     *
     * @param configuration configuration parameters.
     * @param messageBus    message bus instance to allow index tasks to be communicated to available threads.
     * @param metrics       metrics instance to be used by table writers.
     */
    public WriterPool(CairoConfiguration configuration, @NotNull MessageBus messageBus, @NotNull Metrics metrics) {
<span class="fc" id="L93">        super(configuration, configuration.getInactiveWriterTTL());</span>
<span class="fc" id="L94">        this.configuration = configuration;</span>
<span class="fc" id="L95">        this.messageBus = messageBus;</span>
<span class="fc" id="L96">        this.clock = configuration.getMicrosecondClock();</span>
<span class="fc" id="L97">        this.root = configuration.getRoot();</span>
<span class="fc" id="L98">        this.metrics = metrics;</span>
<span class="fc" id="L99">        notifyListener(Thread.currentThread().getId(), null, PoolListener.EV_POOL_OPEN);</span>
<span class="fc" id="L100">    }</span>

    /**
     * &lt;p&gt;
     * Creates or retrieves existing TableWriter from pool. Because of TableWriter compliance with &lt;b&gt;single
     * writer model&lt;/b&gt; pool ensures there is single TableWriter instance for given table name. Table name is unique in
     * context of &lt;b&gt;root&lt;/b&gt;, and pool instance covers single root.
     * &lt;/p&gt;
     * Exceptions thrown:
     * &lt;ul&gt;
     * &lt;li&gt;{@link EntryUnavailableException}: When TableWriter from this pool is used by another thread.
     * In this case, application can retry getting writer from pool again at any time.&lt;/li&gt;
     * &lt;li&gt;{@link CairoException}: When table is locked outside of pool, which includes same or different process.
     * In this case, application has to call {@link #releaseAll(long)} before retrying for TableWriter.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param tableToken name of the table
     * @param lockReason description of where or why lock is held
     * @return cached TableWriter instance.
     */
    public TableWriter get(TableToken tableToken, String lockReason) {
<span class="fc" id="L121">        return get(tableToken, lockReason, true);</span>
    }

    public TableWriter get(TableToken tableToken, String lockReason, boolean logBusy) {
<span class="fc" id="L125">        return getWriterEntry(tableToken, lockReason, null, logBusy);</span>
    }

    /**
     * Counts busy writers in pool.
     *
     * @return number of busy writer instances.
     */
    @TestOnly
    public int getBusyCount() {
<span class="fc" id="L135">        int count = 0;</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (Entry e : entries.values()) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (e.owner != UNALLOCATED) {</span>
<span class="fc" id="L138">                count++;</span>
            }
<span class="fc" id="L140">        }</span>
<span class="fc" id="L141">        return count;</span>
    }

    /**
     * Returns writer from the pool or sends writer command
     *
     * @param tableToken         name of the table
     * @param lockReason         reason for the action
     * @param asyncWriterCommand command to write to TableWriterTask
     * @return null if command is published or TableWriter instance if writer is available
     */
    public TableWriter getWriterOrPublishCommand(
            TableToken tableToken,
            String lockReason,
            @NotNull AsyncWriterCommand asyncWriterCommand
    ) {
        while (true) {
            try {
<span class="fc" id="L159">                return getWriterEntry(tableToken, lockReason, asyncWriterCommand, true);</span>
<span class="nc" id="L160">            } catch (EntryUnavailableException ex) {</span>
                // means retry in this context
<span class="nc" id="L162">            }</span>
        }
    }

    /**
     * Locks writer. Locking operation is always non-blocking. Lock is usually successful
     * when writer is in pool or owned by calling thread, in which case
     * writer instance is closed. Lock will also succeed when writer does not exist.
     * This will prevent from writer being created before it is unlocked.
     * &lt;p&gt;
     * Lock fails immediately with {@link EntryUnavailableException} when writer is used by another thread and with
     * {@link PoolClosedException} when pool is closed.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Lock is beneficial before table directory is renamed or deleted.
     * &lt;/p&gt;
     *
     * @param tableToken table name
     * @param lockReason description of where or why lock is held
     * @return lock reason as String
     */
    public String lock(TableToken tableToken, String lockReason) {
<span class="fc" id="L184">        checkClosed();</span>

<span class="fc" id="L186">        long thread = Thread.currentThread().getId();</span>

<span class="fc" id="L188">        Entry e = entries.get(tableToken.getDirName());</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (e == null) {</span>
            // We are racing to create new writer!
<span class="fc" id="L191">            e = new Entry(clock.getTicks());</span>
<span class="fc" id="L192">            Entry other = entries.putIfAbsent(tableToken.getDirName(), e);</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            if (other == null) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">                if (lockAndNotify(thread, e, tableToken, lockReason)) {</span>
<span class="fc" id="L195">                    return OWNERSHIP_REASON_NONE;</span>
                } else {
<span class="fc" id="L197">                    entries.remove(tableToken.getDirName());</span>
<span class="fc" id="L198">                    return reinterpretOwnershipReason(e.ownershipReason);</span>
                }
            } else {
<span class="nc" id="L201">                e = other;</span>
            }
        }

        // try to change owner
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if ((Unsafe.cas(e, ENTRY_OWNER, UNALLOCATED, thread) /*|| (e.owner == thread)*/)) {</span>
<span class="fc" id="L207">            closeWriter(thread, e, PoolListener.EV_LOCK_CLOSE, PoolConstants.CR_NAME_LOCK);</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">            if (lockAndNotify(thread, e, tableToken, lockReason)) {</span>
<span class="fc" id="L209">                return OWNERSHIP_REASON_NONE;</span>
            }
<span class="nc" id="L211">            return reinterpretOwnershipReason(e.ownershipReason);</span>
        }

<span class="fc" id="L214">        LOG.error().$(&quot;could not lock, busy [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, owner=&quot;).$(e.owner).$(&quot;, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L215">        notifyListener(thread, tableToken, PoolListener.EV_LOCK_BUSY);</span>
<span class="fc" id="L216">        return reinterpretOwnershipReason(e.ownershipReason);</span>
    }

    public int size() {
<span class="fc" id="L220">        return entries.size();</span>
    }

    public void unlock(TableToken tableToken) {
<span class="fc" id="L224">        unlock(tableToken, null, false);</span>
<span class="fc" id="L225">    }</span>

    public void unlock(TableToken tableToken, @Nullable TableWriter writer, boolean newTable) {
<span class="fc" id="L228">        long thread = Thread.currentThread().getId();</span>

<span class="fc" id="L230">        Entry e = entries.get(tableToken.getDirName());</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (e == null) {</span>
<span class="fc" id="L232">            notifyListener(thread, tableToken, PoolListener.EV_NOT_LOCKED);</span>
<span class="fc" id="L233">            return;</span>
        }

<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (e.owner == thread) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (e.writer != null) {</span>
                // When entry is locked, writer must be null, however if writer is not null,
                // calling thread must be trying to unlock writer that hasn't been locked.
                // This qualifies for &quot;illegal state&quot;.
<span class="fc" id="L241">                notifyListener(thread, tableToken, PoolListener.EV_NOT_LOCKED);</span>
<span class="fc" id="L242">                throw CairoException.critical(0).put(&quot;Writer &quot;).put(tableToken.getDirName()).put(&quot; is not locked&quot;);</span>
            }

<span class="fc bfc" id="L245" title="All 2 branches covered.">            if (newTable) {</span>
                // Note that the TableUtils.createTable method will create files, but on some OS's these files
                // will not immediately become visible on all threads, only in this thread will they definitely
                // be visible. To prevent spurious file system errors (or even allowing the same table to be
                // created twice), we cache the writer in the WriterPool whose access via the engine is thread safe.
<span class="pc bpc" id="L250" title="2 of 4 branches missed.">                assert writer == null &amp;&amp; e.lockFd != -1;</span>
<span class="fc" id="L251">                LOG.info().$(&quot;created [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L252">                writer = new TableWriter(configuration, tableToken, messageBus, null, false, e, root, metrics);</span>
            }

<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (writer == null) {</span>
                // unlock must remove entry because pool does not deal with null writer

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">                if (e.lockFd != -1) {</span>
<span class="fc" id="L259">                    Path path = Path.getThreadLocal(root).concat(tableToken.getDirName());</span>
<span class="fc" id="L260">                    TableUtils.lockName(path);</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">                    if (!ff.closeRemove(e.lockFd, path)) {</span>
<span class="nc" id="L262">                        LOG.error().$(&quot;could not remove [file=&quot;).$(path).$(']').$();</span>
                    }
                }
<span class="fc" id="L265">                entries.remove(tableToken.getDirName());</span>
            } else {
<span class="fc" id="L267">                e.writer = writer;</span>
<span class="fc" id="L268">                writer.setLifecycleManager(e);</span>
<span class="fc" id="L269">                writer.transferLock(e.lockFd);</span>
<span class="fc" id="L270">                e.lockFd = -1;</span>
<span class="fc" id="L271">                e.ownershipReason = OWNERSHIP_REASON_NONE;</span>
<span class="fc" id="L272">                Unsafe.getUnsafe().storeFence();</span>
<span class="fc" id="L273">                Unsafe.getUnsafe().putOrderedLong(e, ENTRY_OWNER, UNALLOCATED);</span>
            }
<span class="fc" id="L275">            notifyListener(thread, tableToken, PoolListener.EV_UNLOCKED);</span>
<span class="fc" id="L276">            LOG.debug().$(&quot;unlocked [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, thread=&quot;).$(thread).I$();</span>
        } else {
<span class="fc" id="L278">            notifyListener(thread, tableToken, PoolListener.EV_NOT_LOCK_OWNER);</span>
<span class="fc" id="L279">            throw CairoException.critical(0).put(&quot;Not lock owner of &quot;).put(tableToken.getDirName());</span>
        }
<span class="fc" id="L281">    }</span>

    private void addCommandToWriterQueue(Entry e, AsyncWriterCommand asyncWriterCommand, long thread) {
        TableWriter writer;
<span class="pc bpc" id="L285" title="1 of 4 branches missed.">        while ((writer = e.writer) == null &amp;&amp; e.owner != UNALLOCATED) {</span>
<span class="fc" id="L286">            Os.pause();</span>
        }
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (writer == null) {</span>
            // Retry from very beginning
<span class="nc" id="L290">            throw EntryUnavailableException.instance(&quot;please retry&quot;);</span>
        }
        // Mark command as being executed asynchronously and publish it.
<span class="fc" id="L293">        asyncWriterCommand.startAsync();</span>
<span class="fc" id="L294">        writer.publishAsyncWriterCommand(asyncWriterCommand);</span>

        // Make sure writer does not go to the pool with command in the queue
        // Wait until writer is either in the pool or out
<span class="fc bfc" id="L298" title="All 2 branches covered.">        while (e.owner == QUEUE_PROCESSING_OWNER) {</span>
<span class="fc" id="L299">            Os.pause();</span>
        }

        // If the writer is suddenly in the pool, lock it and call tick to process command queue
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (Unsafe.cas(e, ENTRY_OWNER, UNALLOCATED, thread)) {</span>
            // Writer became available straight after setting items in the queue.
            // Don't leave it unprocessed
            try {
<span class="fc" id="L307">                writer.tick(true);</span>
            } finally {
<span class="fc" id="L309">                Unsafe.cas(e, ENTRY_OWNER, thread, UNALLOCATED);</span>
            }
        }
<span class="fc" id="L312">    }</span>

    private void assertLockReasonIsNone(String lockReason) {
        //noinspection StringEquality
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (lockReason == OWNERSHIP_REASON_NONE) {</span>
<span class="nc" id="L317">            throw new NullPointerException();</span>
        }
<span class="fc" id="L319">    }</span>

    private void checkClosed() {
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (isClosed()) {</span>
<span class="fc" id="L323">            LOG.info().$(&quot;is closed&quot;).$();</span>
<span class="fc" id="L324">            throw PoolClosedException.INSTANCE;</span>
        }
<span class="fc" id="L326">    }</span>

    private TableWriter checkClosedAndGetWriter(TableToken tableToken, Entry e, String lockReason) {
<span class="fc" id="L329">        assertLockReasonIsNone(lockReason);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (isClosed()) {</span>
            // pool closed, but we somehow managed to lock writer
            // make sure that interceptor cleared to allow calling thread close writer normally
<span class="nc" id="L333">            LOG.info().$('\'').utf8(tableToken.getDirName()).$(&quot;' born free&quot;).$();</span>
<span class="nc" id="L334">            return e.goodbye();</span>
        }
<span class="fc" id="L336">        e.ownershipReason = lockReason;</span>
<span class="fc" id="L337">        e.writer.updateTableToken(tableToken);</span>
<span class="fc" id="L338">        return logAndReturn(e, PoolListener.EV_GET);</span>
    }

    private void closeWriter(long thread, Entry e, short ev, int reason) {
<span class="fc" id="L342">        TableWriter w = e.writer;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (w != null) {</span>
<span class="fc" id="L344">            TableToken name = e.writer.getTableToken();</span>
<span class="fc" id="L345">            w.setLifecycleManager(DefaultLifecycleManager.INSTANCE);</span>
<span class="fc" id="L346">            w.close();</span>
<span class="fc" id="L347">            e.writer = null;</span>
<span class="fc" id="L348">            e.ownershipReason = OWNERSHIP_REASON_RELEASED;</span>
<span class="fc" id="L349">            LOG.info().$(&quot;closed [table=`&quot;).utf8(name.getDirName()).$(&quot;`, reason=&quot;).$(PoolConstants.closeReasonText(reason)).$(&quot;, by=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L350">            notifyListener(thread, name, ev);</span>
        }
<span class="fc" id="L352">    }</span>

    private TableWriter createWriter(TableToken tableToken, Entry e, long thread, String lockReason) {
        try {
<span class="fc" id="L356">            checkClosed();</span>
<span class="fc" id="L357">            LOG.info().$(&quot;open [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L358">            e.writer = new TableWriter(configuration, tableToken, messageBus, null, true, e, root, metrics);</span>
<span class="fc" id="L359">            e.ownershipReason = lockReason;</span>
<span class="fc" id="L360">            return logAndReturn(e, PoolListener.EV_CREATE);</span>
<span class="fc" id="L361">        } catch (CairoException ex) {</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            LogRecord record = ex.isCritical() ? LOG.critical() : LOG.error();</span>
<span class="fc" id="L363">            record.$(&quot;could not open [table=`&quot;).utf8(tableToken.getTableName())</span>
<span class="fc" id="L364">                    .$(&quot;`, thread=&quot;).$(e.owner)</span>
<span class="fc" id="L365">                    .$(&quot;, ex=&quot;).utf8(ex.getFlyweightMessage())</span>
<span class="fc" id="L366">                    .$(&quot;, errno=&quot;).$(ex.getErrno())</span>
<span class="fc" id="L367">                    .$(']').$();</span>
<span class="fc" id="L368">            e.ex = ex;</span>
<span class="fc" id="L369">            e.ownershipReason = OWNERSHIP_REASON_WRITER_ERROR;</span>
<span class="fc" id="L370">            e.owner = UNALLOCATED;</span>
<span class="fc" id="L371">            notifyListener(e.owner, tableToken, PoolListener.EV_CREATE_EX);</span>
<span class="fc" id="L372">            throw ex;</span>
        }
    }

    private TableWriter getWriterEntry(
            TableToken tableToken,
            String lockReason,
            @Nullable AsyncWriterCommand asyncWriterCommand,
            boolean logBusy
    ) {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        assert null != lockReason;</span>
<span class="fc" id="L383">        checkClosed();</span>

<span class="fc" id="L385">        long thread = Thread.currentThread().getId();</span>

        while (true) {
<span class="fc" id="L388">            Entry e = entries.get(tableToken.getDirName());</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">            if (e == null) {</span>
                // We are racing to create new writer!
<span class="fc" id="L391">                e = new Entry(clock.getTicks());</span>
<span class="fc" id="L392">                Entry other = entries.putIfAbsent(tableToken.getDirName(), e);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                if (other == null) {</span>
                    // race won
<span class="fc" id="L395">                    return createWriter(tableToken, e, thread, lockReason);</span>
                } else {
<span class="fc" id="L397">                    e = other;</span>
                }
            }

<span class="fc" id="L401">            long owner = e.owner;</span>
            // try to change owner
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (Unsafe.cas(e, ENTRY_OWNER, UNALLOCATED, thread)) {</span>
                // in an extreme race condition it is possible that e.writer will be null
                // in this case behaviour should be identical to entry missing entirely
<span class="fc bfc" id="L406" title="All 2 branches covered.">                if (e.writer == null) {</span>
<span class="fc" id="L407">                    return createWriter(tableToken, e, thread, lockReason);</span>
                }
<span class="fc" id="L409">                return checkClosedAndGetWriter(tableToken, e, lockReason);</span>
            } else {
<span class="fc bfc" id="L411" title="All 2 branches covered.">                if (owner &lt; 0) {</span>
                    // writer is about to be released from the pool by release method.
                    // try again, it should become available soon.
<span class="fc" id="L414">                    Os.pause();</span>
<span class="fc" id="L415">                    continue;</span>
                }
<span class="fc bfc" id="L417" title="All 2 branches covered.">                if (owner == thread) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                    if (e.lockFd != -1L) {</span>
<span class="fc" id="L419">                        throw EntryLockedException.instance(reinterpretOwnershipReason(e.ownershipReason));</span>
                    }

<span class="pc bpc" id="L422" title="1 of 2 branches missed.">                    if (e.ex != null) {</span>
<span class="nc" id="L423">                        notifyListener(thread, tableToken, PoolListener.EV_EX_RESEND);</span>
                        // this writer failed to allocate by this very thread
                        // ensure consistent response
<span class="nc" id="L426">                        entries.remove(tableToken.getDirName());</span>
<span class="nc" id="L427">                        throw e.ex;</span>
                    }
                }
<span class="fc bfc" id="L430" title="All 2 branches covered.">                if (asyncWriterCommand != null) {</span>
<span class="fc" id="L431">                    addCommandToWriterQueue(e, asyncWriterCommand, thread);</span>
<span class="fc" id="L432">                    return null;</span>
                }

<span class="fc" id="L435">                String reason = reinterpretOwnershipReason(e.ownershipReason);</span>

<span class="fc bfc" id="L437" title="All 2 branches covered.">                if (logBusy) {</span>
<span class="fc" id="L438">                    LOG.info().$(&quot;busy [table=`&quot;).utf8(tableToken.getDirName())</span>
<span class="fc" id="L439">                            .$(&quot;`, owner=&quot;).$(owner)</span>
<span class="fc" id="L440">                            .$(&quot;, thread=&quot;).$(thread)</span>
<span class="fc" id="L441">                            .$(&quot;, reason=&quot;).$(reason)</span>
<span class="fc" id="L442">                            .I$();</span>
                }
<span class="fc" id="L444">                throw EntryUnavailableException.instance(reason);</span>
            }
        }
    }

    private boolean lockAndNotify(long thread, Entry e, TableToken tableToken, String lockReason) {
<span class="fc" id="L450">        assertLockReasonIsNone(lockReason);</span>
<span class="fc" id="L451">        Path path = Path.getThreadLocal(root).concat(tableToken.getDirName());</span>
<span class="fc" id="L452">        TableUtils.lockName(path);</span>
<span class="fc" id="L453">        e.lockFd = TableUtils.lock(ff, path);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (e.lockFd == -1) {</span>
<span class="fc" id="L455">            LOG.error().$(&quot;could not lock [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L456">            e.ownershipReason = OWNERSHIP_REASON_MISSING;</span>
<span class="fc" id="L457">            e.owner = UNALLOCATED;</span>
<span class="fc" id="L458">            return false;</span>
        }
<span class="fc" id="L460">        LOG.debug().$(&quot;locked [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, thread=&quot;).$(thread).$(']').$();</span>
<span class="fc" id="L461">        notifyListener(thread, tableToken, PoolListener.EV_LOCK_SUCCESS);</span>
<span class="fc" id="L462">        e.ownershipReason = lockReason;</span>
<span class="fc" id="L463">        return true;</span>
    }

    private TableWriter logAndReturn(Entry e, short event) {
<span class="fc" id="L467">        LOG.info().$(&quot;&gt;&gt; [table=`&quot;).utf8(e.writer.getTableToken().getDirName()).$(&quot;`, thread=&quot;).$(e.owner).$(']').$();</span>
<span class="fc" id="L468">        notifyListener(e.owner, e.writer.getTableToken(), event);</span>
<span class="fc" id="L469">        return e.writer;</span>
    }

    private String reinterpretOwnershipReason(String providedReason) {
        // we cannot always guarantee that ownership reason is set
        // allocating writer and setting &quot;reason&quot; are non-atomic
        // therefore we could be in a situation where we can be confident writer is locked
        // but reason has not yet caught up. In this case we do not really know the reason
        // but not to confuse the caller, we have to provide a non-null value
        //noinspection StringEquality
<span class="fc bfc" id="L479" title="All 2 branches covered.">        return providedReason == OWNERSHIP_REASON_NONE ? OWNERSHIP_REASON_UNKNOWN : providedReason;</span>
    }

    private boolean returnToPool(Entry e) {
<span class="fc" id="L483">        final long thread = Thread.currentThread().getId();</span>
<span class="fc" id="L484">        final TableToken tableToken = e.writer.getTableToken();</span>
        try {
<span class="fc" id="L486">            e.writer.rollback();</span>

<span class="fc bfc" id="L488" title="All 2 branches covered.">            if (e.owner != UNALLOCATED) {</span>
<span class="fc" id="L489">                e.owner = QUEUE_PROCESSING_OWNER;</span>
            }
            // We can apply structure changes with ALTER TABLE and do UPDATE(s) before the writer returned to the pool
<span class="fc" id="L492">            e.writer.tick(true);</span>
<span class="fc" id="L493">        } catch (Throwable ex) {</span>
            // We are here because of a systemic issues of some kind
            // one of the known issues is &quot;disk is full&quot; so we could not roll back properly.
            // In this case we just close TableWriter
<span class="fc" id="L497">            entries.remove(tableToken.getDirName());</span>
<span class="fc" id="L498">            closeWriter(thread, e, PoolListener.EV_LOCK_CLOSE, PoolConstants.CR_DISTRESSED);</span>
<span class="fc" id="L499">            return true;</span>
<span class="fc" id="L500">        }</span>

<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (e.owner != UNALLOCATED) {</span>
<span class="fc" id="L503">            LOG.info().$(&quot;&lt;&lt; [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`, thread=&quot;).$(thread).$(']').$();</span>

<span class="fc" id="L505">            e.ownershipReason = OWNERSHIP_REASON_NONE;</span>
<span class="fc" id="L506">            e.lastReleaseTime = configuration.getMicrosecondClock().getTicks();</span>
<span class="fc" id="L507">            Unsafe.getUnsafe().storeFence();</span>
<span class="fc" id="L508">            Unsafe.getUnsafe().putOrderedLong(e, ENTRY_OWNER, UNALLOCATED);</span>

<span class="fc bfc" id="L510" title="All 2 branches covered.">            if (isClosed()) {</span>
                // when pool is closed it could be busy releasing writer
                // to avoid race condition try to grab the writer before declaring it a
                // free agent
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                if (Unsafe.cas(e, ENTRY_OWNER, UNALLOCATED, thread)) {</span>
<span class="fc" id="L515">                    e.writer = null;</span>
<span class="fc" id="L516">                    notifyListener(thread, tableToken, PoolListener.EV_OUT_OF_POOL_CLOSE);</span>
<span class="fc" id="L517">                    return false;</span>
                }
            }

<span class="fc" id="L521">            notifyListener(thread, tableToken, PoolListener.EV_RETURN);</span>
        } else {
<span class="fc" id="L523">            LOG.critical().$(&quot;orphaned [table=`&quot;).utf8(tableToken.getDirName()).$(&quot;`]&quot;).$();</span>
<span class="fc" id="L524">            notifyListener(thread, tableToken, PoolListener.EV_UNEXPECTED_CLOSE);</span>
        }
<span class="fc" id="L526">        return true;</span>
    }

    /**
     * Closes writer pool. When pool is closed only writers that are in pool are proactively released. Writers that
     * are outside of pool will close when their close() method is invoked.
     * &lt;p&gt;
     * After pool is closed it will notify listener with #EV_POOL_CLOSED event.
     * &lt;/p&gt;
     */
    @Override
    protected void closePool() {
<span class="fc" id="L538">        super.closePool();</span>
<span class="fc" id="L539">        LOG.info().$(&quot;closed&quot;).$();</span>
<span class="fc" id="L540">    }</span>

    int countFreeWriters() {
<span class="fc" id="L543">        int count = 0;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">        for (Entry e : entries.values()) {</span>
<span class="fc" id="L545">            final long owner = e.owner;</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">            if (owner == UNALLOCATED) {</span>
<span class="fc" id="L547">                count++;</span>
            } else {
<span class="fc" id="L549">                LOG.info().$(&quot;'&quot;).utf8(e.writer.getTableToken().getDirName()).$(&quot;' is still busy [owner=&quot;).$(owner).$(']').$();</span>
            }
<span class="fc" id="L551">        }</span>
<span class="fc" id="L552">        return count;</span>
    }

    @Override
    protected boolean releaseAll(long deadline) {
<span class="fc" id="L557">        long thread = Thread.currentThread().getId();</span>
<span class="fc" id="L558">        boolean removed = false;</span>
        final int reason;

<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (deadline == Long.MAX_VALUE) {</span>
<span class="fc" id="L562">            reason = PoolConstants.CR_POOL_CLOSE;</span>
        } else {
<span class="fc" id="L564">            reason = PoolConstants.CR_IDLE;</span>
        }

<span class="fc" id="L567">        Iterator&lt;Entry&gt; iterator = entries.values().iterator();</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L569">            Entry e = iterator.next();</span>
            // lastReleaseTime is volatile, which makes
            // order of conditions important
<span class="fc bfc" id="L572" title="All 4 branches covered.">            if ((deadline &gt; e.lastReleaseTime &amp;&amp; e.owner == UNALLOCATED)) {</span>
                // looks like this writer is unallocated and can be released
                // Lock with negative 3-based owner thread id to indicate it's that next
                // allocating thread can wait until the entry is released.
                // Avoid negative thread id clashing with UNALLOCATED and QUEUE_PROCESSING values
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">                if (Unsafe.cas(e, ENTRY_OWNER, UNALLOCATED, -thread - 3)) {</span>
                    // lock successful
<span class="fc" id="L579">                    closeWriter(thread, e, PoolListener.EV_EXPIRE, reason);</span>
<span class="fc" id="L580">                    iterator.remove();</span>
<span class="fc" id="L581">                    removed = true;</span>
                }
<span class="pc bpc" id="L583" title="1 of 4 branches missed.">            } else if (e.lockFd != -1 &amp;&amp; deadline == Long.MAX_VALUE) {</span>
                // do not release locks unless pool is shutting down, which is
                // indicated via deadline to be Long.MAX_VALUE
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">                if (ff.close(e.lockFd)) {</span>
<span class="fc" id="L587">                    e.lockFd = -1;</span>
<span class="fc" id="L588">                    iterator.remove();</span>
<span class="fc" id="L589">                    removed = true;</span>
                }
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">            } else if (e.ex != null) {</span>
<span class="nc" id="L592">                LOG.info().$(&quot;purging entry for failed to allocate writer&quot;).$();</span>
<span class="nc" id="L593">                iterator.remove();</span>
<span class="nc" id="L594">                removed = true;</span>
            }
<span class="fc" id="L596">        }</span>
<span class="fc" id="L597">        return removed;</span>
    }

    private class Entry implements LifecycleManager {
<span class="fc" id="L601">        private CairoException ex = null;</span>
        // time writer was last released
        private volatile long lastReleaseTime;
<span class="fc" id="L604">        private volatile int lockFd = -1;</span>
        // owner thread id or -1 if writer is available for hire
<span class="fc" id="L606">        private volatile long owner = Thread.currentThread().getId();</span>
<span class="fc" id="L607">        private volatile String ownershipReason = OWNERSHIP_REASON_NONE;</span>
        private TableWriter writer;

<span class="fc" id="L610">        public Entry(long lastReleaseTime) {</span>
<span class="fc" id="L611">            this.lastReleaseTime = lastReleaseTime;</span>
<span class="fc" id="L612">        }</span>

        @Override
        public boolean close() {
<span class="fc bfc" id="L616" title="All 2 branches covered.">            return !WriterPool.this.returnToPool(this);</span>
        }

        public TableWriter goodbye() {
<span class="nc" id="L620">            TableWriter w = writer;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">            if (writer != null) {</span>
<span class="nc" id="L622">                writer.setLifecycleManager(DefaultLifecycleManager.INSTANCE);</span>
<span class="nc" id="L623">                writer = null;</span>
            }
<span class="nc" id="L625">            return w;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>