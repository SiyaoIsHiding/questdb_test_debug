<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WalPurgeJob.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.cairo.wal</a> &gt; <span class="el_source">WalPurgeJob.java</span></div><h1>WalPurgeJob.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.cairo.wal;

import io.questdb.cairo.*;
import io.questdb.cairo.wal.seq.TableSequencerAPI;
import io.questdb.cairo.wal.seq.TransactionLogCursor;
import io.questdb.log.Log;
import io.questdb.log.LogFactory;
import io.questdb.mp.SimpleWaitingLock;
import io.questdb.mp.SynchronizedJob;
import io.questdb.std.*;
import io.questdb.std.datetime.microtime.MicrosecondClock;
import io.questdb.std.datetime.millitime.MillisecondClock;
import io.questdb.std.str.NativeLPSZ;
import io.questdb.std.str.Path;
import io.questdb.std.str.StringSink;

import java.io.Closeable;

public class WalPurgeJob extends SynchronizedJob implements Closeable {
<span class="fc" id="L44">    private static final Log LOG = LogFactory.getLog(WalPurgeJob.class);</span>
    private final TableSequencerAPI.RegisteredTable broadSweepIter;
    private final long checkInterval;
    private final MicrosecondClock clock;
    private final CairoConfiguration configuration;
<span class="fc" id="L49">    private final StringSink debugBuffer = new StringSink();</span>
<span class="fc" id="L50">    private final IntHashSet discoveredWalIds = new IntHashSet();</span>
<span class="fc" id="L51">    private final LongList discoveredWalSegments = new LongList();</span>
    private final CairoEngine engine;
    private final FilesFacade ff;
<span class="fc" id="L54">    private final IntHashSet lockedWalIds = new IntHashSet();</span>
    private final MillisecondClock millisecondClock;
<span class="fc" id="L56">    private final LongList nextToApplyWalSegments = new LongList();</span>
<span class="fc" id="L57">    private final Path path = new Path();</span>
<span class="fc" id="L58">    private final SimpleWaitingLock runLock = new SimpleWaitingLock();</span>
    private final long spinLockTimeout;
<span class="fc" id="L60">    private final ObjList&lt;TableToken&gt; tableTokenBucket = new ObjList&lt;&gt;();</span>
    private final TxReader txReader;
<span class="fc" id="L62">    private final NativeLPSZ walName = new NativeLPSZ();</span>
<span class="fc" id="L63">    private long last = 0;</span>
    private TableToken tableToken;

<span class="fc" id="L66">    public WalPurgeJob(CairoEngine engine, FilesFacade ff, MicrosecondClock clock) {</span>
<span class="fc" id="L67">        this.engine = engine;</span>
<span class="fc" id="L68">        this.ff = ff;</span>
<span class="fc" id="L69">        this.clock = clock;</span>
<span class="fc" id="L70">        this.checkInterval = engine.getConfiguration().getWalPurgeInterval() * 1000;</span>
<span class="fc" id="L71">        this.millisecondClock = engine.getConfiguration().getMillisecondClock();</span>
<span class="fc" id="L72">        this.spinLockTimeout = engine.getConfiguration().getSpinLockTimeout();</span>
<span class="fc" id="L73">        this.txReader = new TxReader(ff);</span>
<span class="fc" id="L74">        this.broadSweepIter = this::broadSweep;</span>

        // some code here assumes that WAL_NAME_BASE is &quot;wal&quot;, this is to fail the tests if it is not
        //noinspection ConstantConditions
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        assert WalUtils.WAL_NAME_BASE.equals(&quot;wal&quot;);</span>
<span class="fc" id="L79">        configuration = engine.getConfiguration();</span>
<span class="fc" id="L80">    }</span>

    public WalPurgeJob(CairoEngine engine) {
<span class="fc" id="L83">        this(engine, engine.getConfiguration().getFilesFacade(), engine.getConfiguration().getMicrosecondClock());</span>
<span class="fc" id="L84">    }</span>

    @Override
    public void close() {
<span class="fc" id="L88">        this.txReader.close();</span>
<span class="fc" id="L89">        path.close();</span>
<span class="fc" id="L90">    }</span>

    /**
     * Delay the first run of this job by half a configured interval to
     * spread its work more evenly across other timer-based jobs with
     * similar cadences.
     */
    public void delayByHalfInterval() {
<span class="fc" id="L98">        this.last = clock.getTicks() - (checkInterval / 2);</span>
<span class="fc" id="L99">    }</span>

    public SimpleWaitingLock getRunLock() {
<span class="fc" id="L102">        return runLock;</span>
    }

    /**
     * Validate equivalent of &quot;^\d+$&quot; regex.
     */
    private static boolean matchesSegmentName(CharSequence name) {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        for (int i = 0, n = name.length(); i &lt; n; i++) {</span>
<span class="fc" id="L110">            char c = name.charAt(i);</span>
<span class="fc bfc" id="L111" title="All 4 branches covered.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="fc" id="L112">                return false;</span>
            }
        }
<span class="fc" id="L115">        return true;</span>
    }

    /**
     * Validate equivalent of &quot;^wal\d+$&quot; regex.
     */
    private static boolean matchesWalNamePattern(CharSequence name) {
<span class="fc" id="L122">        final int len = name.length();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (len &lt; (WalUtils.WAL_NAME_BASE.length() + 1)) {</span>
<span class="fc" id="L124">            return false;</span>
        }

<span class="pc bpc" id="L127" title="2 of 6 branches missed.">        if (name.charAt(0) != 'w' || name.charAt(1) != 'a' || name.charAt(2) != 'l') {</span>
<span class="fc" id="L128">            return false;  // Not a &quot;wal&quot; prefix.</span>
        }

<span class="fc bfc" id="L131" title="All 2 branches covered.">        for (int i = 3; i &lt; len; ++i) {</span>
<span class="fc" id="L132">            final char c = name.charAt(i);</span>
<span class="pc bpc" id="L133" title="1 of 4 branches missed.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="fc" id="L134">                return false;  // Not a number.</span>
            }
        }

<span class="fc" id="L138">        return true;</span>
    }

    private void accumDebugState() {
<span class="fc" id="L142">        debugBuffer.clear();</span>
<span class="fc" id="L143">        debugBuffer.put(&quot;table=&quot;).put(tableToken.getDirName())</span>
<span class="fc" id="L144">                .put(&quot;, discovered=[&quot;);</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">        for (int i = 0, n = discoveredWalSegments.size(); i &lt; n; i++) {</span>
<span class="fc" id="L147">            long walSegment = discoveredWalSegments.getQuick(i);</span>
<span class="fc" id="L148">            int segmentId = Numbers.decodeLowInt(walSegment);</span>
<span class="fc" id="L149">            int walId = Numbers.decodeHighInt(walSegment);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (segmentId &lt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L151">                debugBuffer.put('(').put(walId).put(',').put(segmentId &gt;&gt; 1);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">                if ((segmentId &amp; 1) == 1) {</span>
<span class="fc" id="L153">                    debugBuffer.put(&quot;:locked&quot;);</span>
                }
<span class="fc" id="L155">                debugBuffer.put(')');</span>
            } else {
<span class="fc" id="L157">                debugBuffer.put(&quot;(wal&quot;).put(walId);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                if (lockedWalIds.contains(walId)) {</span>
<span class="fc" id="L159">                    debugBuffer.put(&quot;:locked&quot;);</span>
                }
<span class="fc" id="L161">                debugBuffer.put(')');</span>
            }

<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (i &lt; n - 1) {</span>
<span class="fc" id="L165">                debugBuffer.put(',');</span>
            }
        }

<span class="fc" id="L169">        debugBuffer.put(&quot;], nextToApply=[&quot;);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for (int i = 0, n = nextToApplyWalSegments.size(); i &lt; n; i++) {</span>
<span class="fc" id="L171">            long walSegment = nextToApplyWalSegments.getQuick(i);</span>
<span class="fc" id="L172">            int segmentId = Numbers.decodeLowInt(walSegment) &gt;&gt; 1;</span>
<span class="fc" id="L173">            int walId = Numbers.decodeHighInt(walSegment);</span>

<span class="fc" id="L175">            debugBuffer.put('(').put(walId).put(',').put(segmentId).put(')');</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            if (i &lt; n - 1) {</span>
<span class="fc" id="L177">                debugBuffer.put(',');</span>
            }
        }
<span class="fc" id="L180">        debugBuffer.put(']');</span>
<span class="fc" id="L181">    }</span>

    /**
     * Perform a broad sweep that searches for all tables that have closed
     * WAL segments across the database and deletes any which are no longer needed.
     */
    private void broadSweep() {
<span class="fc" id="L188">        engine.getTableSequencerAPI().forAllWalTables(tableTokenBucket, true, broadSweepIter);</span>
<span class="fc" id="L189">    }</span>

    private void broadSweep(int tableId, final TableToken tableToken, long lastTxn) {
        try {
<span class="fc" id="L193">            this.tableToken = tableToken;</span>
<span class="fc" id="L194">            discoveredWalSegments.clear();</span>
<span class="fc" id="L195">            lockedWalIds.clear();</span>
<span class="fc" id="L196">            discoveredWalIds.clear();</span>
<span class="fc" id="L197">            nextToApplyWalSegments.clear();</span>

<span class="fc" id="L199">            discoverWalSegments();</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (discoveredWalSegments.size() != 0) {</span>

<span class="fc" id="L202">                populateNextToApplyWalSegments();</span>
<span class="fc" id="L203">                accumDebugState();</span>

                // Any of the calls above may leave outstanding `discoveredWalIds` that are still on the filesystem
                // and don't have any active segments. Any unlocked walNNN directories may be deleted if they don't have
                // pending segments that are yet to be applied to the table.
                // Note that this also handles cases where a wal directory was created shortly before a crash and thus
                // never recorded and tracked by the sequencer for that table.
<span class="fc" id="L210">                deleteOutstandingWalDirectories();</span>
            }

<span class="pc bpc" id="L213" title="1 of 4 branches missed.">            if (lastTxn &lt; 0 &amp;&amp; engine.isTableDropped(tableToken)) {</span>
                // Delete sequencer files
<span class="fc" id="L215">                deleteTableSequencerFiles(tableToken);</span>

<span class="fc" id="L217">                if (</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">                        TableUtils.exists(</span>
                                ff,
<span class="fc" id="L220">                                Path.getThreadLocal(&quot;&quot;),</span>
<span class="fc" id="L221">                                configuration.getRoot(),</span>
<span class="fc" id="L222">                                tableToken.getDirName()</span>
                        ) != TableUtils.TABLE_EXISTS
                ) {
                    // Fully deregister the table
<span class="fc" id="L226">                    LOG.info().$(&quot;table is fully dropped [tableDir=&quot;).$(tableToken.getDirName()).I$();</span>
<span class="fc" id="L227">                    ff.rmdir(Path.getThreadLocal(configuration.getRoot()).concat(tableToken).slash$());</span>
<span class="fc" id="L228">                    engine.removeTableToken(tableToken);</span>
                } else {
<span class="nc" id="L230">                    LOG.info().$(&quot;table is not fully dropped, pinging WAL Apply job to delete table files [tableDir=&quot;).$(tableToken.getDirName()).I$();</span>
                    // Ping ApplyWal2TableJob to clean up the table files
<span class="nc" id="L232">                    engine.notifyWalTxnRepublisher();</span>
                }
            }
<span class="nc" id="L235">        } catch (CairoException ce) {</span>
<span class="nc" id="L236">            LOG.error().$(&quot;broad sweep failed [table=&quot;).$(tableToken)</span>
<span class="nc" id="L237">                    .$(&quot;, msg=&quot;).$((Throwable) ce)</span>
<span class="nc" id="L238">                    .$(&quot;, errno=&quot;).$(ff.errno()).$(']').$();</span>
<span class="fc" id="L239">        }</span>
<span class="fc" id="L240">    }</span>

    private boolean deleteFile(Path path) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (!ff.remove(path)) {</span>
<span class="fc" id="L244">            final int errno = ff.errno();</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            if (errno != 2) {</span>
<span class="fc" id="L246">                LOG.error().$(&quot;Could not delete file [path=&quot;).$(path)</span>
<span class="fc" id="L247">                        .$(&quot;, errno=&quot;).$(errno).$(']').$();</span>
<span class="fc" id="L248">                return false;</span>
            }
        }
<span class="fc" id="L251">        return true;</span>
    }

    private void deleteOutstandingWalDirectories() {
        // Merge join discoveredWalSegments and nextToApplyWalSegments
        // Both are sorted by WalId and then SegmentId
        // Delete those segments which are lower than first committed segment
        // Keep locked segments and all segments higher than first locked segment
<span class="fc" id="L259">        int committedWalSegmentIndex = -1;</span>
<span class="fc" id="L260">        int committedWalSegmentId = -1;</span>
<span class="fc" id="L261">        int committedWalId = -1;</span>
<span class="fc" id="L262">        int committedSegmentSize = nextToApplyWalSegments.size();</span>

<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (int i = 0, n = discoveredWalSegments.size(); i &lt; n; i++) {</span>
<span class="fc" id="L265">            long walSegment = discoveredWalSegments.get(i);</span>
<span class="fc" id="L266">            int walId = Numbers.decodeHighInt(walSegment);</span>
<span class="fc" id="L267">            int segmentIdLocked = Numbers.decodeLowInt(walSegment);</span>
<span class="fc" id="L268">            int segmentId = segmentIdLocked &gt;&gt; 1;</span>
<span class="fc bfc" id="L269" title="All 4 branches covered.">            boolean segmentIdIsLocked = segmentIdLocked != Integer.MAX_VALUE &amp;&amp; (segmentIdLocked &amp; 1) == 1;</span>

            // If the current segment is locked, scroll to next wall id.
<span class="fc bfc" id="L272" title="All 2 branches covered.">            int searchWalId = segmentIdIsLocked ? walId + 1 : walId;</span>
<span class="fc bfc" id="L273" title="All 4 branches covered.">            while (committedWalId &lt; searchWalId &amp;&amp; ++committedWalSegmentIndex &lt; committedSegmentSize) {</span>
<span class="fc" id="L274">                long committedWalSegment = nextToApplyWalSegments.get(committedWalSegmentIndex);</span>
<span class="fc" id="L275">                committedWalId = Numbers.decodeHighInt(committedWalSegment);</span>
<span class="fc" id="L276">                committedWalSegmentId = Numbers.decodeLowInt(committedWalSegment) &gt;&gt; 1;</span>
<span class="fc" id="L277">            }</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">            if (walId == committedWalId) {</span>
                // WAL is in use, there are committed transactions in Sequencer
<span class="fc bfc" id="L281" title="All 2 branches covered.">                if (committedWalSegmentId &gt; segmentId) {</span>
                    // Segment already applied.
<span class="fc" id="L283">                    deleteSegmentDirectory(tableToken, walId, segmentId);</span>
                }
<span class="fc bfc" id="L285" title="All 2 branches covered.">            } else if (!segmentIdIsLocked) {</span>
                // Nothing in Sequencer for this WAL and no locked segment means WAL can be deleted if it was not locked.
<span class="fc bfc" id="L287" title="All 2 branches covered.">                if (!lockedWalIds.contains(walId)) {</span>
<span class="fc" id="L288">                    deleteWalDirectory(walId);</span>
                } else {
                    // WAL is locked but the segment in it is not in outstanding commits, delete it.
                    // Segment with ID of Integer.MAX_VALUE is the WAL directory itself, only delete it if it's unlocked.
<span class="fc bfc" id="L292" title="All 2 branches covered.">                    if (segmentId != (Integer.MAX_VALUE &gt;&gt; 1)) {</span>
<span class="fc" id="L293">                        deleteSegmentDirectory(tableToken, walId, segmentId);</span>
                    }
                }
            }
        }
<span class="fc" id="L298">    }</span>

    private void deleteSegmentDirectory(TableToken tableName, int walId, int segmentId) {
<span class="fc" id="L301">        mayLogDebugInfo();</span>
<span class="fc" id="L302">        LOG.info().$(&quot;deleting WAL segment directory [table=&quot;).utf8(tableName.getDirName())</span>
<span class="fc" id="L303">                .$(&quot;, walId=&quot;).$(walId)</span>
<span class="fc" id="L304">                .$(&quot;, segmentId=&quot;).$(segmentId).$(']').$();</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (deleteFile(setSegmentLockPath(tableName, walId, segmentId))) {</span>
<span class="fc" id="L306">            recursiveDelete(setSegmentPath(tableName, walId, segmentId));</span>
        }
<span class="fc" id="L308">    }</span>

    private void deleteTableSequencerFiles(TableToken tableToken) {
<span class="fc" id="L311">        setTableSequencerPath(tableToken);</span>
<span class="fc" id="L312">        LOG.info().$(&quot;table is dropped, deleting sequencer files [table=&quot;).utf8(tableToken.getDirName()).$(']').$();</span>
<span class="fc" id="L313">        recursiveDelete(path);</span>
<span class="fc" id="L314">    }</span>

    private void deleteWalDirectory(int walId) {
<span class="fc" id="L317">        mayLogDebugInfo();</span>
<span class="fc" id="L318">        LOG.info().$(&quot;deleting WAL directory [table=&quot;).utf8(tableToken.getDirName())</span>
<span class="fc" id="L319">                .$(&quot;, walId=&quot;).$(walId).$(']').$();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (deleteFile(setWalLockPath(tableToken, walId))) {</span>
<span class="fc" id="L321">            recursiveDelete(setWalPath(tableToken, walId));</span>
        }
<span class="fc" id="L323">    }</span>

    private void discoverWalSegments() {
<span class="fc" id="L326">        Path path = setTablePath(tableToken);</span>
<span class="fc" id="L327">        long p = ff.findFirst(path);</span>
<span class="fc" id="L328">        int rootPathLen = path.length();</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (p &gt; 0) {</span>
            try {
                do {
<span class="fc" id="L332">                    int type = ff.findType(p);</span>
<span class="fc" id="L333">                    long pUtf8NameZ = ff.findName(p);</span>

<span class="fc bfc" id="L335" title="All 4 branches covered.">                    if (type == Files.DT_DIR &amp;&amp; matchesWalNamePattern(walName.of(pUtf8NameZ))) {</span>
                        // We just record the name for now in a set which we'll remove items to know when we're done.
                        try {
<span class="fc" id="L338">                            int walId = Numbers.parseInt(walName, 3, walName.length());</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                            if (walIsInUse(tableToken, walId)) {</span>
<span class="fc" id="L340">                                lockedWalIds.add(walId);</span>
                            }
<span class="fc" id="L342">                            discoveredWalIds.add(walId);</span>
                            // SegmentId of Integer.MAX_VALUE is to track WAL directory itself.
<span class="fc" id="L344">                            discoveredWalSegments.add(Numbers.encodeLowHighInts(Integer.MAX_VALUE, walId));</span>

                            // Search for segments.
<span class="fc" id="L347">                            path.trimTo(rootPathLen).concat(pUtf8NameZ);</span>
<span class="fc" id="L348">                            int walPathLen = path.length();</span>
<span class="fc" id="L349">                            long sp = ff.findFirst(path.$());</span>

                            try {
                                do {
<span class="fc" id="L353">                                    type = ff.findType(sp);</span>
<span class="fc" id="L354">                                    pUtf8NameZ = ff.findName(sp);</span>

<span class="fc bfc" id="L356" title="All 4 branches covered.">                                    if (type == Files.DT_DIR &amp;&amp; matchesSegmentName(walName.of(pUtf8NameZ))) {</span>
                                        try {
<span class="fc" id="L358">                                            int segmentId = Numbers.parseInt(walName);</span>
<span class="fc" id="L359">                                            Path segmentPath = path.trimTo(walPathLen).slash().put(segmentId);</span>
<span class="fc" id="L360">                                            TableUtils.lockName(segmentPath);</span>
<span class="fc" id="L361">                                            boolean unlocked = unlocked(segmentPath.$());</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">                                            discoveredWalSegments.add(Numbers.encodeLowHighInts((segmentId &lt;&lt; 1) + (unlocked ? 0 : 1), walId));</span>
<span class="nc" id="L363">                                        } catch (NumericException ne) {</span>
                                            // Non-Segment directory, ignore.
<span class="fc" id="L365">                                        }</span>
                                    }
<span class="fc bfc" id="L367" title="All 2 branches covered.">                                } while (ff.findNext(sp) &gt; 0);</span>
                            } finally {
<span class="fc" id="L369">                                ff.findClose(sp);</span>
                            }
<span class="nc" id="L371">                        } catch (NumericException ne) {</span>
                            // Non-WAL directory, ignore.
<span class="fc" id="L373">                        }</span>
                    }
<span class="fc bfc" id="L375" title="All 2 branches covered.">                } while (ff.findNext(p) &gt; 0);</span>
<span class="fc" id="L376">                discoveredWalSegments.sort();</span>
            } finally {
<span class="fc" id="L378">                ff.findClose(p);</span>
            }
        }
<span class="fc" id="L381">    }</span>

    private void mayLogDebugInfo() {
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (debugBuffer.length() &gt; 0) {</span>
<span class="fc" id="L385">            LOG.info().utf8(debugBuffer).$();</span>
<span class="fc" id="L386">            debugBuffer.clear();</span>
        }
<span class="fc" id="L388">    }</span>

    private void populateNextToApplyWalSegments() {
<span class="fc" id="L391">        setTxnPath(tableToken);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (!engine.isTableDropped(tableToken)) {</span>
            try {
<span class="fc" id="L394">                txReader.ofRO(path, PartitionBy.NONE);</span>
<span class="fc" id="L395">                TableUtils.safeReadTxn(txReader, millisecondClock, spinLockTimeout);</span>
<span class="fc" id="L396">                final long lastAppliedTxn = txReader.getSeqTxn();</span>

<span class="fc" id="L398">                TableSequencerAPI tableSequencerAPI = engine.getTableSequencerAPI();</span>
<span class="fc" id="L399">                try (TransactionLogCursor transactionLogCursor = tableSequencerAPI.getCursor(tableToken, lastAppliedTxn)) {</span>
<span class="fc bfc" id="L400" title="All 4 branches covered.">                    while (discoveredWalIds.size() &gt; 0 &amp;&amp; transactionLogCursor.hasNext()) {</span>
<span class="fc" id="L401">                        int walId = transactionLogCursor.getWalId();</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">                        if (discoveredWalIds.contains(walId)) {</span>
<span class="fc" id="L403">                            int segmentId = transactionLogCursor.getSegmentId();</span>
<span class="fc" id="L404">                            nextToApplyWalSegments.add(Numbers.encodeLowHighInts(segmentId &lt;&lt; 1, walId));</span>
<span class="fc" id="L405">                            discoveredWalIds.remove(walId);</span>
                        }
<span class="fc" id="L407">                    }</span>
<span class="fc" id="L408">                    nextToApplyWalSegments.sort();</span>
                }
            } finally {
<span class="fc" id="L411">                txReader.close();</span>
            }
        }
        // If table is dropped, all wals can be deleted.
        // No need to do anything, all discovered segments / wals will be deleted
<span class="fc" id="L416">    }</span>

    private void recursiveDelete(Path path) {
<span class="fc" id="L419">        final int errno = ff.rmdir(path);</span>
<span class="pc bpc" id="L420" title="1 of 4 branches missed.">        if (errno &gt; 0 &amp;&amp; !CairoException.errnoRemovePathDoesNotExist(errno)) {</span>
<span class="fc" id="L421">            LOG.error().$(&quot;could not delete directory [path=&quot;).utf8(path)</span>
<span class="fc" id="L422">                    .$(&quot;, errno=&quot;).$(errno).$(']').$();</span>
        }
<span class="fc" id="L424">    }</span>

    private Path setSegmentLockPath(TableToken tableName, int walId, int segmentId) {
<span class="fc" id="L427">        path.of(configuration.getRoot())</span>
<span class="fc" id="L428">                .concat(tableName).concat(WalUtils.WAL_NAME_BASE).put(walId).slash().put(segmentId);</span>
<span class="fc" id="L429">        TableUtils.lockName(path);</span>
<span class="fc" id="L430">        return path;</span>
    }

    private Path setSegmentPath(TableToken tableName, int walId, int segmentId) {
<span class="fc" id="L434">        return path.of(configuration.getRoot())</span>
<span class="fc" id="L435">                .concat(tableName).concat(WalUtils.WAL_NAME_BASE).put(walId).slash().put(segmentId).$();</span>
    }

    private Path setTablePath(TableToken tableName) {
<span class="fc" id="L439">        return path.of(configuration.getRoot())</span>
<span class="fc" id="L440">                .concat(tableName).$();</span>
    }

    private void setTableSequencerPath(TableToken tableName) {
<span class="fc" id="L444">        path.of(configuration.getRoot())</span>
<span class="fc" id="L445">                .concat(tableName).concat(WalUtils.SEQ_DIR).$();</span>
<span class="fc" id="L446">    }</span>

    private void setTxnPath(TableToken tableName) {
<span class="fc" id="L449">        path.of(configuration.getRoot())</span>
<span class="fc" id="L450">                .concat(tableName)</span>
<span class="fc" id="L451">                .concat(TableUtils.TXN_FILE_NAME).$();</span>
<span class="fc" id="L452">    }</span>

    private Path setWalLockPath(TableToken tableName, int walId) {
<span class="fc" id="L455">        path.of(configuration.getRoot())</span>
<span class="fc" id="L456">                .concat(tableName).concat(WalUtils.WAL_NAME_BASE).put(walId);</span>
<span class="fc" id="L457">        TableUtils.lockName(path);</span>
<span class="fc" id="L458">        return path;</span>
    }

    private Path setWalPath(TableToken tableName, int walId) {
<span class="fc" id="L462">        return path.of(configuration.getRoot())</span>
<span class="fc" id="L463">                .concat(tableName).concat(WalUtils.WAL_NAME_BASE).put(walId).$();</span>
    }

    private boolean unlocked(Path path) {
<span class="fc" id="L467">        final int lockFd = TableUtils.lock(ff, path, false);</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (lockFd != -1) {</span>
<span class="fc" id="L469">            ff.close(lockFd);</span>
<span class="fc" id="L470">            return true; // Could lock/unlock.</span>
        }
<span class="fc" id="L472">        return false; // Could not obtain lock.</span>
    }

    private boolean walIsInUse(TableToken tableName, int walId) {
<span class="fc bfc" id="L476" title="All 2 branches covered.">        return !unlocked(setWalLockPath(tableName, walId));</span>
    }

    @Override
    protected boolean runSerially() {
<span class="fc" id="L481">        final long t = clock.getTicks();</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        if (last + checkInterval &lt; t) {</span>
<span class="fc" id="L483">            last = t;</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">            if (runLock.tryLock()) {</span>
                try {
<span class="fc" id="L486">                    broadSweep();</span>
                } finally {
<span class="fc" id="L488">                    runLock.unlock();</span>
<span class="fc" id="L489">                }</span>
            } else {
<span class="fc" id="L491">                LOG.info().$(&quot;skipping, locked out&quot;).$();</span>
            }
        }
<span class="fc" id="L494">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>