<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LimitedSizeSortedLightRecordCursorFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.engine.orderby</a> &gt; <span class="el_source">LimitedSizeSortedLightRecordCursorFactory.java</span></div><h1>LimitedSizeSortedLightRecordCursorFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.engine.orderby;

import io.questdb.cairo.AbstractRecordCursorFactory;
import io.questdb.cairo.CairoConfiguration;
import io.questdb.cairo.ListColumnFilter;
import io.questdb.cairo.sql.*;
import io.questdb.griffin.PlanSink;
import io.questdb.griffin.SqlException;
import io.questdb.griffin.SqlExecutionContext;
import io.questdb.griffin.engine.RecordComparator;
import io.questdb.std.Misc;
import org.jetbrains.annotations.Nullable;

/**
 * Same as SortedLightRecordCursorFactory but using LimitedSizeLongTreeChain instead.
 */
public class LimitedSizeSortedLightRecordCursorFactory extends AbstractRecordCursorFactory {

    private final RecordCursorFactory base;
    private final RecordComparator comparator;
    private final CairoConfiguration configuration;
    private final Function hiFunction;
    private final Function loFunction;
    private final ListColumnFilter sortColumnFilter;
    // initialization delayed to getCursor() because lo/hi need to be evaluated
    private DelegatingRecordCursor cursor; // LimitedSizeSortedLightRecordCursor or SortedLightRecordCursor

    public LimitedSizeSortedLightRecordCursorFactory(
            CairoConfiguration configuration,
            RecordMetadata metadata,
            RecordCursorFactory base,
            RecordComparator comparator,
            Function loFunc,
            @Nullable Function hiFunc,
            ListColumnFilter sortColumnFilter
    ) {
<span class="fc" id="L61">        super(metadata);</span>
<span class="fc" id="L62">        this.base = base;</span>
<span class="fc" id="L63">        this.loFunction = loFunc;</span>
<span class="fc" id="L64">        this.hiFunction = hiFunc;</span>
<span class="fc" id="L65">        this.configuration = configuration;</span>
<span class="fc" id="L66">        this.comparator = comparator;</span>
<span class="fc" id="L67">        this.sortColumnFilter = sortColumnFilter;</span>
<span class="fc" id="L68">    }</span>

    @Override
    public RecordCursorFactory getBaseFactory() {
<span class="fc" id="L72">        return base;</span>
    }

    @Override
    public RecordCursor getCursor(SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L77">        boolean preTouchEnabled = executionContext.isColumnPreTouchEnabled();</span>
        // Forcefully disable column pre-touch for LIMIT K,N queries for all downstream
        // async filtered factories to avoid redundant disk reads.
<span class="pc bpc" id="L80" title="1 of 4 branches missed.">        executionContext.setColumnPreTouchEnabled(preTouchEnabled &amp;&amp; hiFunction == null);</span>
<span class="fc" id="L81">        RecordCursor baseCursor = null;</span>
        try {
<span class="fc" id="L83">            baseCursor = base.getCursor(executionContext);</span>
<span class="fc" id="L84">            initialize(executionContext, baseCursor);</span>
<span class="fc" id="L85">            cursor.of(baseCursor, executionContext);</span>
<span class="fc" id="L86">            return cursor;</span>
<span class="nc" id="L87">        } catch (Throwable ex) {</span>
<span class="nc" id="L88">            Misc.free(baseCursor);</span>
<span class="nc" id="L89">            Misc.free(cursor);</span>
<span class="nc" id="L90">            throw ex;</span>
        } finally {
<span class="fc" id="L92">            executionContext.setColumnPreTouchEnabled(preTouchEnabled);</span>
        }
    }

    @Override
    public boolean implementsLimit() {
<span class="fc" id="L98">        return true;</span>
    }

    /*
     * 1. &quot;limit L&quot; means we only need to keep :
     * L &gt;=0 - first L records
     * L &lt; 0 - last L records
     * 2. &quot;limit L, H&quot; means we need to keep :
     * L &lt; 0          - last  L records (but skip last H records, if H &gt;=0 then don't skip anything)
     * L &gt;= 0, H &gt;= 0 - first H records (but skip first L later, if H &lt;= L then return empty set)
     * L &gt;= 0, H &lt; 0  - we can't optimize this case (because it spans from record L-th from the beginning up to
     * H-th from the end, and we don't) and need to revert to default behavior - produce the whole set and skip.
     * &lt;p&gt;
     * Similar to LimitRecordCursorFactory.LimitRecordCursor, but doesn't check the underlying count.
     */
    public void initializeLimitedSizeCursor(SqlExecutionContext executionContext, RecordCursor base) throws SqlException {
<span class="fc" id="L114">        loFunction.init(base, executionContext);</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (hiFunction != null) {</span>
<span class="fc" id="L116">            hiFunction.init(base, executionContext);</span>
        }

<span class="fc" id="L119">        long skipFirst = 0, skipLast = 0, limit;</span>
<span class="fc" id="L120">        boolean isFirstN = false;</span>

<span class="fc" id="L122">        long lo = loFunction.getLong(null);</span>
<span class="fc bfc" id="L123" title="All 4 branches covered.">        if (lo &lt; 0 &amp;&amp; hiFunction == null) {</span>
            // last N rows
            // lo is negative, -5 for example
            // if we have 12 records we need to skip 12-5 = 7
            // if we have 4 records = return all of them
            // set limit to return remaining rows
<span class="fc" id="L129">            limit = -lo;</span>
<span class="fc bfc" id="L130" title="All 4 branches covered.">        } else if (lo &gt; -1 &amp;&amp; hiFunction == null) {</span>
            // first N rows
<span class="fc" id="L132">            isFirstN = true;</span>
<span class="fc" id="L133">            limit = lo;</span>
        } else {
            // at this stage we also have 'hi'
<span class="fc" id="L136">            long hi = hiFunction.getLong(null);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (lo &lt; 0) {</span>
                // right, here we are looking for something like -10,-5 five rows away from tail
<span class="fc bfc" id="L139" title="All 2 branches covered.">                if (lo &lt; hi) {</span>
<span class="fc" id="L140">                    limit = -lo;</span>
<span class="fc" id="L141">                    skipLast = Math.max(-hi, 0);</span>
                    //}
                } else {
                    // this is invalid bottom range, for example -3, -10
<span class="fc" id="L145">                    limit = 0;//produce empty result</span>
                }
            } else { //lo &gt;= 0
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">                if (hi &lt; 0) {</span>
                    //if lo&gt;=0 but hi&lt;0 then we fall back to standard algorithm because we can't estimate result size
                    // (it's from lo up to end-hi so probably whole result anyway )
<span class="nc" id="L151">                    limit = -1;</span>
<span class="nc" id="L152">                    skipFirst = lo;</span>
<span class="nc" id="L153">                    skipLast = -hi;</span>
                } else { //both lo and hi are positive
<span class="fc bfc" id="L155" title="All 2 branches covered.">                    if (hi &lt;= lo) {</span>
<span class="fc" id="L156">                        limit = 0;//produce empty result</span>
                    } else {
<span class="fc" id="L158">                        isFirstN = true;</span>
<span class="fc" id="L159">                        limit = hi;</span>
                        //but we've to skip to lo
<span class="fc" id="L161">                        skipFirst = lo;</span>
                    }
                }
            }
        }

<span class="fc" id="L167">        LimitedSizeLongTreeChain chain = new LimitedSizeLongTreeChain(</span>
<span class="fc" id="L168">                configuration.getSqlSortKeyPageSize(),</span>
<span class="fc" id="L169">                configuration.getSqlSortKeyMaxPages(),</span>
<span class="fc" id="L170">                configuration.getSqlSortLightValuePageSize(),</span>
<span class="fc" id="L171">                configuration.getSqlSortLightValueMaxPages(),</span>
                isFirstN,
                limit
        );

<span class="fc" id="L176">        this.cursor = new LimitedSizeSortedLightRecordCursor(chain, comparator, limit, skipFirst, skipLast);</span>
<span class="fc" id="L177">    }</span>

    @Override
    public boolean recordCursorSupportsRandomAccess() {
<span class="fc" id="L181">        return true;</span>
    }

    @Override
    public void toPlan(PlanSink sink) {
<span class="fc" id="L186">        sink.type(&quot;Sort light&quot;);</span>
<span class="fc" id="L187">        sink.meta(&quot;lo&quot;).val(loFunction);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (hiFunction != null) {</span>
<span class="fc" id="L189">            sink.meta(&quot;hi&quot;).val(hiFunction);</span>
        }
<span class="fc" id="L191">        SortedLightRecordCursorFactory.addSortKeys(sink, sortColumnFilter);</span>
<span class="fc" id="L192">        sink.child(base);</span>
<span class="fc" id="L193">    }</span>

    // Check if lo, hi is set and lo &gt;=0 while hi &lt; 0 (meaning - return whole result set except some rows at start and some at the end)
    // because such case can't really be optimized by topN/bottomN
    private boolean canBeOptimized(RecordCursor baseCursor, SqlExecutionContext executionContext) throws SqlException {
<span class="fc" id="L198">        loFunction.init(baseCursor, executionContext);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (hiFunction != null) {</span>
<span class="fc" id="L200">            hiFunction.init(baseCursor, executionContext);</span>
        }

<span class="fc bfc" id="L203" title="All 4 branches covered.">        return !(loFunction.getLong(null) &gt;= 0 &amp;&amp;</span>
                hiFunction != null &amp;&amp;
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">                hiFunction.getLong(null) &lt; 0);</span>
    }

    private void initialize(SqlExecutionContext executionContext, RecordCursor baseCursor) throws SqlException {
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (isInitialized()) {</span>
<span class="fc" id="L210">            return;</span>
        }

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (canBeOptimized(baseCursor, executionContext)) {</span>
<span class="fc" id="L214">            initializeLimitedSizeCursor(executionContext, baseCursor);</span>
        } else {
<span class="nc" id="L216">            initializeUnlimitedSizeCursor();</span>
        }
<span class="fc" id="L218">    }</span>

    private void initializeUnlimitedSizeCursor() {
<span class="nc" id="L221">        LongTreeChain chain = new LongTreeChain(</span>
<span class="nc" id="L222">                configuration.getSqlSortKeyPageSize(),</span>
<span class="nc" id="L223">                configuration.getSqlSortKeyMaxPages(),</span>
<span class="nc" id="L224">                configuration.getSqlSortLightValuePageSize(),</span>
<span class="nc" id="L225">                configuration.getSqlSortLightValueMaxPages()</span>
        );
<span class="nc" id="L227">        this.cursor = new SortedLightRecordCursor(chain, comparator);</span>
<span class="nc" id="L228">    }</span>

    private boolean isInitialized() {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        return cursor != null;</span>
    }

    @Override
    protected void _close() {
<span class="fc" id="L236">        base.close();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (cursor != null) {</span>
<span class="fc" id="L238">            cursor.close();</span>
        }
<span class="fc" id="L240">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>