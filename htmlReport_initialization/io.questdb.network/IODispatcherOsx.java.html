<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IODispatcherOsx.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.network</a> &gt; <span class="el_source">IODispatcherOsx.java</span></div><h1>IODispatcherOsx.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.network;

import io.questdb.std.LongMatrix;

<span class="fc" id="L29">public class IODispatcherOsx&lt;C extends IOContext&gt; extends AbstractIODispatcher&lt;C&gt; {</span>
    private static final int EVM_DEADLINE = 1;
    private static final int EVM_ID = 0;
    private static final int EVM_OPERATION_ID = 2;
    private static final int OPM_ID = 3;
<span class="fc" id="L34">    protected final LongMatrix pendingEvents = new LongMatrix(3);</span>
    private final int capacity;
    private final Kqueue kqueue;
    // the final ids are shifted by 1 bit which is reserved to distinguish socket operations (0) and suspend events (1)
<span class="fc" id="L38">    private long idSeq = 1;</span>

    public IODispatcherOsx(
            IODispatcherConfiguration configuration,
            IOContextFactory&lt;C&gt; ioContextFactory
    ) {
<span class="fc" id="L44">        super(configuration, ioContextFactory);</span>
<span class="fc" id="L45">        this.capacity = configuration.getEventCapacity();</span>
        // bind socket
<span class="fc" id="L47">        this.kqueue = new Kqueue(configuration.getKqueueFacade(), capacity);</span>
<span class="fc" id="L48">        registerListenerFd();</span>
<span class="fc" id="L49">    }</span>

    @Override
    public void close() {
<span class="fc" id="L53">        super.close();</span>
<span class="fc" id="L54">        this.kqueue.close();</span>
<span class="fc" id="L55">        LOG.info().$(&quot;closed&quot;).$();</span>
<span class="fc" id="L56">    }</span>

    private static boolean isEventId(long id) {
<span class="fc bfc" id="L59" title="All 2 branches covered.">        return (id &amp; 1) == 1;</span>
    }

    private void doDisconnect(C context, long id, int reason) {
<span class="fc" id="L63">        final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (suspendEvent != null) {</span>
            // yes, we can do a binary search over EVM_OPERATION_ID since
            // these ref ids are monotonically growing
<span class="fc" id="L67">            int eventRow = pendingEvents.binarySearch(id, EVM_OPERATION_ID);</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">            if (eventRow &lt; 0) {</span>
<span class="nc" id="L69">                LOG.critical().$(&quot;internal error: suspend event not found [id=&quot;).$(id).I$();</span>
            } else {
<span class="fc" id="L71">                kqueue.setWriteOffset(0);</span>
<span class="fc" id="L72">                kqueue.removeFD(suspendEvent.getFd());</span>
<span class="fc" id="L73">                registerWithKQueue(1);</span>
<span class="fc" id="L74">                pendingEvents.deleteRow(eventRow);</span>
            }
        }
<span class="fc" id="L77">        doDisconnect(context, reason);</span>
<span class="fc" id="L78">    }</span>

    private void enqueuePending(int watermark) {
<span class="fc" id="L81">        int index = 0;</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (int i = watermark, sz = pending.size(), offset = 0; i &lt; sz; i++, offset += KqueueAccessor.SIZEOF_KEVENT) {</span>
<span class="fc" id="L83">            kqueue.setWriteOffset(offset);</span>

<span class="fc" id="L85">            final int fd = (int) pending.get(i, OPM_FD);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            final int operation = initialBias == IODispatcherConfiguration.BIAS_READ ? IOOperation.READ : IOOperation.WRITE;</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">            if (operation == IOOperation.READ) {</span>
<span class="fc" id="L89">                kqueue.readFD(fd, pending.get(i, OPM_ID));</span>
            } else {
<span class="fc" id="L91">                kqueue.writeFD(fd, pending.get(i, OPM_ID));</span>
            }
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">            if (++index &gt; capacity - 1) {</span>
<span class="nc" id="L94">                registerWithKQueue(index);</span>
<span class="nc" id="L95">                index = 0;</span>
<span class="nc" id="L96">                offset = 0;</span>
            }
        }
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (index &gt; 0) {</span>
<span class="fc" id="L100">            registerWithKQueue(index);</span>
        }
<span class="fc" id="L102">    }</span>

    private boolean handleSocketOperation(long id) {
        // find row in pending for two reasons:
        // 1. find payload
        // 2. remove row from pending, remaining rows will be timed out
<span class="fc" id="L108">        final int row = pending.binarySearch(id, OPM_ID);</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (row &lt; 0) {</span>
<span class="nc" id="L110">            LOG.critical().$(&quot;internal error: kqueue returned unexpected id [id=&quot;).$(id).I$();</span>
<span class="nc" id="L111">            return false;</span>
        }

<span class="fc" id="L114">        final C context = pending.get(row);</span>
<span class="fc" id="L115">        final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (suspendEvent != null) {</span>
            // the operation is suspended, check if we have a client disconnect
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if (testConnection(context.getFd())) {</span>
<span class="fc" id="L119">                doDisconnect(context, id, DISCONNECT_SRC_PEER_DISCONNECT);</span>
<span class="fc" id="L120">                pending.deleteRow(row);</span>
<span class="fc" id="L121">                return true;</span>
            }
        } else {
<span class="fc" id="L124">            publishOperation(</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                    kqueue.getFilter() == KqueueAccessor.EVFILT_READ ? IOOperation.READ : IOOperation.WRITE,</span>
                    context
            );
<span class="fc" id="L128">            pending.deleteRow(row);</span>
<span class="fc" id="L129">            return true;</span>
        }
<span class="nc" id="L131">        return false;</span>
    }

    private void handleSuspendEvent(long id) {
<span class="fc" id="L135">        final int eventsRow = pendingEvents.binarySearch(id, EVM_ID);</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (eventsRow &lt; 0) {</span>
<span class="nc" id="L137">            LOG.critical().$(&quot;internal error: kqueue returned unexpected event id [eventId=&quot;).$(id).I$();</span>
<span class="nc" id="L138">            return;</span>
        }

<span class="fc" id="L141">        final long opId = pendingEvents.get(eventsRow, EVM_OPERATION_ID);</span>
<span class="fc" id="L142">        final int row = pending.binarySearch(opId, OPM_ID);</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (row &lt; 0) {</span>
<span class="nc" id="L144">            LOG.critical().$(&quot;internal error: suspended operation not found [id=&quot;).$(opId).$(&quot;, eventId=&quot;).$(id).I$();</span>
<span class="nc" id="L145">            return;</span>
        }

<span class="fc" id="L148">        final long eventId = pendingEvents.get(eventsRow, EVM_ID);</span>
<span class="fc" id="L149">        final int operation = (int) pending.get(row, OPM_OPERATION);</span>
<span class="fc" id="L150">        final C context = pending.get(row);</span>
<span class="fc" id="L151">        final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        assert suspendEvent != null;</span>

<span class="fc" id="L154">        LOG.debug().$(&quot;handling triggered suspend event and resuming original operation [fd=&quot;).$(context.getFd())</span>
<span class="fc" id="L155">                .$(&quot;, opId=&quot;).$(opId)</span>
<span class="fc" id="L156">                .$(&quot;, eventId=&quot;).$(eventId).I$();</span>

<span class="fc" id="L158">        context.clearSuspendEvent();</span>
<span class="fc" id="L159">        kqueue.setWriteOffset(0);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (operation == IOOperation.READ) {</span>
<span class="nc" id="L161">            kqueue.readFD(context.getFd(), opId);</span>
        } else {
<span class="fc" id="L163">            kqueue.writeFD(context.getFd(), opId);</span>
        }
<span class="fc" id="L165">        registerWithKQueue(1);</span>

<span class="fc" id="L167">        pendingEvents.deleteRow(eventsRow);</span>
<span class="fc" id="L168">    }</span>

    private long nextEventId() {
<span class="fc" id="L171">        return (idSeq++ &lt;&lt; 1) + 1;</span>
    }

    private long nextOpId() {
<span class="fc" id="L175">        return idSeq++ &lt;&lt; 1;</span>
    }

    private void processIdleConnections(long deadline) {
<span class="fc" id="L179">        int count = 0;</span>
<span class="pc bpc" id="L180" title="1 of 4 branches missed.">        for (int i = 0, n = pending.size(); i &lt; n &amp;&amp; pending.get(i, OPM_TIMESTAMP) &lt; deadline; i++, count++) {</span>
<span class="fc" id="L181">            doDisconnect(pending.get(i), pending.get(i, OPM_ID), DISCONNECT_SRC_IDLE);</span>
        }
<span class="fc" id="L183">        pending.zapTop(count);</span>
<span class="fc" id="L184">    }</span>

    private boolean processRegistrations(long timestamp) {
        long cursor;
<span class="fc" id="L188">        boolean useful = false;</span>
<span class="fc" id="L189">        int count = 0;</span>
<span class="fc" id="L190">        int offset = 0;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        while ((cursor = interestSubSeq.next()) &gt; -1) {</span>
<span class="fc" id="L192">            final IOEvent&lt;C&gt; evt = interestQueue.get(cursor);</span>
<span class="fc" id="L193">            C context = evt.context;</span>
<span class="fc" id="L194">            int requestedOperation = evt.operation;</span>
<span class="fc" id="L195">            interestSubSeq.done(cursor);</span>

<span class="fc" id="L197">            useful = true;</span>
<span class="fc" id="L198">            final long opId = nextOpId();</span>
<span class="fc" id="L199">            final int fd = context.getFd();</span>
<span class="fc" id="L200">            int operation = requestedOperation;</span>
<span class="fc" id="L201">            LOG.debug().$(&quot;processing registration [fd=&quot;).$(fd)</span>
<span class="fc" id="L202">                    .$(&quot;, op=&quot;).$(operation)</span>
<span class="fc" id="L203">                    .$(&quot;, id=&quot;).$(opId).I$();</span>

<span class="fc" id="L205">            final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (suspendEvent != null) {</span>
                // if the operation was suspended, we request a read to be able to detect a client disconnect 
<span class="fc" id="L208">                operation = IOOperation.READ;</span>
            }

<span class="fc" id="L211">            int opRow = pending.addRow();</span>
<span class="fc" id="L212">            pending.set(opRow, OPM_TIMESTAMP, timestamp);</span>
<span class="fc" id="L213">            pending.set(opRow, OPM_FD, fd);</span>
<span class="fc" id="L214">            pending.set(opRow, OPM_ID, opId);</span>
<span class="fc" id="L215">            pending.set(opRow, OPM_OPERATION, requestedOperation);</span>
<span class="fc" id="L216">            pending.set(opRow, context);</span>

<span class="fc" id="L218">            kqueue.setWriteOffset(offset);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (operation == IOOperation.READ) {</span>
<span class="fc" id="L220">                kqueue.readFD(fd, opId);</span>
            } else {
<span class="fc" id="L222">                kqueue.writeFD(fd, opId);</span>
            }
<span class="fc" id="L224">            offset += KqueueAccessor.SIZEOF_KEVENT;</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">            if (++count &gt; capacity - 1) {</span>
<span class="nc" id="L226">                registerWithKQueue(count);</span>
<span class="nc" id="L227">                count = offset = 0;</span>
            }

<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (suspendEvent != null) {</span>
                // ok, the operation was suspended, so we need to track the suspend event
<span class="fc" id="L232">                final long eventId = nextEventId();</span>
<span class="fc" id="L233">                LOG.debug().$(&quot;registering suspend event [fd=&quot;).$(fd)</span>
<span class="fc" id="L234">                        .$(&quot;, op=&quot;).$(operation)</span>
<span class="fc" id="L235">                        .$(&quot;, eventId=&quot;).$(eventId)</span>
<span class="fc" id="L236">                        .$(&quot;, suspendedOpId=&quot;).$(opId)</span>
<span class="fc" id="L237">                        .$(&quot;, deadline=&quot;).$(suspendEvent.getDeadline()).I$();</span>

<span class="fc" id="L239">                int eventRow = pendingEvents.addRow();</span>
<span class="fc" id="L240">                pendingEvents.set(eventRow, EVM_ID, eventId);</span>
<span class="fc" id="L241">                pendingEvents.set(eventRow, EVM_OPERATION_ID, opId);</span>
<span class="fc" id="L242">                pendingEvents.set(eventRow, EVM_DEADLINE, suspendEvent.getDeadline());</span>

<span class="fc" id="L244">                kqueue.setWriteOffset(offset);</span>
<span class="fc" id="L245">                kqueue.readFD(suspendEvent.getFd(), eventId);</span>
<span class="fc" id="L246">                offset += KqueueAccessor.SIZEOF_KEVENT;</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                if (++count &gt; capacity - 1) {</span>
<span class="nc" id="L248">                    registerWithKQueue(count);</span>
<span class="nc" id="L249">                    count = offset = 0;</span>
                }
            }
<span class="fc" id="L252">        }</span>

<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (count &gt; 0) {</span>
<span class="fc" id="L255">            registerWithKQueue(count);</span>
        }

<span class="fc" id="L258">        return useful;</span>
    }

    private void processSuspendEventDeadlines(long timestamp) {
<span class="fc" id="L262">        int index = 0;</span>
<span class="fc" id="L263">        int offset = 0;</span>
<span class="fc" id="L264">        int count = 0;</span>
<span class="pc bpc" id="L265" title="1 of 4 branches missed.">        for (int i = 0, n = pendingEvents.size(); i &lt; n &amp;&amp; pendingEvents.get(i, EVM_DEADLINE) &lt; timestamp; i++, count++) {</span>
<span class="fc" id="L266">            final long opId = pendingEvents.get(i, EVM_OPERATION_ID);</span>
<span class="fc" id="L267">            final int pendingRow = pending.binarySearch(opId, OPM_ID);</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">            if (pendingRow &lt; 0) {</span>
<span class="nc" id="L269">                LOG.critical().$(&quot;internal error: failed to find operation for expired suspend event [id=&quot;).$(opId).I$();</span>
<span class="nc" id="L270">                continue;</span>
            }

            // First, remove the suspend event from kqueue tracking.
<span class="fc" id="L274">            final C context = pending.get(pendingRow);</span>
<span class="fc" id="L275">            final int operation = (int) pending.get(pendingRow, OPM_OPERATION);</span>
<span class="fc" id="L276">            final SuspendEvent suspendEvent = context.getSuspendEvent();</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            assert suspendEvent != null;</span>
<span class="fc" id="L278">            kqueue.setWriteOffset(offset);</span>
<span class="fc" id="L279">            kqueue.removeFD(suspendEvent.getFd());</span>
<span class="fc" id="L280">            offset += KqueueAccessor.SIZEOF_KEVENT;</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (++index &gt; capacity - 1) {</span>
<span class="nc" id="L282">                registerWithKQueue(index);</span>
<span class="nc" id="L283">                index = offset = 0;</span>
            }

            // Next, close the event and resume the original operation.
<span class="fc" id="L287">            context.clearSuspendEvent();</span>
<span class="fc" id="L288">            kqueue.setWriteOffset(offset);</span>
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">            if (operation == IOOperation.READ) {</span>
<span class="nc" id="L290">                kqueue.readFD(context.getFd(), opId);</span>
            } else {
<span class="fc" id="L292">                kqueue.writeFD(context.getFd(), opId);</span>
            }
<span class="fc" id="L294">            offset += KqueueAccessor.SIZEOF_KEVENT;</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">            if (++index &gt; capacity - 1) {</span>
<span class="nc" id="L296">                registerWithKQueue(index);</span>
<span class="nc" id="L297">                index = offset = 0;</span>
            }
        }
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (index &gt; 0) {</span>
<span class="fc" id="L301">            registerWithKQueue(index);</span>
        }
<span class="fc" id="L303">        pendingEvents.zapTop(count);</span>
<span class="fc" id="L304">    }</span>

    private void registerWithKQueue(int changeCount) {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (kqueue.register(changeCount) != 0) {</span>
<span class="nc" id="L308">            throw NetworkError.instance(nf.errno()).put(&quot;could not register [changeCount=&quot;).put(changeCount).put(']');</span>
        }
<span class="fc" id="L310">        LOG.debug().$(&quot;kqueued [count=&quot;).$(changeCount).$(']').$();</span>
<span class="fc" id="L311">    }</span>

    @Override
    protected void pendingAdded(int index) {
<span class="fc" id="L315">        pending.set(index, OPM_ID, nextOpId());</span>
<span class="fc" id="L316">    }</span>

    @Override
    protected void registerListenerFd() {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        if (this.kqueue.listen(serverFd) != 0) {</span>
<span class="nc" id="L321">            throw NetworkError.instance(nf.errno(), &quot;could not kqueue.listen()&quot;);</span>
        }
<span class="fc" id="L323">    }</span>

    @Override
    protected boolean runSerially() {
<span class="fc" id="L327">        boolean useful = false;</span>

<span class="fc" id="L329">        final long timestamp = clock.getTicks();</span>
<span class="fc" id="L330">        processDisconnects(timestamp);</span>
<span class="fc" id="L331">        final int n = kqueue.poll();</span>
<span class="fc" id="L332">        int watermark = pending.size();</span>
<span class="fc" id="L333">        int offset = 0;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (n &gt; 0) {</span>
<span class="fc" id="L335">            LOG.debug().$(&quot;poll [n=&quot;).$(n).$(']').$();</span>
            // check all activated FDs
<span class="fc bfc" id="L337" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L338">                kqueue.setReadOffset(offset);</span>
<span class="fc" id="L339">                offset += KqueueAccessor.SIZEOF_KEVENT;</span>
<span class="fc" id="L340">                final int fd = kqueue.getFd();</span>
<span class="fc" id="L341">                final long id = kqueue.getData();</span>
                // this is server socket, accept if there aren't too many already
<span class="fc bfc" id="L343" title="All 2 branches covered.">                if (fd == serverFd) {</span>
<span class="fc" id="L344">                    accept(timestamp);</span>
<span class="fc" id="L345">                    useful = true;</span>
<span class="fc" id="L346">                    continue;</span>
                }
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (isEventId(id)) {</span>
<span class="fc" id="L349">                    handleSuspendEvent(id);</span>
<span class="fc" id="L350">                    continue;</span>
                }
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">                if (handleSocketOperation(id)) {</span>
<span class="fc" id="L353">                    useful = true;</span>
<span class="fc" id="L354">                    watermark--;</span>
                }
            }
        }

        // process rows over watermark (new connections)
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (watermark &lt; pending.size()) {</span>
<span class="fc" id="L361">            enqueuePending(watermark);</span>
        }

        // process timed out suspend events and resume the original operations
<span class="fc bfc" id="L365" title="All 4 branches covered.">        if (pendingEvents.size() &gt; 0 &amp;&amp; pendingEvents.get(0, EVM_DEADLINE) &lt; timestamp) {</span>
<span class="fc" id="L366">            processSuspendEventDeadlines(timestamp);</span>
        }

        // process timed out connections
<span class="fc" id="L370">        final long deadline = timestamp - idleConnectionTimeout;</span>
<span class="fc bfc" id="L371" title="All 4 branches covered.">        if (pending.size() &gt; 0 &amp;&amp; pending.get(0, OPM_TIMESTAMP) &lt; deadline) {</span>
<span class="fc" id="L372">            processIdleConnections(deadline);</span>
<span class="fc" id="L373">            useful = true;</span>
        }

<span class="fc bfc" id="L376" title="All 4 branches covered.">        return processRegistrations(timestamp) || useful;</span>
    }

    @Override
    protected void unregisterListenerFd() {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (this.kqueue.removeListen(serverFd) != 0) {</span>
<span class="nc" id="L382">            throw NetworkError.instance(nf.errno(), &quot;could not kqueue.removeListen()&quot;);</span>
        }
<span class="fc" id="L384">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>