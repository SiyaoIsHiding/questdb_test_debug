<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupByFunctionsUpdaterFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.questdb in questdb Coverage Results</a> &gt; <a href="index.source.html" class="el_package">io.questdb.griffin.engine.groupby</a> &gt; <span class="el_source">GroupByFunctionsUpdaterFactory.java</span></div><h1>GroupByFunctionsUpdaterFactory.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *     ___                  _   ____  ____
 *    / _ \ _   _  ___  ___| |_|  _ \| __ )
 *   | | | | | | |/ _ \/ __| __| | | |  _ \
 *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
 *    \__\_\\__,_|\___||___/\__|____/|____/
 *
 *  Copyright (c) 2014-2019 Appsicle
 *  Copyright (c) 2019-2022 QuestDB
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

package io.questdb.griffin.engine.groupby;

import io.questdb.griffin.engine.functions.GroupByFunction;
import io.questdb.std.BytecodeAssembler;
import io.questdb.std.ObjList;

public class GroupByFunctionsUpdaterFactory {
    private static final int FIELD_POOL_OFFSET = 3;

    private GroupByFunctionsUpdaterFactory() {
    }

    /**
     * Creates a GroupByFunctionUpdater instance capturing the provided group by functions.
     * The generated class will have fields GroupByFunction f0, GroupByFunction f1, GroupByFunction f2 ... GroupByFunction fn
     * for each group by function from the provided list.
     * &lt;p&gt;
     * The generated class will have the following methods:
     * &lt;ul&gt;
     * &lt;li&gt;updateNew(MapValue value, Record record) - calls f0, f1, f2 ... fn.computeFirst(value, record) for each group by function&lt;/li&gt;
     * &lt;li&gt;updateExisting(MapValue value, Record record) - calls f0, f1, f2 ... fn.computeNext(value, record) for each group by function&lt;/li&gt;
     * &lt;li&gt;updateEmpty(MapValue value) - calls f0, f1, f2 ... fn.setEmpty(value) for each group by function&lt;/li&gt;
     * &lt;li&gt;setFunctions(ObjList&amp;lt;GroupByFunction&amp;gt; groupByFunctions) - sets the group by functions to the fields. This method is called by the factory and should not be called by the caller.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param asm              BytecodeAssembler instance
     * @param groupByFunctions list of group by functions
     * @return GroupByFunctionUpdater instance
     */
    public static GroupByFunctionsUpdater getInstance(
            BytecodeAssembler asm,
            ObjList&lt;GroupByFunction&gt; groupByFunctions
    ) {
<span class="fc" id="L58">        asm.init(GroupByFunctionsUpdater.class);</span>
<span class="fc" id="L59">        asm.setupPool();</span>
<span class="fc" id="L60">        final int thisClassIndex = asm.poolClass(asm.poolUtf8(&quot;io/questdb/griffin/engine/groupby/GroupByFunctionsUpdaterAsm&quot;));</span>
<span class="fc" id="L61">        final int superclassIndex = asm.poolClass(Object.class);</span>
<span class="fc" id="L62">        int interfaceClassIndex = asm.poolClass(GroupByFunctionsUpdater.class);</span>


<span class="fc" id="L65">        final int superIndex = asm.poolMethod(superclassIndex, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span>

<span class="fc" id="L67">        final int typeIndex = asm.poolUtf8(&quot;Lio/questdb/griffin/engine/functions/GroupByFunction;&quot;);</span>
<span class="fc" id="L68">        final int functionSize = groupByFunctions.size();</span>

<span class="fc" id="L70">        int firstFieldNameIndex = 0;</span>
<span class="fc" id="L71">        int firstFieldIndex = 0;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        for (int i = 0; i &lt; functionSize; i++) {</span>
            // if you change pool calls then you will likely need to change the FIELD_POOL_OFFSET constant
<span class="fc" id="L74">            int fieldNameIndex = asm.poolUtf8().put(&quot;f&quot;).put(i).$();</span>
<span class="fc" id="L75">            int nameAndType = asm.poolNameAndType(fieldNameIndex, typeIndex);</span>
<span class="fc" id="L76">            int fieldIndex = asm.poolField(thisClassIndex, nameAndType);</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L78">                firstFieldNameIndex = fieldNameIndex;</span>
<span class="fc" id="L79">                firstFieldIndex = fieldIndex;</span>
            }
        }

<span class="fc" id="L83">        final int computeFirstIndex = asm.poolInterfaceMethod(GroupByFunction.class, &quot;computeFirst&quot;, &quot;(Lio/questdb/cairo/map/MapValue;Lio/questdb/cairo/sql/Record;)V&quot;);</span>
<span class="fc" id="L84">        final int computeNextIndex = asm.poolInterfaceMethod(GroupByFunction.class, &quot;computeNext&quot;, &quot;(Lio/questdb/cairo/map/MapValue;Lio/questdb/cairo/sql/Record;)V&quot;);</span>
<span class="fc" id="L85">        final int setEmptyIndex = asm.poolInterfaceMethod(GroupByFunction.class, &quot;setEmpty&quot;, &quot;(Lio/questdb/cairo/map/MapValue;)V&quot;);</span>

<span class="fc" id="L87">        final int updateNewIndex = asm.poolUtf8(&quot;updateNew&quot;);</span>
<span class="fc" id="L88">        final int updateNewSigIndex = asm.poolUtf8(&quot;(Lio/questdb/cairo/map/MapValue;Lio/questdb/cairo/sql/Record;)V&quot;);</span>
<span class="fc" id="L89">        final int updateExistingIndex = asm.poolUtf8(&quot;updateExisting&quot;);</span>
<span class="fc" id="L90">        final int updateExistingSigIndex = asm.poolUtf8(&quot;(Lio/questdb/cairo/map/MapValue;Lio/questdb/cairo/sql/Record;)V&quot;);</span>
<span class="fc" id="L91">        final int updateEmptyIndex = asm.poolUtf8(&quot;updateEmpty&quot;);</span>
<span class="fc" id="L92">        final int updateEmptySigIndex = asm.poolUtf8(&quot;(Lio/questdb/cairo/map/MapValue;)V&quot;);</span>
<span class="fc" id="L93">        final int setFunctionsIndex = asm.poolUtf8(&quot;setFunctions&quot;);</span>
<span class="fc" id="L94">        final int setFunctionsSigIndex = asm.poolUtf8(&quot;(Lio/questdb/std/ObjList;)V&quot;);</span>

<span class="fc" id="L96">        final int getIndex = asm.poolMethod(ObjList.class, &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;);</span>

<span class="fc" id="L98">        asm.finishPool();</span>

<span class="fc" id="L100">        asm.defineClass(thisClassIndex, superclassIndex);</span>
<span class="fc" id="L101">        asm.interfaceCount(1);</span>
<span class="fc" id="L102">        asm.putShort(interfaceClassIndex);</span>
<span class="fc" id="L103">        asm.fieldCount(functionSize);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        for (int i = 0; i &lt; functionSize; i++) {</span>
<span class="fc" id="L105">            asm.defineField(firstFieldNameIndex + (i * FIELD_POOL_OFFSET), typeIndex);</span>
        }
<span class="fc" id="L107">        asm.methodCount(5);</span>
<span class="fc" id="L108">        asm.defineDefaultConstructor(superIndex);</span>

<span class="fc" id="L110">        generateUpdateNew(asm, functionSize, firstFieldIndex, computeFirstIndex, updateNewIndex, updateNewSigIndex);</span>
<span class="fc" id="L111">        generateUpdateExisting(asm, functionSize, firstFieldIndex, computeNextIndex, updateExistingIndex, updateExistingSigIndex);</span>
<span class="fc" id="L112">        generateUpdateEmpty(asm, functionSize, firstFieldIndex, setEmptyIndex, updateEmptyIndex, updateEmptySigIndex);</span>
<span class="fc" id="L113">        generateSetFunction(asm, functionSize, firstFieldIndex, setFunctionsIndex, setFunctionsSigIndex, getIndex);</span>

        // class attribute count
<span class="fc" id="L116">        asm.putShort(0);</span>

<span class="fc" id="L118">        GroupByFunctionsUpdater updater = asm.newInstance();</span>

<span class="fc" id="L120">        updater.setFunctions(groupByFunctions);</span>
<span class="fc" id="L121">        return updater;</span>
    }

    private static void generateSetFunction(BytecodeAssembler asm, int functionSize, int firstFieldIndex, int setFunctionsIndex, int setFunctionsSigIndex, int getIndex) {
<span class="fc" id="L125">        asm.startMethod(setFunctionsIndex, setFunctionsSigIndex, 3, 3);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        for (int i = 0; i &lt; functionSize; i++) {</span>
<span class="fc" id="L127">            asm.aload(0);</span>
<span class="fc" id="L128">            asm.aload(1);</span>
<span class="fc" id="L129">            asm.iconst(i);</span>
<span class="fc" id="L130">            asm.invokeVirtual(getIndex);</span>
<span class="fc" id="L131">            asm.putfield(firstFieldIndex + (i * FIELD_POOL_OFFSET));</span>
        }
<span class="fc" id="L133">        asm.return_();</span>
<span class="fc" id="L134">        asm.endMethodCode();</span>
        // exceptions
<span class="fc" id="L136">        asm.putShort(0);</span>
        // attributes
<span class="fc" id="L138">        asm.putShort(0);</span>
<span class="fc" id="L139">        asm.endMethod();</span>
<span class="fc" id="L140">    }</span>

    private static void generateUpdateEmpty(
            BytecodeAssembler asm,
            int fieldCount,
            int firstFieldIndex,
            int setEmptyIndex,
            int updateNameIndex,
            int updateSigIndex
    ) {
<span class="fc" id="L150">        asm.startMethod(updateNameIndex, updateSigIndex, 3, 3);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (int i = 0; i &lt; fieldCount; i++) {</span>
<span class="fc" id="L152">            asm.aload(0);</span>
<span class="fc" id="L153">            asm.getfield(firstFieldIndex + (i * FIELD_POOL_OFFSET));</span>
<span class="fc" id="L154">            asm.aload(1);</span>
<span class="fc" id="L155">            asm.invokeInterface(setEmptyIndex, 1);</span>
        }
<span class="fc" id="L157">        asm.return_();</span>
<span class="fc" id="L158">        asm.endMethodCode();</span>
        // exceptions
<span class="fc" id="L160">        asm.putShort(0);</span>
        // attributes
<span class="fc" id="L162">        asm.putShort(0);</span>
<span class="fc" id="L163">        asm.endMethod();</span>
<span class="fc" id="L164">    }</span>

    private static void generateUpdateExisting(
            BytecodeAssembler asm,
            int fieldCount,
            int firstFieldIndex,
            int computeNextIndex,
            int updateNameIndex,
            int updateSigIndex
    ) {
<span class="fc" id="L174">        asm.startMethod(updateNameIndex, updateSigIndex, 3, 3);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        for (int i = 0; i &lt; fieldCount; i++) {</span>
<span class="fc" id="L176">            asm.aload(0);</span>
<span class="fc" id="L177">            asm.getfield(firstFieldIndex + (i * FIELD_POOL_OFFSET));</span>
<span class="fc" id="L178">            asm.aload(1); // map value</span>
<span class="fc" id="L179">            asm.aload(2); // record</span>
<span class="fc" id="L180">            asm.invokeInterface(computeNextIndex, 2);</span>
        }
<span class="fc" id="L182">        asm.return_();</span>
<span class="fc" id="L183">        asm.endMethodCode();</span>
        // exceptions
<span class="fc" id="L185">        asm.putShort(0);</span>
        // attributes
<span class="fc" id="L187">        asm.putShort(0);</span>
<span class="fc" id="L188">        asm.endMethod();</span>
<span class="fc" id="L189">    }</span>

    /**
     * Here we simply unroll the function list and call computeNext on each of them.
     * The end bytecode equals to the following:
     * &lt;code&gt;
     * f0.computeFist(value, record);
     * f1.computeFirst(value, record);
     * // ...
     * fn.computeFirst(value, record);
     * &lt;/code&gt;
     * &lt;p&gt;
     * Other generated methods look similar.
     */
    private static void generateUpdateNew(
            BytecodeAssembler asm,
            int fieldCount,
            int firstFieldIndex,
            int computeFirstIndex,
            int updateNameIndex,
            int updateSigIndex
    ) {
<span class="fc" id="L211">        asm.startMethod(updateNameIndex, updateSigIndex, 3, 3);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">        for (int i = 0; i &lt; fieldCount; i++) {</span>
<span class="fc" id="L213">            asm.aload(0);</span>
<span class="fc" id="L214">            asm.getfield(firstFieldIndex + (i * FIELD_POOL_OFFSET));</span>
<span class="fc" id="L215">            asm.aload(1); // map value</span>
<span class="fc" id="L216">            asm.aload(2); // record</span>
<span class="fc" id="L217">            asm.invokeInterface(computeFirstIndex, 2);</span>
        }
<span class="fc" id="L219">        asm.return_();</span>
<span class="fc" id="L220">        asm.endMethodCode();</span>
        // exceptions
<span class="fc" id="L222">        asm.putShort(0);</span>
        // attributes
<span class="fc" id="L224">        asm.putShort(0);</span>
<span class="fc" id="L225">        asm.endMethod();</span>
<span class="fc" id="L226">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>